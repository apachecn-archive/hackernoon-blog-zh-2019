<html>
<head>
<title>Announcement: Java12 has released!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">公告:Java12发布了！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/announcement-java12-has-released-435e659affee?source=collection_archive---------0-----------------------#2019-04-04">https://medium.com/hackernoon/announcement-java12-has-released-435e659affee?source=collection_archive---------0-----------------------#2019-04-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="576f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">摘要:以非冗长的方式快速概述所有新的Java12特性。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f944e94a26fb26858b2721c40ff38477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M-FyP9EYnCRGBMJz"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/@frankieis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Frankie</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="11c6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">oracle开始了一个新的六个月的Java发布周期，从上次更新开始，Oracle每六个月就快速发布一次新版本。我们可以期待以更快的速度为开发者提供一些很酷的新功能。我已经看到了一些你可以期待在JDK 12版本中看到的特性。你可以获得开放的JDK 12早期版本，并尝试这些<em class="kw">预览功能</em>。让我们仔细看看。</p><ol class=""><li id="2ce0" class="kx ky hu kc b kd ke kg kh kj kz kn la kr lb kv lc ld le lf dt translated"><strong class="kc hv"> JEP 189: Shenandoah:一个低停顿时间的垃圾收集器(实验)。</strong></li></ol><p id="be00" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> 2。JEP 230:微基准测试套件。</strong></p><p id="a699" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">3.JEP 325:切换表情。</p><p id="7a8f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">4.<strong class="kc hv"> JEP 326:原始字符串文字(从JDK 12版本中删除)。</strong></p><p id="c25d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">5.JEP 334: JVM常量API。</p><p id="ac15" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">6.<strong class="kc hv"> JEP 340:一个AArch64端口，而不是两个。</strong></p><p id="c9da" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">7.<strong class="kc hv"> JEP 341:默认CDS档案。</strong></p><p id="3a3c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">8.<strong class="kc hv"> JEP 344:为G1精心准备的混合收藏。</strong></p><p id="3cb7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">9.JEP 346:立即从G1返回未使用的提交内存。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h2 id="cfa5" class="ln lo hu bd lp lq lr ls lt lu lv lw lx kj ly lz ma kn mb mc md kr me mf mg mh dt translated">谢南多厄:一个低停顿时间的垃圾收集器:——</h2><p id="4483" class="pw-post-body-paragraph ka kb hu kc b kd mi iv kf kg mj iy ki kj mk kl km kn ml kp kq kr mm kt ku kv hn dt translated">Java开发团队将对G1垃圾收集器进行一些重大的修改。G1垃圾收集器变化的主要目的是保持相同的一致暂停时间。它是在名为Shenandoah的新垃圾收集(GC)算法的帮助下实现的，该算法通过与程序上正在运行的Java线程同时执行疏散工作来减少GC暂停时间。Shenandoah的暂停时间与堆大小无关，这意味着无论堆是200 MB还是200 GB，您都可以保持相同的暂停时间。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h2 id="8443" class="ln lo hu bd lp lq lr ls lt lu lv lw lx kj ly lz ma kn mb mc md kr me mf mg mh dt translated"><strong class="ak">微基准测试套件:——</strong></h2><blockquote class="mn mo mp"><p id="f832" class="ka kb kw kc b kd ke iv kf kg kh iy ki mq kk kl km mr ko kp kq ms ks kt ku kv hn dt translated">向JDK源代码中添加一套基本的微基准，让开发人员可以轻松运行现有的微基准和创建新的微基准。</p></blockquote><p id="d8b4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">微基准测试套件将与JDK源代码放在同一个目录中，构建时将生成一个JAR文件。协同定位将简化开发过程中添加和定位基准的工作。在运行基准测试时，JMH提供了强大的过滤功能，允许用户只运行当前感兴趣的基准测试。确切的位置还有待确定。</p><h2 id="68b4" class="ln lo hu bd lp lq lr ls lt lu lv lw lx kj ly lz ma kn mb mc md kr me mf mg mh dt translated"><strong class="ak">目标:</strong></h2><ol class=""><li id="7233" class="kx ky hu kc b kd mi kg mj kj mt kn mu kr mv kv lc ld le lf dt translated">基于[Java微基准测试工具(JMH)][1]</li><li id="c3ce" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">稳定且经过调整的性能指标评测，旨在进行持续的性能测试</li><li id="24f9" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">在特性发布的特性完成里程碑之后，对于非特性发布来说，是一个稳定且不可移动的套件。</li><li id="1121" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">支持与以前的JDK版本进行比较，以进行适用的测试</li></ol><p id="0c88" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">简约</strong></p><ol class=""><li id="8509" class="kx ky hu kc b kd ke kg kh kj kz kn la kr lb kv lc ld le lf dt translated">易于添加新的基准</li><li id="0a08" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">在开发过程中，当API和选项改变、被弃用或被删除时，易于更新测试</li><li id="fe81" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">易于构建</li><li id="82cb" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">易于查找和运行基准测试</li><li id="6447" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">支持JMH更新</li><li id="6ea1" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">在套件中包括大约一百个基准的初始集合</li></ol></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h2 id="82fd" class="ln lo hu bd lp lq lr ls lt lu lv lw lx kj ly lz ma kn mb mc md kr me mf mg mh dt translated"><strong class="ak">开关表达式:——</strong></h2><p id="281f" class="pw-post-body-paragraph ka kb hu kc b kd mi iv kf kg mj iy ki kj mk kl km kn ml kp kq kr mm kt ku kv hn dt translated">扩展switch语句，使其既可以用作<strong class="kc hv">语句</strong>也可以用作<strong class="kc hv">表达式</strong>，并且这两种形式都可以使用“传统”或“简化”的作用域和控制流行为。这些变化将简化日常编码，也为在switch情况下使用模式匹配铺平了道路。</p><p id="4162" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现有的switch case与C、C++和JavaScript等编程语言密切相关。这些语言支持控制流中的失败切换条件，以避免问题开发团队对JDK12中的switch语句进行新的修改。</p><p id="3ef9" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">例如，在下面的代码中，有许多break语句使它变得不必要的冗长，并且这种视觉噪音经常掩盖难以调试的错误，对于程序员来说，缺少break语句意味着意外的失败。</p><pre class="jk jl jm jn fq nb nc nd ne aw nf dt"><span id="0959" class="ln lo hu nc b fv ng nh l ni nj">switch (day) {<br/>    case MONDAY:<br/>    case FRIDAY:<br/>    case SUNDAY:<br/>        System.out.println(6);<br/>        break;<br/>    case TUESDAY:<br/>        System.out.println(7);<br/>        break;<br/>    case THURSDAY:<br/>    case SATURDAY:<br/>        System.out.println(8);<br/>        break;<br/>    case WEDNESDAY:<br/>        System.out.println(9);<br/>        break;<br/>}</span></pre><p id="4b54" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">上面的代码是switch case语句的传统风格。新的提案声明将是—</p><pre class="jk jl jm jn fq nb nc nd ne aw nf dt"><span id="bf71" class="ln lo hu nc b fv ng nh l ni nj">switch (day) {<br/>    case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6);<br/>    case TUESDAY                -&gt; System.out.println(7);<br/>    case THURSDAY, SATURDAY     -&gt; System.out.println(8);<br/>    case WEDNESDAY              -&gt; System.out.println(9);<br/>}</span></pre><blockquote class="mn mo mp"><p id="5ef8" class="ka kb kw kc b kd ke iv kf kg kh iy ki mq kk kl km mr ko kp kq ms ks kt ku kv hn dt translated">从JDK12开始，我们可以编写如上所述的switch语句。</p></blockquote></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><p id="9526" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">原始字符串文字(从JDK 12版本中删除):——</strong></p><p id="8e59" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">JDK 12的一个主要提议是移除原始字符串文字。根据JEP，“一个原始字符串文字可以跨越多行源代码，并且不解释转义序列，如\n或\uXXXX形式的Unicode转义”。这就是他们删除字符串文字的原因。</p><p id="5b40" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">示例:- </strong></p><pre class="jk jl jm jn fq nb nc nd ne aw nf dt"><span id="82e4" class="ln lo hu nc b fv ng nh l ni nj">String myContent = "&lt;html&gt;\n" +<br/>                   "    &lt;body&gt;\n" +<br/>                   "		    &lt;p&gt;Hello World.&lt;/p&gt;\n" +<br/>                   "    &lt;/body&gt;\n" +<br/>                   “&lt;/html&gt;\n";</span></pre><p id="d046" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">从JDK12中，我们可以将上面的语句写成如下—</p><pre class="jk jl jm jn fq nb nc nd ne aw nf dt"><span id="ec53" class="ln lo hu nc b fv ng nh l ni nj">String myNewContent = `&lt;html&gt;<br/>                           &lt;body&gt;<br/>                              &lt;p&gt;Hello World.&lt;/p&gt;<br/>                           &lt;/body&gt;<br/>                       &lt;/html&gt;<br/>                       `;</span></pre></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><p id="4846" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> JVM常量API:——</strong></p><p id="a3ea" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">实现新常量API的目的是让操作类文件的程序更容易模拟字节码指令，字节码指令必须处理可加载的常量。</p><p id="be99" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">一般来说，每个Java类都有一个常量池，用来存储类中字节码指令的操作数。它还有一个常量池，表中的每个条目都是一个可加载的常量，格式如下:</p><pre class="jk jl jm jn fq nb nc nd ne aw nf dt"><span id="3675" class="ln lo hu nc b fv ng nh l ni nj">cp_info {<br/>    u1 tag;<br/>    u1 info[];<br/>}</span></pre><p id="d874" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">标签</strong>指定了常量的类型——</p><blockquote class="mn mo mp"><p id="1f2b" class="ka kb kw kc b kd ke iv kf kg kh iy ki mq kk kl km mr ko kp kq ms ks kt ku kv hn dt translated">例如:- 7表示它是类，10是方法引用，8是字符串，等等...</p></blockquote><p id="8ba6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv"> info </strong>数组根据常量类型给出更多关于常量的信息。</p><p id="74cc" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">JVM指令，例如<strong class="kc hv"> LDC </strong>和<strong class="kc hv">调用动态</strong>指令，依赖于该表中的信息(而不是类、接口等的运行时布局)。当这些指令被执行时，可加载常量变成一个活值，例如类、字符串、整数等。</p><p id="b6b7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">处理类文件的程序必须对这些字节码指令建模，并处理可加载的常量。如果常量类型是字符串或整数之类的东西，这没有问题，因为它们是原始数据类型。但是当涉及到类和接口时，就变得更加复杂了。</p><p id="dac3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">加载类并不总是简单明了的，有几种方式可能会失败，例如，如果类不存在或无法访问。那么它可能会引起一个问题，为了避免这个问题—</p><p id="4a8e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">这就是JEP 334的用武之地。</strong></p><p id="9466" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在Java 12中，现在有了一个API，所以这些值可以被符号化地处理。例如，有一个名为ClassDesc的接口，它可以用来象征性地表示Class类型的可加载常量，MethodHandleDesc表示方法句柄常量，MethodTypeDesc表示方法类型常量，等等。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h2 id="5445" class="ln lo hu bd lp lq lr ls lt lu lv lw lx kj ly lz ma kn mb mc md kr me mf mg mh dt translated">一个AArch64端口，而不是两个:—</h2><blockquote class="mn mo mp"><p id="6de8" class="ka kb kw kc b kd ke iv kf kg kh iy ki mq kk kl km mr ko kp kq ms ks kt ku kv hn dt translated">移除所有与arm64端口相关的源，同时保留32位arm端口和64位aarch64端口。</p></blockquote><p id="5376" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">移除此端口将允许所有贡献者将其精力集中在单个64位ARM实现上，并消除维护两个端口所需的重复工作。实现这个特性是为了提高开发的效率。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><p id="0d3f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">默认CDS档案:——</strong></p><blockquote class="mn mo mp"><p id="3dbd" class="ka kb kw kc b kd ke iv kf kg kh iy ki mq kk kl km mr ko kp kq ms ks kt ku kv hn dt translated">增强JDK构建过程，在64位平台上使用默认类列表生成类数据共享(CDS)档案。</p></blockquote><p id="b837" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">实现默认CDS档案的目标是—</p><ol class=""><li id="f68f" class="kx ky hu kc b kd ke kg kh kj kz kn la kr lb kv lc ld le lf dt translated">改善开箱即用的启动时间。</li><li id="c909" class="kx ky hu kc b kd mw kg mx kj my kn mz kr na kv lc ld le lf dt translated">用户无需运行<code class="eh nk nl nm nc b"><strong class="kc hv">-Xshare:dump</strong></code>即可从CDS中获益。</li></ol><p id="e79e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">目前，JDK映像在<code class="eh nk nl nm nc b"><strong class="kc hv">lib</strong></code>目录中包含一个在构建时生成的默认类列表。想要利用CD的用户，即使只有JDK提供的默认课程列表，也必须额外运行<code class="eh nk nl nm nc b"><strong class="kc hv">java -Xshare:dump</strong></code>。这个选项是有文档记录的，但是许多用户并不知道。为了解决这个问题，他们提供了默认的CDS档案—</p><blockquote class="mn mo mp"><p id="43e5" class="ka kb kw kc b kd ke iv kf kg kh iy ki mq kk kl km mr ko kp kq ms ks kt ku kv hn dt translated"><strong class="kc hv">由于他们将光盘存档设为自动，我们可以直接使用，但如果您想禁用它，请运行命令</strong> <code class="eh nk nl nm nc b"><strong class="kc hv">-Xshare:off</strong></code>。</p></blockquote></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h2 id="36e4" class="ln lo hu bd lp lq lr ls lt lu lv lw lx kj ly lz ma kn mb mc md kr me mf mg mh dt translated"><strong class="ak">G1可接受的混合托收:——</strong></h2><p id="18d9" class="pw-post-body-paragraph ka kb hu kc b kd mi iv kf kg mj iy ki kj mk kl km kn ml kp kq kr mm kt ku kv hn dt translated">如果G1混合收集可能会超出暂停目标，请使其可停止。关于<a class="ae jz" href="http://openjdk.java.net/jeps/344" rel="noopener ugc nofollow" target="_blank"> JEP344 </a>的完整描述。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><p id="72cd" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">及时从G1返回未使用的提交内存:——</strong></p><blockquote class="mn mo mp"><p id="5f28" class="ka kb kw kc b kd ke iv kf kg kh iy ki mq kk kl km mr ko kp kq ms ks kt ku kv hn dt translated">增强G1垃圾收集器，在空闲时自动将Java堆内存返回给操作系统。</p></blockquote><p id="6ba0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">有关此功能的完整信息<a class="ae jz" href="http://openjdk.java.net/jeps/346" rel="noopener ugc nofollow" target="_blank"> JEP346 </a>。</p></div><div class="ab cl lg lh hc li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hn ho hp hq hr"><h1 id="1b67" class="nn lo hu bd lp no np nq lt nr ns nt lx ja nu jb ma jd nv je md jg nw jh mg nx dt translated">结论</h1><p id="c4a9" class="pw-post-body-paragraph ka kb hu kc b kd mi iv kf kg mj iy ki kj mk kl km kn ml kp kq kr mm kt ku kv hn dt translated">感谢您的阅读。</p><p id="6cf0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">有了这么多令人兴奋和用户友好的特性，我认为Java12将满足开发者的期望。</p><p id="0698" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">如果你喜欢这篇文章，请点击拍手，给我留下你宝贵的反馈。</strong></p><p id="574d" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">忙碌的人们，你们好，我希望你们在阅读这篇文章时感到愉快，并且我希望你们在这里学到了很多！这是我尝试分享我所学到的东西。</strong></p><p id="d259" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我希望你在这里看到了对你有用的东西。下次再见！😉🤓</p><p id="0de6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">玩得开心！不断学习新事物，编码解决问题。😇</strong></p><p id="643f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">看看我的<a class="ae jz" href="https://twitter.com/Sri_Programmer" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae jz" href="https://github.com/srimani-programmer" rel="noopener ugc nofollow" target="_blank"> Github </a>和<a class="ae jz" href="https://www.facebook.com/srimani.programmer" rel="noopener ugc nofollow" target="_blank">脸书</a>。🙂</p></div></div>    
</body>
</html>