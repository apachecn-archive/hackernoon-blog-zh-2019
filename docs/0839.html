<html>
<head>
<title>Understanding Git-Bisect, i.e. Use Binary Search to Find the Change that Introduced a Bug</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Git-平分，即使用二分搜索法来找到引入Bug的变更</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-git-bisect-i-e-use-binary-search-to-find-the-change-that-introduced-a-bug-89489b4c9fa6?source=collection_archive---------1-----------------------#2019-02-04">https://medium.com/hackernoon/understanding-git-bisect-i-e-use-binary-search-to-find-the-change-that-introduced-a-bug-89489b4c9fa6?source=collection_archive---------1-----------------------#2019-02-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="6a8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Git是一个强大的工具。一旦掌握了<code class="eh jp jq jr js b">commit</code>和<code class="eh jp jq jr js b">merge</code>，就有无限可能。很有用的一个是<code class="eh jp jq jr js b"><a class="ae jt" href="https://git-scm.com/docs/git-bisect" rel="noopener ugc nofollow" target="_blank">git-bisect</a></code>。它帮助你找到一个导致行为改变的提交。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="jz ka l"/></div></figure><p id="8277" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你发现一个<strong class="it hv">回归，一些曾经工作</strong>的东西被破坏了，使用<code class="eh jp jq jr js b">git-bisect</code>找到破坏它的提交。将当前提交标记为<code class="eh jp jq jr js b">bad</code>，并将旧的提交标记为<code class="eh jp jq jr js b">good</code>，其中该特性仍然有效。<code class="eh jp jq jr js b">Git-bisect</code>然后用二分搜索法将这两个提交之间的所有变更一分为二。在每一步，都要求您将提交标记为<code class="eh jp jq jr js b">good</code>或<code class="eh jp jq jr js b">bad</code>，直到<code class="eh jp jq jr js b">bisect</code>发现<strong class="it hv">第一个错误提交</strong>。</p><h2 id="1842" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">如何使用git-平分</h2><pre class="ju jv jw jx fq kw js kx ky aw kz dt"><span id="69af" class="kb kc hu js b fv la lb l lc ld">git bisect start<br/>npm test   #  Double check that this commit is broken.<br/>git bisect bad<br/>git log --oneline   # Find the hash of a good commit.<br/>git checkout 7425633   #  Checkout that good commit.<br/>npm test   # Double check that everything was green.<br/>git bisect good</span></pre><p id="493d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">Bisect</code>使用二分搜索法，因此范围呈指数递减。每一步都将范围减半。如果您提交两倍的数量，平均需要一个额外的步骤——而不是两倍的时间。因此，将大范围的提交一分为二相当快。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff le"><img src="../Images/6dee73643d5fda4d9ced4c6bfe644614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVfHwnJV0NTQ_kNsqxZLjQ.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">Git bisect view. The range of commits to test is cut in half at every step.</figcaption></figure><p id="3398" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在<a class="ae jt" href="https://github.com/nodejs/node" rel="noopener ugc nofollow" target="_blank"> Node.js项目</a>中大量使用<code class="eh jp jq jr js b">git-bisect</code>。Node.js项目具有良好的持续集成性，但有些bug只有在发布后才能发现。使用<code class="eh jp jq jr js b">git-bisect</code>，很容易发现错误的提交。</p><h2 id="41ab" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">试试看！</h2><p id="9698" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">如果你想试用<code class="eh jp jq jr js b">git-bisect</code>，这里有一个<a class="ae jt" href="https://github.com/fhinkel/git-bisect-demo" rel="noopener ugc nofollow" target="_blank">演示库</a>。在某个时候，引入了一个bug，您可以通过运行<code class="eh jp jq jr js b">npx mocha test1.js</code>看到这一点。你能找到错误的提交吗？</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="fe ff lu"><img src="../Images/245bd943dab8a4df843c3e6f962a5c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wqy1LNZewAp5t7FXFCiiwA.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek"><a class="ae jt" href="https://github.com/fhinkel/git-bisect-demo" rel="noopener ugc nofollow" target="_blank">Use this repository to practice git bisect.</a></figcaption></figure><h2 id="1806" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jc km kn ko jg kp kq kr jk ks kt ku kv dt translated">自动化git-二分</h2><p id="bf03" class="pw-post-body-paragraph ir is hu it b iu lp iw ix iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo hn dt translated">您可以使用脚本运行<code class="eh jp jq jr js b">git-bisect</code>,而不是手动测试每个步骤。它将在每一步使用脚本并自动标记提交，直到找到第一个错误的提交。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="jz ka l"/></div></figure></div></div>    
</body>
</html>