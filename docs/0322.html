<html>
<head>
<title>Progressive Web Apps (PWAs) FTW — Pt. 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">渐进式网络应用(PWAs) FTW — Pt。2</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/progressive-web-apps-pwas-ftw-pt-2-31c2779e55c4?source=collection_archive---------1-----------------------#2019-01-14">https://medium.com/hackernoon/progressive-web-apps-pwas-ftw-pt-2-31c2779e55c4?source=collection_archive---------1-----------------------#2019-01-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="ab fr cl iv"><img src="../Images/af1247c98d959a617151d9a198ff8b09.png" data-original-src="https://miro.medium.com/v2/format:webp/1*oGZniVn0jfVzLYkNgX4dQA.png"/></div></figure><h2 id="8e28" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">介绍</h2><p id="f80c" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">在本系列的第1部分中，我们了解了什么是渐进式网络应用，并讨论了它们如何改善移动网络中的用户体验。这些文章基于我在<a class="ae kr" href="https://summit2018.reversim.com/session/5b1041fd892ac30014816955.html" rel="noopener ugc nofollow" target="_blank">黑白棋峰会</a>上的演讲。如果你喜欢看视频，你可以在这里看到它:</p><figure class="ks kt ku kv fq iu"><div class="bz el l di"><div class="kw kx l"/></div></figure><p id="3aeb" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">让我们从上次停止的地方继续，深入研究Web Workers。网络工作者是实现PWAs的核心技术。</p><h2 id="c2fe" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">网络工作者</h2><p id="572e" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">如果你以前对<a class="ae kr" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> Javascript </a>有所了解，你可能会注意到它是单线程的。如果您在客户端进行任何昂贵的计算，这是显而易见的。在这些情况下，在运行计算的脚本完成之前，页面会变得没有响应。一个web工作者来解决我们所有的Javascript在主线程上运行的问题。web worker是在后台运行的JS，独立于脚本，不影响页面的性能。</p><h2 id="4f68" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">服务人员</h2><p id="bc63" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">服务工作者是网络工作者的一种。这意味着它是一个独立于主浏览器线程运行的Javascript文件。服务工作者是事件驱动的，是利用所有先进的web应用技术的基础。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/1b5719a7a7a3f6529cb94b1f7a442ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*jEP8wsLR1Bhzel-3wHoGaw.png"/></div></figure><h2 id="16e0" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">我们能为服务人员做些什么？</h2><ul class=""><li id="bfab" class="le lf hu jy b jz ka kd ke jj lg jn lh jr li kq lj lk ll lm dt translated">服务人员可以作为可编程的网络代理。这就是为什么它只能在https上工作(否则中间人攻击将非常容易！).</li><li id="fbc6" class="le lf hu jy b jz ln kd lo jj lp jn lq jr lr kq lj lk ll lm dt translated">服务人员有一个可预测的生命周期。如果你曾经使用过React、原生Android甚至Chrome扩展，那就非常相似。我们将监听浏览器或应用程序触发的特定事件。</li><li id="3d8d" class="le lf hu jy b jz ln kd lo jj lp jn lq jr lr kq lj lk ll lm dt translated">服务人员还将允许我们以编程方式控制缓存管理。</li><li id="79f1" class="le lf hu jy b jz ln kd lo jj lp jn lq jr lr kq lj lk ll lm dt translated">还有更多！</li></ul><h2 id="cef3" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">服务人员生命周期</h2><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ls"><img src="../Images/e8b50d7b6323f8afc3ade385af0f4b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JdFcHdQSdY_gcl11ZLY1bg.png"/></div></div></figure><p id="406a" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">重要的事情先来。在监听服务工作者事件之前，我们必须注册我们的服务工作者。这很简单。我们只是检查当前的浏览器是否支持服务人员，如果支持，我们就注册我们的服务人员文件。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff lx"><img src="../Images/3a85663f451e41bae5972fd85a5de7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZ-Jo9ZuiRt7XeDnnANULQ.png"/></div></div></figure><p id="20d0" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">现在我们已经注册了我们的服务工作者，我们可以设置事件监听器。注册后触发的第一个事件是<em class="ly"> install事件。</em></p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff lz"><img src="../Images/f866ff386bcae95606a57c48ff86a6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Es8Ta2NkyAup0eDuPz6bw.png"/></div></div></figure><p id="c1b3" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">最后，我们可以监听激活事件。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ma"><img src="../Images/9d3422906e8be065181446a4c649f188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nvz26CZsHFT5b1-HqLrb6w.png"/></div></div></figure><p id="6d53" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">我们已经看到了如何监听这些生命周期事件。随着我们的深入，我们将看看如何利用每个事件来注入我们自己的定制逻辑。让我们用我们的第一个端到端例子来把它付诸实践。</p><h2 id="d2e0" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">我们的第一个服务人员</h2><p id="b408" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">让我们实现一个简单的服务工作者。我们将包括我们的服务人员文件，注册并记录基本事件的触发。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mb"><img src="../Images/dc08c172deefe1f92d95c2e32e96c089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fu1yNWDgt_QhphSTolMpg.png"/></div></div></figure><p id="b877" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">在我们的主JS文件中，我们检查是否支持服务工作者。如果是，让我们注册，然后记录注册尝试的结果。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mc"><img src="../Images/20cff1501fcb81e26189178fa4033452.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*20jhGUFuWw3UyhyZW8shlA.png"/></div></div></figure><p id="c6b0" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">现在，让我们看看我们的基本服务人员日志。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff md"><img src="../Images/2a87006147c98930ece7892587d8e4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sv1AhVUHDRMh9-h8ZiRyYg.png"/></div></div></figure><p id="b207" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">最后，我们可以验证服务工作者事件是否按预期触发！</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff me"><img src="../Images/d6c875d04760c6aedecddd45ae691798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0OHf2SJ5aTj0ald23Kvpg.png"/></div></div></figure><h2 id="7acd" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">拦截网络请求</h2><p id="eba8" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">服务人员可以用来拦截任何网络请求。我们现在可以观看JS，CSS，HTML和XHR请求！让我们熟悉一下API。我们将简单地监听浏览器触发的<em class="ly"> fetch </em>事件。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mf"><img src="../Images/52df513ecaa52eb4a8bf29c6087d307d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKif_JkxV3ysGosPcAGBCA.png"/></div></div></figure><p id="f4fe" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">作为参数提供给回调的事件对象有几个属性，使我们能够容易地检测每个传出获取请求的来源和方法。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mg"><img src="../Images/2117e9bd1a3c957f0dae02221806611a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTneUl1kUY5bJTR1lvN2bw.png"/></div></div></figure><p id="6e59" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">婴儿第一步！对于每个传出的获取请求，让我们返回静态HTML。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mh"><img src="../Images/6f3513c571d58aeba74708683193f919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cyrC_50JP_MU3ENMnhDhvA.png"/></div></div></figure><p id="e7a8" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">在了解缓存API之后，我们将再次讨论拦截<a class="ae kr" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>请求的能力。</p><h2 id="081d" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">缓存API</h2><p id="b372" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">缓存API允许我们通过注册的服务工作者以编程方式控制浏览器缓存。我们可以存储和检索网络请求和相应的响应。想象以下情况:</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mi"><img src="../Images/e572800082d4a3d67fdb3c6ab0094eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A47rLjs5d4oe4TjXkidS1A.png"/></div></div></figure><p id="1466" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">因此，我们可以在服务工作器中为web应用程序发出的请求设置字典。如果我们有应该缓存的数据，或者如果我们想减少网络流量，这正是这样做的地方:)让我们看一些代码。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mi"><img src="../Images/aaa366d4e206190346bbee2105ed0c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUJuZtF9rvPtU0Zhvgz5JA.png"/></div></div></figure><p id="2c66" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><em class="ly"> waitUntil </em>方法告诉浏览器不要杀死服务工作者，直到我们的代码块执行完毕。本质上，我们将这段代码定义为关键代码。最后，我们用put方法写入浏览器缓存。这将更新缓存字典中的现有键，或者创建一个新键(如果它尚不存在)。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mj"><img src="../Images/643ef3c1465246793805f65dfd1b7095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74lQ2ZMAo_-3HvJw9mx5Ww.png"/></div></div></figure><h2 id="372d" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">缓存策略</h2><p id="e2c1" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">缓存API引入了许多有趣的选项，用于以编程方式控制浏览器缓存。我们来看看吧！</p><p id="4a00" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">仅缓存</strong></p><p id="61b5" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">对于每个传出的网络请求，我们将尝试从缓存映射中做出响应。如果我们没有适当的回应，那就没运气了:/</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mk"><img src="../Images/48a215fcc68b14afa89b16cdeff44a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iOSrZbTGv1z7DkiEMQ2VA.png"/></div></div></figure><p id="9e21" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">仅网络</strong></p><p id="119b" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">对于每个传出的获取请求，我们将忽略缓存并将其转发到网络。这正是我们不缓存任何东西时会发生的情况。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ml"><img src="../Images/4a0035de1b494f4bd470fe1a79c21ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbVDQNpj9fHO0qrLYPy36A.png"/></div></div></figure><p id="e77d" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">尽管这不是最佳的！我们可以做得更好！</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mm"><img src="../Images/38154dcd408848650d6e417b9d1ec4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_Pk2CpOBiUCNBaBBMskfQ.png"/></div></div></figure><p id="c9c8" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">混合缓存策略</strong></p><p id="0b13" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">我们来看看<strong class="jy hv">带网络备份策略的缓存。</strong>对于每个传出的获取请求，我们检查以确保响应是否已经存在于我们的缓存映射中。如果是的话，我们就退回去。否则，我们继续发出获取请求。当我们偏爱陈旧数据时，这种方法是首选。例如，对于不经常更新的静态资源。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mn"><img src="../Images/fc28c35c195011eed71de310fd636400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iNM6xErN7ryTYnte06YTw.png"/></div></div></figure><p id="6822" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">现在让我们来看一看<strong class="jy hv">具有缓存备份的网络。对于给定的请求，我们尝试发出网络请求。如果由于任何原因失败，我们会尝试从缓存中提供响应。当我们偏向于新数据时，这种方法是首选的。</strong></p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mo"><img src="../Images/fdba3f01d3ee0c12ceb67433705a32bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bc02Rgo1r5LrqhWTmLPIQg.png"/></div></div></figure><p id="1213" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">缓存API —处理404张图片</strong></p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mp"><img src="../Images/a1f939a037f143da6e5dbc5724dcb6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEKYB_LjAmP0f9ZwV6Xj1A.png"/></div></div></figure><h2 id="0f9b" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">网页推送</h2><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mq"><img src="../Images/ab7ff394f9fd62ce24bb273e208b83ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T89NpbSzN3jwqa4IAbkktg.png"/></div></div></figure><p id="d427" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">什么是网页推送？</strong></p><p id="3d2c" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">网络推送是向用户浏览器发送推送通知的能力。这是一件大事！以前，这只能通过移动应用程序实现！所有主流浏览器都支持网络推送。</p><p id="b6c2" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">web推送是如何工作的？</p><p id="7d78" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">所有主流浏览器都有云推送服务。这意味着有了适当的许可，我们的服务器可以向他们的推送服务发出请求，向我们的用户浏览器发送通知。关于这个更深入的解释，请查看上面的会议视频。这里只做最基本的。</p><p id="eada" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">获取网页推送权限</strong></p><p id="e447" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">相当简单！</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mr"><img src="../Images/940aecdb9c2262bdb801ce2600d423e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nmmV3qaxAdiFJxJDB8PNg.png"/></div></div></figure><p id="f80f" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">向推送管理器订阅推送通知</strong></p><p id="1f75" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">从我们的client.js文件(不是我们的服务人员)来看，它看起来像这样:</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ms"><img src="../Images/ebc851509a7b79e4f7d224f59772aef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_Gis_wl0bH5PJgU0LhSsg.png"/></div></div></figure><p id="5b24" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated"><strong class="jy hv">如何处理来自浏览器推送服务的客户端推送事件</strong></p><p id="a581" class="pw-post-body-paragraph jw jx hu jy b jz ky kb kc kd kz kf kg jj la ki kj jn lb kl km jr lc ko kp kq hn dt translated">我们简单地监听客户端上的<strong class="jy hv">推送事件</strong>，如下所示:</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ml"><img src="../Images/df66c161fdd999712a17a90d59aca4c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vhv9OtdpB-feRzIT1YGpsw.png"/></div></div></figure><h2 id="b2a9" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">结论</h2><p id="a0ad" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">在本系列的第1部分和第2部分中，我们已经看到了PWAs的威力。我们仅仅触及了表面，但是我希望您在离开时能够理解这是多么简单和强大。</p><figure class="ks kt ku kv fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mt"><img src="../Images/8e423e6f54e208657b69e1a5c6e9e9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mimSK5mAT--P9Kl1eQTMpA.png"/></div></div></figure><h2 id="3e35" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">如果这篇文章有帮助，请订阅并点击鼓掌👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">你可以在<a class="ae kr" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae kr" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae kr" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我，了解更多科技相关内容！</p><figure class="ks kt ku kv fq iu"><div class="bz el l di"><div class="mu kx l"/></div></figure></div></div>    
</body>
</html>