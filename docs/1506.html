<html>
<head>
<title>Simplifying Responsive Layouts with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 React 挂钩简化响应布局</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/simplifying-responsive-layouts-with-react-hooks-19db73893a7a#2019-03-04">https://medium.com/hackernoon/simplifying-responsive-layouts-with-react-hooks-19db73893a7a#2019-03-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8e10508a2283dd2c790bf1e53a05d49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bg4KvVu9FXgLgPxEaS7g4Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">By Stéphanie Walter — <a class="ae jg" href="https://blog.stephaniewalter.fr/en/download-illustration-content-is-like-water/" rel="noopener ugc nofollow" target="_blank">https://blog.stephaniewalter.fr/en/download-illustration-content-is-like-water/</a></figcaption></figure><p id="06cd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">自从 React 16.8 发布以来，我一直喜欢使用<a class="ae jg" href="https://hackernoon.com/tagged/hooks" rel="noopener ugc nofollow" target="_blank">钩子</a>来创建可组合和可重用的逻辑，并用显式生命周期方法编写更少的类组件。这不仅会带来更愉快的开发体验，而且(在我看来)会带来可读性更好的代码库。</p><p id="bddc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">今天我将介绍几个钩子，并用它们来构建一个简单的响应布局。使用上下文 API，我们可以确保所有组件都可以访问最新的窗口维度，而不需要依赖生命周期来附加和清理事件侦听器。</p><h2 id="875f" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">成品</h2><figure class="lb lc ld le fq iv fe ff paragraph-image"><div class="fe ff la"><img src="../Images/5b02bfb2c485f3d99646a1fc6dfa8665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*1dgjys8UjLXISZ3ooC-LMg.gif"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">v responsive</figcaption></figure><p id="6ccd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完成的代码可以在<a class="ae jg" href="http://github.com/pdeona/responsive-layout-hooks" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h2 id="e435" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">第一步</h2><p id="5413" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">首先，我们将用<code class="eh lr ls lt lu b">create-react-app</code>搭建一个新的 react 应用，并添加精彩的<code class="eh lr ls lt lu b">bulma</code> css 库:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="dfb5" class="kf kg hu lu b fv lz ma l mb mc">$ create-react-app my-responsive-app<br/>$ cd !$<br/>$ yarn add bulma node-sass<br/>$ yarn start</span></pre><p id="bbd0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">入门到此为止。我们将为一些好看的组件使用<code class="eh lr ls lt lu b">bulma</code>，但是我们将使用 React 和 JS 处理所有的响应设计。</p><h2 id="d85e" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">关于响应</h2><figure class="lb lc ld le fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/c3bc1ab2c233230224259951f326c5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*32jUQrbTf7-V9MYUs_Zthw.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Handling different device sizes is pretty important from what I hear.</figcaption></figure><p id="1832" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">什么是响应式网页设计？根据互联网:</p><blockquote class="me mf mg"><p id="0268" class="jh ji mh jj b jk jl jm jn jo jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ke hn dt translated">响应式网页设计 ( <strong class="jj hv"> RWD </strong>)是一种<a class="ae jg" href="https://en.m.wikipedia.org/wiki/Web_design" rel="noopener ugc nofollow" target="_blank">网页设计</a>的方法，可以让网页在各种设备和窗口或屏幕尺寸上呈现良好</p><p id="6b95" class="jh ji mh jj b jk jl jm jn jo jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ke hn dt translated">—维基百科</p></blockquote><p id="705d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧！这似乎是我们可以在 CSS 中处理的事情，使用相对单位和媒体查询，对吗？</p><p id="4ee0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗯，是也不是。大多数时候，如果工作只是简单地在页面上安排内容，CSS 可以处理这项工作。然而，有时你可能想根据页面大小改变渲染行为，为此，你几乎肯定需要一些 Javascript(或其他黑魔法)。</p><h2 id="8e8b" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">反应过来道</h2><p id="55d9" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">所以 React 就是创建可重用的表示逻辑(组件)并使用它们来组成视图。现在我们有了钩子，我们实际上可以进一步简化这种组合:钩子允许我们将某些行为(通常由多个钩子组成)封装到函数中，这些函数直接集成到 React 的渲染器中(使用新的<code class="eh lr ls lt lu b">React Fiber</code>，我们不会在这里深入讨论)，以使用它们自动更新组件。</p><h2 id="5c73" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">那又怎样？</h2><p id="98f1" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">所以，这个老东西(<code class="eh lr ls lt lu b">/clap</code>如果你已经在你的一个 React 应用中写了这个):</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="ac09" class="kf kg hu lu b fv lz ma l mb mc">class NavBar extends Component {<br/>  state = { open: false }<br/>  <br/>  setOpen = open =&gt; this.setState({ open })</span><span id="5bd3" class="kf kg hu lu b fv ml ma l mb mc">  render() {<br/>    return (this.state.open ?<br/>      &lt;NavMenu /&gt; :<br/>      &lt;HamburgerButton onClick={() =&gt; this.setOpen(true)} /&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="cbeb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在已经变成了:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="05c9" class="kf kg hu lu b fv lz ma l mb mc">function NavBar() {<br/>  const [open, setOpen] = useState(false)<br/>  return (open ?<br/>    &lt;NavMenu /&gt; :<br/>    &lt;HamburgerButton onClick={() =&gt; setOpen(true)} /&gt;<br/>  )<br/>}</span></pre><p id="6c68" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果这还不算什么，你可以在这里看看人们用钩子做的一些很酷的东西:<a class="ae jg" href="https://codesandbox.io/react-hooks" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/react-hooks</a></p><p id="fea9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">关键是，钩子很好。我们不需要输入太多，而且我们几乎再也不用担心<code class="eh lr ls lt lu b">componentDidMount/componentDidUpdate/setState</code>或者类属性提议的状态(谢谢 babel)。</p><p id="3d5d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们知道了什么是响应式网页设计(某种程度上)和钩子(也是某种程度上)，让我们用它们来做点什么吧！首先，让我们实现我们的基本构建块(对于本文):组件<code class="eh lr ls lt lu b">ResponsiveLayout</code>。</p><p id="99f7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们将创建一个很好的旧功能组件(在<code class="eh lr ls lt lu b">src/components/ResponsiveLayout/index.js</code>中)，它接受三个道具:<code class="eh lr ls lt lu b">renderDesktop</code>、<code class="eh lr ls lt lu b">renderMobile</code>和<code class="eh lr ls lt lu b">breakpoint</code>。</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="d3fe" class="kf kg hu lu b fv lz ma l mb mc">import { useState, useEffect } from 'react'</span><span id="483f" class="kf kg hu lu b fv ml ma l mb mc">const ResponsiveLayout = ({ breakpoint, renderMobile, renderDesktop }) =&gt; {<br/>  const [width, setWidth] = useState(window.innerWidth)<br/>  useEffect(() =&gt; {<br/>    const handleResize = () =&gt; {<br/>      setWidth(window.innerWidth)<br/>    }<br/>    window.addEventListener(‘resize’, handleResize)<br/>    return () =&gt; { window.removeEventListener(‘resize’, handleResize) }<br/>  }, [])<br/>  return (width &gt; breakpoint ? renderDesktop() : renderMobile())<br/>}</span></pre><p id="aec1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们只是在创建组件时读取窗口的宽度，并使用<code class="eh lr ls lt lu b">useState</code>钩子存储它，然后在我们的<code class="eh lr ls lt lu b">useEffect</code>钩子中建立一个事件监听器。</p><h2 id="f50c" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">使用状态</h2><p id="b67f" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated"><code class="eh lr ls lt lu b">useState</code>允许我们拥有有状态的功能组件！你调用<code class="eh lr ls lt lu b">useState(initialValue)</code>，它返回一对<code class="eh lr ls lt lu b">[state, setState]</code>。因为它返回一个数组而不是一个对象，所以您可以随意命名这些引用。最重要的是，当您使用从 React DOM 返回的<code class="eh lr ls lt lu b">setState</code>函数时，<code class="eh lr ls lt lu b">useState</code>挂钩到 React DOM 并触发呈现，因此它的工作方式就像<code class="eh lr ls lt lu b">this.setState</code>对类组件的工作方式一样。</p><h2 id="fff8" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">使用效果</h2><p id="0073" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated"><code class="eh lr ls lt lu b">useEffect</code>通常会在每次组件重新渲染时运行它的代码，但是它接受第二个参数，一个变量数组，通知<code class="eh lr ls lt lu b">useEffect</code>它应该只在数组内的值改变时才重新运行。当提供一个空数组时，它将永远不会重新运行，所以它的行为完全像<code class="eh lr ls lt lu b">componentDidMount</code>！如果需要的话，<code class="eh lr ls lt lu b">useEffect</code>的返回值应该是一个清理函数，这样它就可以在效果重新运行或者组件从 DOM 中删除之前运行。这里我们指定了一个匿名函数，它将在卸载这个组件时删除事件监听器(听起来很熟悉吧？这就是我们在<code class="eh lr ls lt lu b">componentWillUnmount</code>中一直在做的事情。</p><p id="3645" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这看起来很好，但是如果页面上有多个地方需要基于断点进行渲染，会发生什么呢？我们不应该在每次安装这些组件时都为同一个事件设置新的事件监听器，特别是因为我们只有一个窗口大小调整监听器。</p><h2 id="e119" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">输入使用上下文</h2><p id="17b1" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">钩子让事情变得更好的一个方法是使用上下文 API。以前，使用上下文需要使用消费者和提供者组件，并在任何需要访问值的组件中使用消费者。这导致开发人员创建更高阶的组件来提供上下文作为道具(例如，<code class="eh lr ls lt lu b">react-redux</code>的<code class="eh lr ls lt lu b">connect</code>)或简单的非常冗长的代码。现在，有了<code class="eh lr ls lt lu b">useContext</code>，我们不再需要使用<code class="eh lr ls lt lu b">Context.Consumer</code>组件让孩子们从上下文中意识到价值。</p><p id="571f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们使用上下文和应用程序范围的<code class="eh lr ls lt lu b">WindowDimensionsProvider</code>重写上面的组件。</p><p id="e034" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh lr ls lt lu b">src/components/WindowDimensionsProvider/index.js</code>中:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="1c1a" class="kf kg hu lu b fv lz ma l mb mc">import React, { createContext, useContext, useState, useEffect } from 'react'</span><span id="ef14" class="kf kg hu lu b fv ml ma l mb mc">const WindowDimensionsCtx = createContext(null)</span><span id="49d5" class="kf kg hu lu b fv ml ma l mb mc">const WindowDimensionsProvider = ({ children }) =&gt; {<br/>  const [dimensions, setDimensions] = useState({<br/>    width: window.innerWidth,<br/>    height: window.innerHeight,<br/>  })<br/>  useEffect(() =&gt; {<br/>    const handleResize = () =&gt; {<br/>      setDimensions({<br/>        width: window.innerWidth,<br/>        height: window.innerHeight,<br/>      })<br/>    }<br/>    window.addEventListener(‘resize’, handleResize)<br/>    return () =&gt; { window.removeEventListener(‘resize’, handleResize) }<br/>  }, [])<br/>  return (<br/>    &lt;WindowDimensionsCtx.Provider value={dimensions}&gt;<br/>      {children}<br/>    &lt;/WindowDimensionsCtx.Provider&gt;<br/>  )<br/>}</span><span id="1488" class="kf kg hu lu b fv ml ma l mb mc">export default WindowDimensionsProvider<br/>export const useWindowDimensions = () =&gt; useContext(WindowDimensionsCtx)</span></pre><p id="76d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个组件应该在<code class="eh lr ls lt lu b">src/App.js</code>中被调用，就像这样:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="e399" class="kf kg hu lu b fv lz ma l mb mc">import React from 'react'<br/>import Content from './components/Content'<br/>import WindowDimensionsProvider from './components/WindowDimensionsProvider'<br/>import items from './data.json'<br/>import 'bulma/css/bulma.css'</span><span id="a651" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">const</em> App = () <em class="mh">=&gt;</em> (<br/>  &lt;WindowDimensionsProvider&gt;<br/>    &lt;div <em class="mh">className</em>="App"&gt;<br/>      &lt;Content <em class="mh">items</em>={items} /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/WindowDimensionsProvider&gt;<br/>)</span><span id="9e20" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">export</em> <em class="mh">default</em> App</span></pre><p id="5d6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:在现实世界的应用程序中，你应该<em class="mh">也</em>写一个高阶组件，用于类组件；请在此处查看示例实现<a class="ae jg" href="https://github.com/pdeona/responsive-layout-hooks/blob/master/src/components/withWindowDimensions/withWindowDimensions.js" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1525" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要担心<code class="eh lr ls lt lu b">Content</code>和<code class="eh lr ls lt lu b">items</code>，我们稍后会谈到它们。重要的是，<code class="eh lr ls lt lu b">Provider</code>组件在应用程序的渲染树中比任何想要从其<code class="eh lr ls lt lu b">Context</code>中读取数据的组件显示得更高。(这很重要，以便 React 知道提供哪个上下文值，以防您的应用程序中呈现同一类型<code class="eh lr ls lt lu b">Provider</code>的多个实例。)</p><p id="4e42" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过这样做，我们确保了以下几点:</p><ul class=""><li id="f51b" class="mm mn hu jj b jk jl jo jp js mo jw mp ka mq ke mr ms mt mu dt translated">页面上只有一个活动的“调整大小”事件侦听器</li><li id="9f80" class="mm mn hu jj b jk mv jo mw js mx jw my ka mz ke mr ms mt mu dt translated">只要 React 正在呈现我们的应用程序组件，它就会保持活动状态</li><li id="99c7" class="mm mn hu jj b jk mv jo mw js mx jw my ka mz ke mr ms mt mu dt translated">我们的应用程序中的所有组件(这里只有<code class="eh lr ls lt lu b">Content</code>组件)都可以访问 WindowDimensionsProvider 的上下文</li></ul><p id="479c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">设置好这个管道后，让我们重写我们的响应式布局处理组件:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="0c5f" class="kf kg hu lu b fv lz ma l mb mc">import { useWindowDimensions } from '../WindowDimensionsProvider'</span><span id="6f84" class="kf kg hu lu b fv ml ma l mb mc">const ResponsiveLayout = ({ breakpoint, renderMobile, renderDesktop }) =&gt; {<br/>  const { width } = useWindowDimensions()<br/>  return (width &gt; breakpoint ? renderDesktop() : renderMobile())<br/>}</span></pre><p id="281d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">哇！我们不仅有了一个性能更好的实现(因为每个实例都不必设置/拆除事件侦听器)，而且组件中发生的事情也少得多。从语义上来说，每一行代码都完美地描述了它在做什么:</p><ul class=""><li id="576f" class="mm mn hu jj b jk jl jo jp js mo jw mp ka mq ke mr ms mt mu dt translated">使用窗口尺寸获得宽度。</li><li id="b6bc" class="mm mn hu jj b jk mv jo mw js mx jw my ka mz ke mr ms mt mu dt translated">如果宽度大于断点，则呈现桌面视图。否则，渲染移动视图。</li></ul><p id="8479" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">非常简单。</p><p id="9221" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们有了这个工具，让我们用它来做一个响应式布局。</p><h2 id="63b4" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">需要更多内容</h2><p id="90b1" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">因此，让我们建立我们的两个布局。对于我们的移动视图，我们将呈现一个选项卡式视图:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="790b" class="kf kg hu lu b fv lz ma l mb mc"><em class="mh">import</em> React <em class="mh">from</em> 'react'<br/><em class="mh">import</em> TabbedView <em class="mh">from</em> './TabbedView'</span><span id="69c1" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">const</em> MobileView = ({ items }) <em class="mh">=&gt;</em> (<br/>  &lt;div <em class="mh">className</em>='container box'&gt;<br/>    &lt;TabbedView <em class="mh">items</em>={items} /&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="b70e" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">export</em> <em class="mh">default</em> MobileView</span></pre><p id="02d1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于 TabbedView，我们将使用<code class="eh lr ls lt lu b">useState</code>来跟踪活动选项卡，这样它就可以接收正确的样式，并且我们知道在内容框中呈现什么。</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="d638" class="kf kg hu lu b fv lz ma l mb mc"><em class="mh">import</em> React, { useState } <em class="mh">from</em> 'react'</span><span id="cb01" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">const</em> TabbedView = ({ className, items, renderItem }) <em class="mh">=&gt;</em> {<br/>  <em class="mh">const</em> [active, setActive] = useState(0)<br/>  <em class="mh">return</em> (<br/>    &lt;div <em class="mh">className</em>='tabs-container'&gt;<br/>      &lt;nav <em class="mh">className</em>='tabs is-centered'&gt;<br/>        &lt;ul&gt;<br/>          {items.map(({ title }, idx) <em class="mh">=&gt;</em> (<br/>            &lt;li<br/>              <em class="mh">className</em>={idx === active ? 'is-active' : ''}<br/>              <em class="mh">key</em>={title}<br/>            &gt;<br/>              &lt;a <em class="mh">onClick</em>={() <em class="mh">=&gt;</em> setActive(idx)}&gt;{title}&lt;/a&gt;<br/>            &lt;/li&gt;<br/>          ))}<br/>        &lt;/ul&gt;<br/>      &lt;/nav&gt;<br/>      &lt;div&gt;<br/>        &lt;p <em class="mh">className</em>='content'&gt;<br/>          {items[active].content}<br/>        &lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="e8b4" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">export</em> <em class="mh">default</em> TabbedView</span></pre><p id="6867" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里，我们简单地在顶部(在一个<code class="eh lr ls lt lu b">nav</code>内)为选项卡设置一个容器，并根据活动选项卡呈现内容。</p><p id="8915" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对于桌面，我们将为每个项目提供自己的磁贴。</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="9441" class="kf kg hu lu b fv lz ma l mb mc"><em class="mh">import</em> React <em class="mh">from</em> 'react'<br/><em class="mh">import</em> Tile <em class="mh">from</em> './Tile'<br/><em class="mh">import</em> { useWindowDimensions } <em class="mh">from</em> '../WindowDimensionsProvider'</span><span id="2563" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">const</em> DesktopView = ({ items }) <em class="mh">=&gt;</em> {<br/>  <em class="mh">const</em> { width } = useWindowDimensions()<br/>  return (<br/>    &lt;div<br/>      <em class="mh">className</em>={‘tile is-ancestor ‘<br/>        .concat(width &lt; 1088 ? ‘is-vertical’ : ‘’)}<br/>    &gt;<br/>      {items.map((item, idx) <em class="mh">=&gt;</em> (<br/>        &lt;Tile<br/>          <em class="mh">key</em>={item.title}<br/>          {...item}<br/>        /&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  )<br/>}</span><span id="4905" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">export</em> <em class="mh">default</em> DesktopView</span></pre><p id="12cb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的桌面视图甚至还可以处理宽度，只需要很小的改变(比如添加一个类名)，而不会变得太复杂。</p><p id="0278" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们的瓷砖只有几格宽:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="f6b8" class="kf kg hu lu b fv lz ma l mb mc">import React from 'react'</span><span id="b6d6" class="kf kg hu lu b fv ml ma l mb mc">const Tile = ({ title, content }) =&gt; (<br/>  &lt;div className='tile is-parent notification box'&gt;<br/>    &lt;div className='tile is-child'&gt;<br/>      &lt;p className='title'&gt;{title}&lt;/p&gt;<br/>      &lt;span className='content'&gt;{content}&lt;/span&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>)</span><span id="5f88" class="kf kg hu lu b fv ml ma l mb mc">export default Tile</span></pre><p id="e8ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<code class="eh lr ls lt lu b">src/Content/index.js</code>中，我们将为响应式布局编写一个基本的包装器:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="1c70" class="kf kg hu lu b fv lz ma l mb mc">import React from 'react'<br/>import ResponsiveLayout from '../ResponsiveLayout'<br/>import MobileView from './MobileView'<br/>import DesktopView from './DesktopView'</span><span id="5c6e" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">const</em> Content = ({ items }) <em class="mh">=&gt;</em> (<br/>  &lt;ResponsiveLayout<br/><em class="mh">    breakPoint</em>={767}<br/><em class="mh">    renderDesktop</em>={() <em class="mh">=&gt;</em> (<br/>      &lt;DesktopView <em class="mh">items</em>={items} /&gt;<br/>    )}<br/><em class="mh">    renderMobile</em>={() <em class="mh">=&gt;</em> (<br/>      &lt;MobileView <em class="mh">items</em>={items} /&gt;<br/>    )}<br/>  /&gt;<br/>)</span><span id="74df" class="kf kg hu lu b fv ml ma l mb mc"><em class="mh">export</em> <em class="mh">default</em> Content</span></pre><h2 id="0c7c" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">包扎</h2><p id="cdec" class="pw-post-body-paragraph jh ji hu jj b jk lm jm jn jo ln jq jr js lo ju jv jw lp jy jz ka lq kc kd ke hn dt translated">现在我们已经定义了我们的<code class="eh lr ls lt lu b">Content</code>组件，我们只需要一些数据来呈现。在<code class="eh lr ls lt lu b">src/data.json</code>中，我们可以创建一些占位符数据，看看我们目前做得如何:</p><pre class="lb lc ld le fq lv lu lw lx aw ly dt"><span id="7fa7" class="kf kg hu lu b fv lz ma l mb mc">[<br/>  { title: "Bananas", "content": "Bananas! I will write some great placeholder text – and nobody writes better placeholder text than me, believe me – and I’ll write it very inexpensively. I will write some great, great text on your website’s Southern border, and I will make Google pay for that text. Mark my words. Lorem Ipsum is a choke artist. It chokes!" },<br/>... more data<br/>]</span></pre><p id="0ff1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一切就绪后，我们应该能够通过调整窗口大小来确认视图从选项卡式视图切换到一组平铺视图。</p><p id="c988" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我希望这个演练已经展示了在 React 应用程序中使用钩子的一些方法。以下是我最近在应用程序中使用钩子的一些好方法:</p><ul class=""><li id="ebbe" class="mm mn hu jj b jk jl jo jp js mo jw mp ka mq ke mr ms mt mu dt translated">用<code class="eh lr ls lt lu b">IntersectionObserver</code>创建一个<code class="eh lr ls lt lu b">OnScrollIntoView</code>组件</li><li id="b160" class="mm mn hu jj b jk mv jo mw js mx jw my ka mz ke mr ms mt mu dt translated">创建可重用的动画组件(使用神奇的<code class="eh lr ls lt lu b">react-spring</code>包)</li><li id="6011" class="mm mn hu jj b jk mv jo mw js mx jw my ka mz ke mr ms mt mu dt translated">构建一个延迟加载的图像组件，用于在慢速连接上呈现图像</li></ul><p id="862f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">本指南到此为止！如果你喜欢这篇文章，如果你想让我写些别的东西，或者如果你有问题，请在评论中告诉我。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>