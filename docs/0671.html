<html>
<head>
<title>Building Isomorphic JavaScript Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建同构的 JavaScript 包</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-isomorphic-javascript-packages-1ba1c7e558c5#2019-01-28">https://medium.com/hackernoon/building-isomorphic-javascript-packages-1ba1c7e558c5#2019-01-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8aee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我第一次在 web 开发中碰到这个词的时候，不得不在字典里查同构。<a class="ae jp" href="https://en.wikipedia.org/wiki/Isomorphic_JavaScript" rel="noopener ugc nofollow" target="_blank">维基百科</a>报道称<strong class="it hv"> <em class="jq">同构 JavaScript </em> </strong> <em class="jq">，也被称为</em> <strong class="it hv"> <em class="jq">通用 JavaScript </em> </strong> <em class="jq">，描述了</em><a class="ae jp" href="https://en.wikipedia.org/wiki/JavaScript" rel="noopener ugc nofollow" target="_blank"><em class="jq"/></a><em class="jq">JavaScript 应用程序，它们同时运行在</em> <a class="ae jp" href="https://en.wikipedia.org/wiki/Client_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="jq">客户端</em> </a> <em class="jq">和</em> <a class="ae jp" href="https://en.wikipedia.org/wiki/Server_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="jq">服务器上</em></a></p><p id="de58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建一个在服务器(即节点)和客户端(即浏览器)都能开箱即用的包是很困难的。一旦你开始混合依赖项，即使其中一个调用一个仅节点的包(想想<code class="eh jr js jt ju b"><a class="ae jp" href="https://nodejs.org/api/fs.html" rel="noopener ugc nofollow" target="_blank">fs</a></code>)或仅浏览器的对象(想想<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.w3schools.com/jsref/obj_window.asp" rel="noopener ugc nofollow" target="_blank">window</a></code>)，它也会影响你的整个构建。更糟糕的是，您甚至可能无法合理地推断出这个问题的存在，因为它们可能隐藏在与您正在编写的代码毫无关系的子-子-子依赖关系中。</p><p id="aec0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文档描述了开发同构节点包的几个简单约定，并以一封关于如何对它们进行打包的固执己见的信件结束。</p><h1 id="4f66" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">忽略 webpack 中的要求</h1><p id="07d9" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">即使你使用像<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.npmjs.com/package/detect-node" rel="noopener ugc nofollow" target="_blank">detect-node</a></code>这样的包来创建条件节点 vs 浏览器导入，<a class="ae jp" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>并不关心条件，因为它不知道运行时将如何解析它们。因此，在下面的场景中:</p><pre class="ky kz la lb fq lc ju ld le aw lf dt"><span id="9393" class="lg jw hu ju b fv lh li l lj lk">const foo = isNode ?<br/>  r<!-- -->equire("fs") :<br/>  require("fs-web");</span></pre><p id="4058" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">它会很乐意尝试打包您需要的所有代码，这意味着在这种情况下，它会尝试打包<code class="eh jr js jt ju b">fs</code>。然后，它将失败，并显示以下错误消息。</p><pre class="ky kz la lb fq lc ju ld le aw lf dt"><span id="ce02" class="lg jw hu ju b fv lh li l lj lk">Module not found: Error: Can't resolve 'fs' in [insert file here]</span></pre><p id="0b08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在回答我关于如何解决这个难题的问题时，Alex Rokabilis 写道:</p><blockquote class="ll lm ln"><p id="98c6" class="ir is jq it b iu iv iw ix iy iz ja jb lo jd je jf lp jh ji jj lq jl jm jn jo hn dt translated">[查看]不太知名的<code class="eh jr js jt ju b">__non_webpack_require__</code>函数。这是一个特定于 webpack 的函数，它将指示解析器避免捆绑这个被请求的模块，并假设全局<code class="eh jr js jt ju b">require</code>函数是可用的。</p></blockquote><p id="2753" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然<code class="eh jr js jt ju b"><a class="ae jp" href="https://webpack.js.org/api/module-variables/" rel="noopener ugc nofollow" target="_blank">__non_webpack_require__</a></code>是 API 的一个文档部分，但它隐藏在文档深处，因此不为人知。然而，它的工作原理就像一个小窍门。</p><p id="723d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你试着写:</p><pre class="ky kz la lb fq lc ju ld le aw lf dt"><span id="0317" class="lg jw hu ju b fv lh li l lj lk">const foo = isNode ?<br/>  <a class="ae jp" href="https://webpack.js.org/api/module-variables/" rel="noopener ugc nofollow" target="_blank">__non_webpack_require__</a>("fs") :<br/>  require("fs-web");</span></pre><p id="f1d9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">节点将退出，并显示以下错误消息:</p><pre class="ky kz la lb fq lc ju ld le aw lf dt"><span id="a53c" class="lg jw hu ju b fv lh li l lj lk">__non_webpack_require__ is not defined</span></pre><p id="628b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Typescript 也不会识别<code class="eh jr js jt ju b">__non_webpack_require__</code>。</p><figure class="ky kz la lb fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff lr"><img src="../Images/ed48877acb173bb6575b1f6072651360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuyNVh5c4xjsb9zcdw0xYA.png"/></div></div></figure><p id="a45b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这可以通过以下方式来克服:</p><ol class=""><li id="a293" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated">对于打字稿用户，需要<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.npmjs.com/package/@types/webpack-env" rel="noopener ugc nofollow" target="_blank">@types/webpack-env</a></code>。不要为此使用<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.npmjs.com/package/@types/webpack" rel="noopener ugc nofollow" target="_blank">@types/webpack</a></code>，它不起作用。</li><li id="097e" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">在您的代码中，在使用<code class="eh jr js jt ju b">__non_webpack_require__</code>之前，编写以下代码:</li></ol><pre class="ky kz la lb fq lc ju ld le aw lf dt"><span id="9ded" class="lg jw hu ju b fv lh li l lj lk">if (isNode) {<br/>  (global as any).__non_webpack_require__ = require;<br/>}</span></pre><p id="fe2f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有几种不同的方法可以实现这一点，其中大多数方法不会在 IDE 中引发错误，并且可以使用<a class="ae jp" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> babel </a>和<a class="ae jp" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> typescript </a>进行编译，但是在您的节点环境中会失败。所以用这个吧——我们的团队已经对它进行了广泛的测试，它是有效的。</p><h1 id="e3a4" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">使用依赖注入和 TS 接口</h1><p id="8014" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated"><a class="ae jp" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>是一种流行的模式，由 Bob 叔叔在<a class="ae jp" href="http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中广为传播，我在这个博客上已经多次提到。其思想是依赖关系应该总是向内导入，这意味着“核心”代码永远不应该知道依赖关系，而是应该通过接口与调用代码签订合同，调用代码通过引入相关的依赖关系来实现这个合同。</p><p id="badc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh jr js jt ju b">unmock-js</code>中，我们将依赖注入用于日志记录和持久性机制，这两者都是在运行时注入到主<code class="eh jr js jt ju b">unmock</code>函数中的选项对象中定义的。如果没有给定选项，则根据<code class="eh jr js jt ju b">detect-node</code>包选择合理的缺省值，这是检测环境是否为节点的最流行、最可靠的方法。让我们看看它是如何工作的。</p><p id="b9ee" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的依赖注入中，<code class="eh jr js jt ju b">options</code>参数被定义为包含以下接口:</p><pre class="ky kz la lb fq lc ju ld le aw lf dt"><span id="494a" class="lg jw hu ju b fv lh li l lj lk">export interface IUnmockOptions {<br/>  // ... some stuff, then ...<br/>  logger?: ILogger;<br/>  persistence?: IPersistence;<br/>  // ... more stuff<br/>}</span></pre><p id="9bed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">ILogger</code>和<code class="eh jr js jt ju b">IPersistence</code>本身包含各种方法，比如<code class="eh jr js jt ju b">ILogger::log</code>和<code class="eh jr js jt ju b">IPersistence::saveHeaders</code>，这些方法调用特定于节点或浏览器的函数。例如，下面是<code class="eh jr js jt ju b">IPersistence</code>接口中一个方法的 node 和 jsdom 代码之间的区别:</p><pre class="ky kz la lb fq lc ju ld le aw lf dt"><span id="1729" class="lg jw hu ju b fv lh li l lj lk">// fs-persistence.ts</span><span id="0b37" class="lg jw hu ju b fv mn li l lj lk">export default class FSPersistence implements IPersistence {<br/>  public saveHeaders(hash: string, headers: {[key: string]: string})   <br/>  {<br/>   fs.writeFileSync(`${this.outdir(hash)}/response-header.json`, JSON.stringify(headers, null, 2));<br/>  }<br/>}</span><span id="9c74" class="lg jw hu ju b fv mn li l lj lk">// local-storage-persistence.ts<br/>export default class LocalStoragePersistence implements IPersistence {<br/>  public saveHeaders(hash: string, headers: {[key: string]: string}) <br/>  {<br/>    window.localStorage[`${this.outdir(hash)}/response-header.json`] = JSON.stringify(headers, null, 2);<br/>  }<br/>}</span></pre><h1 id="8c7d" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">不要使用单独的包装</h1><p id="9e3b" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">我在这个问题上反复思考了很久。一方面，为不同的环境使用不同的包解决了“80 年代圣诞灯”现象，即一个环境中的错误会影响所有其他环境。当然，这对包和项目管理是有害的。另一方面，如果开发人员试图开发一个同构的包，并且现在需要包含和管理多个包，单独的包会导致可用性问题。例如，目前的情况是<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.npmjs.com/package/@sentry/node" rel="noopener ugc nofollow" target="_blank">@sentry/node</a></code>对<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.npmjs.com/package/@sentry/browser" rel="noopener ugc nofollow" target="_blank">@sentry/browser</a></code>。例如，如果您正在开发一个<a class="ae jp" href="https://nextjs.org" rel="noopener ugc nofollow" target="_blank"> Next.js </a>包，并试图重用依赖于<a class="ae jp" href="https://sentry.io" rel="noopener ugc nofollow" target="_blank"> Sentry </a>的服务器和客户端代码，这可能会导致一大堆<code class="eh jr js jt ju b">if / then</code>子句。我相信哨兵会解决这个问题，但如果可能的话，一般问题应该避免。</p><p id="730d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一理念的结果是，<code class="eh jr js jt ju b"><a class="ae jp" href="https://www.npmjs.com/package/unmock" rel="noopener ugc nofollow" target="_blank">unmock-js</a></code>是一个单一的包，可以完美地跨节点和浏览器环境工作，甚至在混合了两者代码的复杂场景中。</p><p id="1e3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目标是简化开发人员的体验，以便他们在构建 web 应用程序时，有一种内置电池的方式来开始处理模拟数据。</p><h1 id="aa9f" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">TL；博士；医生</h1><p id="cdef" class="pw-post-body-paragraph ir is hu it b iu kt iw ix iy ku ja jb jc kv je jf jg kw ji jj jk kx jm jn jo hn dt translated">当制作同构 JS 包时:</p><ol class=""><li id="cc67" class="lz ma hu it b iu iv iy iz jc mb jg mc jk md jo me mf mg mh dt translated">使用<code class="eh jr js jt ju b">__non_webpack_require__</code>。</li><li id="6c04" class="lz ma hu it b iu mi iy mj jc mk jg ml jk mm jo me mf mg mh dt translated">使用依赖注入。</li></ol><p id="b964" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读！</p><figure class="ky kz la lb fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mo"><img src="../Images/13e8779ca0a4cbfdea540c9e27e10d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ctcvm3UA0dovibwM4CygzQ.jpeg"/></div></div><figcaption class="mp mq fg fe ff mr ms bd b be z ek">Who doesn’t like Morph?!?</figcaption></figure></div></div>    
</body>
</html>