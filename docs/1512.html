<html>
<head>
<title>Permission-based Authorization in ASP.NET Core with AuthorizationPolicyProvider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有AuthorizationPolicyProvider的ASP.NET核心中基于权限的授权</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/permission-based-authorization-asp-net-core-with-authorizationpolicyprovider-af4933d575ee?source=collection_archive---------11-----------------------#2019-03-04">https://medium.com/hackernoon/permission-based-authorization-asp-net-core-with-authorizationpolicyprovider-af4933d575ee?source=collection_archive---------11-----------------------#2019-03-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bd110bfa0621f4ac8b0e472f3d3af989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMB1pckSa0R41Vq1Nh1XKw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://www.pexels.com/@duncanoluwaseun" rel="noopener ugc nofollow" target="_blank">Oluwaseun Duncan</a> on <a class="ae jg" href="http://pexels.com" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="1dde" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有多种方法可以实现动态的基于许可的授权；在这篇文章中，我想实现自定义授权策略提供者，以简化ASP.NET核心中基于权限的授权机制。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="edf5" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">介绍</h1><p id="e766" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">根据ASP.NET核心中的授权基础结构，您可以使用以下代码段来应用基于声明的授权和自定义权限声明类型:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="123f" class="ly kn hu lu b fv lz ma l mb mc">services.AddAuthorization(options =&gt;<br/>{<br/>    options.AddPolicy("View Projects",<br/>        policy =&gt; policy.RequireClaim(CustomClaimTypes.Permission, "projects.view"));<br/>});</span></pre><p id="ce3b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以如下使用它:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="75d6" class="ly kn hu lu b fv lz ma l mb mc">[Authorize("View Projects")]<br/>public IActionResult Index(int siteId)<br/>{<br/>    return View();<br/>}</span></pre><p id="143b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种方法是集成的，非常简单，你不需要做任何定制；但是，在一个真实的项目或企业范围内，很难将所有权限都定义为基于声明的策略。幸运的是，<a class="ae jg" href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/iauthorizationpolicyprovider?view=aspnetcore-2.1" rel="noopener ugc nofollow" target="_blank">ASP.NET核心支持实现自定义授权策略提供者</a>并在DI系统中注册。它的用途之一是:</p><blockquote class="md me mf"><p id="6ba4" class="jh ji mg jj b jk jl jm jn jo jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated">使用大范围的策略(例如，针对不同的房间号或年龄)，因此为每个单独的授权策略添加一个AuthorizationOptions没有意义。添加策略调用。</p></blockquote></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="682d" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">实施授权策略提供者</h1><p id="ac5d" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">为此，我们可以实现AuthorizationPolicyProvider或从DefaultAuthorizationPolicyProvider继承，后者在DI系统中注册为默认提供者。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="def5" class="ly kn hu lu b fv lz ma l mb mc">public class AuthorizationPolicyProvider : DefaultAuthorizationPolicyProvider<br/>{<br/>    public AuthorizationPolicyProvider(IOptions&lt;AuthorizationOptions&gt; options)<br/>        : base(options)<br/>    {<br/>    }<br/><br/>    public override Task&lt;AuthorizationPolicy&gt; GetPolicyAsync(string policyName)<br/>    {<br/>        if (!policyName.StartsWith(PermissionAuthorizeAttribute.PolicyPrefix, StringComparison.OrdinalIgnoreCase))<br/>        {<br/>            return base.GetPolicyAsync(policyName);<br/>        }<br/><br/>        var permissionNames = policyName.Substring(PermissionAuthorizeAttribute.PolicyPrefix.Length).Split(',');<br/><br/>        var policy = new AuthorizationPolicyBuilder()<br/>            .RequireClaim(CustomClaimTypes.Permission, permissionNames)<br/>            .Build();<br/><br/>        return Task.FromResult(policy);<br/>    }<br/>}</span></pre><p id="ce44" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个实现中，GetPolicyAsync负责根据policyName查找并返回一个策略。但是，我们可以通过覆盖策略并使用AuthorizationPolicyBuilder的实例来自动化定义策略的过程。在GetPolicyAsync方法的主体中，首先检查收到的policyName是否以“PERMISSION:”开头；然后用'，'字符分割policyName以检索权限名称。最后，用检索到的权限定义策略并返回它。</p><p id="4ce6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，要用default registered替换这个实现，请在启动时使用以下代码:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="56e0" class="ly kn hu lu b fv lz ma l mb mc">services.AddSingleton&lt;IAuthorizationPolicyProvider, AuthorizationPolicyProvider&gt;();</span></pre></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="9803" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">实现PermissionAuthorizeAttribute</h1><p id="6784" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">最后一步，我们需要实现自定义AuthorizeAttribute来操作策略属性，并将权限名称作为逗号分隔的字符串存储在该属性中。</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="8dd6" class="ly kn hu lu b fv lz ma l mb mc">public class PermissionAuthorizeAttribute : AuthorizeAttribute<br/>{<br/>    internal const string PolicyPrefix = "PERMISSION:";</span><span id="bd19" class="ly kn hu lu b fv mk ma l mb mc">/// &lt;summary&gt;<br/>    /// Creates a new instance of &lt;see cref="AuthorizeAttribute"/&gt; class.<br/>    /// &lt;/summary&gt;<br/>    /// &lt;param name="permissions"&gt;A list of permissions to authorize&lt;/param&gt;<br/>    public PermissionAuthorizeAttribute(params string[] permissions)<br/>    {<br/>        Policy = $"{PolicyPrefix}{string.Join(",", permissions)}";<br/>    }<br/>}</span></pre><p id="7340" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要使用它:</p><pre class="lp lq lr ls fq lt lu lv lw aw lx dt"><span id="4114" class="ly kn hu lu b fv lz ma l mb mc">[PermissionAuthorize(PermissionNames.Projects_View)]<br/>public IActionResult Get(FilteredQueryModel query)<br/>{<br/>   //...<br/>}<br/>[PermissionAuthorize(PermissionNames.Projects_Create)]<br/>public IActionResult Post(ProjectModel model)<br/>{<br/>   //...<br/>}</span></pre></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="d3b8" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">结论</h1><p id="8c6c" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">使用本文中介绍的方法，您可以简单地在ASP.NET核心项目中应用动态许可授权，并且只需进行最少的定制。</p><p id="769d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，您可以在DNTFrameworkCore存储库中找到完整的实现<a class="ae jg" href="https://github.com/rabbal/DNTFrameworkCore/tree/master/src/DNTFrameworkCore.Web/Authorization" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>