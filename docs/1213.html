<html>
<head>
<title>Using a multivariate linear regression model to predict the sprint speed of players in FIFA 19</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运用多元线性回归模型预测FIFA 19运动员的冲刺速度</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-a-multivariable-linear-regression-model-to-predict-the-sprint-speed-of-players-in-fifa-19-530618986e1c?source=collection_archive---------3-----------------------#2019-02-20">https://medium.com/hackernoon/using-a-multivariable-linear-regression-model-to-predict-the-sprint-speed-of-players-in-fifa-19-530618986e1c?source=collection_archive---------3-----------------------#2019-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/01d7eaedb68907734b1fc45a5220a5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*JHNz2nrOvNb3OH97BTk_qQ.jpeg"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">FIFA 19 Source: Express.co.uk</figcaption></figure><p id="3bb1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我偶尔玩国际足联的游戏，但我认为自己是一个相对强大的玩家，在与其他休闲玩家的比赛中，我经常获胜。总的来说，我不是一个超级足球迷，也不会尝试去玩战略游戏。相反，我非常依赖运动员的冲刺速度和不可预测的跑动和转身。我经常结合这些技巧在我对手的空间中寻找和制造空间，并运球取得胜利，这让我的对手很沮丧。在这种背景下，我决定从Kaggle 下载<a class="ae ka" href="https://www.kaggle.com/karangadiya/fifa19" rel="noopener ugc nofollow" target="_blank"> FIFA19数据集，目的是根据我认为最能预测球员冲刺速度的变量/特征来预测球员的冲刺速度。</a></p><p id="9c2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">线性回归</strong></p><p id="12aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">线性回归可以总结为试图建立一个或多个自变量与特定结果或因变量之间关系的模型。为了使该算法有效，自变量和因变量之间必须有线性关系。应用于两个或更多变量之间存在中度到强相关性的数据，通过找到最适合/预测结果的线，它可以是预测一个结果的值的非常有用的起点。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="5fa5" class="kk kl hu kg b fv km kn l ko kp">Y = MX + B</span></pre><p id="736e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这背后的数学很简单，特别是当你只看一个独立变量的时候。y代表结果或因变量，而m代表斜率，x代表自变量，b代表y截距。简单地说，假设x和y之间存在线性关系，如果你知道直线的斜率和独立变量的值，你就可以预测结果。</p><p id="a3cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，在我的例子中，我要考虑多个独立变量，因此公式需要稍微改变。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e2ef" class="kk kl hu kg b fv km kn l ko kp">F(x) = A +(B1*X1) +(B2*X2)+(B3*X2)+(B4*X4)...+(Bn*Xn)</span></pre><p id="e2cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用这个公式，我假设有(n)个独立变量。在这种情况下，F(x)是该线性模型的预测结果，A是Y截距，X1-Xn是预测值/独立变量，B1-Bn =回归系数(与简单线性回归公式中的斜率相当)。在这个公式中插入适当的数字会给我一个结果的预测，在这种情况下，一个球员在FIFA19上的冲刺速度。</p><p id="3d56" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">与数据交互</strong></p><p id="5a45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这个分析，我选择使用Python，从Kaggle下载数据，上传到我的Google Drive，加载Google Colab，并使用pandas read.csv功能上传数据。上传完scipy、numpy和pandas库后，我开始了数据清理过程。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e2e5" class="kk kl hu kg b fv km kn l ko kp">#libraries<br/>import pandas as pd<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import scipy.stats  as stats<br/>from google.colab import drive</span><span id="995b" class="kk kl hu kg b fv kq kn l ko kp">#uploading data<br/>fifa_dataset = pd.read_csv('/content/gdrive/My Drive/Google Research/Learning/Kaggle Projects/FIFA19 dataset/data.csv')</span></pre><p id="fcdf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">数据清理</strong></p><p id="2665" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我从几个假设开始，我假设短跑速度很大程度上受身高、体重、年龄、加速度统计以及可能的运动员体重和身高的比例的影响。在观察数据集时，我注意到身高和体重是以字符串格式记录的(例如5英尺11英寸和180磅)，此外，作为一个更习惯于公制的人，我想将这些测量值分别改为厘米和千克。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="6efa" class="kk kl hu kg b fv km kn l ko kp">#inches to cms<br/>fifa_dataset['Height']= fifa_dataset.Height.str.replace("'",".").apply(lambda x: float(x)*30.48).dropna()<br/>fifa_dataset['Height']= fifa_dataset['Height'].fillna(fifa_dataset['Height'].mean()).astype(np.int64)</span><span id="66ec" class="kk kl hu kg b fv kq kn l ko kp">#lbs to kgs<br/>fifa_dataset['Weight'] = fifa_dataset.Weight.str.replace("lbs", "").apply(lambda x: float(x)*0.45359237).dropna()<br/>fifa_dataset['Weight']  = fifa_dataset['Weight'].fillna(fifa_dataset['Weight'].mean()).astype(np.int64)</span></pre><p id="b366" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于weight，这个转换过程包括通过寻找撇号作为分隔符来拆分字符串，用句号(小数点分隔符)替换它，并应用lambda函数将str转换为浮点数并转换为厘米。我将str转换为float，因为我知道计算将返回一个本质上是float的数字。这样做之后，我继续用数据帧中的平均高度值填充所有NaN值，并将该数字转换为整数(低于100行)。我假设用平均值填充缺失值比向前填充更适合我的分析，省略NaN行或将它们更改为零。我后来了解到，这些柱子不适用于我的分析，但是，我决定把它包括进来，以显示我清理一些柱子所做的工作。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="f9e8" class="kk kl hu kg b fv km kn l ko kp">def func(x):<br/>  x = x.fillna(x.mean()).astype(np.int64)<br/>  return x<br/>fifa_dataset[['Agility','Acceleration','Balance','Positioning','Skill Moves','BallControl','Crossing','Finishing','Reactions','SprintSpeed']] = func(fifa_dataset[['Agility','Acceleration','Balance','Positioning','Skill Moves','BallControl','Crossing','Finishing','Reactions','SprintSpeed']])</span></pre><p id="b1e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在对height列进行了同样的清理之后，我定义了一个函数，当它应用于一个列时，用该列的平均值填充所有NaN值，并将数字转换为int。在测试出哪些列将用于我的分析之后，我将这个函数应用到相关的列</p><p id="92c7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">相关性检验和显著性检验</strong></p><p id="2fd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了测试每个列和结果列(sprintspeed)之间的相关性，我选择使用scipy包中的<a class="ae ka" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.spearmanr.html" rel="noopener ugc nofollow" target="_blank"> spearmanr函数</a>。此函数计算相关性并返回x和y之间的相关性以及p值或此相关性的显著性概率。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="9381" class="kk kl hu kg b fv km kn l ko kp">#We want to test for moderate to strong correlations<br/>def corr_test(x):<br/>  x_corr = stats.spearmanr(x, fifa_dataset['SprintSpeed'])<br/>  return x_corr</span><span id="704a" class="kk kl hu kg b fv kq kn l ko kp">corr_test(fifa_dataset[x])</span></pre><p id="367a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用这个函数，我遍历了数据集中的不同列，以确定哪些列将用于我的回归模型。我选择使用存在至少-0.50(或低于-0.50)的中度到强相关性的列。以此为基准，我完成了这些列；敏捷、加速、平衡、定位、技术动作、控球、传中、射门和反应——这些是独立变量。</p><p id="8bc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通常，当您测量线性时，您可能需要用散点图显示每一列，以确认线性关系确实存在。单纯依赖相关系数的问题在于，有影响的异常值可以显著增加或减少相关系数，使得看起来好像存在强/弱相关性，而实际情况恰恰相反。在了解了FIFA中球员分数的分布之后，我做出了这样的假设:这是不必要的，我们不会得到具有高度影响力的单个值(销售价格等列除外)。</p><p id="971a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">多元线性回归模型</strong></p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="d9c3" class="kk kl hu kg b fv km kn l ko kp">#multivariate linear regression<br/>#80/20 split- 20% training data<br/>from sklearn.linear_model import LinearRegression<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import mean_absolute_error<br/>from sklearn.metrics import accuracy_score<br/>train, test = train_test_split(fifa_dataset, test_size=0.2)</span></pre><p id="d6e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的机器学习算法(假设你考虑线性回归模型机器学习)严重依赖于sklearn库。在导入这个库之后，我选择应用80/20规则将我的数据分为训练数据和测试数据，其中20%的数据属于训练数据。我的理由是，我不想使用超过20%的值，以便更确定我的模型可以推广到整个数据库。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="fb8e" class="kk kl hu kg b fv km kn l ko kp">#independent and dependent variables<br/>features= ['Agility', 'Acceleration', 'Balance','Reactions','Positioning','Skill Moves','BallControl','Crossing','Finishing']<br/>target = 'SprintSpeed'</span><span id="fbc3" class="kk kl hu kg b fv kq kn l ko kp">#define model I am using<br/>model = LinearRegression()</span><span id="eba4" class="kk kl hu kg b fv kq kn l ko kp">#training process<br/>model.fit(train[features], train[target])</span><span id="1455" class="kk kl hu kg b fv kq kn l ko kp">#mean absolute value for training data<br/>data = train[target]<br/>predict =  model.predict(train[features])<br/>training_error = mean_absolute_error(data, predict)</span><span id="c337" class="kk kl hu kg b fv kq kn l ko kp">#mean absolute value for test data<br/>test_data = test[target]<br/>predict_test = model.predict(test[features])<br/>test_data_error = mean_absolute_error(test_data, predict_test)</span></pre><p id="74c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我继续定义我将用于该模型的特征(自变量)和我试图预测的目标或变量(因变量)，然后继续使用线性回归模型训练该模型。训练包括查看自变量和因变量之间的相关性，以进行计算，使模型能够从测试数据中预测结果。</p><p id="8c5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">测试模型</strong></p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/eeae10346e316bf25141a9307b51f8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*kInlS5dY0gD3p2Mhd7v2cw.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Mean Absolute Error Formula</figcaption></figure><p id="98dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了测试数据中的预测误差(损失函数)，我使用度量模块n sklearn为训练和测试数据计算了<a class="ae ka" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_absolute_error.html" rel="noopener ugc nofollow" target="_blank">平均绝对误差</a> (MAE)。在此公式中，n代表数据中的错误数量，σ简单地表示总和，而|yj — ŷj|指从预测中观察到的绝对错误。该公式将绝对误差相加，然后除以实例总数，得到一个数字，显示预测的和实际的冲刺速度之间的平均误差。</p><p id="f7bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理想情况下，我希望这个数字尽可能小，并报告这个数字以及我的预测成功率。我也可以打开使用<a class="ae ka" href="http://statweb.stanford.edu/~susan/courses/s60/split/node60.html" rel="noopener ugc nofollow" target="_blank">均方根误差</a> (RMSE)，类似于MAE。这将返回一个数字，显示预测值与预测值的偏差。RMSE简单地找到了MAE数字的平方根(然而，在这种情况下，我们将平方绝对误差)。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="e7ea" class="kk kl hu kg b fv km kn l ko kp">#we need some metric to measure the accuracy of our regression model<br/>from sklearn.metrics import r2_score</span><span id="c57e" class="kk kl hu kg b fv kq kn l ko kp">#on training data<br/>true_value = train[target]<br/>predicted_val =  model.predict(train[features])<br/>accuracy = r2_score(true_value, predicted_val)</span><span id="0563" class="kk kl hu kg b fv kq kn l ko kp">#on test data<br/>true_value2 = test[target]<br/>predicted_val2 =  model.predict(test[features])<br/>accuracy2 = r2_score(true_value2, predicted_val2)</span></pre><p id="6ac3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了测试这个模型的准确性，我依赖于<a class="ae ka" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.r2_score.html" rel="noopener ugc nofollow" target="_blank"> r2_score指标</a> ( <a class="ae ka" href="https://en.wikipedia.org/wiki/Coefficient_of_determination" rel="noopener ugc nofollow" target="_blank">决定系数</a>)。R2分数或R平方，衡量数据与回归模型的拟合程度，数字越接近1，就越表明很大一部分值可以用线性回归模型来解释，这表明预测能力更强。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="c912" class="kk kl hu kg b fv km kn l ko kp">print('This model accounts for {}% of the training data with mean data error of {}'.format(round(accuracy2*100,2), round(training_error,2)))<br/>print('This model accounts for {}% of the testing data with mean data error of {}'.format(round(accuracy*100,2), round(test_data_error,2)))</span><span id="3987" class="kk kl hu kg b fv kq kn l ko kp">####RESULT####<br/>&gt;This model accounts for 84.96% of the training data with mean data error of 4.08 <br/>&gt;This model accounts for 85.61% of the testing data with mean data error of 4.2</span></pre><p id="6e4c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">据我的控制台报告，预测模型占我的测试数据的85.61%，平均偏差约为4.2(预测值与实际值之间的平均偏差)。根据这个结果，例如，如果我们用这个模型对短跑速度为90的运动员进行预测，那么实际的短跑速度很有可能平均在86和94之间。</p><p id="c78b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理解到我的R平方值会随着我加入更多的预测因子而增加，因为当我在我的模型中加入更多的预测因子时，我解释了我的数据中更多的可变性。为了考虑到这一点，我可以查看调整后的R平方值，它会对更多预测值的使用造成不利影响，这种不利影响的大小取决于预测值的数量与数据集中可能的预测值(所有其他列)的大小之间的关系。其结果是，仅当添加的预测因子对模型的改善程度超过偶然情况下的预期时，调整后的R平方值才会增加。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/5e84761e679eccab543f8571b098592a.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*LfMyMqWhzWRnd6cOhtzvYQ.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Adjusted R Squared</figcaption></figure><p id="1392" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面给出的公式中，k表示预测值的数量，而n表示数据集中列的总数。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="7f41" class="kk kl hu kg b fv km kn l ko kp">n = len(list(fifa_dataset))-1<br/>k = len(features)<br/>#calculating adjusted r squared using formula given<br/>r2 = 1-(1-accuracy2)*(n-1)/(n-k-1)<br/>print('Adjusted R Squared is {}%'.format(round(r2*100,2)))</span><span id="35a0" class="kk kl hu kg b fv kq kn l ko kp">####RESULT####<br/>&gt;Adjusted R Squared is 83.97%</span></pre><p id="b801" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我想测试这个模型和其他模型之间的适合度时，这个百分比会变得更有用。</p><p id="bac7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我注意到使用预测因子的另一个问题是，一些预测因子与其他预测因子相关，产生了<a class="ae ka" href="http://statisticsbyjim.com/regression/multicollinearity-in-regression-analysis/" rel="noopener ugc nofollow" target="_blank">多重共线性</a>。然而，根据我的理解，这对我的模型的预测能力没有显著影响，但对估计每个预测因子对我的模型的影响的能力有较大影响。</p><p id="791c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">做出预测</strong></p><p id="531f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们想象我们想要使用这个模型来做一个实际的预测。我们在数据集中随机挑选一个玩家。这是现在21岁的英国出生的约瑟夫·亚尼。这个玩家恰好出现在我测试数据帧的第26行。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/2c25e8f8c87d421697675ca4bb41b020.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Dk1rsxjQQ45KoMTiE8ipyw.jpeg"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Josef Yarney Source: WorldFootball.net</figcaption></figure><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="930f" class="kk kl hu kg b fv km kn l ko kp">josef = test.iloc[25]<br/>josef_stats = josef[['Acceleration','Balance','Reactions','Positioning','Skill Moves','BallControl','Crossing','Finishing']]</span><span id="be7e" class="kk kl hu kg b fv kq kn l ko kp">#make prediction<br/>model.predict(np.array([[josef_stats[0],josef_stats[1],josef_stats[2],josef_stats[3],josef_stats[4],josef_stats[5],josef_stats[6],josef_stats[7]]]))<br/>josef_predic</span><span id="6c53" class="kk kl hu kg b fv kq kn l ko kp">####RESULT####<br/>&gt;array([51.32203933])</span></pre><p id="477c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我继续定位这个球员并提取相关的统计数据，保存在josef_stats变量下。然后，我使用创建的多元线性回归公式对玩家的冲刺速度进行预测，得到的冲刺速度大约为51，而实际冲刺速度为48。</p><p id="ea00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">将方程式可视化</strong></p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff ku"><img src="../Images/95e625bca0ebae435b03b94c5ae60800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqlgzH7j6u_dYvFURoQzBQ.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek">Visualising the multivariate linear regression equation for the FIFA dataset</figcaption></figure><p id="36db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了直观地展示预测函数的工作原理，我们需要重温一下多元线性回归方程。简单地说，预测的冲刺速度是每个预测因子的斜率乘以它们的值的函数(即。如果加速度是80，我们用加速度的斜率乘以80，我们把这些加在一起，然后把总数加到y轴截距上。</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="35f2" class="kk kl hu kg b fv km kn l ko kp">coefs = model.coef_</span></pre><p id="d37a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以得到每个预测值的系数(斜率)。coef_ function。</p><p id="5237" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，我们可以使用以下代码在python中解释这个等式:</p><pre class="kb kc kd ke fq kf kg kh ki aw kj dt"><span id="1202" class="kk kl hu kg b fv km kn l ko kp">speed = [a*b for a,b in zip(coefs,josef_stats)]<br/>sum(speed)+model.intercept_</span><span id="3bde" class="kk kl hu kg b fv kq kn l ko kp">####RESULT####<br/>&gt;51.32203933182582</span></pre><p id="daee" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，我们将josef_stats列表中的每个值乘以其对应的斜率，将这些值加在一起，并将这些数字加到我们使用model.intecept_ function找到的截距上，从而得到预测的冲刺速度51。</p><p id="dd5e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就结束了我的分析。</p></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="e369" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">欢迎发送反馈或通过Twitter @Emmoemm联系我</p></div></div>    
</body>
</html>