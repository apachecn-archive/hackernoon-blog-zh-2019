<html>
<head>
<title>Serverless Computing with Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Swift 进行无服务器计算</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-computing-with-swift-4fa27ab36161#2019-03-25">https://medium.com/hackernoon/serverless-computing-with-swift-4fa27ab36161#2019-03-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="3432" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">第 2 部分:Apache OpenWhisk 和 IBM Cloud</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/ecb8b19482fcdd599f8498116ce19646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5JHIRJxUFLMwSCMuSoxpg.png"/></div></div></figure><p id="84c3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你可能认为我会担心烤面包……</p><p id="c937" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">回想一下这篇文章的第一部分——<a class="ae kr" rel="noopener" href="/capital-one-tech/serverless-computing-with-swift-f515ff052919"><strong class="jx hv">Swift 的无服务器计算</strong> : Swift 和 AWS Lambda</a>——我已经决定成立一家初创公司，<em class="ks">这是我能做的酵母</em>，一家专注于美食面包的在线面包店。我的 CLO ( <em class="ks">首席发酵官</em>)愿意同意我优先考虑云基础设施，而不是真正的烘焙产品。但她担心我们还没有充分探索我们的选择。在本文中，我将重写第 1 部分中的代码，以便在<a class="ae kr" href="http://openwhisk.incubator.apache.org/" rel="noopener ugc nofollow" target="_blank">Apache open whish</a>下运行。</p><p id="0be4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">OpenWhisk 是一个用于无服务器计算的开源平台。您可以在自己的服务器上托管它，有或没有容器(如 Docker)。你甚至可以在 AWS 上运行它。对于本文，我将使用 IBM Cloud，这是一个云服务基础设施，以前被称为 Bluemix。</p><p id="dbf4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">(如果你在家跟进，你需要一个 IBM 账户。(可以在这里注册一个 <a class="ae kr" href="https://www.ibm.com/cloud" rel="noopener ugc nofollow" target="_blank"> <em class="ks">免费试用</em> </a> <em class="ks">)注册账号后，安装 CLI 及其云功能插件；按照说明</em> <a class="ae kr" href="https://console.bluemix.net/docs/cli/reference/ibmcloud/download_cli.html#install_use" rel="noopener ugc nofollow" target="_blank"> <em class="ks">这里</em> </a> <em class="ks">和</em> <a class="ae kr" href="https://console.bluemix.net/docs/openwhisk/bluemix_cli.html#cloudfunctions_cli" rel="noopener ugc nofollow" target="_blank"> <em class="ks">这里</em> </a> <em class="ks">。为了避免以后出现含糊不清的错误消息，请确保在同一区域创建一个组织和空间。)</em></p><p id="6d3c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">OpenWhisk 为多种语言提供了开箱即用的直接支持，包括 JavaScript、Python、Java、Go 和 Swift。OpenWhisk 还通过 Docker 容器支持其他语言；您可以用 Lua、Forth、Rust 或几乎任何语言编写动作，甚至是 Bash 脚本。</p><p id="1413" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">OpenWhisk 不仅让你用 Swift 编程，而且基础设施直接支持<a class="ae kr" href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv"><em class="ks">【Codable】</em></strong></a>。在第 1 部分的 AWS 代码中，我必须从标准输入中读取数据，并使用<strong class="jx hv"> <em class="ks"> JSONDecoder </em> </strong>将其反序列化。然而，在 OpenWhisk 中，主函数被传递了一个反序列化的对象。</p><p id="4b2f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于 Swift 的支持是内置的，编译代码<em class="ks">应该比我们使用 AWS 要容易。让我们看看这是否成立。</em></p><h2 id="dd81" class="kt ku hu bd kv kw kx ky kz la lb lc ld ke le lf lg ki lh li lj km lk ll lm ln dt translated"><strong class="ak">一个例子</strong></h2><p id="e2cf" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">在第 1 部分的<a class="ae kr" rel="noopener" href="/capital-one-tech/serverless-computing-with-swift-f515ff052919">中，我创建了一个无服务器函数，它将接收客户订购的商品列表并返回收据。尽管新版本的代码将与原始版本非常相似，但为了简单起见，我将从头开始。</a></p><p id="7ed7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一开始，我会做些错事，但很容易。首先，我为我的代码创建一个目录并切换到它:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="ea32" class="kt ku hu lu b fv ly lz l ma mb">mkdir yeast</span><span id="d5bf" class="kt ku hu lu b fv mc lz l ma mb">cd yeast</span></pre><p id="2db1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，我把，<em class="ks"> Item.swift </em>，<em class="ks"> Order.swift </em>，和<em class="ks">receive . swift</em>组合成一个文件，称之为<em class="ks"> Yeast.swift </em>。这些与第一部分的<a class="ae kr" href="https://gist.github.com/profburke/2e951f48542a9a1ff47051572d77584c" rel="noopener ugc nofollow" target="_blank">要点</a>没有变化。</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="6346" class="kt ku hu lu b fv ly lz l ma mb">curl -o Item.swift <a class="ae kr" href="https://git.io/fh9Kg" rel="noopener ugc nofollow" target="_blank">https://git.io/fh9Kg</a></span><span id="d1bd" class="kt ku hu lu b fv mc lz l ma mb">curl -o Order.swift <a class="ae kr" href="https://git.io/fh9K2" rel="noopener ugc nofollow" target="_blank">https://git.io/fh9K2</a></span><span id="6e68" class="kt ku hu lu b fv mc lz l ma mb">curl -o Receipt.swift <a class="ae kr" href="https://git.io/fh9Ka" rel="noopener ugc nofollow" target="_blank">https://git.io/fh9Ka</a></span><span id="cf8b" class="kt ku hu lu b fv mc lz l ma mb">cat Item.swift Order.swift Receipt.swift &gt; Yeast.swift</span></pre><p id="c0a3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我需要在文件底部创建主函数，<em class="ks"> Yeast.swift </em>。这里是与 AWS 版本的区别:OpenWhisk 基础设施进行输入解码，但是动作的 main 函数必须具有以下签名:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="f739" class="kt ku hu lu b fv ly lz l ma mb">main(input: Codable, completion: (Codable?, Error?) -&gt; Void) -&gt; Void</span></pre><p id="29ae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">(<em class="ks">实际上，目前还有几个备选签名没有记录在案。可以阅读 OpenWhisk </em> <a class="ae kr" href="https://github.com/apache/incubator-openwhisk-runtime-swift/blob/master/core/swift41Action/epilogue.swift" rel="noopener ugc nofollow" target="_blank"> <em class="ks">源代码</em> </a> <em class="ks">了解详情。</em>)</p><p id="2fbe" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我编辑了 Yeast.swift，添加了一个主函数和几个辅助结构:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="1bda" class="kt ku hu lu b fv ly lz l ma mb"><br/>public struct Output: Codable {<br/>   let receipt: String<br/>}</span><span id="d888" class="kt ku hu lu b fv mc lz l ma mb">public struct Input: Codable {<br/>   let items: [Item]<br/>}</span><span id="0945" class="kt ku hu lu b fv mc lz l ma mb">func main(param: Input, completion: (Output?, Error?) -&gt; Void) -&gt;                Void {<br/>   let receipt = Receipt(with: param.items)<br/>   completion(Output(receipt: “\(receipt)”), nil)<br/>}</span></pre><p id="8452" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv"> <em class="ks">注意—输入</em> </strong>和<strong class="jx hv"> <em class="ks">输出</em> </strong>是必需的，因为字符串不允许作为顶级 JSON 对象，所以我将字符串包装在简单的结构中。</p><h1 id="3cdc" class="md ku hu bd kv me mf mg kz mh mi mj ld ja mk jb lg jd ml je lj jg mm jh lm mn dt translated">正在添加 open whish…</h1><p id="2b7f" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">最后，我使用 IBM 的命令行工具创建了一个 OpenWhisk 动作(<em class="ks">相当于 AWS Lambda 函数</em>)。咒语如下:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="78ea" class="kt ku hu lu b fv ly lz l ma mb">ibmcloud fn action create yeast Yeast.swift — kind swift:4.1</span></pre><p id="f1db" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这导致消息“ok:创建了行动酵母”</p><p id="b004" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在为了测试它，我创建了一个名为<em class="ks"> params.json </em>的参数文件，内容如下:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="da6e" class="kt ku hu lu b fv ly lz l ma mb">{<br/>  “items”: [<br/>      {“amount”: 3, “style”: “rye”},<br/>      {“amount”: 4, “style”: “naan”}<br/>  ]<br/>}</span></pre><p id="86c9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">并像这样调用操作:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="3e2a" class="kt ku hu lu b fv ly lz l ma mb">ibmcloud fn action invoke -r yeast — param-file params.json</span></pre><p id="5f7c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我在控制台上打印了以下 JSON:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="ac33" class="kt ku hu lu b fv ly lz l ma mb">{“receipt”: “Receipt for Order on 2018–08–02 19:44:37 +0000\n — — — — -\n3 RYE @ 0.62 = 1.86\n4 NAAN @ 0.87 = 3.48\n — — — — -\nTotal: 5.34\n\n”}</span></pre><p id="6b5d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="ks"> -r </em>开关执行阻塞调用，并将响应限制为动作的输出。相反，如果我键入以下内容:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="0fcc" class="kt ku hu lu b fv ly lz l ma mb">ibmcloud fn action invoke -b yeast — param-file params.json</span></pre><p id="25db" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我还获得了一个阻塞调用，但是除了动作的输出之外，我还获得了许多元数据，比如开始和结束时间戳以及持续时间。不带<em class="ks"> -r </em>或<em class="ks"> -b </em>开关调用动作会导致非阻塞调用。</p><p id="65fd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">阻塞调用和非阻塞调用之间有什么区别？这类似于同步和异步方法调用。当您使用一个阻塞调用时，您会得到您的结果(<em class="ks">有或者没有元数据</em>)。当您使用非阻塞调用时，您会立即得到一个返回给您的激活 ID。在将来的某个时候，您可以使用这个激活 ID 来查找结果和关于激活的其他信息。如果您想了解更多细节，请阅读<a class="ae kr" href="https://console.bluemix.net/docs/openwhisk/openwhisk_actions.html#openwhisk_actions" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="23e4" class="md ku hu bd kv me mf mg kz mh mi mj ld ja mk jb lg jd ml je lj jg mm jh lm mn dt translated">减轻冷启动延迟</h1><p id="d46f" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">我上面说了，我做的是错的…</p><p id="edbd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里有两个问题。</p><p id="d6aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">●首先，除非你正在编写一个非常简单的动作，否则你不会想把所有代码放在一个文件中。</p><p id="4577" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">●第二，采用我们刚刚采取的方法，行动将有一个冷启动延迟。</p><p id="66ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">注意，上面创建动作的命令使用了 Swift <em class="ks">源</em>。但是，当然，Swift 是一种编译语言，所以在您的操作可以运行之前，必须编译 Swift 源代码。直到第一次调用您的操作时，才会进行编译；这被称为冷启动，会导致动作运行延迟。在初始调用之后，编译后的程序被缓存，因此后续调用通常不会有延迟。“通常”，因为当您的应用程序水平扩展时，当额外的容器启动时，会偶尔出现冷启动。</p><p id="b7a8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果可能，最好减少冷启动延迟。事实上，我可以通过将代码重新组织成更模块化的结构，并用预编译的 Swift 程序创建动作来避免这两个问题。</p><p id="8984" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，我将重新组织代码。确保你在你的<em class="ks">酵母</em>目录中。以下是步骤:</p><p id="5049" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">创建 SPM 包。</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="a2dd" class="kt ku hu lu b fv ly lz l ma mb">swift package init — type=executable</span></pre><p id="81f9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<em class="ks"> Sources </em>目录中，添加<em class="ks"> YeastModels </em>作为子目录。将文件<em class="ks"> Item.swift </em>、<em class="ks"> Order.swift </em>和<em class="ks"> Receipt.swift </em>移动到<em class="ks">yeas models</em>中。</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="9ff5" class="kt ku hu lu b fv ly lz l ma mb">mkdir Sources/YeastModels<br/>mv Item.swift Sources/YeastModels<br/>mv Order.swift Sources/YeastModels<br/>mv Receipt.swift Sources/YeastModels</span></pre><p id="4997" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">编辑<em class="ks">来源/酵母</em>中的<em class="ks"> main.swift </em>如下:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="9236" class="kt ku hu lu b fv ly lz l ma mb">import YeastModels</span><span id="b66f" class="kt ku hu lu b fv mc lz l ma mb">public struct Output: Codable {<br/>   let receipt: String<br/>}</span><span id="46a6" class="kt ku hu lu b fv mc lz l ma mb">public struct Input: Codable {<br/>   let items: [Item]<br/>}</span><span id="4ead" class="kt ku hu lu b fv mc lz l ma mb">func main(param: Input, completion: (Output?, Error?) -&gt; Void) -&gt; Void {<br/>   let receipt = Receipt(with: param.items)<br/>   completion(Output(receipt: “\(receipt)”), nil)<br/>}</span></pre><p id="1751" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">更新<em class="ks"> Package.swift </em>以包含 YeastModels 的目标，并添加 YeastModels 作为主目标的依赖项。<em class="ks"> Package.swift </em>将如下所示:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="0d93" class="kt ku hu lu b fv ly lz l ma mb">// swift-tools-version:4.0<br/>import PackageDescription</span><span id="1322" class="kt ku hu lu b fv mc lz l ma mb">let package = Package(<br/>   name: “yeast”,<br/>   targets: [<br/>      .target(<br/>         name: “yeast”,<br/>         dependencies: [“YeastModels”]),<br/>      .target(<br/>         name: “YeastModels”,<br/>         dependencies: []),<br/>   ]<br/>)</span></pre><p id="c7dd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">删除<em class="ks">酵母</em>目录中的<em class="ks"> Yeast.swift </em>)。</p><h1 id="666a" class="md ku hu bd kv me mf mg kz mh mi mj ld ja mk jb lg jd ml je lj jg mm jh lm mn dt translated">减轻交叉编译问题</h1><p id="fb6b" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">现在我必须编译它。但是有两个小问题:OpenWhisk 基础设施需要在 Swift 程序中注入少量代码，以及交叉编译。</p><p id="9518" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">公平地说，如果你不是在 Ubuntu 上开发，交叉编译只是一个问题。我通常在 Mac 上编码，所以交叉编译对我来说是个问题，可能对你也是。所以，我需要以某种方式构建一个 Linux 二进制文件。最简单的方法是使用 Docker。确保您安装了最新版本的 docker，并且守护程序正在运行。</p><p id="8f4d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们开始吧:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="7d0c" class="kt ku hu lu b fv ly lz l ma mb">docker run — rm -it -v “$(pwd):/owexec” ibmfunctions/action-swift-v4.1 bash</span><span id="2066" class="kt ku hu lu b fv mc lz l ma mb">cp /swift4Action/spm-build/Sources/Action/_Whisk.swift /owexec/Sources/yeast</span><span id="9d25" class="kt ku hu lu b fv mc lz l ma mb">cat swift4Action/epilogue.swift &gt;&gt; owexec/Sources/yeast/main.swift</span><span id="a19d" class="kt ku hu lu b fv mc lz l ma mb">echo ‘_run_main(mainFunction:main)’ &gt;&gt; owexec/Sources/yeast/main.swift</span><span id="fdba" class="kt ku hu lu b fv mc lz l ma mb">echo ‘_ = _whisk_semaphore.wait(timeout: .distantFuture)’ &gt;&gt; owexec/Sources/yeast/main.swift</span><span id="576a" class="kt ku hu lu b fv mc lz l ma mb">cd owexec/</span><span id="ed68" class="kt ku hu lu b fv mc lz l ma mb">swift build -c release</span><span id="7695" class="kt ku hu lu b fv mc lz l ma mb">mv .build/release/yeast .build/release/Action</span><span id="b4d3" class="kt ku hu lu b fv mc lz l ma mb">zip yeast.zip .build/release/Action</span></pre><p id="1047" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在，退出停止 Docker 容器的 shell(类型 Control-D)。</p><p id="b4c2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我做了什么？第一个命令启动一个 Docker 实例并启动 Bash shell。该实例使用了 IBM 提供的一个图像，<strong class="jx hv"> <em class="ks">。该图包含 Swift 编译器和构建操作所需的基础设施。Docker 的<a class="ae kr" href="https://docs.docker.com/engine/reference/commandline/run/#usage" rel="noopener ugc nofollow" target="_blank">文档</a>给了你更多的细节，但是标志使得从你的主机外壳与容器交互成为可能，并且它们使得你的动作目录在 Docker 容器内部可见。</em></strong></p><p id="bcc4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来的四个命令将基础设施代码注入我们的 Swift 项目。最后，最后四个命令构建项目，并根据 OpenWhisk 的期望打包它。具体来说，OpenWhisk 假设 Swift 可执行文件被命名为<strong class="jx hv"> <em class="ks"> Action </em> </strong>。</p><p id="5bad" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">更新操作以使用新编译的二进制文件:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="aa92" class="kt ku hu lu b fv ly lz l ma mb">ibmcloud fn action update yeast yeast.zip — kind swift:4.1</span></pre><p id="54fd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">再次测试:</p><pre class="jk jl jm jn fq lt lu lv lw aw lx dt"><span id="4720" class="kt ku hu lu b fv ly lz l ma mb">ibmcloud fn action invoke -r yeast — param-file params.json</span></pre><p id="aceb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您应该会得到与之前相同的结果(再次使用<em class="ks">，对时间戳</em>取模)。我将把它作为一个练习留给读者，让他们探索热启动与冷启动的加速对比。</p><p id="40aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当然，现在您会想要自动化构建过程。事实上，如果您通读 IBM 文档，他们会提供一个 shell 脚本来为您进行编译。但是，该脚本对您的操作的目录结构做了一些假设，这些假设可能不符合您组织代码的方式。更重要的是，它没有正确处理<em class="ks"> modern </em> SPM 文件结构；它希望您的代码直接位于<em class="ks"> Sources </em>目录下，而 SPM 希望您的代码位于<em class="ks"> Sources </em>的子目录下。</p><p id="159c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我建议手工构建几个，一旦有了建立环境的想法，就写一个脚本。</p><h2 id="e720" class="kt ku hu bd kv kw kx ky kz la lb lc ld ke le lf lg ki lh li lj km lk ll lm ln dt translated"><strong class="ak">势如破竹</strong></h2><p id="f2e0" class="pw-post-body-paragraph jv jw hu jx b jy lo iv ka kb lp iy kd ke lq kg kh ki lr kk kl km ls ko kp kq hn dt translated">既然基本的想法是可行的，那么接下来的步骤和第 1 部分一样。也就是说，将它集成到基础设施的其余部分。IBM Cloud 提供了一个 API 网关和几个其他机制来触发您的操作。自从我撰写第 1 部分以来，服务器端(和无服务器)Swift 继续发展。例如，<a class="ae kr" href="https://github.com/amzn/smoke-framework" rel="noopener ugc nofollow" target="_blank"> Smoke 框架</a>似乎正在为 Swift 中的编写服务赢得一些支持。</p><p id="4ef4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">与此同时，我将继续推迟经营我的面包店，转而探索新技术。也许我的面包店需要一个<a class="ae kr" href="https://www.appcoda.com/blockchain-introduction/" rel="noopener ugc nofollow" target="_blank">斯威夫特</a> <a class="ae kr" href="https://learnappmaking.com/blockchain-app-swift-how-to/" rel="noopener ugc nofollow" target="_blank">区块链</a>？</p></div></div>    
</body>
</html>