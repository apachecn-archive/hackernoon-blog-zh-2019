<html>
<head>
<title>Scope &amp; Hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的范围和提升</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/scope-hoisting-in-javascript-19b991babc4f#2019-03-08">https://medium.com/hackernoon/scope-hoisting-in-javascript-19b991babc4f#2019-03-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b81e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理解提升需要很好地理解 JavaScript 中的作用域。所以我们将从示波器开始。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/39ce81bc0c1b7432e35344bb40742cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6OY1ZpvUbrdZ6qUF"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Photo by <a class="ae kf" href="https://unsplash.com/@c_baumeister?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Baumeister</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="43ab" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">范围</h1><p id="569a" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated"><strong class="it hv">作用域</strong>决定了 JavaScript 程序内部变量的可访问性。JavaScript 定义了两种范围</p><ul class=""><li id="53b7" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated"><strong class="it hv">功能范围</strong></li><li id="011a" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv">全球范围</strong></li><li id="1a74" class="lj lk hu it b iu ls iy lt jc lu jg lv jk lw jo lo lp lq lr dt translated"><strong class="it hv">阻塞范围</strong></li></ul><h2 id="4a55" class="lx kh hu bd ki ly lz ma km mb mc md kq jc me mf ku jg mg mh ky jk mi mj lc mk dt translated">功能范围</h2><p id="4a25" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">在函数作用域中，在函数内部声明的变量只能在该函数内部访问，或者只能被在该函数内部声明的其他函数访问。这些变量被称为局部变量。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/4a328a387f401353272bfd2dd5c1938f.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*epP5roHuQAPPZTrqBgdr0A.png"/></div></figure><p id="70ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，我们在函数范围内声明了一个变量，并输出了它的值。这是成功的，因为它在函数的范围内。当变量在范围之外打印时，我们得到的错误是变量没有被定义。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/c7aa42f9cd29ceea6ce4c52fad3f406b.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*wrYzByKmPO6ohnG6SVU-uQ.png"/></div></figure><p id="0db1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，当我们在函数作用域之外创建一个变量并打印变量的值时，我们会根据定义变量的作用域得到相同变量的不同值。</p><p id="fdb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">全局范围</strong></p><p id="bfb2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在任何函数作用域之外、全局作用域之内定义的变量和函数称为全局变量/函数。该程序中的任何成员都可以访问和操作它们。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/c7aa42f9cd29ceea6ce4c52fad3f406b.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*wrYzByKmPO6ohnG6SVU-uQ.png"/></div></figure><p id="5534" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这与上面的例子相同，第一行中定义的变量在全局范围内。程序中的任何成员都可以访问和更改它。</p><p id="a20e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过这个例子，我们还可以推断出，函数内部的局部变量比全局变量具有更高的优先级。这是因为全局变量和局部变量具有相同的名称，但是当打印变量时，由于给予局部变量更高的优先级，所以打印局部变量的值。</p><h2 id="6bf4" class="lx kh hu bd ki ly lz ma km mb mc md kq jc me mf ku jg mg mh ky jk mi mj lc mk dt translated">块范围</h2><p id="e2db" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">ES6 之前的 JavaScript 没有块作用域的概念。当引入块范围时，还引入了两个新的关键字来加强范围行为。我们先来讨论一下它们。</p><p id="110c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">让&amp;保持不变</strong></p><p id="8664" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简而言之，let 和 const 的行为基本相同，主要区别在于，const 不能被重新赋值，而 let 可以。</p><p id="08e3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当使用 let 或 const 关键字在块<strong class="it hv"> {} </strong>中定义一个变量时，它们在该块之外是不可访问的，而如果使用 var 定义了相同的变量，它仍然具有全局作用域(如果该块不在函数中)。</p><pre class="jq jr js jt fq mn mo mp mq aw mr dt"><span id="7f52" class="lx kh hu mo b fv ms mt l mu mv">{ <br/>  let x = 70;<br/>}<br/>// x can NOT be used here</span><span id="a704" class="lx kh hu mo b fv mw mt l mu mv">{ <br/>  var x = 274;<br/>}<br/>// x can be used here</span></pre><p id="b805" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">附:试抓<strong class="it hv">挡块</strong>在<strong class="it hv"> ES6 </strong>推出前<strong class="it hv">挡块</strong>范围内。</p></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="b34d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，考虑到上面关于范围的部分，清除了基础知识，让我们继续进行<strong class="it hv">吊装</strong>。</p><h1 id="b04d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">提升</h1><p id="76fd" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">以前提升是指一种机制，在代码执行之前，程序中的函数/变量声明被移动到它们作用域的顶部。这意味着无论函数/变量在哪里声明，它们都被移动到它们作用域的顶部，不管它们是全局作用域还是局部作用域。</p><p id="092f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是外部的感觉，但内部的过程几乎没有什么不同。根据 MDN</p><blockquote class="ne nf ng"><p id="597b" class="ir is nh it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated">在<em class="hu">编译</em>阶段，变量和函数声明被放入内存，但是停留在您在代码中键入它们的地方。</p></blockquote><p id="6e3a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这有点令人困惑，不容易一读就明白。让我们看一些例子来了解这实际上意味着什么。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/4bd1c39318c2e7110c8150b2b7bbcf54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*bn43sHknDwx-2ZvYucruiw.png"/></div></figure><p id="76b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在任何编程语言中，像这样的函数定义和调用都是非常标准的，这里没有错误，我们得到我们的输出。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/0a30117228edfe33c3bef280fbd5d6fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*QTe-KhMkAFQZ6qvQHvH2GQ.png"/></div></figure><p id="a824" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不支持提升的语言，或者如果我们禁用提升，上面的实现将抛出一个错误。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff nn"><img src="../Images/003d457cf4199aa646ebf87dac4407dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*5lwvWqDkCTN_cAkPtKATww.png"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Error</figcaption></figure><p id="f04c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再谈起重的定义</p><blockquote class="ne nf ng"><p id="21e5" class="ir is nh it b iu iv iw ix iy iz ja jb ni jd je jf nj jh ji jj nk jl jm jn jo hn dt translated">在<em class="hu">编译</em>阶段，变量和函数声明被放入内存，但是停留在您在代码中键入它们的地方。</p></blockquote><p id="47ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，函数声明在编译时放在内存中，所以从哪里调用函数并不重要，因为 JS 知道声明在内存中的确切位置。希望弄清楚，吊装究竟是什么。</p><p id="9b55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们用例子来了解更多关于吊装的知识。</p><ul class=""><li id="5b76" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">JavaScript 在执行任何代码段之前将函数声明放入内存，是因为它允许您在代码中声明函数之前使用它。这和上面的例子是一样的</li></ul><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/0958073528c241615b47968a99cc9b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*lDjZ6KWVy1vbk6u_3xqOdw.png"/></div></figure><ul class=""><li id="eb9f" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">提升让我们在声明变量之前使用初始化和使用变量。</li></ul><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff no"><img src="../Images/6b1954b7002936a570d503086988f320.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*en-pFgLI7F0zn757fxPo_w.png"/></div></figure><ul class=""><li id="4f64" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">JavaScript 只对该变量进行声明，而不是初始化/赋值。</li></ul><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff np"><img src="../Images/17cabfb48ac1c26b412f8aded37482a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*DKwf4oi8Li1lTNbppKZNxw.png"/></div></figure><p id="9e29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因为只有声明被提升，在使用后初始化一个声明的变量会产生 undefined。</p><ul class=""><li id="802e" class="lj lk hu it b iu iv iy iz jc ll jg lm jk ln jo lo lp lq lr dt translated">函数表达式不被提升。</li></ul><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nq"><img src="../Images/a79049cc5dd7a6314a0896d35334752a.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*UNkRvSbwfozl4snBXc0Jzg.png"/></div></div></figure><p id="d551" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个关于在 JavaScript 中使用提升的简介。如果你喜欢你所读的，跟着拍手！</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nr"><img src="../Images/8fa3b0fe054a13c3766d159ba831adc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/1*puO9QPsENQ5ww1QKNuf6tw.gif"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Google</figcaption></figure></div></div>    
</body>
</html>