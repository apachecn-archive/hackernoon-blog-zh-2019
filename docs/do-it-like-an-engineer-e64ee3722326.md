# 像工程师一样去做

> 原文：<https://medium.com/hackernoon/do-it-like-an-engineer-e64ee3722326>

软件工程师的工作就是解决问题。一切都可以归结为这个活动。这就是为什么有一个可靠的方法来解决问题是很重要的。我们毕竟是工程师，我们接受的是解决问题的训练。我们必须像工程师一样去做。

![](img/d8a560875ec70e24b16a87808b33eab4.png)

Engineering Hubris — [https://xkcd.com/319/](https://xkcd.com/319/)

## 了解需求

第一步是**了解需求**。要解决一个问题，你必须确切地了解问题是什么。发生在我身上的是，一个 2/3 周的工作，变成了 3 个月没用的“*哦，还有那个…* ”，“*哦，我们没有想到！也许如果……会更好。*”。我的错。吸取教训。
当你开始解决一个问题时，一定要了解**的起点**、**的终点**以及**之间的障碍**。最糟糕的事情可能是产生一个实际上没有达到预期效果的解决方案。
最后一点，记住*你*并且只有*你*决定*如何*解决问题。这是你的工作，因为这是给你新特性需求的人的工作，用最好的方式表达他们。如果一个不是工程师的人试图告诉你如何解决问题，打他的脸。你是完全正当的。至少是被我。

## 了解尺寸

我们都同意每秒处理 100000 个请求与每分钟处理 100 个请求有点不同。解决问题的方法是不同的。这就是为什么理解什么是*【输入的大小】*或者，换句话说，**问题有多大**很重要。否则，有两种情况。最好的情况是，你花 6 个月的时间来设计和实现一个利用率为 10%的系统。最糟糕的情况是当你花 1 个月的时间设计一个利用率为 180%的系统。如果最好的情况是浪费时间/资源，你也不想让自己处于最坏的情况。为了避免这种情况，我们必须提出正确的问题。系统应该满足多少个请求？
- *预计响应时间是多少？*
- *我们有多少资源？*
- *期限呢？*
正确的问题取决于上下文，但目标是一个且只有一个:**理解问题的大小**。

## 站在巨人的肩膀上…

我告诉你一个秘密。别人已经解决了你的问题的可能性很大。**非常高**。您所要做的就是在文献中搜索，找出是否有与您的用例相匹配的问题的解决方案。避免自制解决众所周知的问题的方法，它们只会带来其他问题。有很多公司有“他们的冬眠”、“他们的卡夫卡”等等。因为:
- *“我们有不一样的用例”*(我想看看)
- *“技术 X 的性能不够我们用”*(真的？)
- *“我们可以做得更好”*(这个最好笑😆)
底线:一旦你知道自己的要求和问题的大小，就在文献中做一个搜索。**没有重新发明轮子的意义**。

## …但是记住你不是巨人

在现有解决方案的基础上发展是可以的，但要避免过度。记住 [**你不是 Google**](https://blog.bradfieldcs.com/you-are-not-google-84912cf44afb) 。在酷炫技术的海洋中，最著名/最创新/最常用的技术并不总是最适合你的。部署一个 Kafka 集群来一天处理 5 条消息可能不是一个好主意。选择**将以最低复杂性**完成工作的技术。从长远来看，这个决定会给你带来好处。

## 奶奶驱动的发展

实施你的解决方案，努力让你的祖母能够理解。避免花哨和超级复杂的实现。把它们放到一边，赞成一个*简单的*和*可以理解的*一个。这将使代码更易于维护。把优化留到必要的时候。
更正式地说，你的实现应该遵循[最小功率法则](https://en.wikipedia.org/wiki/Rule_of_least_power)。最初的规则指的是编程语言的选择。在这种情况下，我们可以把它理解为:

> "在可用的解决方案中，选择能解决你的问题的最不强大的一个."

当我开始使用函数式编程时，我学会了这个规则。它允许您以一种无与伦比的优雅实现解决方案。然而，这种解决方案有时过于复杂。我更喜欢一个不那么优雅和高效，但更容易理解和维护的实现。你不会是唯一一个阅读你的代码的人。

## 结论

我们是工程师，我们的工作是解决问题，不管问题以什么形式出现。我们需要运用我们的工程技能，务实地分析问题*以提供正确的解决方案。我们需要记住，这不是产生预期结果的解决办法。它是需要**最少努力**和**最不复杂**的。我希望我在这个故事中描述的方法能帮助你向这样的成就迈进一步。*

*再见！🚀*

*如果你喜欢读这个故事，就像我喜欢写它一样，请给我一些掌声👏。*