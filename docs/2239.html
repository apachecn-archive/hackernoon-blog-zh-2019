<html>
<head>
<title>Overview of how does CSS works behind the scenes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS 如何在幕后工作的概述？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/overview-of-how-does-css-works-behind-the-scenes-498d98b0e404#2019-04-08">https://medium.com/hackernoon/overview-of-how-does-css-works-behind-the-scenes-498d98b0e404#2019-04-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/32b90694d5639482f5eb6b92ec8f3adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpvwCo9GaT9MqVIjfoPYSA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Frontamentals</figcaption></figure><p id="e2cd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们从理解当我们在浏览器中加载一个网页时，我们的 CSS 代码实际上发生了什么开始。</p><p id="a568" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当浏览器开始加载初始 HTML 文件时，它会获取加载的 HTML 代码并解析它，这意味着它将逐行解码代码。通过这一过程，浏览器构建了所谓的 DOM(文档对象模型),它用一个包含父元素、子元素和兄弟元素的树来描述整个 web 文档。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ke"><img src="../Images/c9c8549213f8e7206141e37ae56329ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EUqO4ad9IuaIaM2bhZ8SGQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">HTML Parsing by Jonas Schmedtmann</figcaption></figure><p id="130c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当浏览器解析 HTML 时，它也会找到 HTML 头中包含的样式表，就像 HTML 一样，CSS 也会被解析。<br/>但是 CSS 的解析有点复杂。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kj"><img src="../Images/fae2667c1128b3b3ffec86947b771b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8SCfl7rGNLKFqqIp-GiNQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">By Jonas Schmedtmann</figcaption></figure><p id="3a31" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在 CSS 解析阶段有两个主要步骤要执行:</p><blockquote class="kk"><p id="79a4" class="kl km hu bd kn ko kp kq kr ks kt kd ek translated">1.冲突的 CSS 声明被解决(也称为级联)</p><p id="0ae7" class="kl km hu bd kn ko kp kq kr ks kt kd ek translated">2.处理最终的 CSS 值(例如，将百分比单位定义的边距转换为像素)</p></blockquote><p id="82bb" class="pw-post-body-paragraph jg jh hu ji b jj ku jl jm jn kv jp jq jr kw jt ju jv kx jx jy jz ky kb kc kd hn dt translated">解析后的 CSS 也存储在一个名为 CSS Object Modal 的树状结构中，类似于 DOM。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/724f84ee5a7ef516437f5f6d4bdac107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*VNBzD4W043-PgDa8X8qFcA.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">CSS Parsing by Jonas Schmedtmann</figcaption></figure><p id="a5c2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">解析后的 HTML 和 CSS 一起形成了所谓的渲染树。<br/>这样，我们终于拥有了渲染页面所需的一切。</p><p id="181b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">视觉格式模型是浏览器用来实际呈现页面的东西。该算法为渲染树中的每个元素计算盒子(盒子模型)并确定这些盒子的布局，以便确定页面的最终布局。</p><p id="7a24" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以最后，在视觉格式化模型之后，网站最终被渲染或绘制到屏幕上。</p><figure class="kf kg kh ki fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff la"><img src="../Images/e8d5b370a813aa4a9abb1f361d2e18b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pU6B5gIzzOIX3vcbXHNEhA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">By Jonas Schmedtmann</figcaption></figure></div><div class="ab cl lb lc hc ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hn ho hp hq hr"><p id="911b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是幕后发生的过程的简要描述。<br/>在下一篇文章中，我们将深入这个主题(CSS 解析，可视化格式化模态)，以了解幕后到底发生了什么。</p><p id="e27d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<a class="ae li" href="https://twitter.com/jscodelover" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae li" href="https://www.linkedin.com/in/jscodelover" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae li" href="https://github.com/jscodelover" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。</p><p id="6030" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="lj">希望这篇文章对你有用。感谢阅读&amp;继续学习！！</em></p></div></div>    
</body>
</html>