<html>
<head>
<title>Web Performance: Understanding the Critical Render Path (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web性能:理解关键呈现路径(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/web-performance-understanding-the-critical-render-path-part-1-54eec8d7667c?source=collection_archive---------12-----------------------#2019-07-01">https://medium.com/hackernoon/web-performance-understanding-the-critical-render-path-part-1-54eec8d7667c?source=collection_archive---------12-----------------------#2019-07-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5394" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">当访问一个新的web应用程序时，最大的障碍是加载速度慢！</h2></div><figure class="jj jk jl jm fq jn"><div class="bz el l di"><div class="jo jp l"/></div></figure><p id="5af7" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">幸运的是，有几种技术可以大大加快加载速度。在我们学习优化之前，我们需要了解浏览器是如何加载页面的。记住优化的黄金法则:</p><blockquote class="km"><p id="0cce" class="kn ko hu bd kp kq kr ks kt ku kv kl ek translated"><strong class="ak">先测量，后优化</strong></p></blockquote><p id="2e8f" class="pw-post-body-paragraph jq jr hu js b jt kw iv jv jw kx iy jy jz ky kb kc kd kz kf kg kh la kj kk kl hn dt translated">在衡量理解之前，我会增加一个额外的步骤:)这将让我们对可能在早期阻碍我们网站性能的事情有一个强烈的直觉。</p><h2 id="acf0" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">什么是关键的渲染路径？</h2><p id="bdf9" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">关键的渲染路径是浏览器将HTML、CSS和Javascript转换成屏幕上实际像素的一系列步骤。一旦我们理解了关键的渲染路径，我们将能够改善网站的加载时间。在开始之前，让我们先来分析一下这个名字:</p><ul class=""><li id="3306" class="mb mc hu js b jt ju jw jx jz md kd me kh mf kl mg mh mi mj dt translated">关键-必须加载</li><li id="a137" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl mg mh mi mj dt translated">渲染-在用户浏览器中显示</li><li id="2cde" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl mg mh mi mj dt translated">导致我们的页面显示在用户浏览器中的事件序列</li></ul><h2 id="cfbe" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">关键渲染路径序列</h2><p id="27ec" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">在我们深入细节之前，让我们整体检查一下序列:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/e6bf43495d468633d6d239174f2e5b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*4P-TCF1fzwhLKyfmrfvkBw.png"/></div></figure><ol class=""><li id="894c" class="mb mc hu js b jt ju jw jx jz md kd me kh mf kl ms mh mi mj dt translated"><strong class="js hv"> DOM: </strong>我们按字符处理HTML，标记并创建DOM节点，这些节点最终将成为DOM的一部分。</li><li id="d85d" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated"><strong class="js hv"> CSSOM: </strong>一旦我们处理了头部并获取了请求的CSS资源，我们就开始构建CSSOM。这部分是阻塞的，我们将在下面看到。</li><li id="da15" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated"><strong class="js hv">构建渲染树🌳 🌲:</strong>我们结合创建的DOM和CSSOM来创建<strong class="js hv">渲染树。</strong></li><li id="a5be" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated"><strong class="js hv">布局:</strong>通过检查创建的<strong class="js hv">渲染树计算页面的布局。</strong></li><li id="1abf" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated"><strong class="js hv">画图:</strong>我们终于可以在屏幕上画出像素了。</li></ol><h2 id="ba82" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">构建文档对象模型(DOM)</h2><p id="5d15" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">那么浏览器如何将一个请求转化为我们在屏幕上看到的像素呢？</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff mt"><img src="../Images/102c438881a86fb12d4dcdfa7aba1e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BddtNDHNLTAqHELzRKxFIg.png"/></div></div><figcaption class="my mz fg fe ff na nb bd b be z ek">example HTML payload</figcaption></figure><ol class=""><li id="c37b" class="mb mc hu js b jt ju jw jx jz md kd me kh mf kl ms mh mi mj dt translated">浏览器接收字节格式的HTML有效负载。</li><li id="a74d" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated">我们首先扫描字符来识别标记。</li><li id="9edd" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated">一旦标识了令牌，一个单独的进程就开始使用令牌并创建DOM节点。</li><li id="4bdd" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated">节点之间的关系由start ( &lt;&gt;)和end( &gt;)标记定义，这让我们可以定义父子关系👶节点之间的关系。</li></ol><p id="a2b5" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">总的来说，DOM解析序列如下所示:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/e23c5703141b5a5428672b811dee61e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*LlQHREP1tmwVCDzMOGglvg.png"/></div></figure><p id="290e" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">一旦我们使用了所有的令牌并创建了它们各自的节点，我们就得到一个叫做DOM的树状结构。关于HTML如何转换为DOM的示例，请参见下图:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff nc"><img src="../Images/d293a0edf6173175cba63ace5debe426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znE8gVZD8vsL-XP-Q499Rg.png"/></div></div><figcaption class="my mz fg fe ff na nb bd b be z ek">From Udacity</figcaption></figure><p id="8ea8" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><strong class="js hv">构建DOM是一个渲染阻塞器，</strong>因为显然没有DOM我们就没有任何东西可以渲染。</p><h2 id="b219" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">构建CSS对象模型(CSSOM)</h2><p id="3780" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">DOM捕捉页面的内容，但是我们也需要知道如何显示页面本身。为此，我们需要CSSOM。解析和构建CSSOM的过程与DOM非常相似。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/c632e8bba3a333ee13bb124b3b23168e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*GdpwYI3ZDO4voUeUV5G34A.png"/></div></figure><p id="2a77" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">很好，我们读取了接收到的解析后的CSS规则，并将它们映射到我们拥有的节点上。</p><h2 id="9099" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">将样式映射到HTML元素</h2><p id="60b7" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">映射算法很幼稚。我们搜索具有相应标识符的节点。当我们从右到左阅读规则时，更具体的CSS规则需要更长的时间才能找到并应用。让我们来看看这个例子——你认为哪个规则需要更长的时间来应用？</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff nd"><img src="../Images/3875d57a6fcd50e67913d472037a43cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOyZACUYANIWo7B2KYL8Ng.png"/></div></div></figure><p id="f2b1" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">第一条规则是将任何<em class="ne"> &lt; h1 &gt; </em>标签修改为16px 的<em class="ne">字体大小。</em></p><p id="f0b2" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">第二条规则(从右向左读)说找到一个<em class="ne"> &lt; p &gt; </em>标签。为每个<em class="ne"> &lt; p &gt; </em>标签搜索一个<em class="ne"> &lt; div &gt; </em>祖先。如果存在，应用16px的字体大小。很明显，这个规则更复杂，并且需要更长的时间才能找到，因为我们要遍历树中更多的DOM节点。话虽如此，这种差异可能是微不足道的，并不是一个大的性能瓶颈。</p><p id="bdb2" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">令人惊讶的是，<strong class="js hv">构建CSSOM也是浏览器的渲染阻塞资源。</strong>这是因为许多网站在应用CSS之前基本无法使用。比如看我的作品集网站<strong class="js hv"> <em class="ne">有无CSS的区别。</em>T15】</strong></p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff nf"><img src="../Images/330ba295aa15467e1378c73d8b013b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kiwDPzKOVkImY5DyLN37nQ.png"/></div></div></figure><p id="9c01" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><strong class="js hv">虽然CSS是一个渲染拦截器，但是媒体类型和查询允许我们将一些CSS资源标记为非渲染拦截。</strong>明确声明我们的媒体类型确实可以缩短加载时间(我们节省了不必要的读取和解析！)所以用你的<em class="ne"> CSS includes注意这个。</em></p><p id="52cf" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们来看看这个例子:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff ng"><img src="../Images/29bb3c0281f06bf5fee084ad41775387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UjRzOMy45iurJk5-gNfeHg.png"/></div></div><figcaption class="my mz fg fe ff na nb bd b be z ek">From the Google Documentation</figcaption></figure><ul class=""><li id="87a0" class="mb mc hu js b jt ju jw jx jz md kd me kh mf kl mg mh mi mj dt translated">前两个CSS链接是等效的。它们将被应用于每一个场景，不管是动作还是屏幕大小。</li><li id="8817" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl mg mh mi mj dt translated">第三个<em class="ne"> CSS包含</em>将<strong class="js hv">仅在屏幕方向设置为纵向时适用。</strong></li><li id="6bb3" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl mg mh mi mj dt translated">第四个<em class="ne"> CSS include </em>将<strong class="js hv">仅在我们打印文档时适用。</strong></li><li id="fb3d" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl mg mh mi mj dt translated"><strong class="js hv">指定最后两种媒体类型使得这些资源不阻塞，</strong>因此我们的站点在这些不适用的情况下会加载得更快。</li></ul><p id="f06b" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">还要注意，CSS上下文中的“呈现阻塞”仅指浏览器是否必须暂停页面的呈现，直到接收到该资源。在任何情况下<strong class="js hv">浏览器将总是下载所有CSS资源，</strong>不管阻塞或非阻塞行为。</p><p id="2162" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">考虑到CSS的阻塞特性，我们会一直努力让<strong class="js hv">尽快将CSS发送到客户端(用户浏览器),以改善初始渲染时间。</strong></p><h2 id="42d8" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">渲染树</h2><p id="904e" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">渲染树结合了DOM和CSSOM，并且只包含屏幕上可见的内容📺。因此，我们不会在渲染树中看到任何显示设置为“无”的元素。</p><p id="f005" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们看看DOM和CSSOM是如何结合起来创建一个渲染树的:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff nh"><img src="../Images/39eab5ffdf7a30a1971340519dc044cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2sc2mPzDMI7LTDvo9j0dsw.png"/></div></div></figure><p id="5438" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">当渲染树完成后，我们可以继续布局阶段。</p><h2 id="f8fb" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">布局</h2><p id="45c1" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">我们有了渲染树，但我们仍然需要弄清楚元素应该如何在屏幕上定位。为了确定页面上每个对象的确切大小和位置，浏览器查看收到的渲染树的根，并开始遍历它。</p><p id="592a" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">除非另外指定，否则调整元素大小和放置元素始终相对于父div。让我们来看看:</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="fe ff ni"><img src="../Images/c0620e94698c6268f586ecf606f26539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kM7BMqhJqInCt8vS4Bf1A.png"/></div></div><figcaption class="my mz fg fe ff na nb bd b be z ek">From Udacity</figcaption></figure><p id="6199" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">布局阶段的时间取决于几个因素:</p><ul class=""><li id="dba8" class="mb mc hu js b jt ju jw jx jz md kd me kh mf kl mg mh mi mj dt translated">运行它的设备</li><li id="a0bf" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl mg mh mi mj dt translated">文档的大小</li><li id="f74d" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl mg mh mi mj dt translated">将样式应用于文档</li></ul><p id="d03e" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">文档越大，样式越复杂，完成布局阶段所需的时间就越长。</p><h2 id="54b8" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">颜料🎨🎨</h2><p id="acc3" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">此时，我们知道哪些节点是可见的，以及它们的计算布局和样式。在这一步，我们采用最终的渲染树，将像素(单个节点)渲染到屏幕上😱😱。</p><h2 id="ff9b" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">摘要</h2><p id="a1d3" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">我们在这里学到了很多。让我们总结一下呈现通过来自浏览器的HTTP GET请求接收的网页所需的步骤。</p><ol class=""><li id="b88f" class="mb mc hu js b jt ju jw jx jz md kd me kh mf kl ms mh mi mj dt translated">解析和处理HTML并构建DOM。</li><li id="2521" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated">解析和处理CSS并构建CSSOM。</li><li id="245d" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated">合并渲染树的DOM和CSSOM。</li><li id="851f" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated">运行布局计算来计算渲染树中每个节点的大小和位置。</li><li id="3e9c" class="mb mc hu js b jt mk jw ml jz mm kd mn kh mo kl ms mh mi mj dt translated">在屏幕上绘制每个节点(像素)。</li></ol><p id="1471" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">为了让我们的页面加载速度超快，我们的目标是让上述过程中的每一步都尽可能快！</p><p id="1317" class="pw-post-body-paragraph jq jr hu js b jt ju iv jv jw jx iy jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在本系列的下一篇文章中，我们将关注关键的渲染路径优化。记住，<strong class="js hv">我们不能优化我们不能测量的东西！</strong></p><h2 id="3093" class="lb lc hu bd ld le lf lg lh li lj lk ll jz lm ln lo kd lp lq lr kh ls lt lu lv dt translated">如果这篇文章有帮助，请订阅并点击鼓掌👏按钮以示支持！⬇⬇</h2><p id="7f78" class="pw-post-body-paragraph jq jr hu js b jt lw iv jv jw lx iy jy jz ly kb kc kd lz kf kg kh ma kj kk kl hn dt translated">您可以在<a class="ae nj" href="https://www.instagram.com/omeragoldberg/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>、<a class="ae nj" href="https://www.linkedin.com/in/omer-goldberg-680b40100/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>和<a class="ae nj" rel="noopener" href="/@omergoldberg"> Medium </a>上关注我，了解更多科技相关内容！</p></div></div>    
</body>
</html>