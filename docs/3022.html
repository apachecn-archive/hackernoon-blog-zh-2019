<html>
<head>
<title>Let’s code the roots of Functional Programming: Lambda calculus implemented in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们编写函数式编程的根源:在Typescript中实现的Lambda演算</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lets-code-the-roots-of-functional-programming-lambda-calculus-implemented-in-typescript-36806ebc2857?source=collection_archive---------4-----------------------#2019-05-14">https://medium.com/hackernoon/lets-code-the-roots-of-functional-programming-lambda-calculus-implemented-in-typescript-36806ebc2857?source=collection_archive---------4-----------------------#2019-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/084220321c2fb32f16947b38ca6caff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCX6bsSNUF_v2hFKgnaQIA.png"/></div></div></figure><h1 id="d2c5" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">序幕</h1><p id="8569" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这是一篇关于类型脚本和函数式编程的文章。不是一篇关于Lambda微积分理论的文章。</p><p id="61c0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们将在Typescript中实现Lambda演算，作为练习函数式编程的一种方式。我们将只使用Lambda演算构造来解决一个简单的问题。</p><p id="6f1f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">最终，也许理论的基础也会变得更加清晰。</p><h1 id="f885" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">问题和语言</h1><p id="b855" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">要解决的问题很简单:<strong class="kc hv"> <em class="ld">如果2个数字</em> </strong> <code class="eh le lf lg lh b"><strong class="kc hv">n</strong></code> <strong class="kc hv"> <em class="ld">和</em> </strong> <code class="eh le lf lg lh b"><strong class="kc hv">m</strong></code> <strong class="kc hv"> <em class="ld">相等，则返回</em> </strong> <code class="eh le lf lg lh b"><strong class="kc hv">n + m</strong></code> <strong class="kc hv"> <em class="ld">否则返回</em> </strong> <code class="eh le lf lg lh b"><strong class="kc hv">m — n</strong></code>。</p><p id="6490" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">但是我们的语言只允许我们使用下面的结构</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="fb5f" class="lq jd hu lh b fv lr ls l lt lu">x =&gt; y  // anonymous function with 1 parameter (i.e. unary function) </span></pre><p id="3fe2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">其中<code class="eh le lf lg lh b">x</code>和<code class="eh le lf lg lh b">y</code>可以是一切。<code class="eh le lf lg lh b">x</code>和<code class="eh le lf lg lh b">y</code>甚至可以是函数，所以在我们的语言中，以下也是有效的构造</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="0c78" class="lq jd hu lh b fv lr ls l lt lu">x =&gt; y =&gt; z =&gt; z(x)(y)  // x is the parameter and the value returned is y =&gt; z =&gt; z(x)(y)</span></pre><p id="c0d5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">换句话说，要解决这个问题，我们只有匿名函数(也称为“胖箭头”函数)。没有Javascript原生<code class="eh le lf lg lh b">numbers</code>，没有<code class="eh le lf lg lh b">==</code>或<code class="eh le lf lg lh b">===</code>操作符，没有<code class="eh le lf lg lh b">if then else</code>。只是功能。请记住，在本文的其余部分</p><blockquote class="lv"><p id="318c" class="lw lx hu bd ly lz ma mb mc md me kx ek translated">我们只有功能。</p></blockquote><h2 id="fbb5" class="lq jd hu bd je mf mg mh ji mi mj mk jm kl ml mm jq kp mn mo ju kt mp mq jy mr dt translated">λ演算</h2><p id="16c9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Lambda演算为我们提供了仅使用函数来解决这个问题的理论基础。实际上，Lambda演算只用函数就能解决任何可计算的问题。</p><p id="8003" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">什么是Lambda微积分？有许多资料提供了很好的描述。就本文的目的而言，Lambda演算就是我们可以使用匿名函数来解决问题的简单事实。</p><p id="7c60" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在这里，我们想看看如何使这个概念具体化，用Typescript实现Lambda演算，并通过它解决我们的问题。在这个过程中，我们将广泛地，或者更好地，专门使用<strong class="kc hv">函数式编程</strong>技术，因为</p><blockquote class="lv"><p id="23cd" class="lw lx hu bd ly lz ma mb mc md me kx ek translated">我们只有功能。</p></blockquote><p id="2115" class="pw-post-body-paragraph ka kb hu kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx hn dt translated">考虑到Lambda演算也是函数式编程的基础，那么是的，我们可以说<strong class="kc hv">我们要用Typescript编写根函数式编程。</strong></p><p id="9d5e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">问题解决方案的完整代码和额外的Lambda演算构造可以在<a class="ae mx" href="https://github.com/EnricoPicci/lambda-calculus-typescript" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="93ae" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">没有数字的数字</h1><p id="de55" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们的问题从2个数字开始，但是我们不能使用Javascript数字，因为</p><blockquote class="lv"><p id="411d" class="lw lx hu bd ly lz ma mb mc md me kx ek translated">我们只有功能。</p></blockquote><p id="0f35" class="pw-post-body-paragraph ka kb hu kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx hn dt translated">所以我们需要发明一种方法来定义一个<strong class="kc hv">的概念，一个<em class="ld">的数字</em>一个</strong>的使用函数。</p><p id="decc" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们开始说，数字零，一和二分别由</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="7312" class="lq jd hu lh b fv lr ls l lt lu">ZERO = f =&gt; x =&gt; x        // in lambda calculus this is <strong class="lh hv"><em class="ld">λf.λx.x<br/> </em></strong>ONE = f =&gt; x =&gt; f(x)     // in lambda calculus this is <strong class="lh hv"><em class="ld">λf.λx.fx<br/> </em></strong>TWO<strong class="lh hv"><em class="ld"> = </em></strong>f =&gt; x =&gt; f(f(x))  // in lambda calculus this is <strong class="lh hv"><em class="ld">λf.λx.f(fx)</em></strong></span></pre><p id="42b2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果<code class="eh le lf lg lh b">f</code>是一个函数，<code class="eh le lf lg lh b">x</code>是任意值，<code class="eh le lf lg lh b">ZERO</code> <em class="ld">返回</em> <code class="eh le lf lg lh b"><em class="ld">x</em></code> <em class="ld"> </em> <strong class="kc hv"> <em class="ld">从不</em> </strong> <em class="ld">应用</em> <code class="eh le lf lg lh b"><em class="ld">f</em></code> <em class="ld">而</em> <code class="eh le lf lg lh b">ONE</code> <em class="ld">返回应用</em> <code class="eh le lf lg lh b"><em class="ld">f</em></code> <em class="ld">一次</em><code class="eh le lf lg lh b"><em class="ld">x</em></code><em class="ld"/><code class="eh le lf lg lh b"><em class="ld">TWO</em></code><em class="ld">的结果</em>所以基本上这是我们的约定:一个<strong class="kc hv">数</strong>由一个函数<code class="eh le lf lg lh b">f</code>被应用到自变量<code class="eh le lf lg lh b">x</code>的次数来表示。</p><p id="b5d0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">所以机制是清楚的。一个数字<strong class="kc hv"> n </strong>代表一个函数<code class="eh le lf lg lh b">f</code>对一个自变量<code class="eh le lf lg lh b">x</code> <strong class="kc hv"> <em class="ld"> n次</em> </strong>的应用。记住这个概念，我们后面会用到。对了，这叫数字的教会编码。这是λ演算的发明者阿隆佐·邱奇用来表示自然数的惯例。</p><h2 id="654f" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">后继函数</h2><p id="be29" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">到目前为止，我们已经对前3个数字进行了硬编码，但是我们需要找到一种更灵活、更智能的方式来定义数字。这种方式是由后继函数提供给我们的</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8986" class="lq jd hu lh b fv lr ls l lt lu">SUCC = n =&gt; f =&gt; x =&gt; f(n(f)(x)) // equivalent to <strong class="lh hv"><em class="ld">λn.λf.λx.f(nfx)</em></strong></span></pre><p id="38a0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它看起来不是直接的，对吗？但是我们来推理一下。</p><p id="bc34" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">先说<code class="eh le lf lg lh b">n</code>等于<code class="eh le lf lg lh b">ZERO</code>的情况。如果<code class="eh le lf lg lh b">n</code>是<code class="eh le lf lg lh b">ZERO</code>(记住<code class="eh le lf lg lh b">ZERO</code>已经被定义为<code class="eh le lf lg lh b">f =&gt; x =&gt; x</code>)那么将<code class="eh le lf lg lh b">SUCC(n)</code>应用于<code class="eh le lf lg lh b">ZERO</code>，即用<code class="eh le lf lg lh b">ZERO</code>的定义替换<code class="eh le lf lg lh b">n</code>，我们得到</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/c8162f78b39dbcfb0be4b2b702a8359e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01RgUGHFyMJrw9ZXVuwoRg.png"/></div></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">Substitutions in SUCC(ZERO) to reach ONE</figcaption></figure><p id="8ca2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果我们尝试<code class="eh le lf lg lh b">SUCC(ONE)</code>应用相同的机械替代，我们得到<code class="eh le lf lg lh b">TWO</code>。然后<code class="eh le lf lg lh b">SUCC(TWO)</code>就是<code class="eh le lf lg lh b">THREE</code>以此类推。</p><h2 id="2728" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">关于奉承的几句话</h2><p id="4fca" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们刚刚定义了</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="e981" class="lq jd hu lh b fv lr ls l lt lu">SUCC = n =&gt; f =&gt; x =&gt; f(n(f)(x))</span></pre><p id="b174" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">说得迂腐一点我们可以说<code class="eh le lf lg lh b">SUCC</code>是一个<strong class="kc hv"> <em class="ld">函数</em> </strong>带<strong class="kc hv"> <em class="ld">一个参数</em></strong><code class="eh le lf lg lh b">n</code>，返回一个<strong class="kc hv"> <em class="ld">函数</em> </strong>带<strong class="kc hv"> <em class="ld">一个参数</em></strong><code class="eh le lf lg lh b">f</code>，返回一个<strong class="kc hv"> <em class="ld">函数</em> </strong>带<strong class="kc hv"> <em class="ld">一个参数</em> </strong></p><p id="4816" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">因此，我们实际上可以说<code class="eh le lf lg lh b">SUCC</code>是三个参数<code class="eh le lf lg lh b">n</code> <code class="eh le lf lg lh b">f</code>和<code class="eh le lf lg lh b">x</code>的函数，并且一次应用一个参数。这种单参数的部分应用被称为<em class="ld">curry</em>。</p><p id="fa62" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">从现在起，我们将自由地谈论<em class="ld"> m </em>参数的函数，其中<em class="ld"> m ≥ 1 </em>，即使在这个概念后面总是有<em class="ld">curring</em>机制，因为Lambda函数根据定义是一元的，即只接受1个参数。</p><h2 id="2629" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">让我们添加一些类型</h2><p id="5957" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果我们按照惯例来看一个数的结构，我们会看到两件事</p><ul class=""><li id="540d" class="ni nj hu kc b kd ky kh kz kl nk kp nl kt nm kx nn no np nq dt translated">数字是一个函数，它有两个参数，<code class="eh le lf lg lh b">f</code>和<code class="eh le lf lg lh b">x</code>，并返回一些东西</li><li id="e2b4" class="ni nj hu kc b kd nr kh ns kl nt kp nu kt nv kx nn no np nq dt translated">第一个参数<code class="eh le lf lg lh b">f</code>本身必须是一元函数，因为它可以应用于每个数字体中的<code class="eh le lf lg lh b">x</code></li></ul><p id="5525" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">所以我们可以开始在Typescript中定义一些类型</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="3c65" class="lq jd hu lh b fv lr ls l lt lu">type uF = (x: any) =&gt; any;                 // unary function<br/>type NUMBER = (f: uF) =&gt; (x: any) =&gt; any;  // the type of numbers</span></pre><p id="74a3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">然后也可以输入函数<code class="eh le lf lg lh b">SUCC</code></p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="d89f" class="lq jd hu lh b fv lr ls l lt lu">SUCC = (n: NUMBER): NUMBER =&gt; (f: uF) =&gt; (x: any) =&gt; f(n(f)(x));</span></pre><p id="9738" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">Typescript为我们提供了向函数定义中添加类型的机会，这可以通过智能感知和类型检查为我们提供很大的帮助，特别是当我们想要解决的问题变得复杂时。</p><h2 id="10ea" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">但是如果这些是“数字”，我们能把它们看作正常的数字吗？</h2><p id="8745" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">数字的Church编码是将一个函数应用于一个参数n次。这一切都很好，但是…</p><p id="a6af" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们能把它们看成正常的数字吗，比如0，1，2，36，49，112？</p><p id="3b8c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">是的，我们可以。如果我们将一个JavaScript数字递增1的函数作为<code class="eh le lf lg lh b">f</code>传递，将Javascript数字0作为<code class="eh le lf lg lh b">x</code>传递，我们将获得对应于教堂编码数字的Javascript数字，如下例所示。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nw nx l"/></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">Get the Javascript encoding of Church number 2</figcaption></figure><p id="02c3" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">同时，如果我们改变函数<code class="eh le lf lg lh b">f</code>和初始值，那么我们可以看到我们的教会用不同格式编码的数字。例如，在这里，一个教堂号码<strong class="kc hv"> n </strong>被转换成一串n个字符<code class="eh le lf lg lh b">*</code>。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nw nx l"/></div></figure><h1 id="11a4" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">没有布尔的布尔</h1><p id="2374" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">对于布尔值，我们必须面对与数字相同的问题。我们需要用一种没有这些概念的语言来定义真和假，这种语言</p><blockquote class="lv"><p id="2e03" class="lw lx hu bd ly lz ma mb mc md me kx ek translated">我们只有功能。</p></blockquote><p id="2c2b" class="pw-post-body-paragraph ka kb hu kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx hn dt translated">我们再次回到惯例。直觉:在Javascript三元运算符中，<code class="eh le lf lg lh b">condition ? first : second</code>、<strong class="kc hv"> True </strong>表示选择第一个选项，<strong class="kc hv"> False </strong>表示选择第二个选项。</p><p id="9cbb" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们在这里使用相同的约定，教会对布尔的编码，即</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="bfe1" class="lq jd hu lh b fv lr ls l lt lu">// TRUE and FALSE are binary functions, they expect 2 parameters<br/>TRUE  =  <strong class="lh hv">x</strong> =&gt; y =&gt; <strong class="lh hv">x</strong>   // TRUE returns the <strong class="lh hv">first</strong> parameter<br/>FALSE =  x =&gt; <strong class="lh hv">y</strong> =&gt; <strong class="lh hv">y</strong>   // FALSE returns the <strong class="lh hv">second</strong> parameter</span></pre><p id="48ff" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">现在我们将看到这种约定实际上是如何适用于布尔运算符的。</p><h2 id="643e" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">AND函数</h2><p id="d71b" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">现在让我们看看如何构建一个行为类似于<code class="eh le lf lg lh b">AND</code>的函数，也就是说，它需要两个教会编码的布尔参数<code class="eh le lf lg lh b">p</code>和<code class="eh le lf lg lh b">q</code>，并且只有当两个参数都是<code class="eh le lf lg lh b">TRUE</code>时才返回<code class="eh le lf lg lh b">TRUE</code>。</p><p id="a1e0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh le lf lg lh b">AND</code>必须有以下形式</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="479f" class="lq jd hu lh b fv lr ls l lt lu">AND = p =&gt; q =&gt; ....   // p and q are Church encoded booleans</span></pre><p id="ede7" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh le lf lg lh b">p</code>和<code class="eh le lf lg lh b">q</code>是我们仅有的东西，所以我们最好在函数体中使用它们。</p><p id="6c71" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们尝试用<code class="eh le lf lg lh b">p</code>开始主体的实现，它本身是一个二进制函数，因为它是一个教会编码的布尔值。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8a67" class="lq jd hu lh b fv lr ls l lt lu">AND = p =&gt; q =&gt; p(_)(_)  // p expects 2 arguments</span></pre><p id="68dd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果<code class="eh le lf lg lh b">p</code>是<code class="eh le lf lg lh b">FALSE</code>，根据<code class="eh le lf lg lh b">FALSE</code>的定义，它选择第二个参数。但是如果<code class="eh le lf lg lh b">p</code>是<code class="eh le lf lg lh b">FALSE</code>，那么<code class="eh le lf lg lh b">AND</code>的结果必须是<code class="eh le lf lg lh b">FALSE</code>，因此<code class="eh le lf lg lh b">p</code>之后的第二个参数必须是<code class="eh le lf lg lh b">FALSE</code>。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="89e0" class="lq jd hu lh b fv lr ls l lt lu">AND = p =&gt; q =&gt; p(_)(FALSE) // if p is false it selects the 2nd arg</span></pre><p id="591c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果<code class="eh le lf lg lh b">p</code>是<code class="eh le lf lg lh b">TRUE</code>，那么根据<code class="eh le lf lg lh b">TRUE</code>的定义，选择<code class="eh le lf lg lh b">p</code>之后的第一个自变量。但是在这种情况下，<code class="eh le lf lg lh b">AND</code>的结果取决于<code class="eh le lf lg lh b">q</code>的值。如果<code class="eh le lf lg lh b">q</code>为<code class="eh le lf lg lh b">TRUE</code>，则结果为<code class="eh le lf lg lh b">TRUE</code>，否则为<code class="eh le lf lg lh b">FALSE</code>。但这意味着<code class="eh le lf lg lh b">p</code>之后的第一个参数是<code class="eh le lf lg lh b">q</code>本身。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="d13e" class="lq jd hu lh b fv lr ls l lt lu">AND = p =&gt; q =&gt; p(q)(FALSE) // if p is true it selects q as result</span></pre><p id="9899" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们现在可以做最后的简化。<code class="eh le lf lg lh b">p</code>的第二个参数是<code class="eh le lf lg lh b">FALSE</code>，只有当<code class="eh le lf lg lh b">p</code>为<code class="eh le lf lg lh b">FALSE</code>时才选择。这意味着我们可以用<code class="eh le lf lg lh b">p</code>代替<code class="eh le lf lg lh b">FALSE</code>作为函数的最终版本</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="9830" class="lq jd hu lh b fv lr ls l lt lu">AND = p =&gt; q =&gt; p(q)(p)</span></pre><p id="1648" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">甚至对称版本也能工作</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="e773" class="lq jd hu lh b fv lr ls l lt lu">AND = p =&gt; q =&gt; q(p)(q)</span></pre><p id="4f9c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">用类似的方法，可以找到所有其他布尔运算符。</p><p id="a1df" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们可以向Church编码的布尔值添加类型，并测试我们的逻辑的正确性，如本例所示。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nw nx l"/></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">The AND function typed and tested</figcaption></figure><h1 id="d2b1" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">没有比较运算符的比较</h1><p id="63ec" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们的问题要求我们比较两个数字，但是我们没有像<code class="eh le lf lg lh b">==</code>或<code class="eh le lf lg lh b">===</code>这样的比较运算符，</p><blockquote class="lv"><p id="7e98" class="lw lx hu bd ly lz ma mb mc md me kx ek translated">我们只有功能。</p></blockquote><p id="debd" class="pw-post-body-paragraph ka kb hu kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx hn dt translated">我们需要找到不同的策略。请容忍我的旅程。</p><p id="fcd2" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">检查两个数<code class="eh le lf lg lh b">n</code>和<code class="eh le lf lg lh b">m</code>是否等于<strong class="kc hv"><em class="ld"/></strong>的一种方法是检查<code class="eh le lf lg lh b">n</code>是否小于等于<strong class="kc hv"><em class="ld"/></strong>到<code class="eh le lf lg lh b">m</code><code class="eh le lf lg lh b">m</code>是否小于等于<strong class="kc hv"><em class="ld"/></strong>到<code class="eh le lf lg lh b">n</code>。假设我们有一个函数<code class="eh le lf lg lh b">LEQ(m)(n)</code>，如果<code class="eh le lf lg lh b">m</code>是<strong class="kc hv"> <em class="ld">小于或等于</em> </strong> <code class="eh le lf lg lh b">n</code>，它返回<code class="eh le lf lg lh b">TRUE</code>，那么我们可以将<code class="eh le lf lg lh b">EQ</code>函数定义为</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="10e1" class="lq jd hu lh b fv lr ls l lt lu">EQ(m)(n) = AND (LEQ(m)(n)) (LEQ(m)(n))</span></pre><p id="3f5a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">现在我们需要定义<code class="eh le lf lg lh b">LEQ</code>。</p><p id="20be" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">假设我们有两个函数，SUB和ISZERO，定义如下:</p><ul class=""><li id="4de6" class="ni nj hu kc b kd ky kh kz kl nk kp nl kt nm kx nn no np nq dt translated"><code class="eh le lf lg lh b">SUB(m)(n)</code>从<code class="eh le lf lg lh b">m</code>中减去<code class="eh le lf lg lh b">n</code>，这样，如果<code class="eh le lf lg lh b">n</code>大于<code class="eh le lf lg lh b">m</code>，结果总是<code class="eh le lf lg lh b">ZERO</code>，否则就是<code class="eh le lf lg lh b">m-n</code></li><li id="32cb" class="ni nj hu kc b kd nr kh ns kl nt kp nu kt nv kx nn no np nq dt translated">如果<code class="eh le lf lg lh b">n</code>是<code class="eh le lf lg lh b">ZERO</code>，则<code class="eh le lf lg lh b">ISZERO(n)</code>返回<code class="eh le lf lg lh b">TRUE</code>，否则返回<code class="eh le lf lg lh b">FALSE</code></li></ul><p id="01fd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们现在可以将<code class="eh le lf lg lh b">LEQ</code>表示为</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8a22" class="lq jd hu lh b fv lr ls l lt lu">LEQ(m)(n) = ISZERO(SUB(m)(n))</span></pre><p id="2e99" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">好了，我们现在只剩下定义<code class="eh le lf lg lh b">ISZERO</code>和<code class="eh le lf lg lh b">SUB</code>的问题了。</p><h2 id="6c43" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">检查数字是否为零</h2><p id="519c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh le lf lg lh b">ISZERO</code>是一个函数，它需要一个教堂编码的数字作为它的参数。教会编码的数字<code class="eh le lf lg lh b">n</code>本身就是一个二元函数，它是我们唯一被给予的东西，所以我们最好以某种方式使用它</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="8088" class="lq jd hu lh b fv lr ls l lt lu">ISZERO(n) = n(<strong class="lh hv">x</strong>)(<strong class="lh hv">y</strong>) // we need to find the right <strong class="lh hv">x</strong> and <strong class="lh hv">y</strong></span></pre><p id="fb32" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">先说<code class="eh le lf lg lh b">n</code>为<code class="eh le lf lg lh b">ZERO,</code>即<code class="eh le lf lg lh b">n = f =&gt; x =&gt; x</code>的情况。根据定义，<code class="eh le lf lg lh b">ZERO</code>总是返回第二个参数，因此<code class="eh le lf lg lh b"><strong class="kc hv">y</strong></code>必须是<code class="eh le lf lg lh b">TRUE</code>。</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="14c3" class="lq jd hu lh b fv lr ls l lt lu">ISZERO(n) = n(<strong class="lh hv">x</strong>)(TRUE) // we need to find the right <strong class="lh hv">x</strong> for n not ZERO</span></pre><p id="a940" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">现在我们来考虑一下<code class="eh le lf lg lh b">n = ONE</code>，也就是<code class="eh le lf lg lh b">n = f =&gt; x =&gt; f(x)</code>。在这种情况下，对于<code class="eh le lf lg lh b">x</code>的任何值，<code class="eh le lf lg lh b">f</code>必须始终返回<code class="eh le lf lg lh b">FALSE</code>。也就是说<code class="eh le lf lg lh b">f = x =&gt; FALSE</code>。</p><p id="c658" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">所以最终<code class="eh le lf lg lh b">ISZERO</code>是</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="0c5a" class="lq jd hu lh b fv lr ls l lt lu">ISZERO(n) = n(x =&gt; FALSE)(TRUE)</span></pre><p id="0a27" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们可以用下面的代码对此进行测试</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nw nx l"/></div></figure><h2 id="4180" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">从<code class="eh le lf lg lh b">m</code>中减去<code class="eh le lf lg lh b">n</code></h2><p id="0607" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如果我们有一个返回<code class="eh le lf lg lh b">n</code>的前任的函数<code class="eh le lf lg lh b">PRED(n)</code>，那么我们可以说从<code class="eh le lf lg lh b">m</code>中减去<code class="eh le lf lg lh b">n</code>相当于将n倍的<code class="eh le lf lg lh b">PRED</code>函数应用于<code class="eh le lf lg lh b">m</code>。但是，如果你还记得我们在介绍数字的教会编码时说过的话，<code class="eh le lf lg lh b"><strong class="kc hv"><em class="ld">n</em></strong></code>本身代表了函数<code class="eh le lf lg lh b">f</code>对参数<code class="eh le lf lg lh b">x</code> <strong class="kc hv"> <em class="ld"> n次</em> </strong>的应用。换句话说</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="e9d4" class="lq jd hu lh b fv lr ls l lt lu">SUB(m)(n) = n(PRED)(m)</span></pre><p id="6730" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">现在，让我们大胆地接受以下PRED的定义</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="6283" class="lq jd hu lh b fv lr ls l lt lu">const PRED = n =&gt; f =&gt; x =&gt; n(g =&gt; h =&gt; h(g(f)))(u =&gt; x)(u =&gt; u)</span></pre><p id="17df" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">感兴趣的，本文末尾有对<code class="eh le lf lg lh b">PRED</code>的解释。</p><h2 id="cd4b" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">n到m的总和</h2><p id="e29d" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">与我们如何构造<code class="eh le lf lg lh b">SUB</code>类似，我们可以使用后继函数来构造<code class="eh le lf lg lh b">SUM</code>,如下所示</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="ad01" class="lq jd hu lh b fv lr ls l lt lu">SUM(n)(m) = n(SUCC)(m)</span></pre><h1 id="2cd7" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">现在我们可以构建解决方案</h1><p id="b14d" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们还记得最初的问题吗？</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="9c1c" class="lq jd hu lh b fv lr ls l lt lu">if (n = m) {<br/>  return n + m;  // return the sum if n and m are equal<br/>} else {<br/>  return n — m;  // return the difference if not equal<br/>}</span></pre><p id="5bd4" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">现在我们有了所有的工具来解决这个问题</p><blockquote class="lv"><p id="1a87" class="lw lx hu bd ly lz ma mb mc md me kx ek translated">我们只有功能..</p></blockquote><p id="fb8d" class="pw-post-body-paragraph ka kb hu kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx hn dt translated">看看这个</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="1faa" class="lq jd hu lh b fv lr ls l lt lu">EQ(n)(m)      // returns TRUE if n and m are equal, FALSE otherwise<br/>(SUM(n)(m))   // argument picked if EQ returns TRUE<br/>(SUB(n)(m))   // argument picked if EQ returns FALSE</span></pre><p id="1e47" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这正是我们问题的解决方案，运行下面的代码可以证明这一点</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nw nx l"/></div></figure><p id="835e" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">更多细节和测试可以在<a class="ae mx" href="https://github.com/EnricoPicci/lambda-calculus-typescript/blob/master/examples/problem-solution.ts" rel="noopener ugc nofollow" target="_blank">报告</a>中看到。</p><p id="d674" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">顺便说一下，如果我们替换掉<code class="eh le lf lg lh b">EQ</code> <code class="eh le lf lg lh b">SUM</code> <code class="eh le lf lg lh b">SUB</code>和所有其他我们为了方便而添加的定义，我们的解决方案的代码是这样的</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nw nx l"/></div><figcaption class="ne nf fg fe ff ng nh bd b be z ek">Solution code showing only anonymous functions</figcaption></figure><h1 id="8290" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">最后:函数式程序员有什么好处？</h1><p id="b91c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们一直在玩函数。我们已经定义了它们，将它们作为参数传递，期望作为参数，评估它们。在我们的法典中，他们被视为一等公民，这一点我们已经越来越熟悉了。</p><p id="1cf8" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们已经做了一些练习，这些练习帮助我们理解了在函数式编程方法中使用函数的动力学和力学。</p><p id="0fb0" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">例如，如果我们看到这个</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="af74" class="lq jd hu lh b fv lr ls l lt lu">FLIP = f =&gt; a =&gt; b =&gt; f(b)(a)</span></pre><p id="ad61" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们理解是使用<code class="eh le lf lg lh b">f</code>的一种方式，参数顺序颠倒。并且可以在<strong class="kc hv"> lodash </strong>和<strong class="kc hv"> rambda </strong>库中找到FLIP等价物。FP库实现的其他魔法现在应该更清楚了。如果是这样，我们就达到了本文的目的。</p><h1 id="b1af" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">对于真正感兴趣的人:如何使用Pairs构建PRED函数</h1><p id="2aef" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这是什么？</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="b3d6" class="lq jd hu lh b fv lr ls l lt lu">x =&gt; y =&gt; f =&gt; f(x)(y)</span></pre><p id="b3f9" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这是一个<strong class="kc hv"> <em class="ld">对</em> </strong>，一个二维向量。，实际上这种方式编码一个<strong class="kc hv"> <em class="ld">对一个</em> </strong>同功能。</p><p id="0118" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">考虑以下情况</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="b44b" class="lq jd hu lh b fv lr ls l lt lu">const PAIR = x =&gt; y =&gt; f =&gt; f(x)(y);<br/>const myPair = PAIR(1)(2);</span></pre><p id="1385" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh le lf lg lh b">myPair</code>是一个包含<code class="eh le lf lg lh b">1</code>和<code class="eh le lf lg lh b">2</code>作为其不可变值的结构。我们只需要传递一个函数给<code class="eh le lf lg lh b">myPair</code>来指定我们想要用它的值做什么。</p><p id="31aa" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">可以使用符号<code class="eh le lf lg lh b"><strong class="kc hv">(n, m).</strong></code>定义一对<code class="eh le lf lg lh b">n</code>和<code class="eh le lf lg lh b">m</code></p><p id="870b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果我们想得到一个<strong class="kc hv"> <em class="ld">对</em> </strong>的第二个值，我们只需将FALSE函数传递给<strong class="kc hv"> <em class="ld">对</em> </strong></p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="5f1f" class="lq jd hu lh b fv lr ls l lt lu">SECOND = p =&gt; p(FALSE)    // where p is a <strong class="lh hv"><em class="ld">pair</em></strong></span></pre><p id="be2d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们可以用下面的代码进行测试</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="nw nx l"/></div></figure><p id="9d81" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">类似地，功能<code class="eh le lf lg lh b">FIRST</code>是</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="bb10" class="lq jd hu lh b fv lr ls l lt lu">FIRST = = p =&gt; p(TRUE)    // where p is a <strong class="lh hv"><em class="ld">pair</em></strong></span></pre><p id="ef19" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们现在可以定义另一个函数<code class="eh le lf lg lh b">PHI</code>，如下所示</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="0499" class="lq jd hu lh b fv lr ls l lt lu">PHI = p =&gt; PAIR(SECOND(p))(SUCCESSOR(SECOND(p)))  // p is a PAIR</span></pre><p id="d552" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">PHI将<strong class="kc hv"> <em class="ld">对</em> </strong> <code class="eh le lf lg lh b">(m, n)</code>转换成新的<strong class="kc hv"> <em class="ld">对</em> </strong> <code class="eh le lf lg lh b">(n, n + 1)</code>。</p><p id="ce8f" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">所以，</p><ul class=""><li id="ce31" class="ni nj hu kc b kd ky kh kz kl nk kp nl kt nm kx nn no np nq dt translated"><code class="eh le lf lg lh b">PHI(0,0)</code>回报<code class="eh le lf lg lh b">(0,1)</code></li><li id="0cb7" class="ni nj hu kc b kd nr kh ns kl nt kp nu kt nv kx nn no np nq dt translated"><code class="eh le lf lg lh b">PHI(PHI(0,0))</code>等于<code class="eh le lf lg lh b">PHI(0,1)</code>，返回<code class="eh le lf lg lh b">(1,2)</code></li><li id="07fd" class="ni nj hu kc b kd nr kh ns kl nt kp nu kt nv kx nn no np nq dt translated"><code class="eh le lf lg lh b">PHI(PHI(PHI(0,0)</code>等于<code class="eh le lf lg lh b">PHI(1,2)</code>，后者返回<code class="eh le lf lg lh b">(2,3)</code></li></ul><p id="bb8a" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">外推我们可以说<code class="eh le lf lg lh b">PHI</code>到<code class="eh le lf lg lh b">(0,0)</code>的<code class="eh le lf lg lh b">n</code>应用返回了<strong class="kc hv"> <em class="ld">对</em> </strong> <code class="eh le lf lg lh b">(n-1, n)</code>。这导致<code class="eh le lf lg lh b">PRED</code>的定义为</p><pre class="li lj lk ll fq lm lh ln lo aw lp dt"><span id="02c9" class="lq jd hu lh b fv lr ls l lt lu">PRED = n =&gt; FIRST(n(PHI)(PAIR(ZERO)(ZERO)))</span></pre><p id="cfeb" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">还有其他方法来构造PRED函数，但这可能是更自然的方法。</p><h2 id="a744" class="lq jd hu bd je mf my mh ji mi mz mk jm kl na mm jq kp nb mo ju kt nc mq jy mr dt translated">感谢</h2><p id="bfd2" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">本文从Gabriel Lebec(@ glebec)<a class="ae mx" href="https://www.youtube.com/watch?v=3VQ382QG-y4" rel="noopener ugc nofollow" target="_blank">“Lambda Calculus”</a>和<a class="ae mx" href="https://www.youtube.com/watch?v=pAnLQ9jwN-E" rel="noopener ugc nofollow" target="_blank">“一群函数”</a>的两个伟大演讲中获得灵感。我真的建议任何对这个论点感兴趣的人仔细看看。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff ny"><img src="../Images/2cf0f3fe1a5e75edecff4f3942f104d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:352/0*9vjvu18JIu7_n0FC"/></div></figure></div></div>    
</body>
</html>