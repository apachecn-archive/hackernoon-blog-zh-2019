<html>
<head>
<title>How we built an account creation popup for Google and Outlook OAuth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何为Google和Outlook OAuth创建一个帐户创建弹出窗口</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-we-use-a-popup-for-google-and-outlook-oauth-5d8c03652171?source=collection_archive---------24-----------------------#2019-04-25">https://medium.com/hackernoon/how-we-use-a-popup-for-google-and-outlook-oauth-5d8c03652171?source=collection_archive---------24-----------------------#2019-04-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c144a03b17b78c8295cfc759c5006d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xozKehKk3NjbSCdDRLH4oQ.jpeg"/></div></div></figure><p id="eea9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" href="https://leavemealone.xyz" rel="noopener ugc nofollow" target="_blank">别管我</a>我们使用谷歌和微软OAuth进行用户登录。为此，我们将用户重定向到相关的登录页面，用户输入他们的详细信息，然后被重定向回我们的站点并登录。一个不幸的结果是，我们的分析报告了大量来自“accounts.google.com”和“login.microsoft.com”的推荐流量。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/e4e50b72cedcf3e9822fa2c83fff8237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JjhBoM0sYSlgfUoD.jpg"/></div></div></figure><p id="7e8a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了解决这个问题，如果我们能为OAuth流打开一个新的窗口或弹出窗口，而不是重定向，会更好。此外，对于用户来说，这可能是比被重定向更好的体验。</p><p id="d500" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用<a class="ae ka" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">护照</a>进行身份验证，因此当用户登录后被引导回我们的应用程序时，URL包含一些我们需要的参数，包括我们用来在服务器上对他们进行身份验证的令牌。</p><p id="709c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们想要使用弹出窗口，所以在流程中间需要一个额外的步骤来捕获重定向、检索URL参数、关闭弹出窗口，并在打开的窗口(不是弹出窗口)中使用令牌。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/f361c489dfe3520cb83ed95e9c45c825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*6YpSBdB8H57mC2SD.png"/></div></div></figure><p id="e9bd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们允许用户使用Google和Outlook登录，两者的实现是相同的。为了便于阅读，这个例子将使用谷歌。</p><h1 id="d8be" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">步骤1:打开弹出窗口</h1><p id="9874" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">为了打开一个新窗口，我们使用<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/open" rel="noopener ugc nofollow" target="_blank"> Window.open() </a>和passport登录URL(在我们的例子中是/auth/google ),这将在一个新窗口中打开“登录让我和google独处”页面。我们还为窗口命名，并传递我们希望它拥有的<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Window_features" rel="noopener ugc nofollow" target="_blank">请求特性</a>。</p><p id="ce96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们分配窗口引用并记录以前的URL，这样，如果用户再次尝试单击登录按钮，即使是针对不同的提供商，也会使用或聚焦同一个窗口。我们不希望不同供应商的两个弹出窗口四处浮动，造成混乱。</p><p id="2edc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们为消息添加了一个事件监听器，因为popup将在完成后发送URL参数和auth token。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><p id="fbcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lm">为了让窗口作为弹出窗口而不是新标签打开，我们必须请求“menubar=no，toolbar=no”功能。</em></p><h1 id="b32e" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">步骤2:在弹出窗口中获取OAuth回调参数</h1><p id="9c41" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">当OAuth流完成时，Google将用户重定向到一个回调URL。通常，这将是一个执行Passport身份验证的服务器路由。由于验证是在弹出窗口中进行的，我们在应用程序中使用了一个页面，当加载时，该页面会获取搜索参数并将其发送给父页面。</p><p id="7caf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个回调页面使用一个<a class="ae ka" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank"> React使用效果钩子</a>，它在页面加载时执行。我们获取包含身份验证令牌的URL参数，并使用<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" rel="noopener ugc nofollow" target="_blank"> Window.postMessage() </a>将它们发送到打开的窗口(父窗口)。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><h1 id="1934" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">步骤3:验证用户并重定向到应用程序</h1><p id="50cf" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">OAuth流几乎完成了，弹出窗口现在关闭了，我们只需要在我们的服务器上验证用户。</p><p id="dec6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了安全起见，接收消息函数需要检查消息的来源，以确保它来自同一个域。在编写这段代码时，我们意识到几个Chrome开发工具使用的postMessage()来自同一个来源，所以我们在试图提取有效载荷之前也检查了源代码。</p><p id="ba68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们有了OAuth参数，我们就将用户重定向到我们自己的身份验证端点，这样我们就可以使用Passport进行身份验证和登录。</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="lk ll l"/></div></figure><h1 id="9630" class="kh ki hu bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le dt translated">完了！</h1><p id="e0e8" class="pw-post-body-paragraph jc jd hu je b jf lf jh ji jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz hn dt translated">这个过程非常简单，我们在这里所做的就是在OAuth流中添加一个中间步骤来传递回调参数。</p><p id="747c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">可能有很多实现方式，但对我们来说，使用<a class="ae ka" href="https://hackernoon.com/tagged/reactjs" rel="noopener ugc nofollow" target="_blank"> React.js </a>是最快最简单的。</p></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><p id="6065" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望这对您有所帮助，或者为您自己的解决方案提供一些灵感。</p><p id="fe58" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您有任何问题或建议，请告诉我们。</p></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><p id="47a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="lm">原载于2019年4月25日</em><a class="ae ka" href="https://blog.squarecat.io/how-to-oauth-popup/" rel="noopener ugc nofollow" target="_blank"><em class="lm">https://blog . squarecat . io</em></a><em class="lm">。</em></p></div></div>    
</body>
</html>