<html>
<head>
<title>Design Patterns: Strategy Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:JavaScript中的策略模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/design-patterns-strategy-pattern-in-javascript-59ce8e5310f9?source=collection_archive---------15-----------------------#2019-02-22">https://medium.com/hackernoon/design-patterns-strategy-pattern-in-javascript-59ce8e5310f9?source=collection_archive---------15-----------------------#2019-02-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c79e76a2c2a8f3d45b7acdfc0768a136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4IVZ5fyeTzLttgXj"/></div></div></figure><blockquote class="jc jd je"><p id="ffd9" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">原载于<a class="ae ke" href="https://carloscaballero.io/stategy-pattern-in-javascript-typescript/" rel="noopener ugc nofollow" target="_blank">www . carloscaballero . io</a>2019 . 2 . 22。</p></blockquote><p id="c650" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">有23种经典的设计模式，在原著<code class="eh ki kj kk kl b">Design Patterns: Elements of Reusable Object-Oriented Software</code>中有描述。模式为软件开发中重复出现的特定问题提供了解决方案。</p><p id="5c9b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在这篇文章中，我将描述<strong class="ji hv">战略模式</strong>如何运作，如何以及何时应用。这种模式在其他上下文中被称为<strong class="ji hv">策略</strong>。</p><h1 id="7808" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">战略模式:基本理念</h1><blockquote class="jc jd je"><p id="3386" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">策略模式是一种行为设计模式，支持在运行时选择算法——Wikipedia</p><p id="afa4" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="hu">定义一族算法，封装每一个，使它们可以互换。<br/>策略让算法独立于使用它的客户而变化——设计模式:可重用面向对象软件的元素</em></p></blockquote><p id="bd14" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这种模式的主要特点是客户端有一组算法，在运行时会选择一个特定的算法来使用。这种算法在它们之间是可以互换的。</p><p id="4ddd" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">下面的代码展示了一个经典的问题，你需要在你的应用程序中选择一个具体的算法。在这段代码中，您可以使用任何编程语言的<code class="eh ki kj kk kl b">switch</code>控制结构。</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lk"><img src="../Images/fbefdcc6ba8e8543a53d4773afbfdb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5A630f-SdUSmvi9spwlcQ.png"/></div></div></figure><p id="ebc5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">然而，使用以下结构的<strong class="ji hv">策略模式</strong>可以更加灵活:</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/4b540e99d308fab3ecd9d380616e09bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylQXwu5N2_xMyovvLrGbDQ.png"/></div></div></figure><p id="8338" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这个模式的UML图表如下:</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/df89149c7b82a69454c1ece363b48ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/0*lf4m6tymXqUx28wf.png"/></div></figure><p id="0515" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">每种策略都用一个具体的对象来表示。因此，客户端/上下文包含一个实现in接口<code class="eh ki kj kk kl b">Strategy</code>的<code class="eh ki kj kk kl b">Strategy</code>对象(<code class="eh ki kj kk kl b">concreteStrategyA</code>、<code class="eh ki kj kk kl b">concreteStrategyB</code>、…)。策略之间互换的关键在于在改变策略的上下文中实现一个方法，例如<code class="eh ki kj kk kl b">setStrategy</code>。</p><h1 id="d5d8" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">策略模式:何时使用</h1><ol class=""><li id="6253" class="lr ls hu ji b jj lt jn lu kf lv kg lw kh lx kd ly lz ma mb dt translated">解决策略模式的问题是当你需要使用几个具有不同变量的算法时。这时，你需要创建一个具体的类来实现你的算法(可以包含在一个或几个函数中)。</li><li id="d284" class="lr ls hu ji b jj mc jn md kf me kg mf kh mg kd ly lz ma mb dt translated">另一个需要这种模式的有趣时刻是，在一些算法之间存在相关的条件语句。</li><li id="8ad5" class="lr ls hu ji b jj mc jn md kf me kg mf kh mg kd ly lz ma mb dt translated">最后，当你的大多数类都有相关行为时，你必须使用这种模式。</li></ol><h1 id="f640" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">战略模式:优势</h1><p id="1e7d" class="pw-post-body-paragraph jf jg hu ji b jj lt jl jm jn lu jp jq kf mh jt ju kg mi jx jy kh mj kb kc kd hn dt translated">这种战略模式有几个优点，可以总结为以下几点:</p><ul class=""><li id="fe76" class="lr ls hu ji b jj jk jn jo kf mk kg ml kh mm kd mn lz ma mb dt translated">在运行时，在不同的算法(策略)之间切换很容易，因为你使用了接口的多态性。</li><li id="d626" class="lr ls hu ji b jj mc jn md kf me kg mf kh mg kd mn lz ma mb dt translated"><strong class="ji hv">清理代码</strong>因为你避免了条件感染代码(不复杂)。</li><li id="3e53" class="lr ls hu ji b jj mc jn md kf me kg mf kh mg kd mn lz ma mb dt translated"><strong class="ji hv">更干净的代码</strong>因为您将关注点分成了类(每个策略一个类)。</li></ul><h1 id="97fc" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">策略模式:使用JavaScript的基本实现</h1><p id="8db9" class="pw-post-body-paragraph jf jg hu ji b jj lt jl jm jn lu jp jq kf mh jt ju kg mi jx jy kh mj kb kc kd hn dt translated">现在，我将向您展示如何使用Javascript实现这种模式，您必须记住JavaScript缺乏接口。所以，你需要编写一个名为<code class="eh ki kj kk kl b">StrategyManager</code>的类作为接口:</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mo"><img src="../Images/7fa0d383568a942be4bd278696ab17d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpJRH4zWIiV_8nJPk9bGeA.png"/></div></div></figure><p id="20a7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这个类包含一个名为<code class="eh ki kj kk kl b">_strategy</code>的私有属性，它表示此时将使用的策略。方法<code class="eh ki kj kk kl b">doAction</code>是将在每个具体战略中实施的方法。JavaScript中的策略模式不同于UML，因为这种语言缺乏面向对象的特性。</p><p id="0f5b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">每个具体策略的实施如下:</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/08770f44f8bfda182f83a313db3f0448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Voqxi_w_meR2p66B7vjkQ.png"/></div></div></figure><p id="4ac7" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">注意，具体方法<code class="eh ki kj kk kl b">doAction</code>是在每个具体策略中实现的。</p><p id="702c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最后，context/client必须包含<code class="eh ki kj kk kl b">StrategyManager</code>(或者策略接口是面向对象语言)才能使用具体的策略:</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/a5c63d0b921e3ba0d31beb1b5a5363ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmbKNVXNMGna9XfUUZ1eqw.png"/></div></div></figure><h1 id="7885" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">策略模式:使用JavaScript的一组策略</h1><p id="9f58" class="pw-post-body-paragraph jf jg hu ji b jj lt jl jm jn lu jp jq kf mh jt ju kg mi jx jy kh mj kb kc kd hn dt translated">在下面的实现中，我们的<code class="eh ki kj kk kl b">StrategyManager</code>可以更复杂，包含一系列算法。在这种情况下，您可以更改属性<code class="eh ki kj kk kl b">_strategy</code>，而不是名为<code class="eh ki kj kk kl b">_strategies</code>的数组。</p><p id="bda1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最后，您可以使用方法<code class="eh ki kj kk kl b">addStrategy</code>在我们的策略列表中添加新策略。<code class="eh ki kj kk kl b">Strategy</code>类有两个属性:1)策略的名称；2)算法(名为<code class="eh ki kj kk kl b">handler</code>)。方法<code class="eh ki kj kk kl b">doAction</code>用于调用具体的算法。</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/cb2375a6a37281d68a2974c9768f05f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOmv-EZCac0EHmNsovJMHg.png"/></div></div></figure><p id="330a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最后，我们使用具体策略的客户端/上下文代码如下:</p><figure class="ll lm ln lo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/6f71d8844f3ef7679202bc7b4be83460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQpysk2SCx_FANWYMWSBGg.png"/></div></div></figure><p id="f9cc" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">第一部分是创建具体的策略(可以使用<strong class="ji hv"> Singleton </strong>模式和<strong class="ji hv"> Factory </strong>模式构建)并添加到我们的<strong class="ji hv"> strategyManager </strong>(可以是我们的接口)。客户端的下一部分是选择要使用的策略，可以使用我们应用程序中的<strong class="ji hv"> GUI </strong>或<strong class="ji hv"> CLI </strong>选择该策略。</p><p id="c7d5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最后，您可以注意到，如果选择了不支持的策略，系统会返回一个错误。当您想要为您的系统提供高级算法时，可以使用这种方法。</p><h1 id="12a4" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">结论</h1><p id="f5e7" class="pw-post-body-paragraph jf jg hu ji b jj lt jl jm jn lu jp jq kf mh jt ju kg mi jx jy kh mj kb kc kd hn dt translated"><strong class="ji hv">策略模式</strong>是一种在需要选择具体算法时可以避免代码复杂的模式。在这篇文章中，你可以获得一个使用JavaScript语言的简单实现，它没有接口。如果你使用一种有接口的编程语言，你可以遵循这个模式的UML。</p><p id="936d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最重要的不是实现我给你展示的模式，而是你需要知道模式解决了什么问题，以及为什么你必须使用它，因为实现会因编程语言的不同而不同。</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="0191" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><em class="jh">原载于2019年2月22日</em><a class="ae ke" href="https://carloscaballero.io/stategy-pattern-in-javascript-typescript/" rel="noopener ugc nofollow" target="_blank"><em class="jh">www . carloscaballero . io</em></a><em class="jh">。</em></p></div></div>    
</body>
</html>