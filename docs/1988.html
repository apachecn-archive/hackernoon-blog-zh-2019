<html>
<head>
<title>Lower Your AWS Lambda Bill by Increasing Memory Size— yep!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过增加内存大小来降低AWS Lambda账单——没错！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/lower-your-aws-lambda-bill-by-increasing-memory-size-yep-e591ae499692?source=collection_archive---------0-----------------------#2019-03-26">https://medium.com/hackernoon/lower-your-aws-lambda-bill-by-increasing-memory-size-yep-e591ae499692?source=collection_archive---------0-----------------------#2019-03-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5a82571dbe30d1c0eebb22806ab4ebd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5IWzEdWYC1TTKgZA"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="jg">Photo by </em><a class="ae jh" href="https://unsplash.com/photos/LqKhnDzSF-8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">Joshua Sortino</em></a><em class="jg"> on </em><a class="ae jh" href="https://unsplash.com/search/photos/data-center?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">Unsplash</em></a></figcaption></figure><p id="73d1" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">当我们为Lambda函数指定内存大小时，AWS将按比例分配CPU。例如，256 MB功能的处理能力是128 MB功能的两倍。这看起来简单明了，但是…</p><blockquote class="kg"><p id="996f" class="kh ki hu bd kj kk kl km kn ko kp kf ek translated">我有这样一个问题:在Lambda上运行一个给定任务时，会有一个理想的内存大小来最小化成本吗？</p></blockquote><p id="1913" class="pw-post-body-paragraph ji jj hu jk b jl kq jn jo jp kr jr js jt ks jv jw jx kt jz ka kb ku kd ke kf hn dt translated">为了回答这个问题，我测试了在多种内存大小上运行的相同任务，以检查是否存在这样的成本/内存权衡最佳点。</p><h1 id="a7eb" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">基准Lambdas</h1><p id="eea5" class="pw-post-body-paragraph ji jj hu jk b jl lt jn jo jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">我创建了两个Lambda函数来运行这个测试:</p><ul class=""><li id="32df" class="ly lz hu jk b jl jm jp jq jt ma jx mb kb mc kf md me mf mg dt translated">斐波那契数列:生成一系列……你猜对了，斐波那契数列的基本代码！这只是一个低内存、CPU密集型的任务。</li><li id="a402" class="ly lz hu jk b jl mh jp mi jt mj jx mk kb ml kf md me mf mg dt translated"><strong class="jk hv">基准测试</strong>:多次调用斐波那契函数(或任何其他函数)，切换内存大小；最后，它会对结果进行平均，以确定哪个内存大小可以优化速度和成本。</li></ul><p id="a0ec" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果你想测试你自己的Lambdas，<a class="ae jh" href="https://github.com/byrro/awslambda-memory-tradeoff" rel="noopener ugc nofollow" target="_blank">代码是开源的</a>。下面给出的结果肯定会根据您测试的函数而有所不同，所以我鼓励您下载Benchmarker Lambda并亲自运行它。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/aa76420691f920b47cff5f9263625962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SewxONiODMnoFQFe"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="jg">Photo by </em><a class="ae jh" href="https://unsplash.com/photos/qwtCeJ5cLYs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">Stephen Dawson</em></a><em class="jg"> on </em><a class="ae jh" href="https://unsplash.com/search/photos/data-center?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="jg">Unsplash</em></a></figcaption></figure><h1 id="1d89" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">测试参数</h1><ul class=""><li id="7b60" class="ly lz hu jk b jl lt jp lu jt mr jx ms kb mt kf md me mf mg dt translated">AWS地区:美国东部-1(北弗吉尼亚)</li><li id="28aa" class="ly lz hu jk b jl mh jp mi jt mj jx mk kb ml kf md me mf mg dt translated">测试的内存大小:128、256、512、768、1024、1280、1536、1792、2048、2304、2560、2752、3008</li><li id="7918" class="ly lz hu jk b jl mh jp mi jt mj jx mk kb ml kf md me mf mg dt translated">对于每种内存大小，斐波那契被调用20次</li><li id="b76e" class="ly lz hu jk b jl mh jp mi jt mj jx mk kb ml kf md me mf mg dt translated">调用以10个并发请求为一批运行，以加快进程</li><li id="f6d1" class="ly lz hu jk b jl mh jp mi jt mj jx mk kb ml kf md me mf mg dt translated">每次调用时，Fibonacci函数都会构建前30个Fibonacci数的序列</li><li id="0c05" class="ly lz hu jk b jl mh jp mi jt mj jx mk kb ml kf md me mf mg dt translated">忽略冷启动以标准化持续时间结果</li></ul><h1 id="8a7a" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">试验结果</h1><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/c0378f4b2d43ca4e7de5c546018fa99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*ylagxmv_3AxdGU2h"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Average cost (USD) per million executions of the Fibonacci sequence builder (n=30)</figcaption></figure><p id="7802" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">成本方面最有利的地方是:</p><ul class=""><li id="c762" class="ly lz hu jk b jl jm jp jq jt ma jx mb kb mc kf md me mf mg dt translated">768 MB :这是我们在Lambda上能得到的最便宜的任务了；为什么128 MB不便宜？它需要更长的处理时间，长到足以使它的总成本更高！</li><li id="ee3d" class="ly lz hu jk b jl mh jp mi jt mj jx mk kb ml kf md me mf mg dt translated"><strong class="jk hv"> 2048 MB </strong>:虽然价格比768 MB高~3%，但运行速度快2.5倍；在某些情况下，多花点钱来加快处理速度可能是值得的。</li></ul><p id="2b1b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">举例来说，与128 MB相比，运行768 MB的任务花费更少，这是违反直觉的。这意味着在某些情况下，我们实际上可以通过增加内存大小来降低AWS账单。当然，在考虑改变设置时，我们需要知道我们的函数需要的最小内存是多少。有一些监控服务——比如<a class="ae jh" href="https://dashbird.io" rel="noopener ugc nofollow" target="_blank">dash bird</a>——可以更容易地分析Lambda内存使用情况，并为这种基准分析确定阈值。</p><p id="db43" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">内存容量越大，线斜率(上图)的急剧上升引起了我的注意。从那时起，有报道称——尽管不是官方的Lambda提供了两个内核。我的假设是处理能力在内核之间分配，由于我的工作只使用了一个内核，测试实际上是在惩罚双核功能设置。这是在未来的测试中需要更密切关注的事情，这项任务可以利用多个内核。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/1325a70efe866750312638d1953744dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*bI3gNQM65BbpZLw_"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Average duration (milliseconds) for running the Fibonacci sequence builder (n=30)</figcaption></figure><p id="428e" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在时长方面，上图看似没有什么惊喜，但我其实在结果中发现了一贯怪异的地方:<strong class="jk hv"> 2048 MB </strong>总是比<strong class="jk hv"> 2304 </strong>和<strong class="jk hv"> 2560 MB </strong>执行<em class="mv">快</em>，这是意料之外的。放大到最高内存大小，我们可以注意到差异。</p><figure class="mn mo mp mq fq iv fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/6061994986602fe5f057814def6bf896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/0*vM7wTMtAli7bi4qj"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Average duration (milliseconds) for running the Fibonacci sequence builder (n=30)</figcaption></figure><p id="9ee7" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这可能是可以忽略的，因为它代表大约2%的额外执行时间。尽管如此，如果我们运行这个函数数百万次，或者如果延迟非常重要，那么这些额外的毫秒可能是相关的。</p><p id="5692" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">很难准确理解哪些因素在产生这些意想不到的结果中发挥了作用。Lambda基础设施是一种黑箱。也许服务于每个请求的硬件有所不同，这将在我们的测试中引入一些不期望的可变性。底线是:如果你想优化Lambda的使用，以获得最快的执行速度或最低的成本，你应该明确地对你的函数进行基准测试。</p><p id="dfed" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我已经<a class="ae jh" href="https://github.com/byrro/awslambda-memory-tradeoff" rel="noopener ugc nofollow" target="_blank">发布了基准函数</a>，这样你就可以自己部署和测试你自己的Lambda函数。只需按照存储库自述文件中的说明进行操作。</p></div></div>    
</body>
</html>