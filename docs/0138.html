<html>
<head>
<title>How I Used My Programming Skills to Save Over 8 Hours of Writing Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何利用我的编程技能节省了8个多小时的写作时间</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-i-used-my-programming-skills-to-save-over-8-hours-of-writing-work-7aba154d4232?source=collection_archive---------1-----------------------#2019-01-07">https://medium.com/hackernoon/how-i-used-my-programming-skills-to-save-over-8-hours-of-writing-work-7aba154d4232?source=collection_archive---------1-----------------------#2019-01-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b0d049bf432fed44da9173aaf9349212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVzJTznRRfP1lM7AXe9yLw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/aiyBwbrWWlo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f23b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近在脸书<a class="ae jg" href="http://hackernoon.com/@davidsmooke" rel="noopener ugc nofollow" target="_blank">上，David Smooke</a>(hacker noon的首席执行官)发布了一篇文章，他在文章中列出了<a class="ae jg" href="https://hackernoon.com/dear-hacker-2018s-top-tech-stories-d1d76108bbec" rel="noopener ugc nofollow" target="_blank"> 2018年的顶级科技故事</a>。他还提到，如果有人希望列出一个类似的清单，比如说关于<em class="kf"> JavaScript </em>的清单，他会很乐意在<em class="kf"> Hackernoon </em>的首页上展示。</p><p id="9066" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在不断努力让更多人阅读我的作品的过程中，我不能错过这个机会，所以我立即开始计划如何列出这样一个清单。</p><p id="7963" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因为这一年即将结束，我的时间有限，所以我决定不用手动搜索帖子，而是使用我的网络搜索技能。</p><p id="c3a9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我相信学习如何制作这样一个刮刀可以是一个有用的练习，并作为一个有趣的案例研究。</p><p id="548b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你读过我写的关于<a class="ae jg" href="https://hackernoon.com/how-to-create-an-instagram-bot-with-node-js-a289185a7d6f" rel="noopener ugc nofollow" target="_blank">我如何创建instagram bot </a>的文章，那么你就会知道用<em class="kf"> Node.js </em>与网站互动的最佳方式是使用控制<em class="kf"> chromium </em>实例的<a class="ae jg" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank"> <em class="kf">木偶师</em> </a>库。这样我们就可以做任何潜在用户在网站上可以做的事情。</p><p id="b16e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是到存储库的<a class="ae jg" href="https://github.com/maciejcieslar/scraper-hackernoon" rel="noopener ugc nofollow" target="_blank">链接。</a></p><h1 id="f50d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">创建刮刀</h1><p id="1784" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">让我们用这个简单的助手创建一个<em class="kf">木偶师</em>的浏览器和页面:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="3541" class="ls kh hu lo b fv lt lu l lv lw">const createBrowser = async () =&gt; {<br/> const browser = await puppeteer.launch({ headless: true })<br/><br/> return async function getPage&lt;T&gt;(url: string, callback: (page: puppeteer.Page) =&gt; Promise&lt;T&gt;) {<br/>   const page = await browser.newPage()<br/><br/>   try {<br/>     await page.goto(url, { waitUntil: 'domcontentloaded' })<br/><br/>     page.on('console', (msg) =&gt; console.log(msg.text()))<br/><br/>     const result = await callback(page)<br/><br/>     await page.close()<br/><br/>     return result<br/>   } catch (e) {<br/>     await page.close()<br/><br/>     throw e<br/>   }<br/> }<br/>}</span></pre><p id="2d1e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在回调中使用页面，这样可以避免一遍又一遍地重复相同的代码。多亏了这个助手，我们不需要担心去一个给定的url，从<code class="eh lx ly lz lo b">page.evaluate</code>内部监听<em class="kf"> console.logs </em>，以及在一切完成后关闭页面。函数的结果将在一个承诺中返回，所以我们可以稍后再调用它，而不必在回调中使用结果。</p><h1 id="341b" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">来说说数据吧</h1><p id="5273" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">有一个<a class="ae jg" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank">网站</a>，在那里我们可以找到<em class="kf"> Hackernoon </em>发布的所有带有<em class="kf"> JavaScript </em>标签的文章。它们是按日期排序的，但有时会不知从哪里冒出一篇很早以前发表的文章，比如2016年，所以我们必须小心这一点。</p><p id="501f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以单独从这个帖子预览中提取所有需要的信息——而不需要在新标签页中打开帖子，这使我们的工作更加容易。</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/c443322e988d2096e9136635509c4f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VQF2ZtfccsfVgxIY.png"/></div></div></figure><p id="7a1a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面显示的框中，我们可以看到我们需要的所有数据:</p><ol class=""><li id="6a72" class="mb mc hu jj b jk jl jo jp js md jw me ka mf ke mg mh mi mj dt translated">作者姓名及其个人资料的url</li><li id="dbd7" class="mb mc hu jj b jk mk jo ml js mm jw mn ka mo ke mg mh mi mj dt translated">文章标题和url</li><li id="8276" class="mb mc hu jj b jk mk jo ml js mm jw mn ka mo ke mg mh mi mj dt translated">鼓掌次数</li><li id="e7b9" class="mb mc hu jj b jk mk jo ml js mm jw mn ka mo ke mg mh mi mj dt translated">读出时间</li><li id="92aa" class="mb mc hu jj b jk mk jo ml js mm jw mn ka mo ke mg mh mi mj dt translated">日期</li></ol><p id="64cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是一篇文章的界面:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="b135" class="ls kh hu lo b fv lt lu l lv lw">interface Article {<br/> articleUrl: string<br/> date: string<br/> claps: number<br/> articleTitle: string<br/> authorName: string<br/> authorUrl: string<br/> minRead: string<br/>}</span></pre><p id="b974" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<em class="kf">媒体</em>上有一个无限滚动，这意味着当我们向下滚动时，会加载更多的文章。如果我们要使用<em class="kf"> GET </em>请求来获取静态<em class="kf"> HTML </em>并使用诸如<em class="kf"> JSDOM </em>之类的库来解析它，那么获取那些文章将是不可能的，因为我们不能对静态<em class="kf"> HTML </em>使用scroll。这就是为什么在任何与网站的互动中，<em class="kf">木偶师</em>都是救命恩人。</p><p id="c650" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要获得我们可以使用的所有已加载的帖子:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="efd5" class="ls kh hu lo b fv lt lu l lv lw">Array.from(document.querySelectorAll('.postArticle'))<br/>         .slice(offset)<br/>         .map((post) =&gt; {})</span></pre><p id="17af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们可以将每篇文章作为选择器的上下文——我们现在要写<code class="eh lx ly lz lo b">post.querySelector</code>而不是写<code class="eh lx ly lz lo b">document.querySelector</code>。这样，我们可以将搜索限制在给定的post元素。</p><p id="3c88" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另外，请注意<code class="eh lx ly lz lo b">.slice(offset)</code>片段——因为我们是向下滚动而不是打开新页面，所以已经解析过的文章仍然在那里。当然，我们可以再次解析它们，但这不会真正有效。偏移量从0开始，每次我们删除一些文章时，我们都会将集合的长度添加到偏移量中。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="1582" class="ls kh hu lo b fv lt lu l lv lw">offset += scrapedArticles.length</span></pre><h1 id="11c1" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">抓取帖子的数据</h1><p id="b3eb" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在抓取数据时，最常见的错误是“无法读取null的属性‘text content’”。我们将创建一个简单的helper函数来防止我们试图获取一个不存在的元素的属性。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="2f15" class="ls kh hu lo b fv lt lu l lv lw">function safeGet&lt;T extends Element, K&gt;(<br/>  element: T,<br/>  callback: (element: T) =&gt; K,<br/>  fallbackValue = null,<br/>): K {<br/>  if (!element) {<br/>    return fallbackValue<br/>  }<br/><br/>  return callback(element)<br/>}</span></pre><p id="cecb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">只有当<code class="eh lx ly lz lo b">element</code>存在时<code class="eh lx ly lz lo b">safeGet</code>才会执行回调。现在让我们用它来访问保存我们感兴趣的数据的元素的属性。</p><h2 id="19e3" class="ls kh hu bd ki mp mq mr km ms mt mu kq js mv mw ku jw mx my ky ka mz na lc nb dt translated">文章发表的日期</h2><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="5fce" class="ls kh hu lo b fv lt lu l lv lw">const dateElement = post.querySelector('time')<br/>const date = safeGet(<br/>  dateElement,<br/>  (el) =&gt; new Date(el.dateTime).toUTCString(),<br/>  '',<br/>)</span></pre><p id="d6f9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果<code class="eh lx ly lz lo b">dateElement</code>发生了什么事情而没有被发现，我们的<code class="eh lx ly lz lo b">safeGet</code>将会防止错误。<code class="eh lx ly lz lo b">&lt;time&gt;</code>元素有一个名为<code class="eh lx ly lz lo b">dateTime</code>的属性，它保存文章发表日期的字符串表示。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="8398" class="ls kh hu lo b fv lt lu l lv lw">const authorDataElement = post.querySelector&lt;HTMLLinkElement&gt;(</span><span id="3767" class="ls kh hu lo b fv nc lu l lv lw">'.postMetaInline-authorLockup a[data-action="show-user-card"]',<br/>)<br/><br/>const { authorUrl, authorName } = safeGet(<br/>  authorDataElement,<br/>  (el) =&gt; {<br/>    return {<br/>      authorUrl: removeQueryFromURL(el.href),<br/>      authorName: el.textContent,<br/>    }<br/>  },<br/>  {},<br/>)</span></pre><p id="cd59" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个<code class="eh lx ly lz lo b">&lt;a&gt;</code>元素中，我们可以找到用户的个人资料URL和他/她的名字。</p><p id="116c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">此外，这里我们使用<code class="eh lx ly lz lo b">removeQueryFromURL</code>,因为作者的个人资料URL和帖子的URL在查询中都有这个奇怪的源参数，我们希望删除它:</p><p id="6f99" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://hackernoon.com/javascript-2018-top-20-hackernoon-articles-of-the-year-9975563216d1?source=---------1---------------------" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/JavaScript-2018-top-20-hacker noon-年度文章-9975563216d1？<strong class="jj hv">来源=——1——————</strong>——T10】</a></p><p id="8878" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">？</em>URL中的字符表示查询参数的开始，所以让我们简单地删除它后面的所有内容。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="9d2d" class="ls kh hu lo b fv lt lu l lv lw">const removeQueryFromURL = (url: string) =&gt; url.split('?').shift()</span></pre><p id="4506" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们在<em class="kf">拆分字符串？</em>并且只返回第一部分。</p><h2 id="50d5" class="ls kh hu bd ki mp mq mr km ms mt mu kq js mv mw ku jw mx my ky ka mz na lc nb dt translated">拍手</h2><p id="1f9b" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">在上面的示例帖子中，我们看到“鼓掌”的次数是204，这是准确的。然而，一旦数字超过1000，它们就会显示为1K、2K、2.5K。如果我们需要确切的拍手次数，这可能会是一个问题。在我们的用例中，这种舍入工作得很好。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="f6d2" class="ls kh hu lo b fv lt lu l lv lw">const clapsElement = post.querySelector('span &gt; button')<br/><br/>const claps = safeGet(<br/>  clapsElement,<br/>  (el) =&gt; {<br/>    const clapsString = el.textContent<br/><br/>    if (clapsString.endsWith('K')) {<br/>      return Number(clapsString.slice(0, -1)) * 1000<br/>    }<br/><br/>    return Number(clapsString)<br/>  },<br/>  0,<br/>)</span></pre><p id="dd9f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果掌声的字符串表示以K结尾，我们只需去掉K字母，然后乘以1000——非常简单。</p><h2 id="3e94" class="ls kh hu bd ki mp mq mr km ms mt mu kq js mv mw ku jw mx my ky ka mz na lc nb dt translated">文章的url和标题</h2><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="ca1b" class="ls kh hu lo b fv lt lu l lv lw">const articleTitleElement = post.querySelector('h3')<br/>const articleTitle = safeGet(<br/>  articleTitleElement,<br/>  (el) =&gt; el.textContent<br/>)</span><span id="448e" class="ls kh hu lo b fv nc lu l lv lw">const articleUrlElement = post.querySelector&lt;HTMLLinkElement&gt;(<br/>  '.postArticle-readMore a',<br/>)</span><span id="0488" class="ls kh hu lo b fv nc lu l lv lw">const articleUrl = safeGet(<br/>  articleUrlElement,<br/>  (el) =&gt; removeQueryFromURL(el.href)<br/>)</span></pre><p id="ab5a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，由于选择器是在<code class="eh lx ly lz lo b">post</code>上下文中使用的，我们不需要过于具体地描述它们的结构。</p><h2 id="df8d" class="ls kh hu bd ki mp mq mr km ms mt mu kq js mv mw ku jw mx my ky ka mz na lc nb dt translated">"最小读取"</h2><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="6031" class="ls kh hu lo b fv lt lu l lv lw">const minReadElement = post.querySelector&lt;HTMLSpanElement&gt;('span[title]')<br/>const minRead = safeGet(minReadElement, (el) =&gt; el.title)</span></pre><p id="f97d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里我们使用一个稍微不同的选择器:我们寻找一个包含<code class="eh lx ly lz lo b">data-title</code>属性的<code class="eh lx ly lz lo b">&lt;span&gt;</code>。</p><p id="6d61" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">注意:稍后我们将使用<code class="eh lx ly lz lo b">.title</code>属性，因此区分它们是很重要的。</p><p id="6fc2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好了，我们已经抓取了页面上当前显示的所有文章，但是我们如何滚动来加载更多的文章呢？</p><h1 id="7034" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">滚动以加载更多文章</h1><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="d345" class="ls kh hu lo b fv lt lu l lv lw"><em class="kf">// scroll to the bottom of the page</em><br/>await page.evaluate(() =&gt; {<br/>  window.scrollTo(0, document.body.scrollHeight)<br/>})<br/><br/><em class="kf">// wait to fetch the new articles</em><br/>await page.waitFor(7500)</span></pre><p id="bef4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将页面滚动到底部，等待7.5秒。这是一个“安全”的时间——文章可以在2秒钟内加载，但我们更希望确保所有帖子都已加载，而不是错过一些。如果时间是一个重要的因素，我们可能会在请求时设置一些拦截器，它会获取帖子并在完成后继续前进。</p><h1 id="84f4" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">何时结束刮擦</h1><p id="5db2" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">如果帖子按日期排序，我们可以在看到2017年的文章时停止抓取。然而，由于2018年的文章之间出现了一些奇怪的旧文章，我们不能这样做。我们能做的反而是把刮下来的文章筛选出2018年或以后发表的。如果得到的数组是空的，我们可以有把握地认为不再有我们感兴趣的文章了。在<code class="eh lx ly lz lo b">matchingArticles</code>我们保留2018年或之后发布的文章，在<code class="eh lx ly lz lo b">parsedArticles</code>我们只保留2018年发布的文章。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="29f6" class="ls kh hu lo b fv lt lu l lv lw">const matchingArticles = scrapedArticles.filter((article) =&gt; {<br/>  return article &amp;&amp; new Date(article.date).getFullYear() &gt;= 2018<br/>})<br/><br/>if (!matchingArticles.length) {<br/>  return articles<br/>}<br/><br/>const parsedArticles = matchingArticles.filter((article) =&gt; {<br/>  return new Date(article.date).getFullYear() === 2018<br/>})<br/><br/>articles = [...articles, ...parsedArticles]</span></pre><p id="138f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果<code class="eh lx ly lz lo b">matchingArticles</code>是空的，我们返回所有物品，从而结束刮擦。</p><h1 id="c373" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">把所有的放在一起</h1><p id="946e" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">下面是获取文章所需的全部代码:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="58c1" class="ls kh hu lo b fv lt lu l lv lw">const scrapArticles = async () =&gt; {<br/> const createPage = await createBrowser()<br/><br/> return createPage&lt;Article[]&gt;('https:<em class="kf">//hackernoon.com/tagged/javascript', async (page) =&gt; {</em><br/>   let articles: Article[] = []<br/>   let offset = 0<br/><br/>   while (true) {<br/>     console.log({ offset })<br/><br/>     const scrapedArticles: Article[] = await page.evaluate((offset) =&gt; {<br/>       function safeGet&lt;T extends Element, K&gt;(<br/>         element: T,<br/>         callback: (element: T) =&gt; K,<br/>         fallbackValue = null,<br/>       ): K {<br/>         if (!element) {<br/>           return fallbackValue<br/>         }<br/><br/>         return callback(element)<br/>       }<br/><br/>       const removeQueryFromURL = (url: string) =&gt; url.split('?').shift()<br/><br/>       return Array.from(document.querySelectorAll('.postArticle'))<br/>         .slice(offset)<br/>         .map((post) =&gt; {<br/>           try {<br/>             const dateElement = post.querySelector('time')<br/>             const date = safeGet(dateElement, (el) =&gt; new Date(el.dateTime).toUTCString(), '')<br/><br/>             const authorDataElement = post.querySelector&lt;HTMLLinkElement&gt;(<br/>               '.postMetaInline-authorLockup a[data-action="show-user-card"]',<br/>             )<br/><br/>             const { authorUrl, authorName } = safeGet(<br/>               authorDataElement,<br/>               (el) =&gt; {<br/>                 return {<br/>                   authorUrl: removeQueryFromURL(el.href),<br/>                   authorName: el.textContent,<br/>                 }<br/>               },<br/>               {},<br/>             )<br/><br/>             const clapsElement = post.querySelector('span &gt; button')<br/><br/>             const claps = safeGet(<br/>               clapsElement,<br/>               (el) =&gt; {<br/>                 const clapsString = el.textContent<br/><br/>                 if (clapsString.endsWith('K')) {<br/>                   return Number(clapsString.slice(0, -1)) * 1000<br/>                 }<br/><br/>                 return Number(clapsString)<br/>               },<br/>               0,<br/>             )<br/><br/>             const articleTitleElement = post.querySelector('h3')<br/>             const articleTitle = safeGet(articleTitleElement, (el) =&gt; el.textContent)<br/><br/>             const articleUrlElement = post.querySelector&lt;HTMLLinkElement&gt;(<br/>               '.postArticle-readMore a',<br/>             )<br/>             const articleUrl = safeGet(articleUrlElement, (el) =&gt; removeQueryFromURL(el.href))<br/><br/>             const minReadElement = post.querySelector&lt;HTMLSpanElement&gt;('span[title]')<br/>             const minRead = safeGet(minReadElement, (el) =&gt; el.title)<br/><br/>             return {<br/>               claps,<br/>               articleTitle,<br/>               articleUrl,<br/>               date,<br/>               authorUrl,<br/>               authorName,<br/>               minRead,<br/>             } as Article<br/>           } catch (e) {<br/>             console.log(e.message)<br/>             return null<br/>           }<br/>         })<br/>     }, offset)<br/><br/>     offset += scrapedArticles.length<br/><br/>     <em class="kf">// scroll to the bottom of the page</em><br/>     await page.evaluate(() =&gt; {<br/>       window.scrollTo(0, document.body.scrollHeight)<br/>     })<br/><br/>     <em class="kf">// wait to fetch the new articles</em><br/>     await page.waitFor(7500)<br/><br/>     const matchingArticles = scrapedArticles.filter((article) =&gt; {<br/>       return article &amp;&amp; new Date(article.date).getFullYear() &gt;= 2018<br/>     })<br/><br/>     if (!matchingArticles.length) {<br/>       return articles<br/>     }<br/><br/>     const parsedArticles = matchingArticles.filter((article) =&gt; {<br/>       return new Date(article.date).getFullYear() === 2018<br/>     })<br/><br/>     articles = [...articles, ...parsedArticles]<br/><br/>     console.log(articles[articles.length - 1])<br/>   }<br/> })<br/>}</span></pre><p id="0e8c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们以适当的格式保存数据之前，让我们按掌声降序排列文章:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="f69b" class="ls kh hu lo b fv lt lu l lv lw">const sortArticlesByClaps = (articles: Article[]) =&gt; {<br/>  return articles.sort(<br/>    (fArticle, sArticle) =&gt; sArticle.claps - fArticle.claps<br/>  )<br/>}</span></pre><p id="49cf" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们把文章输出到一个可读的格式，因为到目前为止它们只存在于我们计算机的内存中。</p><h1 id="e237" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">信息输出公式</h1><h2 id="c226" class="ls kh hu bd ki mp mq mr km ms mt mu kq js mv mw ku jw mx my ky ka mz na lc nb dt translated">JSON</h2><p id="5c16" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">我们可以使用<em class="kf"> JSON </em>格式将所有数据转储到一个文件中。以这种方式存储所有的文章可能在将来的某个时候会派上用场。</p><p id="3592" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">转换成<em class="kf"> JSON </em>格式可以归结为键入:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="2d13" class="ls kh hu lo b fv lt lu l lv lw">const jsonRepresentation = JSON.stringify(articles)</span></pre><p id="df9a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们现在可以停止使用文章的JSON表示，只是将我们认为属于那里的文章复制并粘贴到我们的列表中。但是，你可以想象，这也可以自动化。</p><h2 id="04b3" class="ls kh hu bd ki mp mq mr km ms mt mu kq js mv mw ku jw mx my ky ka mz na lc nb dt translated">超文本标记语言</h2><p id="f5bb" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">HTML 格式肯定会比手动复制JSON 格式的所有内容更容易从列表中复制和粘贴项目。</p><p id="cf90" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">大卫在他的<a class="ae jg" href="https://hackernoon.com/dear-hacker-2018s-top-tech-stories-d1d76108bbec" rel="noopener ugc nofollow" target="_blank">文章</a>中以如下方式列出了文章:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/8c92aee924061ac0704b1f8aa49a404b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G8a4bXiFgow6Oaou.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">David’s list format</figcaption></figure><p id="9f6e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们希望我们的列表是这样的格式。同样，我们可以使用<em class="kf">木偶师</em>来创建和操作<em class="kf"> HTML </em>元素，但是，由于我们使用的是<em class="kf"> HTML </em>，我们可以将值嵌入到字符串中——浏览器无论如何都会解析它们。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="3fd6" class="ls kh hu lo b fv lt lu l lv lw">const createHTMLRepresentation = async (articles: Article[]) =&gt; {<br/> const list = articles<br/>   .map((article) =&gt; {<br/>     return `<br/>       &lt;li&gt;<br/>         &lt;a href="${article.articleUrl}"&gt;${article.articleTitle}&lt;/a&gt; by<br/>         &lt;a href="${article.authorUrl}"&gt;${article.authorName}&lt;/a&gt;<br/>         [${article.minRead}] (${article.claps})<br/>       &lt;/li&gt;<br/>     `<br/>   })<br/>   .join('')<br/><br/> return `<br/>   &lt;!DOCTYPE html&gt;<br/>   &lt;html lang="en"&gt;<br/>     &lt;head&gt;<br/>       &lt;meta charset="UTF-8" /&gt;<br/>       &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>       &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;<br/>       &lt;title&gt;Articles&lt;/title&gt;<br/>     &lt;/head&gt;<br/>     &lt;body&gt;<br/>       &lt;ol&gt;<br/>         ${list}<br/>       &lt;/ol&gt;<br/>     &lt;/body&gt;<br/>   &lt;/html&gt;<br/> `<br/>}</span></pre><p id="4a8c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如你所看到的，我们只是对文章进行了<code class="eh lx ly lz lo b">.map()</code>处理，并返回一个包含我们喜欢的格式的数据的字符串。我们现在有了一个包含<code class="eh lx ly lz lo b">&lt;li&gt;</code>个元素的数组——每个元素代表一篇文章。现在我们只需要<code class="eh lx ly lz lo b">.join()</code>它们来创建一个字符串，并将它嵌入到一个简单的<em class="kf"> HTML5 </em>模板中。</p><h2 id="f932" class="ls kh hu bd ki mp mq mr km ms mt mu kq js mv mw ku jw mx my ky ka mz na lc nb dt translated">保存文件</h2><p id="c834" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">剩下要做的最后一件事是将表示保存在单独的文件中。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="e183" class="ls kh hu lo b fv lt lu l lv lw">const scrapedArticles = await scrapArticles()<br/>const articles = sortArticlesByClaps(scrapedArticles)<br/><br/>console.log(`Scrapped ${articles.length} articles.`)<br/><br/>const jsonRepresentation = JSON.stringify(articles)<br/>const htmlRepresentation = createHTMLRepresentation(articles)</span><span id="636d" class="ls kh hu lo b fv nc lu l lv lw">await Promise.all([<br/>  fs.writeFileAsync(jsonFilepath, jsonRepresentation),<br/>  fs.writeFileAsync(htmlFilepath, htmlRepresentation),<br/>])</span></pre><h1 id="3ac7" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">结果呢</h1><p id="72b4" class="pw-post-body-paragraph jh ji hu jj b jk le jm jn jo lf jq jr js lg ju jv jw lh jy jz ka li kc kd ke hn dt translated">根据scraper的数据，今年有894篇带有<em class="kf"> JavaScript </em>标签的文章发表在<em class="kf"> Hackernoon </em>上，平均每天2.45篇。</p><p id="74af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是HTML 文件的样子:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="b38d" class="ls kh hu lo b fv lt lu l lv lw">&lt;li&gt;<br/>  &lt;a href="https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5"&gt;I’m harvesting credit card numbers and passwords from your site. Here’s how.&lt;/a&gt; by<br/>  &lt;a href="https://hackernoon.com/@david.gilbertson"&gt;David Gilbertson&lt;/a&gt;<br/>  [10 min read] (222000)<br/>&lt;/li&gt;<br/><br/>&lt;li&gt;<br/>  &lt;a href="https://hackernoon.com/part-2-how-to-stop-me-harvesting-credit-card-numbers-and-passwords-from-your-site-844f739659b9"&gt;Part 2: How to stop me harvesting credit card numbers and passwords from your site&lt;/a&gt; by<br/>  &lt;a href="https://hackernoon.com/@david.gilbertson"&gt;David Gilbertson&lt;/a&gt;<br/>  [16 min read] (18300)<br/>&lt;/li&gt;<br/><br/>&lt;li&gt;<br/>  &lt;a href="https://hackernoon.com/javascript-2018-top-20-hackernoon-articles-of-the-year-9975563216d1"&gt;JAVASCRIPT 2018 — TOP 20 HACKERNOON ARTICLES OF THE YEAR&lt;/a&gt; by<br/>  &lt;a href="https://hackernoon.com/@maciejcieslar"&gt;Maciej Cieślar&lt;/a&gt;<br/>  [2 min read] (332)<br/>&lt;/li&gt;</span></pre><p id="af5f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">而现在的<em class="kf"> JSON </em>文件:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="dff1" class="ls kh hu lo b fv lt lu l lv lw">[<br/>    {<br/>    "claps": 222000,<br/>    "articleTitle": "I’m harvesting credit card numbers and passwords from your site. Here’s how.",<br/>    "articleUrl": "https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5",<br/>    "date": "Sat, 06 Jan 2018 08:48:50 GMT",<br/>    "authorUrl": "https://hackernoon.com/@david.gilbertson",<br/>    "authorName": "David Gilbertson",<br/>    "minRead": "10 min read"<br/>  },<br/>  {<br/>    "claps": 18300,<br/>    "articleTitle": "Part 2: How to stop me harvesting credit card numbers and passwords from your site",<br/>    "articleUrl": "https://hackernoon.com/part-2-how-to-stop-me-harvesting-credit-card-numbers-and-passwords-from-your-site-844f739659b9",<br/>    "date": "Sat, 27 Jan 2018 08:38:33 GMT",<br/>    "authorUrl": "https://hackernoon.com/@david.gilbertson",<br/>    "authorName": "David Gilbertson",<br/>    "minRead": "16 min read"<br/>  },<br/>  {<br/>    "claps": 218,<br/>    "articleTitle": "JAVASCRIPT 2018 -- TOP 20 HACKERNOON ARTICLES OF THE YEAR",<br/>    "articleUrl": "https://hackernoon.com/javascript-2018-top-20-hackernoon-articles-of-the-year-9975563216d1",<br/>    "date": "Sat, 29 Dec 2018 16:26:36 GMT",<br/>    "authorUrl": "https://hackernoon.com/@maciejcieslar",<br/>    "authorName": "Maciej Cieślar",<br/>    "minRead": "2 min read"<br/>  }<br/>]</span></pre><p id="878b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我可能已经为自己节省了7-8个小时，因为我发明了一个刮刀，它替我完成了所有单调乏味、令人麻木的工作。一旦完成了，剩下要做的就是回顾最热门的文章，并选择在文章中放些什么。创建代码需要大约一个小时，而手工复制和粘贴所有数据(更不用说同时保存为<em class="kf"> HTML </em>和<em class="kf"> JSON </em>格式)很容易需要更多时间。</p><p id="e70b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这里是第<a class="ae jg" href="https://hackernoon.com/javascript-2018-top-20-hackernoon-articles-of-the-year-9975563216d1" rel="noopener ugc nofollow" target="_blank">篇</a>，如果你有兴趣看看我选择放在列表中的内容。</p></div><div class="ab cl ne nf hc ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hn ho hp hq hr"><p id="5af4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">原载于2019年1月7日</em><a class="ae jg" href="https://www.mcieslar.com/how-i-used-my-programming-skills-to-save-8-hours-of-work" rel="noopener ugc nofollow" target="_blank"><em class="kf">【www.mcieslar.com】</em></a><em class="kf">。</em></p></div></div>    
</body>
</html>