# 魔术揭秘:打破 Swift 中的零合并运算符

> 原文：<https://medium.com/hackernoon/magic-trick-revealed-breaking-the-nil-coalescing-operator-in-swift-7f319e40e0bd>

![](img/f14261443e6e05f234057c0741a368dc.png)

# 什么是可选的？

这几乎是每位 swift 开发人员在开始工作时阅读的第一件事。让我们用一种更有趣更简短的方式来理解 optional，比如说你去购物，口袋里放着一个钱包。钱包里可以有点钱，也可以没有。如果你认为钱包是一个 ***可选的*** 变量，那么要么它有一些价值，要么根本没有价值。

在商店买东西之前，你会检查钱包里是否有钱。如果有钱，你会购买，否则你会跳过。这与 ***可选绑定*** 是同一个概念。但是如果你在买东西之前没有检查，那么如果钱包里没有现金，你可能会有麻烦。这个概念在 Swift 中被称为*。*

*因此，如果可选值为零，强制展开可能会导致不必要的崩溃。为了安全起见，您可以使用可选绑定。但是 Swift 也提供了一个更安全的选项，叫做***nil-coalescing operator***，它要求在应用于 nil 时返回一个额外的默认值。*

# *打破僵局:*

****零合并运算符(？？)*** 检查可选变量是否为零 ***(a？？b)*** 。如果为空，则返回默认值，否则返回可选的未包装值。让我们看看它在 swift 中是如何定义的*

*我们可以使用如下的操作符-*

*但是 ***有个小问题？？*** 定义。每当我们使用 nil-coalescing 操作符时，无论可选操作符是否有值，我们都必须计算默认值。默认值的计算可能是一个复杂的操作，也可能是一个从磁盘存储器中大量读取的操作。因此，我们希望在不需要的时候避免计算，因为它有时是开销。所以为了避免 read 操作，我们可以重写 ***？？*** 功能定义如下图-*

*因此，我们现在提供一个闭包类型 ***() - > U*** ，而不是直接提供类型*的默认值。所以现在 ***defaultValue*** 是一个 ***() - > U*** 类型的函数。 ***defaultValue*** 函数内的代码只能从 else 块中执行。上面的实现也有一个缺点，因为 ***defaultValue*** 是一个匿名函数，所以我们必须在花括号 ***({ })*** 内编写计算默认值的代码。**

**我们可以通过使用***auto close***类型属性从 ***defaultValue*** 闭包中去掉那些显式的花括号。该属性隐式地将任何参数转换为 ***？？*中的**操作符要求闭合。因此，我们可以提供与最初相同的接口，但不需要用户创建包装 defaultValue 参数的显式闭包。因此，Swift 标准库中使用的定义如下**

**现在看看上面使用的例子，我们已经从 ***defaultValue*** 函数中去掉了花括号，它的工作原理和我们每天为一个 ***零合并*** 操作符编写的一样。**

# **新的可选绑定:**

**因此，如果我们有一个可选的，我们可以通过使用可选绑定，保护块或强制解包来解包值。但是我们可以再补充一点。假设我们有一个如下定义的函数**

**在上面，如果 ***可选*** 没有值，那么我们简单地返回 nil，否则做一些计算。我们可以在 optional 上创建一个扩展来进行安全计算。**

*****稳妥地*** 函数取一个 ***变换*** 的类型***(Wrapped)->U***。如果 ***可选*** 不为零，则应用 ***变换*** ，否则 ***安全*** 函数返回零。**

**利用这个扩展，我们可以更紧凑、更通用地重新编写 ***add*** 函数。**

**因此，我们可以安全地将函数应用于任何可选的 Struct 或 Class 类型。**

**🙏🙏🙏感谢您的阅读！！🙏🙏🙏**