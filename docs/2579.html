<html>
<head>
<title>Serverless AppSync Plugin: Top 10 New Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器AppSync插件:十大新功能</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/serverless-appsync-plugin-top-10-new-features-3faaf6789480?source=collection_archive---------1-----------------------#2019-04-23">https://medium.com/hackernoon/serverless-appsync-plugin-top-10-new-features-3faaf6789480?source=collection_archive---------1-----------------------#2019-04-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8c8c95c8803f980d951ce8971088fb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YECmE-s_1XlOw5aXzOhPuQ.png"/></div></div></figure><p id="5b88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">如果你还不熟悉AppSync或插件，我们建议你先阅读下面的帖子:</em></p><blockquote class="kb kc kd"><p id="82cc" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">第1部分:<a class="ae kh" href="https://serverless.com/blog/running-scalable-reliable-graphql-endpoint-with-serverless/" rel="noopener ugc nofollow" target="_blank">简介:带API网关的GraphQL端点+ AWS Lambda </a> <br/>第2部分:<a class="ae kh" href="https://hackernoon.com/running-a-scalable-reliable-graphql-endpoint-with-serverless-24c3bb5acb43" rel="noopener ugc nofollow" target="_blank"> AppSync后端:AWS托管的GraphQL服务</a> <br/>第3部分:<a class="ae kh" href="https://hackernoon.com/running-a-scalable-reliable-graphql-endpoint-with-serverless-db16e42dc266" rel="noopener ugc nofollow" target="_blank"> AppSync前端:AWS托管的GraphQL服务</a> <br/>第4部分:无服务器AppSync插件:新特性(本博客)</p></blockquote><h1 id="004d" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">介绍</h1><p id="e331" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><a class="ae kh" href="https://aws.amazon.com/appsync/" rel="noopener ugc nofollow" target="_blank"> AWS AppSync </a>是一个完全托管的无服务器<a class="ae kh" href="http://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务，用于实时数据查询、同步、通信和离线编程功能。它非常适合快速构建可扩展的数据驱动的移动、web或企业应用程序，并且没有管理复杂基础架构的麻烦。</p><p id="00b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/" rel="noopener ugc nofollow" target="_blank">无服务器AppSync插件</a>允许您在工作站上本地开发和测试AppSync GraphQL API。您可以将该插件作为持续集成和持续部署(CI/CD)框架的一部分，在生产中自动部署您的GraphQL API。</p><p id="9817" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该插件建立在<a class="ae kh" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>之上，自去年2018年推出以来，获得了开源GraphQL社区的极大欢迎。到目前为止，我们已经发布了17个版本的插件，在GitHub上有450多颗星，65K+总npm下载量，45+贡献者帮助关闭了100+个公开的GitHub问题。甚至有一个<a class="ae kh" href="https://www.youtube.com/watch?v=eTUYqI_LCQ4" rel="noopener ugc nofollow" target="_blank"> youtube视频</a>展示了它的行动。开源社区在过去的几个月里做了大量的工作来改进这个插件的特性，我们已经收到了几十个请求。</p><blockquote class="ll"><p id="177b" class="lm ln hu bd lo lp lq lr ls lt lu jz ek translated">在本帖中，我们将概述在过去几个月中添加到这个插件中的一些重要特性…</p></blockquote><h1 id="ddb7" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt lv kv kw kx lw kz la lb lx ld le lf dt translated">什么是新的？</h1><h2 id="8b47" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">1) AppSync离线支持</h2><p id="7c01" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><em class="ka">你有没有梦想过通过在本地测试AppSync解析器来加快AppSync开发周期？</em></p><p id="fe35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">离线支持</strong>已经成为AppSync用户中反复出现的<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/114" rel="noopener ugc nofollow" target="_blank">讨论话题</a>，感谢<a class="ae kh" href="https://github.com/lightsofapollo" rel="noopener ugc nofollow" target="_blank"> James </a>和<a class="ae kh" href="https://github.com/aheissenberger" rel="noopener ugc nofollow" target="_blank"> Andreas </a>，你的梦想实现了！建立在AppSync插件之上的<a class="ae kh" href="https://github.com/ConduitVC/aws-utils/tree/master/packages/appsync-emulator-serverless" rel="noopener ugc nofollow" target="_blank"> AppSync模拟器</a>为您提供了在本地环境中测试和开发AppSync API的灵活性。现在，您不必在每次进行更改时都部署代码:)</p><p id="2379" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个<a class="ae kh" href="https://github.com/aheissenberger/serverless-appsync-offline" rel="noopener ugc nofollow" target="_blank">插件扩展</a>甚至会为你自动启动模拟器。</p><p id="4604" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">样本代码(</em> <a class="ae kh" href="https://github.com/serverless/serverless-graphql/blob/master/app-backend/appsync/dynamo/serverless.yml" rel="noopener ugc nofollow" target="_blank"> <em class="ka">参考</em> </a> <em class="ka"> ) </em></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="cc66" class="ly kj hu mr b fv mv mw l mx my">plugins:<br/>  - serverless-appsync-plugin<br/>  - serverless-dynamodb-local<br/>  - serverless-appsync-offline<br/>  - serverless-offline<br/><br/>custom:<br/>  appsync-offline:<br/>    port: 62222<br/>    dynamodb:<br/>      client:<br/>        endpoint: "http://localhost:8000"<br/>        region: localhost</span></pre><p id="44bc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用<code class="eh mz na nb mr b">serverless-offline</code>插件时可以自动触发<code class="eh mz na nb mr b">serverless appsync-offline start</code>命令。</p><h2 id="474f" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated"><strong class="ak"> 2)自动生成的角色和策略</strong></h2><p id="0c11" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><em class="ka">您是否曾经努力为您的数据源创建正确的IAM角色和策略？</em></p><p id="df2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为AppSync数据源创建、更新和管理IAM策略、语句和操作并不是一件容易的事情。最重要的是，它通常会向无服务器的yaml文件添加额外的样板代码。该插件现在通过根据数据源及其目标的类型为您生成IAM角色和策略来解决这个问题。</p><p id="83c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，一个lambda数据源将被自动分配一个策略，允许它执行目标lambda函数，一组给定的DynamoDB数据源将被授权执行目标表上的所有读/写操作。除此之外，使用新的iamRoleStatements配置，定制策略变得更加容易。</p><p id="d1ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">样本代码:</em></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="d4f4" class="ly kj hu mr b fv mv mw l mx my">dataSources:<br/>  - type: AMAZON_DYNAMODB<br/>    name: DynamoDBDataSource<br/>    description:<br/>    config:<br/>      tableName: myTable<br/>      #allow datasource to execute GetItem on "myTable"<br/>      iamRoleStatements:<br/>        - Effect: "Allow"<br/>          Action:<br/>            - "dynamodb:GetItem"<br/>          Resource:<br/>            - "arn:aws:dynamodb:{REGION}:{ACCOUNT_ID}:myTable"<br/>            - "arn:aws:dynamodb:{REGION}:{ACCOUNT_ID}:myTable/*"</span></pre><p id="715f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您想要对角色和策略进行更细粒度的控制，您仍然可以指定一个<code class="eh mz na nb mr b">serviceRoleArn</code>。当指定时，它将优先于<code class="eh mz na nb mr b">iamRoleStatements</code>使用。</p><blockquote class="kb kc kd"><p id="0dad" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/141" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/141</a></p></blockquote><h2 id="19a0" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">3) RDS数据源</h2><p id="17b5" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">DynamoDB很棒，但我真正需要的是一个好的老式关系数据库。支持吗？</p><p id="864e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AWS在2018年11月推出了<a class="ae kh" href="https://aws.amazon.com/blogs/mobile/aws-appsync-releases-pipeline-resolvers-aurora-serverless-support-delta-sync/" rel="noopener ugc nofollow" target="_blank">关系数据库支持</a>。它允许直接从数据源和映射模板访问运行在Aurora上的关系数据库，如MySQL。感谢<a class="ae kh" href="https://github.com/roznalex" rel="noopener ugc nofollow" target="_blank">Alex</a><strong class="je hv"/>问题的答案是<em class="ka">是的！</em>。你现在可以告别你的AWS Lambda函数，减少一些延迟和费用！</p><p id="57e8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">样本代码:</em></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="bc8c" class="ly kj hu mr b fv mv mw l mx my">- type: RELATIONAL_DATABASE<br/>  name: My relational DB resolver<br/>  config:<br/>    dbClusterIdentifier: { Ref: RDSCluster }<br/>    awsSecretStoreArn: { Ref: RDSClusterSecret }<br/>    databaseName: rds_db<br/>    schema: mysql</span></pre><p id="515b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如在前面的特性中所描述的，这个插件将为您自动生成rds数据源策略，除非您指定自定义的策略。</p><blockquote class="kb kc kd"><p id="f1ca" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/226" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/226</a></p></blockquote><h2 id="2235" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">4)管道解析器</h2><p id="b5f9" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><em class="ka">您是否期望最近推出的</em> <a class="ae kh" href="https://aws.amazon.com/blogs/mobile/aws-appsync-releases-pipeline-resolvers-aurora-serverless-support-delta-sync/" rel="noopener ugc nofollow" target="_blank"> <em class="ka">管道解析器</em> </a> <em class="ka">添加到此插件中？</em></p><p id="ddae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AWS在带有关系数据库的AppSync中引入了管道解析器。它们支持在单个GraphQL字段上按顺序对多个数据源执行一个或多个操作。这允许通过将代码组合到单个解析器中或者在多个解析器之间共享代码来编排动作。</p><p id="c3fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢<a class="ae kh" href="https://github.com/Foosballfan" rel="noopener ugc nofollow" target="_blank"> C K </a>，这个插件现在支持了。</p><p id="b54d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">样本代码:</em></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="eddb" class="ly kj hu mr b fv mv mw l mx my">custom:<br/>  appsync: <br/>    mappingTemplates:<br/>      - type: Query<br/>        field: testPipelineQuery<br/>        request: 'start.vtl'<br/>        response: 'common-response.vtl'<br/>        kind: PIPELINE<br/>        functions:<br/>          - authorizeFunction <br/>          - fetchDataFunction<br/>    functionConfigurations:<br/>      - dataSource: graphqlLambda<br/>        name: 'authorizeFunction'<br/>        request: './mapping-templates/authorize-request.vtl'<br/>        response: './mapping-templates/common-response.vtl'<br/>      - dataSource: dataTable<br/>        name: 'fetchDataFunction'<br/>        request: './mapping-templates/fetchData.vtl'<br/>        response: './mapping-templates/common-response.vtl'</span></pre><p id="179a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有关管道解析器以及如何使用它们的更多信息，请参考<a class="ae kh" href="https://docs.aws.amazon.com/appsync/latest/devguide/pipeline-resolvers.html" rel="noopener ugc nofollow" target="_blank"> AWS文档</a>。</p><blockquote class="kb kc kd"><p id="f730" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/181" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/181</a></p></blockquote><h2 id="4d7a" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">5)多API支持</h2><p id="487b" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">你的项目需要不止一个GraphQL API吗？这是给你的！</p><p id="0bd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设您的项目中有两个API:一个用于公共访问(未经身份验证)，另一个使用自定义身份验证供内部使用。感谢<a class="ae kh" href="https://github.com/ZY-Ang" rel="noopener ugc nofollow" target="_blank">亚历克斯</a>,<code class="eh mz na nb mr b">appsync</code>config键现在支持接收一组对象，每个对象代表一个API的配置，这允许您在一个部署中部署多个AppSync GraphQL端点。</p><p id="4ef7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">样本代码:</em></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="2fa2" class="ly kj hu mr b fv mv mw l mx my">custom:<br/>  appsync:<br/>    - name: public-api<br/>      authenticationType: API_KEY<br/>      schema: public.graphql<br/>      # ...<br/>    - name: private-api<br/>      authenticationType: AMAZON_COGNITO_USER_POOLS<br/>      schema: private.graphql<br/>      # ...</span></pre><p id="966f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，在两个API之间共享资源没有任何限制，比如<em class="ka">映射模板</em>或<em class="ka">数据源</em>定义；或者甚至是模式定义，但是请记住，产生的AppSync APIs将是完全独立的，并部署在单个CF堆栈中。AWS Lambda函数、DynamoDB表等底层外部资源。可以由两个API共享。</p><blockquote class="kb kc kd"><p id="0c1c" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/155" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/155</a></p></blockquote><h2 id="077e" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">6) GraphQL模式拼接</h2><p id="3c98" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><em class="ka">因此，您的API正在增长，您有几十个查询、变化和订阅，这导致了巨大的monolith schema.graphql文件。</em></p><p id="287b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大文件对人不友好，很难阅读，维护起来可能是一场真正的噩梦。多亏了<a class="ae kh" href="https://github.com/trilliput" rel="noopener ugc nofollow" target="_blank"> Ilya </a>和模式拼接，您现在可以将您的模式分割成几个文件，并且它们会在您的AppSync API部署之前被合并。</p><p id="5e10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">样本代码:</em></p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="58cc" class="ly kj hu mr b fv mv mw l mx my">custom:<br/>  appSync:<br/>  schema:<br/>    - path/to/schema_base.graphql<br/>    - path/to/schema_internal.graphql</span></pre><blockquote class="kb kc kd"><p id="4c3f" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/227" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/227</a></p></blockquote><h2 id="068b" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">7)外部数据源和映射模板参考</h2><p id="cc16" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><em class="ka">如果您有一个大的graphql模式，那么很可能您也有巨大的数据源和映射模板配置文件……</em></p><p id="c397" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像您可以分割您的数据模式一样，您现在也可以将您的数据源和映射模板定义分割到单独的文件中。多亏了<a class="ae kh" href="https://github.com/lkhari" rel="noopener ugc nofollow" target="_blank">哈里</a>你现在可以这样做了:</p><p id="729e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在</strong>之前</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="797d" class="ly kj hu mr b fv mv mw l mx my">appSync:<br/>  datasources:<br/>    - type: AMAZON_DYNAMODB<br/>      name: posts<br/>      description: "Posts table datasource"<br/>      config:<br/>        tableName: posts<br/>    - type: AWS_LAMBDA<br/>      name: users<br/>      description: "Users lambda datasource"<br/>      config:<br/>        functionName: getUsers<br/>    - # a long list of datasources</span><span id="c7fd" class="ly kj hu mr b fv nc mw l mx my">mappingTemplates:<br/>    - dataSource: posts<br/>      type: Query<br/>      field: getPost<br/>      request: "Query.getPost.request.vtl"<br/>      response: "Query.getPost.response.vtl"<br/>    - dataSource: users<br/>      type: Query<br/>      field: getUsers<br/>      request: "Query.getUsers.request.vtl"<br/>      response: "Query.getUsers.response.vtl"<br/>    - # a long list of mapping templates</span></pre><p id="d2e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">后<strong class="je hv"/></p><p id="9fd2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只需将数据源和映射模板定义移动到单独的文件中，并按如下方式引用它们。</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="8d7d" class="ly kj hu mr b fv mv mw l mx my">appSync:<br/>  datasources:<br/>    - ${file(datasources/dynamodb.yml)}<br/>    - ${file(datasources/lambda.yml)}<br/>  mappingTemplates:<br/>    - ${file(mapping-templates/posts.yml)}<br/>    - ${file(mapping-templates/users.yml)}</span></pre><blockquote class="kb kc kd"><p id="f193" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PRs:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/216" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/216</a>和<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/182" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/182</a></p></blockquote><h2 id="e60c" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">8)简化的数据源功能配置</h2><p id="0d2a" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">还记得您不得不在数据源中手动引用您的函数ARN吗？现在有一种更简单的方法。</p><p id="8b79" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不再需要通过数据源配置中的ARN来引用AWS Lambda函数。从<code class="eh mz na nb mr b">functions</code>无服务器配置中提供功能的<em class="ka">键</em>要容易得多。该插件将自动为您解析该函数的ARNs。</p><p id="a3e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在</strong>之前</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="22b1" class="ly kj hu mr b fv mv mw l mx my">functions:<br/> getUser:<br/>  ...<br/>custom:<br/> appsync:<br/>  datasources:<br/>   - type: AWS_LAMBDA<br/>     name: myLambdaDatasource<br/>     config:<br/>      lambdaFunctionArn: {Fn::GetAtt: GetUserLambdaFunction, Arn]}</span></pre><p id="e52e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在</strong>之后</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="9545" class="ly kj hu mr b fv mv mw l mx my">functions:<br/>  getUser:<br/>    ...<br/>custom:<br/>  appsync:<br/>    datasources:<br/>      - type: AWS_LAMBDA<br/>        name: myLambdaDatasource<br/>        config:<br/>          functionName: getUser</span></pre><blockquote class="kb kc kd"><p id="542a" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/215" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/215</a></p></blockquote><h2 id="4c4f" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">9)映射模板的默认文件名约定</h2><p id="c966" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><em class="ka">您是否曾想进一步简化您的映射模板？我们现在又前进了一步……</em></p><p id="c61a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于有了<a class="ae kh" href="https://github.com/caki0915" rel="noopener ugc nofollow" target="_blank"> Carl-Johan </a>，您不需要显式地指定您的映射模板文件名。相反，您可以遵循以下命名约定:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="52a0" class="ly kj hu mr b fv mv mw l mx my">{Type}.{Field}.request.vtl # for mapping template requests<br/>{Type}.{Field}.response.vtl # for mapping template responses</span></pre><p id="d024" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在</strong>之前</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="37a3" class="ly kj hu mr b fv mv mw l mx my">mappingTemplates:<br/>  - field: getSomeData<br/>    dataSource: myDatasource<br/>    type: Query<br/>    request: getSomeData.request.vtl<br/>    response: getSomeData.response.vtl</span></pre><p id="6f13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在</strong>之后</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="b60f" class="ly kj hu mr b fv mv mw l mx my">mappingTemplates:<br/>  - field: getSomeData<br/>    dataSource: myDatasource<br/>    type: Query<br/>    #request: defaults to Query.getSomeData.request.vtl<br/>    #response: defaults to Query.getSomeData.response.vtl</span></pre><p id="c873" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">插件将继续在<em class="ka"> mapping-templates </em>文件夹中查找文件，或者从<em class="ka">mappingTemplatesLocation</em>配置中指定的路径中查找，但是使用默认名称。当然，仍然可以像以前一样指定一个自定义文件名。</p><blockquote class="kb kc kd"><p id="384d" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/206" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/206</a></p></blockquote><h2 id="6c17" class="ly kj hu bd kk lz ma mb ko mc md me ks jn mf mg kw jr mh mi la jv mj mk le ml dt translated">10)增强的堆栈输出</h2><p id="dbc1" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated"><em class="ka">我的端点URL是什么？什么是API密钥？部署后，您是否问过自己这些问题？厌倦了进入AppSync控制台解决问题吗？继续读！</em></p><p id="784a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在成功部署之后(或者在调用<a class="ae kh" href="https://serverless.com/framework/docs/providers/aws/cli-reference/info/" rel="noopener ugc nofollow" target="_blank"> sls info </a>之后)，插件现在将在<em class="ka">服务信息</em>部分中输出关于已部署堆栈的有意义的信息。这包括生成的API密钥(如果您使用API_KEY身份验证类型)和AppSync端点。看看这个:</p><pre class="mm mn mo mp fq mq mr ms mt aw mu dt"><span id="695c" class="ly kj hu mr b fv mv mw l mx my">Service Information<br/>-------------------<br/>service: blogs-api<br/>stage: dev<br/>region: us-east-1<br/>stack: blogs-api-dev<br/>resources: 42<br/>api keys:<br/>  None<br/>appsync api keys:<br/>  da2-xxxxxxxxxx<br/>endpoints:<br/>  None<br/>appsync endpoints:<br/>  <a class="ae kh" href="https://loh5g2cyy5bi7h7xkfsxsuhjlu.appsync-api.us-east-1.amazonaws.com/graphql" rel="noopener ugc nofollow" target="_blank">https://xxxxxxx.appsync-api.us-east-1.amazonaws.com/graphql</a></span></pre><blockquote class="kb kc kd"><p id="53db" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">PR:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/pull/215" rel="noopener ugc nofollow" target="_blank">https://github . com/sid 88 in/server less-app sync-plugin/pull/215</a></p></blockquote><h1 id="5425" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">下一步是什么？</h1><p id="8214" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">我们正在积极寻找这个插件的贡献者。请随时参与进来，提出您的想法、创意、缺陷修复或功能需求。敬请期待更多；)</p><h1 id="503b" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">特别感谢</h1><p id="edd0" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">感谢<a class="ae kh" href="https://github.com/sid88in" rel="noopener ugc nofollow" target="_blank"> Sid </a>创建了这个插件，并围绕它建立了一个开源社区；<a class="ae kh" href="https://github.com/lkhari" rel="noopener ugc nofollow" target="_blank">哈里</a>、<a class="ae kh" href="https://github.com/caki0915" rel="noopener ugc nofollow" target="_blank">卡尔-约翰</a>、<a class="ae kh" href="https://github.com/Foosballfan" rel="noopener ugc nofollow" target="_blank"> C </a> K、<a class="ae kh" href="https://github.com/ZY-Ang" rel="noopener ugc nofollow" target="_blank">亚历克斯·昂</a>、<a class="ae kh" href="https://github.com/roznalex" rel="noopener ugc nofollow" target="_blank">亚历克斯·罗兹</a>、<a class="ae kh" href="https://github.com/aheissenberger" rel="noopener ugc nofollow" target="_blank">安德里亚斯</a>、<a class="ae kh" href="https://github.com/trilliput" rel="noopener ugc nofollow" target="_blank">伊利亚</a>和<a class="ae kh" href="https://github.com/lightsofapollo" rel="noopener ugc nofollow" target="_blank">詹姆斯</a>，感谢他们帮助开发了本文中展示的特性，并感谢所有其他<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin/graphs/contributors" rel="noopener ugc nofollow" target="_blank">贡献者</a>让这个插件物有所值。最后但并非最不重要的是AWS AppSync团队，他们的不断支持和反馈使这一成功。</p><figure class="mm mn mo mp fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>