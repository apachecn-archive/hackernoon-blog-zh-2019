<html>
<head>
<title>Writing Testable Code. Main Rules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可测试的代码。主要规则</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-testable-code-main-rules-43188dee2cb3?source=collection_archive---------4-----------------------#2019-04-19">https://medium.com/hackernoon/writing-testable-code-main-rules-43188dee2cb3?source=collection_archive---------4-----------------------#2019-04-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ebaeaa432a8d24976ac615839312b31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrVeIQd89dZq7P7HtwnUlQ.jpeg"/></div></div></figure><p id="02de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个开发人员都知道可测试的代码可以让生活变得更简单。有很多关于单元测试的书籍和文章。测试驱动开发(TDD)作为高科技产品开发的最佳过程受到了特别的关注。在我的日常工作中，我面临着大量不可测试代码的问题。这甚至可能发生在那些100%测试覆盖率是主要验收标准的项目中。</p><p id="099e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我承认“好的代码”和“单元可测试的代码”并不总是等同的术语。您的代码可以是可理解的、自我记录的，但同时也是不可测试的。编写单元可测试代码有一个通用的技巧。你应该只使用干燥，亲吻和固体的原则，就像我在Dashdevs中做的那样。</p><p id="4d21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，开发人员可能会因为节省时间或者缺乏能力而忽略它们。无论如何，当你需要为一个根本不可测试的代码编写一个测试时，这种情况会比你希望的更频繁。</p><p id="7827" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">作为一名拥有6年以上经验的开发人员，我愿意分享我的生活经验和获得的可测试代码知识。在本文中，我将尝试列出最常见的问题和解决方法。进一步说，你可能会发现我的个人经验和C#、MsTest和Moq的源代码例子的挤压。经验是最好的老师，我们Dashdevs 喜欢分享如何在实践中学习。让我们为更好的代码而奔跑吧！</p><h1 id="2d25" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">操作员新建</h1><p id="61b9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在我看来，操作符new是你在等待单元测试的代码中可能遇到的最可怕的事情。这个操作符的值是可疑的，因为它的使用违反了SOLID中的依赖反转原则。</p><p id="1f38" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们参考一个简单的例子:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6ef8" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> <em class="ls">CertificateManager</em><br/>{<br/>    <strong class="lj hv">public void</strong> CreateCertificate(CertificateDto certificateDto)<br/>    {</span><span id="d96c" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="fc91" class="ln kc hu lj b fv lt lp l lq lr"><strong class="lj hv">        var</strong> certificate = <strong class="lj hv">new</strong> Certificate(certificateDto.Name, certificateDto.Url, certificateDto.Content);</span><span id="349f" class="ln kc hu lj b fv lt lp l lq lr">        certificate.Upload();<br/>    }<br/>}</span></pre><p id="b5a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种方法之所以不好，只有一个原因:它无法通过任何方式进行测试。</p><p id="f39b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它的存在只是为了调用Upload()。然而，我们不能创建模拟对象(mock)证书；因此，我们无法检查它是否真的被“调用”</p><p id="4201" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是不可能的。有三种方法可以解决这个问题。</p><ol class=""><li id="ef04" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated"><strong class="je hv">直白。</strong>我们可以将证书实例化委托给工厂方法。</li></ol><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="5b21" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> CertificateManager<br/>{<br/>    <strong class="lj hv">private</strong> CertificateCreator _certificateCreator;<br/> <br/>    <strong class="lj hv">public</strong> CertificateManager(CertificateCreator certificateCreator)<br/>    {<br/>         _certificateCreator = certificateCreator;<br/>    }<br/> <br/>    <strong class="lj hv">public void</strong> CreateCertificate(CertificateDto certificateDto)<br/>    {</span><span id="18aa" class="ln kc hu lj b fv lt lp l lq lr">            ...<br/> <br/>        <strong class="lj hv">var</strong> certificate = _certificateCreator.Create(certificateDto.Name, certificateDto.Url, certificateDto.Content);<br/> <br/>        сertificate.Upload();<br/>    }<br/>}</span></pre><p id="5e34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以创建_certificateCreator和证书本身的模拟。</p><p id="0ac3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点:</em> </strong> <em class="ls">它不改变代码结构。</em></p><p id="b3be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点:</em> </strong> <em class="ls">这种方法需要创建两个新类型。为了创建单元测试，我们将代码复杂化。很难理解使用fabric方法的原因。它可能导致违反单一责任原则(固体)。</em></p><p id="0883" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。将实例化移动到上层</strong>。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="b9f6" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> CertificateManager<br/>{<br/>    <strong class="lj hv">public void</strong> CreateCertificate(Certificate certificate)<br/>    {</span><span id="d870" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="cdd1" class="ln kc hu lj b fv lt lp l lq lr">        certificate.Upload();<br/>    }<br/>}</span></pre><p id="e65f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中，我们将Certificate作为一个参数发送，并可以模拟它。</p><p id="dd1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">利弊</em> </strong> <em class="ls">:我们简化一下方法。</em></p><p id="1d2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:需要改变代码的内部结构。这可能会导致问题，并要求为调用方法重写测试。这种重构需要更多的时间来实现。无论如何，这种方法是最好的，因为它总体上改进了应用程序的架构。</em></p><p id="6439" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3。将功能移至较低级别</strong>。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3af9" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> CertificateManagerpublic class CertificateManager<br/>{<br/>    <strong class="lj hv">private</strong> CertificateUploader _certificateUploader;<br/> <br/>    <strong class="lj hv">public</strong> CertificateManager(CertificateUploader certificateUploader)<br/>    {<br/>        _certificateUploader = certificateUploader;<br/>    }<br/> <br/>    <strong class="lj hv">public void</strong> CreateCertificate(CertificateDto certificateDto)<br/>    {</span><span id="f230" class="ln kc hu lj b fv lt lp l lq lr">            ...<br/> <br/>        <strong class="lj hv">var</strong> certificate = new Certificate(certificateDto.Name, certificateDto.Url, certificateDto.Content);<br/> <br/>        _certificateUploader.Upload(certificate);<br/>    }<br/>}</span></pre><p id="9c75" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个解决方案中，Certificate变成了一个平面模型，我们不需要模仿它。相反，我们模仿CertificateUploader。</p><p id="119e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点</em> </strong> <em class="ls">:不改变代码的结构，而是将证书转换为平面模型。</em></p><p id="93b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:测试创建过程变得更加复杂，因为我们需要检查_certificateUploader中的一个参数。按照模板上传。它看起来是这样的:</em></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="ea0f" class="ln kc hu lj b fv lo lp l lq lr">certificateUploader.Verify(x =&gt; x. Upload(<br/>    It.Is&lt;Certificate&gt;<br/>    (arg =&gt;<br/>        arg.Name == certificateDto.Name<br/>            &amp;&amp; arg.Url == certificateDto.Url<br/>            &amp;&amp; arg.Content == certificateDto.Content<br/>    )<br/>), Times.Once);</span></pre><p id="a91b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，这个类只有三个字段，这就是为什么这个类与一个模板的比较不是一个复杂的任务。但是，在实际项目中，一个类中可以有十个以上的属性。一些开发人员编写一些“半测试”来简化过程:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8a44" class="ln kc hu lj b fv lo lp l lq lr">certificateUploader.Verify(x =&gt; x. Upload(It.IsAny&lt;Certificate&gt;), Times.Once);</span></pre><p id="5aac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样的做法带来的利润很小。它检查调用的事实，但忽略参数的实例化。此外，模板的比较要求与模板相关的所有测试对象属性都是公共的。否则，我们需要拒绝完整的测试或者公开类属性的一部分，这会干扰封装。这就是为什么我不推荐使用这种方法，除非它的使用是非常必要的。</p><h1 id="3616" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">对对象属性的访问</h1><p id="4949" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这个问题几乎是看不见的，但它会引起一堆问题。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="5185" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public void</strong> ProcessCertificate(Certificate certificate)<br/>{</span><span id="8aab" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="0a88" class="ln kc hu lj b fv lt lp l lq lr">    <strong class="lj hv">var</strong> ownerName = certificate.Owner.Name;</span><span id="70d6" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="9f4c" class="ln kc hu lj b fv lt lp l lq lr">}</span></pre><p id="fdb9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会想“几乎没有”。是的，这是一个微小的细微差别。除非这个小问题把证书嘲讽的过程转化为令人难以置信的体验。为了解决NullReferenceException失败的问题，我们还需要模仿Owner。一般来说，设置对类属性或方法的多级访问是一种不好的做法。但是，如果您需要用这样的结构测试代码，您可以使用这些解决方案:</p><ol class=""><li id="3b11" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated">将取回财产的责任移交给上级。</li></ol><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="15c7" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public void</strong> ProcessCertificate(Certificate certificate, string ownerName)<br/>{</span><span id="432f" class="ln kc hu lj b fv lt lp l lq lr">    ...</span><span id="ca5b" class="ln kc hu lj b fv lt lp l lq lr">}</span></pre><p id="8a77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点</em> </strong> <em class="ls">:要求代码结构变化最小。</em></p><p id="dd43" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:通话看起来如下:</em></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0c6f" class="ln kc hu lj b fv lo lp l lq lr">_certificateManager.ProcessCertificate(certificate, certificate.Owner.Name);</span></pre><p id="15cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可能很难称之为一个好的解决方案。</p><p id="b534" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。类的扩展</strong>。</p><p id="d9a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给<strong class="je hv">证书</strong>添加一个属性或方法，负责多级访问。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="0cec" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public</strong> <strong class="lj hv">class</strong> Certificate<br/>{</span><span id="9c37" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="91a1" class="ln kc hu lj b fv lt lp l lq lr">    <strong class="lj hv">public</strong> <strong class="lj hv">virtual string</strong> OwnerName =&gt; <strong class="lj hv">this</strong>.Owner.Name;</span><span id="4d25" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="6b07" class="ln kc hu lj b fv lt lp l lq lr">}</span></pre><p id="e8ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="c7c2" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> Certificate<br/>{</span><span id="370f" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="1fea" class="ln kc hu lj b fv lt lp l lq lr">    <strong class="lj hv">public virtual string</strong> GetOwnerName()<br/>    {<br/>        return <strong class="lj hv">this</strong>.Owner.Name;<br/>    }</span><span id="1ba4" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="2911" class="ln kc hu lj b fv lt lp l lq lr">}</span></pre><p id="9732" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该方法将变成这样:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="28a6" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public void</strong> ProcessCertificate(Certificate certificate)<br/>{</span><span id="a8c7" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="4566" class="ln kc hu lj b fv lt lp l lq lr">    <strong class="lj hv">var</strong> ownerName = certificate.OwnerName;</span><span id="101a" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="e821" class="ln kc hu lj b fv lt lp l lq lr">}</span></pre><p id="234a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1f0f" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public void</strong> ProcessCertificate(Certificate certificate)<br/>{</span><span id="4b35" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="a986" class="ln kc hu lj b fv lt lp l lq lr">    <strong class="lj hv">var</strong> ownerName = certificate.GetOwnerName();</span><span id="42c2" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="f4d9" class="ln kc hu lj b fv lt lp l lq lr">}</span></pre><p id="f8f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相应地。</p><p id="6f99" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点</em> </strong> <em class="ls">:不需要改变代码的结构。</em></p><p id="a85b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:这种做法没有明显的缺点。但是，我们不应该在代码中添加一个与多级访问无关的属性或方法、逻辑。如果有逻辑，我们必须编写额外的测试来检查它。如果该类没有接口，重要的是不要忘记将新的属性或方法设置为虚拟的。</em></p><h1 id="3c0b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">静态</h1><p id="e546" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">静态的使用使你沉迷于模仿库(模仿者)。一些模仿者可以为静态类创建模仿(AFAIK大多数是付费的，但是你可以试着找一个免费的)。最好的解决方案是在代码中完全避免静态类和方法。但是这并不总是可能的，因为现在很多著名的框架仍然在使用它。如果您需要测试一个静态类，您可以用常规类包装它，并以通常的方式模拟它。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="bc53" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public static class</strong> StaticLegacy<br/>{<br/>    <strong class="lj hv">public static void</strong> StaticDo()<br/>    {</span><span id="2d3c" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="bfd4" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}<br/> <br/><strong class="lj hv">public interface</strong> ILegacyAdapter<br/>{<br/>    <strong class="lj hv">void</strong> Do();<br/>}<br/> <br/><strong class="lj hv">public class</strong> LegacyAdapter : ILegacyAdapter<br/>{<br/>    <strong class="lj hv">public void</strong> Do()<br/>    {<br/>        StaticLegacy.StaticDo();<br/>    }<br/>}</span></pre><p id="0770" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点</em> </strong> <em class="ls">:你很难找到一个，但是这种方法允许用静态调用来测试方法。</em></p><p id="42f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:我们将不得不为单元测试创建两个额外的类型。</em></p><h1 id="2fb2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">私有方法</h1><p id="6742" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">私有方法是封装的核心。然而，在单元测试创建期间，它们会成为一个真正令人头痛的问题。我完全不呼吁拒绝私有方法的使用，但是你在创建它们之前应该三思。如果私有方法只是公共方法的一部分，一切都很好。我们可以在公共方法的上下文中测试它。当几个公共方法共享一个私有方法时，问题就出现了。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="f2a1" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass: ISomeClass<br/>{<br/>    <strong class="lj hv">public void</strong> Do1()<br/>    {</span><span id="e13a" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="4dae" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="9f5d" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="7df0" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public void</strong> Do2()<br/>    {</span><span id="0eea" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="221a" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="5e0c" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="96b1" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">private void</strong> PrivateDo()<br/>    {</span><span id="bdb6" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="a02d" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><p id="b610" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以在两个公共方法的上下文中测试PrivateDo，但是这会导致重复的测试，因此，当改变PrivateDo时，工作会加倍(作为一种替代方法——单元测试结构的复杂化，这是不希望的)。您可以只在一个公共方法的上下文中测试PrivateDo，但是在这种情况下，另一个方法的单元测试失去了它的信息性:因为不清楚测试方法是自身出错还是只有它的私有部分出错。</p><ol class=""><li id="6c6f" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated"><strong class="je hv">把私有方法变成公有</strong>。</li></ol><p id="5c9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个解决方案允许我们直接测试这个方法。这种方法的严重缺点是违反了封装。我们面临的另一个问题是来自PrivateDo的Do1和Do2之间的依赖性。一些模仿器允许通过部分模仿(例如，nSubstitude)来解决这个问题，而另一些则没有部分模仿功能。</p><p id="8202" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，我们可以通过不向接口添加新打开的方法来减少负面影响。例如:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d61e" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public interface</strong> ISomeClass<br/>{<br/>    <strong class="lj hv">public void</strong> Do1();<br/> <br/>    <strong class="lj hv">public void</strong> Do2();<br/>}<br/> <br/><strong class="lj hv">public class</strong> SomeClass: ISomeClass<br/>{<br/>    <strong class="lj hv">public virtual void</strong> Do1()<br/>    {</span><span id="be55" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="ca9c" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="83d2" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="b163" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public virtual void</strong> Do2()<br/>    {</span><span id="1c3e" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="dd12" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="21ff" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="aee2" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public virtual void</strong> PrivateDo()<br/>    {</span><span id="de90" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="fb85" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><p id="7cab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，ISomeClass客户端不会知道PrivateDo。它允许我们避免非法使用。测试不会模拟接口ISomeClass，而是直接模拟某个类(因此，它的方法已经变成了虚拟的)。</p><p id="71ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。倒影</strong>。</p><p id="06a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">反射允许我们在不违反封装规则的情况下测试私有方法。然而，测试变得更加复杂，并且其执行速度降低。一些测试框架包括简化反射测试的适配器。例如，MsTest有一个特殊的类PrivateObject，它允许我们以这样的方式调用私有方法:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="2b79" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">var</strong> someClass = new SomeClass();<br/><strong class="lj hv">var</strong> obj = new PrivateObject(someClass);<br/>obj.Invoke(“PrivateDo”);</span></pre><p id="0612" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是PrivateDo的Do1和Do2之间的依赖关系问题不能用所选的方法解决。</p><p id="109b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3。搬出责任</strong>。</p><p id="38de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于私有方法，更明智的解决方案是将其作为另一个类的公共方法。例如:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="6056" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass: ISomeClass<br/>{<br/>    <strong class="lj hv">private</strong> IHelper _helper;<br/> <br/>    <strong class="lj hv">public</strong> SomeClass(IHelper helper)<br/>    {<br/>        _helper = helper;<br/>    }<br/> <br/>    <strong class="lj hv">public void</strong> Do1()<br/>    {</span><span id="0849" class="ln kc hu lj b fv lt lp l lq lr">                ...</span><span id="b799" class="ln kc hu lj b fv lt lp l lq lr">        _helper.Do();</span><span id="7cc8" class="ln kc hu lj b fv lt lp l lq lr">                ...</span><span id="2a9e" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public void</strong> Do2()<br/>    {</span><span id="08c7" class="ln kc hu lj b fv lt lp l lq lr">                ...</span><span id="0769" class="ln kc hu lj b fv lt lp l lq lr">           _helper.Do();</span><span id="f0b7" class="ln kc hu lj b fv lt lp l lq lr">                ...</span><span id="b575" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><p id="5779" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点</em> </strong> <em class="ls">:解决了私有方法测试的所有问题，减少了代码连接。</em></p><p id="9e5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:如果私有方法需要私有字段，将其移出到单独的类型会破坏封装。这是因为我们需要将私有字段作为参数发送。</em></p><p id="4bce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果私有方法改变了内部状态，这种解决方案是不可接受的。例如:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9586" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass: ISomeClass<br/>{<br/>    <strong class="lj hv">private string</strong> _privateString1;<br/> <br/>    <strong class="lj hv">private string</strong> _privateString2;<br/> <br/>    <strong class="lj hv">public void</strong> Do1()<br/>    {</span><span id="68db" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="891d" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="e166" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="b189" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public void</strong> Do2()<br/>    {</span><span id="d6f9" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="6436" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="d70e" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="9d97" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">private void</strong> PrivateDo()<br/>    {</span><span id="5382" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="0011" class="ln kc hu lj b fv lt lp l lq lr">        privateString1 = "qwe";<br/>        privateString2 = "asd";<br/> <br/>    }<br/>}</span></pre><p id="2278" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种特殊情况下，我们可以做一个小把戏。如果我们只保留状态变化的逻辑，但将所有其他部分移到单独的类中，我们可以在类中保存一个私有方法:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="55e0" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass: ISomeClass<br/>{<br/>    <strong class="lj hv">private string</strong> _privateString1;<br/> <br/>    <strong class="lj hv">private string</strong> _privateString2;<br/> <br/>    <strong class="lj hv">private</strong> IHelper _helper;<br/> <br/>    <strong class="lj hv">public</strong> SomeClass(IHelper helper)<br/>    {<br/>        _helper = helper;<br/>    }<br/> <br/>    <strong class="lj hv">public void</strong> Do1()<br/>    {</span><span id="e9c8" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="e469" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="2910" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="7403" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public void</strong> Do2()<br/>    {</span><span id="c779" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="fb0c" class="ln kc hu lj b fv lt lp l lq lr">        PrivateDo();</span><span id="2508" class="ln kc hu lj b fv lt lp l lq lr">            ...<br/>    }<br/> <br/>    <strong class="lj hv">private void</strong> PrivateDo()<br/>    {</span><span id="1a79" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="d99f" class="ln kc hu lj b fv lt lp l lq lr">        <strong class="lj hv">var</strong> result = _helper.Do();<br/> <br/>        privateString1 = result.String1;<br/>        privateString1 = result.String2;<br/>    }<br/>}</span></pre><h1 id="01c4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">没有接口的类</h1><p id="c7f1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们可以模仿没有接口的类。但是我们需要记住两件事。首先，这些类的方法必须是虚拟的。否则，您的模拟的一部分将作为模拟，另一部分作为原始对象。在这种情况下，缺乏适当的关注会导致低可追溯性的bug。修复这样一个错误可能会花费你额外的几个小时。一个例子:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="88eb" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass<br/>{<br/>    <strong class="lj hv">public virtual void</strong> Do1()<br/>    {</span><span id="e192" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="636c" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public virtual void</strong> Do2()<br/>    {</span><span id="ced2" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="7763" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public void</strong> Do3()<br/>    {</span><span id="f423" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="b0aa" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><p id="5738" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">模拟装置<strong class="je hv"> Do1 </strong>和<strong class="je hv"> Do2 </strong>将按照预期的方式工作。模拟方法Do3是无用的，因为它调用原始方法。</p><p id="b19c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">没有接口的类的第二个问题是构造函数。类的模拟需要存在默认构造函数(不带参数)。否则，您也需要创建参数模型。</p><p id="ad5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在某些情况下，构造函数包含逻辑。所以这个逻辑在所有模拟类的测试中都被调用。总的来说，这不是一个好方法。解决方案非常简单——所有被模仿的类都必须包含接口。这条规则没有例外。</p><p id="545a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">唯一的特例是没有接口的密封类。我们可以在一些框架中找到它们。默认情况下，它们是不可移除的。唯一的解决方案是创建一个包装器并模仿它。</p><h1 id="8f28" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构造函数中的逻辑</h1><p id="4b1f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">构造函数中的逻辑是一种众所周知的反模式。然而，很多开发人员使用它。这种方法有许多缺点。对我们来说最关键的是，每次测试都会反复调用构造函数逻辑。构造函数中的错误破坏了该类的所有测试。有两种方法可以避免这个问题。</p><ol class=""><li id="6b9a" class="lu lv hu je b jf jg jj jk jn lw jr lx jv ly jz lz ma mb mc dt translated"><strong class="je hv">方法初始化</strong>。</li></ol><p id="e8c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它将初始化过程分为两个独立的部分:对象创建(构造函数)和附加逻辑(Init())。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1dfb" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass<br/>{<br/>    <strong class="lj hv">public</strong> SomeClass(params)<br/>    {</span><span id="71bb" class="ln kc hu lj b fv lt lp l lq lr">         ...</span><span id="7f8e" class="ln kc hu lj b fv lt lp l lq lr">    }<br/> <br/>    <strong class="lj hv">public void</strong> Init()<br/>    {</span><span id="e886" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="9a2c" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><p id="9d89" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点</em> </strong> <em class="ls">:测试忽略Init方法以避免依赖于构造函数逻辑。</em></p><p id="50c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:在测试之外，这种方法非常糟糕。首先，因为它不明显。其次，它使IoC容器的设置复杂化，违反了SOLID的单一责任原则。</em></p><p id="9f3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不推荐使用初始化器，即使它们解决了构造函数的核心问题。</p><p id="5e39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。面料方法</strong>。</p><p id="7c5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实例化逻辑被移到一个单独的类中。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="15c1" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass<br/>{<br/>    <strong class="lj hv">public</strong> SomeClass(calculatedParams)<br/>    {</span><span id="1e6d" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="aab4" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}<br/> <br/>    <strong class="lj hv">public interface</strong> ISomeClassCreator<br/>    {<br/>        SomeClass Create(params);<br/>    }<br/> <br/><strong class="lj hv">public class</strong> SomeClassCreator: ISomeClassCreator<br/>{<br/>    <strong class="lj hv">public</strong> SomeClass Create(params)<br/>    {</span><span id="949e" class="ln kc hu lj b fv lt lp l lq lr">        ...</span><span id="7482" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><p id="f2ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">优点</em> </strong> <em class="ls">:可以摆脱繁重的构造函数，改善代码结构。</em></p><p id="ca64" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> <em class="ls">缺点</em> </strong> <em class="ls">:需要为测试创建两个特殊类型。此外，繁重的构造函数不仅仅是单元测试的问题。这就是为什么这种复杂化是合理的。</em></p><h1 id="82db" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">变量环境的使用</h1><p id="da6a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果该方法使用某个全局资源(例如，app.config中的设置),那么它的测试过程就变得非常重要。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="e071" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass<br/>{<br/>    <strong class="lj hv">public void</strong> Do()<br/>    {</span><span id="373a" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="0392" class="ln kc hu lj b fv lt lp l lq lr">        <strong class="lj hv">var</strong> mySetting = ConfigurationManager.AppSettings["MySetting"]</span><span id="3758" class="ln kc hu lj b fv lt lp l lq lr">            ...</span><span id="3782" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><p id="787d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">模拟ConfigurationManager的正确操作是一项复杂的任务。我们不能嘲笑它。我们可以为不同的测试创建不同的文件，但这可能是一个相当复杂的解决方案。一般来说，这种情况与静态对象相同。这就是为什么解决方案是相同的——创建一个包含环境变量的类并通过它工作:</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="7410" class="ln kc hu lj b fv lo lp l lq lr"><strong class="lj hv">public class</strong> SomeClass<br/>{<br/>    <strong class="lj hv">private</strong> Settings _settings;<br/> <br/>    <strong class="lj hv">public</strong> SomeClass(Settings setting)<br/>    {<br/>            _ settings = setting;<br/>    }<br/><br/>    <strong class="lj hv">public void</strong> Do()<br/>    {</span><span id="ac59" class="ln kc hu lj b fv lt lp l lq lr">                ...</span><span id="6fb7" class="ln kc hu lj b fv lt lp l lq lr">        <strong class="lj hv">var</strong> mySetting = settings.MySetting;</span><span id="9747" class="ln kc hu lj b fv lt lp l lq lr">                ...</span><span id="2c83" class="ln kc hu lj b fv lt lp l lq lr">    }<br/>}</span></pre><h1 id="18e1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="0dba" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">单元测试的支持增加了设计测试工作流时需要考虑的几个因素，但是努力会有回报的。</p><p id="77dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多编写可测试代码的最佳实践。我们的主要目标是创建一个每个人都可以维护的健壮的解决方案。即使你不打算写单元测试，你也需要使用这个指南，因为它会帮助你提高代码和架构的质量。这需要额外的时间，但这是值得的。</p><p id="103b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ls">在</em><a class="ae ka" href="https://www.dashdevs.com/#expertise" rel="noopener ugc nofollow" target="_blank"><em class="ls">dash devs</em></a><em class="ls">公司的经历中，我们有很多客户要求不要写单元测试的产品。毕竟，大多数客户意识到单元测试是稳定产品的保证。</em></p><p id="64a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ls">让我们用</em><a class="ae ka" href="https://www.dashdevs.com/#contacts" rel="noopener ugc nofollow" target="_blank"><em class="ls">dash devs</em></a><em class="ls">来讨论一下你的可靠产品开发的细微差别。</em></p></div></div>    
</body>
</html>