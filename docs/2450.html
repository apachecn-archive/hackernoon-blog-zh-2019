<html>
<head>
<title>Go Celebrity Spotting with the Twilio API for WhatsApp, AWS Rekognition and Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用WhatsApp、AWS Rekognition和Ruby的Twilio API寻找名人</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/go-celebrity-spotting-made-easy-with-the-twilio-api-for-whatsapp-aws-rekognition-and-ruby-48909dc14f52?source=collection_archive---------25-----------------------#2019-04-16">https://medium.com/hackernoon/go-celebrity-spotting-made-easy-with-the-twilio-api-for-whatsapp-aws-rekognition-and-ruby-48909dc14f52?source=collection_archive---------25-----------------------#2019-04-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5bcd681db64897fdbbcb96d116f89a25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OKKr2zoJQC93_i41Qz1Xxw.jpeg"/></div></div></figure><p id="45df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你知道你可以使用WhatsApp的<a class="ae ka" href="https://www.twilio.com/whatsapp" rel="noopener ugc nofollow" target="_blank">Twilio API</a>发送和接收媒体吗？当我发现我想用它做些有趣的事情时，为什么不把它和<a class="ae ka" href="https://aws.amazon.com/rekognition/" rel="noopener ugc nofollow" target="_blank"> AWS认知</a>结合起来，看看我看起来是否像任何名人？</p><p id="5e2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章结束时，你将知道如何构建一个应用程序，让你向WhatsApp号码发送图像，下载图像，用AWS Rekognition API分析图像，并回复说照片中是否有名人。</p><h1 id="1a14" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">你需要什么</h1><p id="4864" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">要构建这个应用程序，您需要一些东西:</p><ul class=""><li id="cb16" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">一个Twilio账户，<a class="ae ka" href="https://www.twilio.com/try-twilio" rel="noopener ugc nofollow" target="_blank">在这里注册一个免费账户</a></li><li id="b07f" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ka" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank">AWS账户</a></li><li id="0c9f" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ka" href="https://www.ruby-lang.org/en/downloads/" rel="noopener ugc nofollow" target="_blank">安装红宝石</a>和<a class="ae ka" href="https://bundler.io/" rel="noopener ugc nofollow" target="_blank">捆扎机</a></li><li id="b046" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ka" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>帮助我们<a class="ae ka" href="https://www.twilio.com/blog/2015/09/6-awesome-reasons-to-use-ngrok-when-testing-webhooks.html" rel="noopener ugc nofollow" target="_blank">测试我们的webhooks </a></li></ul><p id="a426" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">明白了吗？那我们开始吧。</p><h1 id="6e71" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">应用基础</h1><p id="e502" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当Twilio收到WhatsApp消息时，它会向我们提供的URL发送一个HTTP请求，一个<a class="ae ka" href="https://www.twilio.com/docs/glossary/what-is-a-webhook" rel="noopener ugc nofollow" target="_blank"> webhook </a>。我们需要构建一个应用程序来接收这些webhooks，使用AWS Rekognition服务处理图像，然后在对Twilio的响应中发送一条消息。</p><p id="3c19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为自己创建一个构建应用程序的目录，并使用bundler初始化一个新的<code class="eh ls lt lu lv b">Gemfile</code>:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="8486" class="me kc hu lv b fv mf mg l mh mi">mkdir celebrity-spotting<br/>cd celebrity-spotting<br/>bundle init</span></pre><p id="7695" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开<code class="eh ls lt lu lv b">Gemfile</code>并添加我们将用于该应用程序的宝石:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="c4d9" class="me kc hu lv b fv mf mg l mh mi"># frozen_string_literal: true<br/><br/>source "https://rubygems.org"<br/><br/>gem "sinatra", require: "sinatra/base"<br/>gem "aws-sdk"<br/>gem "envyable"<br/>gem "down"<br/>gem "twilio-ruby"</span></pre><p id="0db1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用<a class="ae ka" href="http://sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>作为web框架来接收来自Twilio的webhooks。我们将需要<a class="ae ka" href="https://github.com/aws/aws-sdk-ruby" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>来与Rekognition服务进行通信。<a class="ae ka" href="https://github.com/philnash/envyable" rel="noopener ugc nofollow" target="_blank">envable</a>是<a class="ae ka" href="https://www.twilio.com/blog/2015/02/managing-development-environment-variables-across-multiple-ruby-applications.html" rel="noopener ugc nofollow" target="_blank">在开发</a>的环境变量中存储我们的凭证。<a class="ae ka" href="https://github.com/janko/down" rel="noopener ugc nofollow" target="_blank"> Down </a>是一块宝石，使<a class="ae ka" href="https://www.twilio.com/blog/download-image-files-ruby" rel="noopener ugc nofollow" target="_blank">真正容易下载文件</a>。并且<a class="ae ka" href="https://www.twilio.com/docs/libraries/ruby" rel="noopener ugc nofollow" target="_blank"> twilio-ruby </a> gem将用于生成<a class="ae ka" href="https://www.twilio.com/docs/sms/twiml" rel="noopener ugc nofollow" target="_blank"> TwiML </a>以便我们可以在响应中向twilio发回信息。</p><p id="5e98" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行<code class="eh ls lt lu lv b">bundle install</code>来安装gems，然后创建这个应用程序需要的其他文件:<code class="eh ls lt lu lv b">app.rb</code>、<code class="eh ls lt lu lv b">config.ru</code>和<code class="eh ls lt lu lv b">config/env.yml</code>。准备工作已经完成，让我们开始构建应用程序。</p><h1 id="3b4a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构建应用程序</h1><p id="cb0c" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们将使用<code class="eh ls lt lu lv b">config.ru</code>来加载和运行应用程序。将以下代码添加到<code class="eh ls lt lu lv b">config.ru</code>:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="f381" class="me kc hu lv b fv mf mg l mh mi">require "bundler"<br/>Bundler.require<br/><br/>Envyable.load("./config/env.yml") unless ENV["RACK_ENV"] == "production"<br/><br/>require "./app.rb"<br/><br/>run CelebritySpotting</span></pre><p id="df6f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这需要在<code class="eh ls lt lu lv b">Gemfile</code>中定义的所有依赖项，使用<code class="eh ls lt lu lv b">Envyable</code>将我们的配置加载到环境中，然后加载并运行应用程序。接下来，让我们创建<code class="eh ls lt lu lv b">CelebritySpotting</code>应用程序。</p><p id="5838" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开<code class="eh ls lt lu lv b">app.rb</code>并创建一个新类:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="b9dd" class="me kc hu lv b fv mf mg l mh mi">class CelebritySpotting &lt; Sinatra::Base<br/><br/>end</span></pre><p id="0b2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要一个可以作为我们的webhook URL提供的端点路径。默认情况下，Twilio发出一个<code class="eh ls lt lu lv b">POST</code>请求，因此我们的端点将响应<code class="eh ls lt lu lv b">POST</code>请求:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="c1f4" class="me kc hu lv b fv mf mg l mh mi">class CelebritySpotting &lt; Sinatra::Base<br/>  post "/messages" do<br/><br/>  end<br/>end</span></pre><p id="dbcd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将返回TwiML，所以我们将创建一个新的<code class="eh ls lt lu lv b">Twilio::TwiML::MessagingResponse</code>并将内容类型头设置为<code class="eh ls lt lu lv b">application/xml</code>:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="d11a" class="me kc hu lv b fv mf mg l mh mi">class CelebritySpotting &lt; Sinatra::Base<br/>  post "/messages" do<br/>    content_type "application/xml"<br/>    twiml = Twilio::TwiML::MessagingResponse.new<br/>  end<br/>end</span></pre><p id="a983" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了确保目前为止这是可行的，让我们添加一条消息，将TwiML作为XML返回并测试它:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="a9e3" class="me kc hu lv b fv mf mg l mh mi">class CelebritySpotting &lt; Sinatra::Base<br/>  post "/messages" do<br/>    content_type "application/xml"<br/>    twiml = Twilio::TwiML::MessagingResponse.new<br/>    twiml.message body: "Hello! Just testing here."<br/>    twiml.to_xml<br/>  end<br/>end</span></pre><p id="bcd3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在命令行上使用以下命令启动应用程序:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="868b" class="me kc hu lv b fv mf mg l mh mi">bundle exec rackup</span></pre><p id="42d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">应用程序将于<code class="eh ls lt lu lv b">http://localhost:9292</code>开始。没有接口，所以我们可以使用<code class="eh ls lt lu lv b">curl</code>来测试它，看看它是否正常工作。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="913e" class="me kc hu lv b fv mf mg l mh mi">$ curl -d "" http://localhost:9292/messages<br/>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;Response&gt;<br/>&lt;Message&gt;Hello! Just testing here.&lt;/Message&gt;<br/>&lt;/Response&gt;</span></pre><p id="574b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以看到消息在TwiML中被返回，所以让我们把它连接到WhatsApp的Twilio API。</p><h1 id="e4ec" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">连接到WhatsApp的Twilio API</h1><p id="26b8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://www.twilio.com/docs/sms/whatsapp/api#twilio-sandbox-for-whatsapp" rel="noopener ugc nofollow" target="_blank"> Twilio提供了一个沙箱</a>来测试您的WhatsApp集成，而无需等待Twilio编号被WhatsApp批准。登录你的Twilio控制台，按照说明设置你的WhatsApp沙盒。</p><p id="ae15" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">设置好之后，你需要定义一个webhook URL，这样你就可以配置你的WhatsApp沙盒号了。</p><p id="0eeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的应用程序目前在我们自己的机器上运行，所以我们需要从公共互联网上下载，这就是ngrok的用武之地。通过运行以下命令启动ngrok:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="eca5" class="me kc hu lv b fv mf mg l mh mi">ngrok http 9292</span></pre><p id="e41a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">执行这个命令会给你一个类似于<code class="eh ls lt lu lv b">https://RANDOM_STRING.ngrok.io</code>的公共URL。获取那个ngrok URL，添加<code class="eh ls lt lu lv b">/messages</code>路径，并将其输入到WhatsApp沙盒设置中，作为当有消息从WhatsApp传来时调用的URL。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/832e4904b2ad9545278365090b638952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zygLsna-EY48aqOJRSxJrQ.png"/></div></div></figure><p id="287b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">保存WhatsApp沙盒的设置，并向沙盒号码发送消息。你应该会收到你的测试信息。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/c6dd4d66a7032709d6c900a371371da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Oqxp7rR3fnKEzek1yc_Syw.jpeg"/></div></figure><p id="0b80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们有WhatsApp连接，我们可以来回发送消息。这为使用包含的图像并使用AWS Rekognition对其进行分析奠定了基础。</p><h1 id="a74e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">接收和下载图像</h1><p id="e2c5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">之前我们在申请中加入了<code class="eh ls lt lu lv b">Down</code>宝石。我们将使用它来下载发送到我们的WhatsApp号码的图像。</p><p id="28f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到<code class="eh ls lt lu lv b">app.rb</code>,我们将测试我们收到的消息是否有图片，如果有，下载第一张图片。</p><p id="fd49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Twilio在webhook请求的主体中发送我们需要的所有信息。我们将寻找<code class="eh ls lt lu lv b">NumMedia</code>参数来判断是否有任何媒体。如果有，图像URL将在<code class="eh ls lt lu lv b">MediaUrl0</code>参数中。</p><p id="73d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有了<code class="eh ls lt lu lv b">MediaUrl0</code>参数，我们可以使用<code class="eh ls lt lu lv b">Down</code>来下载图像。当你用Down下载图片时，它会给你一个<code class="eh ls lt lu lv b"><a class="ae ka" href="http://ruby-doc.org/stdlib-2.6.2/libdoc/tempfile/rdoc/Tempfile.html" rel="noopener ugc nofollow" target="_blank">Tempfile</a></code>。我们可以读取该文件或其各种属性。</p><p id="69a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦我们完成了tempfile，我们应该关闭它并用<code class="eh ls lt lu lv b">close!</code>方法解除它的链接，这样它就不会挂在操作系统上了。我们还需要处理没有图像被发送的情况，为此我们可以回复一条请求图片的消息。</p><p id="dd6d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">删除测试消息并添加以下代码:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="9e3d" class="me kc hu lv b fv mf mg l mh mi">post "/messages" do<br/>    content_type = "text/xml"<br/>    twiml = Twilio::TwiML::MessagingResponse.new<br/>    if params["NumMedia"].to_i &gt; 0<br/>      tempfile = Down.download(params["MediaUrl0"])<br/>      begin<br/>        twiml.message body: "Thanks for the image! It's #{tempfile.size} bytes large."<br/>      ensure<br/>        tempfile.close!<br/>      end<br/>    else<br/>      twiml.message body: "I can't look for celebrities if you don't send me a picture!"<br/>    end<br/>    twiml.to_xml<br/>  end</span></pre><p id="48cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重启你的应用程序，给自己多发送几条带图片和不带图片的测试消息，确保结果如你所愿。</p><p id="fd9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在是时候开始在图片中搜索名人了，是时候深入研究AWS Rekognition了。</p><h1 id="9cb1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">AWS识别</h1><p id="ef88" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在我们对AWS进行任何API调用之前，我们需要获得一个访问密钥和密码。在您的<a class="ae ka" href="https://console.aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS控制台</a>中，使用<code class="eh ls lt lu lv b">AmazonRekognitionFullAccess</code>策略创建一个用户。</p><p id="756b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有许多方法可以在AWS中创建用户并授予他们权限。下面是一种可以让您访问Rekognition服务的API用户的方法。</p><p id="c589" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从<a class="ae ka" href="https://console.aws.amazon.com/console/home" rel="noopener ugc nofollow" target="_blank"> AWS控制台主页</a>开始，在“查找服务”框中搜索并选择IAM。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/541084d71ce6537f8142fa793b04239f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pdk9fmtdGIjZg2UWiYhIpg.png"/></div></div></figure><p id="006c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在IAM部分，单击左侧导航栏中的“用户”菜单，然后单击“添加用户”按钮。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ml"><img src="../Images/a786d3f20995485c89ed6b3c038e9367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8DHPLVF54qlFqrcpeFcE2g.png"/></div></div></figure><p id="7a7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给你的用户一个名字，选中“编程访问”框，然后点击“下一步:权限”。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/1ae6e0aa7450ca6140db2bd6c18e9e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPkvMmiFvSPBn72tZj8QsQ.png"/></div></div></figure><p id="e0c1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">选择“直接附加现有策略”，您将看到一个策略表。搜索“重新确认”的策略。您将看到三个策略，选择<code class="eh ls lt lu lv b">AmazonRekognitionFullAccess</code>策略，描述为“访问所有Amazon Rekognition APIs”。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/58110591be64bfb3282ba115e215170b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MDP0zyOibwIwIkrBXWYqQ.png"/></div></div></figure><p id="f2c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在单击“下一步”,直到看到成功消息。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mm"><img src="../Images/2a8a607830d93eb80642aef65087ec4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXEfk_X3EKOcacvZt65-uQ.png"/></div></div></figure><p id="dc65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在成功页面上，您将看到您的“访问密钥ID”和“秘密访问密钥”，将它们保存在<code class="eh ls lt lu lv b">config/env.yml</code>中，以及一个AWS区域，其中Rekognition可用，如“us-east-1”。如果您想了解关于此过程的更多信息，请查阅关于Rekognition 的认证和访问控制的<a class="ae ka" href="https://docs.aws.amazon.com/rekognition/latest/dg/authentication-and-access-control.html" rel="noopener ugc nofollow" target="_blank">文档。</a></p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="019d" class="me kc hu lv b fv mf mg l mh mi">AWS_ACCESS_KEY_ID: YOUR_KEY_ID<br/>AWS_SECRET_ACCESS_KEY: YOUR_SECRET_KEY<br/>AWS_REGION: us-east-1</span></pre><p id="99d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，为了在我们的照片中找出名人，我们需要创建一个客户端来使用AWS API，并将图像发送到<a class="ae ka" href="https://docs.aws.amazon.com/rekognition/latest/dg/celebrities-procedure-image.html" rel="noopener ugc nofollow" target="_blank">名人识别端点</a>。在<code class="eh ls lt lu lv b">begin</code>块中添加以下代码:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="6c6b" class="me kc hu lv b fv mf mg l mh mi">      begin  <br/>        client = Aws::Rekognition::Client.new<br/>        response = client.recognize_celebrities image: { bytes: tempfile.read }<br/>      ensure<br/>        tempfile.close!<br/>      end</span></pre><p id="39ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Ruby AWS SDK自动从环境中获取您的凭证。然后，我们读取下载的图像，并将其作为字节发送给客户端的<code class="eh ls lt lu lv b">recognize_celebrities</code>方法。</p><p id="f938" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ls lt lu lv b">response</code>将会有关于被检测到的面孔的所有细节，以及他们是否可能是名人。然后，你可以按照自己喜欢的方式做出回应。我选择报告照片中的名人，如果有，如果没有，报告检测到多少张脸:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="a23b" class="me kc hu lv b fv mf mg l mh mi">        if response.celebrity_faces.any?<br/>          if response.celebrity_faces.count == 1<br/>            celebrity = response.celebrity_faces.first<br/>            twiml.message body: "Ooh, I am #{celebrity.match_confidence}% confident this looks like #{celebrity.name}."<br/>          else<br/>            twiml.message body: "I found #{response.celebrity_faces.count} celebrities in this picture. Looks like #{to_sentence(response.celebrity_faces.map { |face| face.name }) } are in the picture."<br/>          end<br/>        else<br/>          case response.unrecognized_faces.count<br/>          when 0<br/>            twiml.message body: "I couldn't find any faces in that picture. Maybe try another pic?"<br/>          when 1<br/>            twiml.message body: "I found 1 face in that picture, but it didn't look like any celebrity I'm afraid."<br/>          else<br/>            twiml.message body: "I found #{response.unrecognized_faces.count} faces in that picture, but none of them look like celebrities."<br/>          end<br/>        end</span></pre><p id="45f1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我还在这里添加了一个简短的helper函数，将一列名字转换成一个可读的句子:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="d53a" class="me kc hu lv b fv mf mg l mh mi">def to_sentence(array)<br/>  return array.to_s if array.length &lt;= 1<br/>  "#{array[0..-2].join(", ")} and #{array[-1]}"<br/>end</span></pre><p id="444d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再次重启你的应用程序，并向WhatsApp号码发送一张图片。事实证明，我看起来不像任何名人，无法从Rekognition获得匹配，所以我想我也可以尝试与一些名人匹配。我给自己发了几张名人照片，<a class="ae ka" href="https://twitter.com/theellenshow/status/440322224407314432?lang=en" rel="noopener ugc nofollow" target="_blank">就像这张</a>，看看效果。</p><figure class="lw lx ly lz fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/0fdc92571b4c91a1e7b03ac5dc59aca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*qFM_SS3Fgvs2RkK5yC5qyQ.jpeg"/></div><figcaption class="mn mo fg fe ff mp mq bd b be z ek"><em class="mr">There’s a few more than that Rekognition!</em></figcaption></figure><h1 id="d0f6" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">WhatsApp、图片、AWS和名人</h1><p id="bcff" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在这篇文章中，我们看到了如何使用WhatsApp的Twilio API接收发送到WhatsApp号码的图像，使用<code class="eh ls lt lu lv b"><a class="ae ka" href="https://github.com/janko/down" rel="noopener ugc nofollow" target="_blank">Down</a></code>下载图像，然后使用<a class="ae ka" href="https://aws.amazon.com/rekognition/" rel="noopener ugc nofollow" target="_blank"> AWS Rekognition </a>在图像中搜索名人。你可以在这个<a class="ae ka" href="https://github.com/philnash/celebrity-spotting" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中看到这个帖子的所有代码。</p><p id="95a8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不过这只是开始，Rekognition给了你一堆分析图像的工具，包括识别<a class="ae ka" href="https://docs.aws.amazon.com/rekognition/latest/dg/labels.html" rel="noopener ugc nofollow" target="_blank">物体和场景</a>、<a class="ae ka" href="https://docs.aws.amazon.com/rekognition/latest/dg/text-detection.html" rel="noopener ugc nofollow" target="_blank">文本</a>，甚至<a class="ae ka" href="https://docs.aws.amazon.com/rekognition/latest/dg/moderation.html" rel="noopener ugc nofollow" target="_blank">裸体或暗示内容</a>。</p><p id="850b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个小的Sinatra应用程序，但是你也可以在Rails中实现它。下载图像和使用Rekognition APIs需要相当长的时间，所以您可能希望用ActiveJob 延迟这些API调用，而用REST API 响应<a class="ae ka" href="https://www.twilio.com/docs/sms/whatsapp/api?code-sample=code-send-a-message-with-whatsapp&amp;code-language=Ruby&amp;code-sdk-version=default" rel="noopener ugc nofollow" target="_blank">。值得考虑的是响应时间，因为</a><a class="ae ka" href="https://www.twilio.com/docs/api/errors/11200" rel="noopener ugc nofollow" target="_blank"> Twilio webhooks在超时</a>之前只会等待15秒。</p><p id="e76e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你用图像分析做了什么很酷的东西吗？我很乐意在评论中或在Twitter上听到你的形象问题。</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="f727" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mz">最初发表于</em><a class="ae ka" href="https://www.twilio.com/blog/celebrity-spotting-twilio-api-whatsapp-aws-rekognition-ruby" rel="noopener ugc nofollow" target="_blank"><em class="mz">www.twilio.com</em></a><em class="mz">。</em></p><figure class="lw lx ly lz fq iv"><div class="bz el l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>