<html>
<head>
<title>Image Classification with high-level API of Tensorflow 2.x</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Tensorflow 2.x的高级API进行影像分类</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/image-classification-with-tensorflow-2-0-d5a98bcffce1?source=collection_archive---------2-----------------------#2019-05-12">https://medium.com/hackernoon/image-classification-with-tensorflow-2-0-d5a98bcffce1?source=collection_archive---------2-----------------------#2019-05-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ffb2" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">与之前的版本不同，<a class="jj jk gr" href="https://medium.com/u/b1d410cb9700?source=post_page-----d5a98bcffce1--------------------------------" rel="noopener" target="_blank"> TensorFlow </a> 2.0即将推出一些重大变化。它将变得更加pythonic化，并且不需要显式地打开急切执行。随着Keras的紧密集成，现在它将专注于简单性和易用性。</h2></div><p id="b183" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><a class="ae kh" href="https://keras.io" rel="noopener ugc nofollow" target="_blank"> Keras </a>是一个高级API，允许轻松构建、训练、评估和执行各种神经网络。Keras由Franç ois Chollet开发，于2015年3月开源。凭借其简单易用的特性，它很快就流行起来。Tensorflow自带Keras的实现，带有一些TF特有的特性。</p><blockquote class="ki kj kk"><p id="3144" class="jl jm kl jn b jo jp iv jq jr js iy jt km jv jw jx kn jz ka kb ko kd ke kf kg hn dt translated">Keras可以运行在MXNet、CNTK或Theano之上。</p></blockquote><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff kp"><img src="../Images/6548e61348cc3470916e6a315bb136a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4P9JrUaMS_OyL4T9YsnKA.png"/></div></div></figure><h1 id="2eed" class="lb lc hu bd ld le lf lg lh li lj lk ll ja lm jb ln jd lo je lp jg lq jh lr ls dt translated">让我们构建一个简单的图像分类器</h1><p id="236a" class="pw-post-body-paragraph jl jm hu jn b jo lt iv jq jr lu iy jt ju lv jw jx jy lw ka kb kc lx ke kf kg hn dt translated">我们将为图像分类创建一个简单的神经网络架构。《时尚MNIST》收集了70，000张28x28像素的灰度图像，包含10类不同的服装。我们将在这个数据集上训练我们的神经网络。</p><blockquote class="ki kj kk"><p id="8e0a" class="jl jm kl jn b jo jp iv jq jr js iy jt km jv jw jx kn jz ka kb ko kd ke kf kg hn dt translated">对于图像分类，无论是在时间上还是在精度上，CNN都比稠密NN表现得更好。我在这里使用密集神经网络架构进行演示。</p></blockquote><blockquote class="ly"><p id="6031" class="lz ma hu bd mb mc md me mf mg mh kg ek translated"><a class="ae kh" href="https://becominghuman.ai/not-just-introduction-to-convolutional-neural-networks-part-1-56a36b938592" rel="noopener ugc nofollow" target="_blank">查看这篇文章，了解卷积神经网络。</a></p></blockquote><h2 id="0ff8" class="mi lc hu bd ld mj mk ml lh mm mn mo ll ju mp mq ln jy mr ms lp kc mt mu lr mv dt translated">首先导入库并下载F-MNIST数据集。</h2><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="ef4a" class="mi lc hu mx b fv nb nc l nd ne">import tensorflow as tf<br/>from tensorflow import keras  <em class="kl"># tensorflow implementation of keras</em><br/>import matplotlib.pyplot as plt</span><span id="f15b" class="mi lc hu mx b fv nf nc l nd ne"><em class="kl"># Download dataset with Keras utility function</em></span><span id="857c" class="mi lc hu mx b fv nf nc l nd ne">fashion_mnist = keras.datasets.fashion_mnist<br/>(X_train_full, y_train_full), (X_test, y_test) = fashion_mnist.load_data()</span><span id="1e28" class="mi lc hu mx b fv nf nc l nd ne">print(X_train_full.shape)<br/>(60000, 28, 28)</span></pre><p id="7ece" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">将数据集分成训练集、验证集和测试集始终是一个好的做法。因为我们已经有了测试集，所以让我们创建一个验证集。我们可以将数据的像素强度除以255.0，从而将其调整到0–1的范围内。缩放导致更好的梯度更新。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="94ef" class="mi lc hu mx b fv nb nc l nd ne">X_valid, X_train = X_train_full[:5000] / 255.0, X_train_full[5000:] / 255.0</span><span id="d7a6" class="mi lc hu mx b fv nf nc l nd ne">y_valid, y_train = y_train_full[:5000], y_train_full[5000:]</span></pre><p id="cd3e" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们可以使用matplotlib查看任何照片。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="2f7c" class="mi lc hu mx b fv nb nc l nd ne">plt.imshow(X_train[5])</span></pre><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div class="fe ff ng"><img src="../Images/1f01deec51610849ffa91cc3f08b52b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*TWIU4HAXLrYTTFRGUa3DKw.png"/></div></figure><h2 id="439e" class="mi lc hu bd ld mj nh ml lh mm ni mo ll ju nj mq ln jy nk ms lp kc nl mu lr mv dt translated">使用Keras顺序API创建模型</h2><p id="cd95" class="pw-post-body-paragraph jl jm hu jn b jo lt iv jq jr lu iy jt ju lv jw jx jy lw ka kb kc lx ke kf kg hn dt translated">现在是时候建立我们简单的图像分类人工神经网络了。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="b7c3" class="mi lc hu mx b fv nb nc l nd ne">model = keras.models.Sequential()<br/>model.add(keras.layers.Flatten(input_shape=[28, 28]))<br/>model.add(keras.layers.Dense(300, activation="relu"))<br/>model.add(keras.layers.Dense(100, activation="relu"))<br/>model.add(keras.layers.Dense(10, activation="softmax"))</span></pre><p id="a694" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">如果你没有得到它，那么不要担心，让我一行一行地解释代码。</p><p id="92b5" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jn hv">顺序</strong>模型是层的线性堆栈，按顺序连接。</p><p id="ee7a" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">下一层，即<strong class="jn hv"> Flatten </strong>只是将28x28维数组转换成1D数组。如果它接收输入数据X，那么它计算X . shape(-1，1)。它需要一个<strong class="jn hv"> input_shape </strong>参数来指定输入数据的大小。但是，Keras可以自动检测到input_shape。</p><p id="53bd" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jn hv">密集</strong>层是神经网络中全连接的神经元。这里有两个隐层，第一个隐层有300个神经元，第二个隐层有100个神经元。</p><p id="cd7d" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">最后一个致密层由输出层中的10个神经元组成。它负责计算损失和预测。</p><h2 id="dd33" class="mi lc hu bd ld mj nh ml lh mm ni mo ll ju nj mq ln jy nk ms lp kc nl mu lr mv dt translated">现在，我们需要编译我们的模型</h2><p id="5397" class="pw-post-body-paragraph jl jm hu jn b jo lt iv jq jr lu iy jt ju lv jw jx jy lw ka kb kc lx ke kf kg hn dt translated">Keras有一个compile()方法，它指定要使用的损失函数、优化器和度量。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="fa2a" class="mi lc hu mx b fv nb nc l nd ne">model.compile(loss=keras.losses.sparse_categorical_crossentropy,<br/>optimizer="sgd", metrics=["accuracy"])</span></pre><h2 id="1ca3" class="mi lc hu bd ld mj nh ml lh mm ni mo ll ju nj mq ln jy nk ms lp kc nl mu lr mv dt translated">培训和评估</h2><p id="bfb7" class="pw-post-body-paragraph jl jm hu jn b jo lt iv jq jr lu iy jt ju lv jw jx jy lw ka kb kc lx ke kf kg hn dt translated">模型编译后，我们可以通过指定历元、批量大小等来拟合()方法。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="99bb" class="mi lc hu mx b fv nb nc l nd ne"><em class="kl"># Training model for 30 epochs</em></span><span id="4c10" class="mi lc hu mx b fv nf nc l nd ne">history = model.fit(X_train, y_train,<br/>epochs=30, validation_data=(X_valid, y_valid<em class="kl">))</em></span></pre><p id="7c6e" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">该方法将训练30个时期的模型。训练丢失、验证丢失和训练精度、验证精度可在<strong class="jn hv">历史中找到。</strong></p><p id="41a3" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们可以使用<strong class="jn hv">历史</strong>创建学习曲线的可视化。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="469c" class="mi lc hu mx b fv nb nc l nd ne">import pandas as pd<br/>pd.DataFrame(history.history).plot(figsize=(8, 5))<br/>plt.grid(True)<br/>plt.gca().set_ylim(0, 1) <em class="kl"># set the vertical range to [0-1]</em><br/>plt.show()</span></pre><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff nm"><img src="../Images/8d3e19874971acdb1bb5b32ee3f4ab01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLrZIrYpxK8SIsOqDMBncg.png"/></div></div><figcaption class="nn no fg fe ff np nq bd b be z ek">Source: “Hands-on Machine Learning with Scikit-Learn, Keras, and TensorFlow”</figcaption></figure><p id="1540" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">我们可以看到，验证曲线和训练曲线之间的空间很小，这就是为什么没有过度拟合的问题。</p><p id="ad6a" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">现在，我们可以尝试不同的超参数来提高数据集的准确性。</p><p id="411b" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">如果您对训练和验证的准确性感到满意，那么就在测试集上对其进行评估。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="27ec" class="mi lc hu mx b fv nb nc l nd ne">model.evaluate(X_test, Y_test)</span></pre><blockquote class="ki kj kk"><p id="d50d" class="jl jm kl jn b jo jp iv jq jr js iy jt km jv jw jx kn jz ka kb ko kd ke kf kg hn dt translated"><em class="hu">测试集的精度可能低于验证集，因为超参数是为验证集调整的。</em></p></blockquote><h2 id="a1af" class="mi lc hu bd ld mj nh ml lh mm ni mo ll ju nj mq ln jy nk ms lp kc nl mu lr mv dt translated">保存训练好的模型</h2><p id="2729" class="pw-post-body-paragraph jl jm hu jn b jo lt iv jq jr lu iy jt ju lv jw jx jy lw ka kb kc lx ke kf kg hn dt translated">当你在测试集上训练和评估了你的神经网络模型后，你可以使用Keras save()方法下载你的模型，然后可以随时加载它进行推理。</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="e7f9" class="mi lc hu mx b fv nb nc l nd ne"># save your model as HDF5 format<br/>model.save("my_keras_model.h5")</span></pre><p id="72fc" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">它保存模型的架构和每个层的所有模型参数的值(所有训练的权重和偏差)。</p><p id="bcd2" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">如果您想使用您的训练模型进行推理，只需加载它:</p><pre class="kq kr ks kt fq mw mx my mz aw na dt"><span id="848f" class="mi lc hu mx b fv nb nc l nd ne">model = keras.models.load_model("my_keras_model.h5")</span></pre><p id="be3f" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated">现在，是时候自己训练不同的数据集了。祝你好运😄！</p><p id="d879" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jn hv">推荐:</strong></p><ol class=""><li id="8483" class="nr ns hu jn b jo jp jr js ju nt jy nu kc nv kg nw nx ny nz dt translated">深度学习专业化(Coursera)</li><li id="6fe4" class="nr ns hu jn b jo oa jr ob ju oc jy od kc oe kg nw nx ny nz dt translated">《用Scikit-Learn和TensorFlow进行机器实践学习》作者<a class="jj jk gr" href="https://medium.com/u/c939be75faee?source=post_page-----d5a98bcffce1--------------------------------" rel="noopener" target="_blank"> Aurélien Géron </a>(作者O'Reilly)</li></ol></div><div class="ab cl of og hc oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="hn ho hp hq hr"><p id="3e5d" class="pw-post-body-paragraph jl jm hu jn b jo jp iv jq jr js iy jt ju jv jw jx jy jz ka kb kc kd ke kf kg hn dt translated"><strong class="jn hv">你可以通过</strong><a class="ae kh" href="http://twitter.com/iamaniketmaurya" rel="noopener ugc nofollow" target="_blank"><strong class="jn hv">【twitter.com/aniketmaurya】</strong></a><strong class="jn hv">联系我或者留言安📧在</strong><a class="ae kh" href="http://aniketmaurya@outlook.com" rel="noopener ugc nofollow" target="_blank"><strong class="jn hv">aniketmaurya@outlook.com</strong></a></p></div></div>    
</body>
</html>