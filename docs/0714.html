<html>
<head>
<title>Clojure Immutable and Persistent Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Clojure 不可变和持久数据结构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/clojure-immutable-and-persistent-data-structures-3978118f6805#2019-01-29">https://medium.com/hackernoon/clojure-immutable-and-persistent-data-structures-3978118f6805#2019-01-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/baf82c31713a22ff1124d6e11aa888eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*y526ZLHqMt4MYDhBilb7Jw.png"/></div></figure><h2 id="e6b6" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">Clojure 是什么？</h2><p id="bd0e" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">Clojure 是老式编程语言 LISP 的现代方言。Clojure 坚信代码即数据，数据即代码哲学，就像 LISP 一样。Clojure 是一种运行在 Java 虚拟机上的动态通用编程语言。Clojure 强调</p><h2 id="b134" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">安装 Clojure</h2><p id="38d6" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">Clojure 需要 JVM，因为它运行在 JVM 之上。确保您的系统上安装了最小 Java 1.7</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="847f" class="iy iz hu kw b fv la lb l lc ld">mkdir -p ~/bin &amp;&amp; cd ~/bin </span><span id="4aed" class="iy iz hu kw b fv le lb l lc ld">curl -O https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein </span><span id="1cd1" class="iy iz hu kw b fv le lb l lc ld">chmod a+x lein</span><span id="fd53" class="iy iz hu kw b fv le lb l lc ld">export PATH="$PATH":~/bin</span></pre><p id="ebc9" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt translated">或者</p><pre class="kr ks kt ku fq kv kw kx ky aw kz dt"><span id="3f73" class="iy iz hu kw b fv la lb l lc ld">curl -O https://download.clojure.org/install/linux-install-1.10.0.403.sh<br/>chmod +x linux-install-1.10.0.403.sh<br/>sudo ./linux-install-1.10.0.403.sh</span></pre><h2 id="8212" class="iy iz hu bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv dt translated">数据结构</h2><p id="276f" class="pw-post-body-paragraph jw jx hu jy b jz ka kb kc kd ke kf kg jj kh ki kj jn kk kl km jr kn ko kp kq hn dt translated">4 clo jure 的基本数据结构。</p><ul class=""><li id="d1c6" class="lk ll hu jy b jz lf kd lg jj lm jn ln jr lo kq lp lq lr ls dt translated">列表()</li><li id="bc3a" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">向量[]</li><li id="c1bd" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">设置# { }幅图像</li><li id="ead1" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">地图{}</li></ul><p id="3d7b" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt translated">通过不可变的方式，当从集合中添加、更新、移除元素时，集合的值在任何时间点都不会改变，而是输出将是结构的新版本。</p><p id="9759" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt ly translated"><span class="l lz ma mb bm mc md me mf mg di">在法律上，这是基本原则。Clojure 中的列表是链接列表，列表中的第一个元素总是作为函数调用进行计算。Clojure 中两个大括号之间的内容是 list。当我们想从列表的顶部获取项目时，列表很有用。</span></p><figure class="kr ks kt ku fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="c531" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt ly translated"><span class="l lz ma mb bm mc md me mf mg di"> V </span> ectors []是 Clojure 中创建序列的默认方式。载体是异质的。我们可以从它们中检索项目，还可以将它们添加到末尾和开头。当我们想在列表中添加新元素时，最新的元素总是被添加到向量的末尾。</p><figure class="kr ks kt ku fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="4c92" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt translated">Clojure 向量中的检索非常快。</p><p id="456d" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt ly translated">M  aps {}非常有用，在 Clojure 中广泛使用，以{:key value}格式存储结构化数据。为了从映射中检索值，我们可以使用<code class="eh mj mk ml kw b">get</code>并且我们也可以使用<code class="eh mj mk ml kw b">keys</code>作为从映射中检索值的函数，这是从映射中检索的更惯用的方法。</p><p id="8f82" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt translated">一些有用的函数可用于地图操作</p><ul class=""><li id="a114" class="lk ll hu jy b jz lf kd lg jj lm jn ln jr lo kq lp lq lr ls dt translated">获取-从地图中检索值</li><li id="9edd" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">关联-更新地图</li><li id="d28e" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">disoc—从映射中删除键/值</li><li id="2612" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">键-获取地图中的所有键</li><li id="e97c" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">vals 获取地图中的所有键</li><li id="5a5c" class="lk ll hu jy b jz lt kd lu jj lv jn lw jr lx kq lp lq lr ls dt translated">合并-将多个地图合并为一个地图</li></ul><figure class="kr ks kt ku fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure><p id="e733" class="pw-post-body-paragraph jw jx hu jy b jz lf kb kc kd lg kf kg jj lh ki kj jn li kl km jr lj ko kp kq hn dt ly translated">集合#{}是唯一值的集合。不允许重复。</p><figure class="kr ks kt ku fq iv"><div class="bz el l di"><div class="mh mi l"/></div></figure></div></div>    
</body>
</html>