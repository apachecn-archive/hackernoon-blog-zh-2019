<html>
<head>
<title>Building RESTful APIs (Authentication &amp; Error Handling)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建RESTful APIs(认证和错误处理)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-restful-apis-authentication-error-handling-4013681381a2?source=collection_archive---------11-----------------------#2019-03-06">https://medium.com/hackernoon/building-restful-apis-authentication-error-handling-4013681381a2?source=collection_archive---------11-----------------------#2019-03-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu"><div class="bz el l di"><div class="iv iw l"/></div></figure></div><div class="ab cl ix iy hc iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="hn ho hp hq hr"><p id="381a" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">订阅Mobycast<br/><a class="ae kc" href="https://itunes.apple.com/us/podcast/mobycast/id1365791129" rel="noopener ugc nofollow" target="_blank">iTunes</a>|<a class="ae kc" href="https://play.google.com/music/m/I4uq3qw5rby27ncgtpxpvuznre4?t=Mobycast" rel="noopener ugc nofollow" target="_blank">Google Play</a>|<a class="ae kc" href="https://soundcloud.com/pro-docker-training" rel="noopener ugc nofollow" target="_blank">Soundcloud</a>|<a class="ae kc" href="https://www.stitcher.com/podcast/pro-docker-training/mobycast?refid=stpr" rel="noopener ugc nofollow" target="_blank">Stitcher</a>|<a class="ae kc" href="https://open.spotify.com/show/6GFEu9fYpRsyFWZQJSLsGg?si=WB-ZTP-8QVix_MlN-job7w" rel="noopener ugc nofollow" target="_blank">Spotify</a></p><p id="48e2" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated"><strong class="jg hv">显示注释</strong></p><p id="b27e" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Kelsus的乔恩·克里斯滕森和克里斯·希克曼以及Secret Stache的里奇·斯塔茨继续他们关于构建RESTful APIs的对话，特别关注认证和错误处理。REST代表转移的表象状态。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div class="fe ff kd"><img src="../Images/3edb10d2834d694f9994b7ffcc262b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*mKqlMTBbCISddr6vlgggFQ.jpeg"/></div></figure><p id="ea00" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated"><strong class="jg hv">该节目的一些亮点包括:</strong></p><ul class=""><li id="bad8" class="kk kl hu jg b jh ji jl jm jp km jt kn jx ko kb kp kq kr ks dt translated">使用API进行身份验证以识别调用者及其授权权限的重要性</li><li id="9cd5" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">实体之间的无状态与有状态通信通道</li><li id="b6f3" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">最简单的认证技术是在报头中使用基本的HTTP元数据；你必须通过加密连接发送</li><li id="daa7" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">交换基于用户凭证协商的短期令牌是另一种选择</li><li id="a088" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">认证优势:更少的用户名/密码请求，拒绝令牌的能力</li><li id="335f" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">降低复杂性并处理无差别的繁重工作的流行身份管理服务包括Auth0、OneLogin、Okta和Cognito</li><li id="8cb0" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">理解客户端和后端之间的契约，以避免给使用API的应用程序开发人员增加难度</li><li id="5b1a" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">错误代码的级别</li><li id="8bc7" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">返回的关于调用方的公共与私有API信息可能存在安全风险；执行错误消毒——不要晾你的脏衣服</li><li id="293c" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">超媒体作为应用程序状态的引擎(HATEOAS):调用者从少量众所周知的端点开始，然后API根据响应变得可被发现</li><li id="7194" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">HATEOAS的圣杯:提供了发布新特性和增加API功能的可能性，而无需对客户端进行任何更改</li><li id="27fe" class="kk kl hu jg b jh kt jl ku jp kv jt kw jx kx kb kp kq kr ks dt translated">Apiary、Swagger和Kong是可以用来开发API的工具</li></ul><p id="7147" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated"><strong class="jg hv">成绩单</strong></p><p id="5879" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Rich:在Mobycast的第49集，我们继续关于构建RESTful APIs的对话。特别是，我们讨论认证和错误处理。欢迎来到Mobycast，这是一个关于容器化、Docker和现代软件部署的每周对话。让我们直接开始吧。</p><p id="5add" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:你好，欢迎。欢迎，克里斯，欢迎回来，瑞奇。又是一集Mobycast。</p><p id="1d3a" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">里奇:嘿。</p><p id="b0f6" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:嘿，伙计们。</p><p id="505f" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:很高兴听到你的声音。本周，我们将直接进入主题，因为我们正在做REST系列的第二部分，面向REST的微服务，以及如何用REST APIs构建干净漂亮的微服务。</p><p id="30f9" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">上周，我们只是接触了很多基础知识。这几集是真正以学习为中心的，以帮助确保我们作为软件开发人员构建的东西对其他人有用，易于维护，易于理解，并且易于交给其他开发人员。</p><p id="42cf" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">上周，我们刚刚讨论了它是什么，许多基础知识，不同的方法，它是如何工作的，以及命名方案是如何工作的。我们谈了一点REST和HTTP协议之间的关系，REST APIs是如何将HTTP协议扩展到网页之外的东西的。[……]了解这个东西是什么，并举例说明什么该做，什么不该做。</p><p id="d783" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">上周我最喜欢的事情是，我们不做像/order/neworder这样的事情作为我们的REST端点。我们只需使用/orders并对其进行发布。这一点很好理解，但尽管很好理解，但在Kelsus，我们肯定会看到这一点并不总是得到遵守。我认为，当你感觉自己正在变成一块椒盐卷饼，以保持头脑中确切的RESTful想法，并且你只需要一次性或特殊的东西时，可能会有打破休息的时候，但我们可以稍后再谈这个问题。</p><p id="63a0" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">本周，我们将深入了解一些事情。我认为这是一个有点更硬核，所以不要认为这是干燥，但更硬核。我们将讨论身份验证、错误处理，以及一些我不会发音的东西，因为我对它们不太熟悉。克里斯会说，当我们到达它的时候。然后在开发API时可能会有一些有用的工具。让我们跳进来，让除我之外的人谈谈。让我们来谈谈认证，克里斯。</p><p id="5ffe" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对。显然，认证对于API来说非常重要。你可能有一些公开的API，你真的不需要任何与之相关的身份。但我认为，在大多数情况下，这是非常少的，而且相距甚远。因此，几乎总是会有这样的情况，当有人调用您的API时，您需要能够识别他们是谁来进行身份验证，然后还有调用者，即授权。一旦我知道他们是谁，他们真的有权限做他们要求做的事情吗？所以，构建一个API的最基本的部分。</p><p id="abac" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">当你设计一个RESTful API时，它会带来这个挑战。这就像是，“你是怎么做到的？”特别是在大多数情况下，它是一种无状态的通信机制。有些客户端通过HTTP/HTTPS向您发出调用或发送API调用，服务器接收到这些调用，然后返回一个响应。因此，这是一种请求-响应模式，其中的每一件事情本质上都是原子性的。你如何管理像会话或设置这个身份，并能够知道他们是谁，他们可以做另一个认证或授权？非常基本。</p><p id="aeb1" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon:不过，你刚才说了一些我需要深入了解的东西，因为我经常听到这种说法，我只是想确保我们知道这是什么意思。你刚刚说了“无国籍”许多应用程序服务器确实专注于无状态，因此您的微服务不会跟踪您的用户正在做什么或应用程序的整体状态。但这有点微妙，我只想指出，整个应用程序是绝对有状态的。作为用户，你看到的客户端是不同的，因为你做的事情不同，所以客户端的状态也在变化。那是有状态的。然后，服务器中的后端，我们姑且称之为后端，它也是完全有状态的。当你写下新的博客文章或在社交媒体应用中更新你的状态时，你正在改变后台世界对你的了解。</p><p id="18f7" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">唯一无状态的东西就是运行微服务、监听请求并返回响应的东西。这就是无状态的部分。这么说公平吗，克里斯？</p><p id="5fcf" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对。通常，当我们谈论有状态和无状态时，我们谈论的是两个实体之间的通信通道，以及它是有状态还是无状态。作为一个系统，总会有一个状态。它指向某个地方，但它只是一个区分点，就像，在这两个实体之间的系统的这个特定部分中，它们是有状态关系还是无状态关系？因此，这种传递请求并获得响应以支持特定关系的行为是无状态的。</p><p id="55f0" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:对。它不知道你最后要的是什么，也不会预测你下一个要的是什么。它只是不保持跟踪。</p><p id="ffda" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对。</p><p id="88e7" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:酷。继续我们的认证世界。</p><p id="16b8" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对，所以是认证。我们必须弄清楚打电话的人的身份，以及我们该怎么做。有很多技术可以利用。最直接、最容易实现的方法之一就是使用基本的HTTP认证。这样的东西超级容易实现。</p><p id="e991" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">您的呼叫者有一个基于用户名和密码的身份。每当他们向您的服务发送请求时，该用户名和密码都将被Base64编码，并放入HTTP请求头中。对于HTTP调用，有一部分是这样的。它上面有报头，所以它几乎就像是你正在发送的数据包的元数据，然后是实际的数据包本身。在元数据中，头中用于存储身份验证信息，即在服务器端接收的Base64编码的用户名和密码，然后它可以对Base64进行解码，以确定这是用户名和密码，然后根据您可能拥有的特定身份存储进行身份验证。</p><p id="fc7b" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">因此，实现起来非常简单。客户端操作系统只知道它的用户名和密码，在报头中发送，服务器接收，在数据库中查找，然后回复。它要么允许请求继续，要么返回一个错误，说不允许您这样做。很简单。它一点也不安全。Base64根本不是加密。这只是用文本格式描述二进制数据的一种方式。很容易就能看出这是什么信息。</p><p id="3ab0" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">如果你在API中使用基本认证，那么你必须通过TLS发送。你必须通过加密连接发送。非加密流量上的基本身份验证是一个禁忌。这是一个大问题杀手。就像，“放下你的笔，放下你的键盘，你不能再打字了。你完了。游戏结束。”</p><p id="7c33" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">这是基本的认证。这真的是很少的有用途的应用了。它只是如此简单，基本，有点像遗产，除了纯粹的简单之外，真的没有理由这样做。</p><p id="0da4" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">这就引出了其他一些方法，这些方法基本上都是基于交换短期令牌，这些令牌是根据用户的真实凭据进行协商的。想象一下，我有一个用户名和密码，我将向某个服务或实体进行身份验证，它将对此进行验证，作为回报，它将返回给我一个对我来说唯一的短期令牌，该令牌将我标识为那个特定的人。现在，我可以将该令牌作为身份验证请求的一部分发送。然后后端可以说，“给定这个令牌，他们是谁？”然后决定是否允许访问该请求。</p><p id="63b8" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon:我认为这种基于令牌的身份验证有两个好处，一是包含用户名和密码信息的请求更少，或者说减少了包含用户名和密码信息的请求的总面积。另一种是拒绝令牌或取消令牌的授权，而不要求用户更改用户名和密码。</p><p id="8f32" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:的确如此。有各种方案，你基本上使用这种类型的令牌。你有OAuth之类的东西，这是一个伪造身份验证的规范。O代表开放。OAuth基本上定义了这种舞蹈，给定我的凭证，其他一些服务是身份提供者或身份存储，它们将这些凭证交换为这些短期令牌中的一个。基于此，现在它可以发出请求。</p><p id="382a" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">OAuth有各种不同的味道。还有OAuth的1.x代和OAuth 2.0。显然，OAuth 2.0更新了，尽管实际上并没有太多的实现。肯定更复杂。许多使用OAuth进行身份验证的常见的大型应用程序正在使用1.x版本或它的某种版本，可能特定于它们的实现。</p><p id="9b8a" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:这就是我要说的，克里斯。我以为O代表“哦，并且在不同的实现中不一致。”</p><p id="342b" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:是的，在一天结束的时候，它是开放的，如果你愿意的话，这取决于人们想怎么做。脸书认证有它自己的方式，相对于谷歌，相对于任何其他主要的API，无论什么API。有一个完整的API经济，有许多不同的API可供调用，它们都实现了身份验证，并且都略有不同。你只需要看看细节，看看他们在期待什么。那是OAuth。</p><p id="1b7d" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">OAuth面临的挑战之一是，您是否必须实现自己的OAuth服务器？那里有现成的系统，您可以使用它或托管版本，但它确实有些复杂。为了隐藏这种复杂性，还有一些非常流行的服务来进行身份管理。这些是像Auth0，OneLogin，Okta这样的服务。有很多这样的。</p><p id="cb20" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon:几周前我们谈到了Cognito。</p><p id="96c5" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:是的，当然。科宁托，绝对的。这些服务真的可以消除一些复杂性。这让他们很容易上手。他们最终要么托管身份存储，要么联合到您的身份存储(可能在另一台服务器或另一个数据库中)，但他们负责进行握手，“给我凭据，还给我一个短期令牌，该令牌唯一标识我，保证是我，现在我可以这样打电话。”</p><p id="e1a0" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">这些通常表示为JWTs，代表JSON Web Token。这只是这些代币打包的标准格式。它们最终实际上是一个JSON文档，带有一些定义良好的模式来识别这个人是谁。然后用散列加密以确保它们的安全。</p><p id="abc3" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:对。只是让整个OAuth舞蹈统计数据更加一致。</p><p id="c5da" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Chris:如果你愿意的话，它只是消除了解释的复杂性，所以使用一个最不常用的身份来认证和识别用户的服务要容易得多。这就是它们如此受欢迎的原因。这是你的API不会成功的事情之一，因为你实现OAuth的方式。这就像AWS爱说的无差别举重。在这里，和为你做这件事的人在一起很有意义。</p><p id="cba5" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:太好了。我们可以谈论更多关于认证的内容，但是让我们继续讨论错误处理，这是我所看到的大多数API中比认证更不一致的事情之一。</p><p id="72b8" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对。这是另一个大的领域，如果你不遵循某种压倒一切的原则，它会很快变得非常混乱，让使用你的API的应用程序开发人员感到非常沮丧。有点理解客户和后端之间的契约。那是什么？那些反应看起来像什么？我如何表示成功的回应与不成功的回应？以及事情出错的原因。</p><p id="84e6" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">这也是在HTTP之上构建RESTful APIs的地方。HTTP协议已经有了众所周知的状态代码来指示事情是成功还是失败。它实际上有不同的成功和失败代码类别。大多数人肯定对此很熟悉，比如200是目前最流行的错误代码之一。它只是意味着OK。它是成功的。我们有一个201是另一个成功的回答，但这意味着一些东西实际上是被创造出来的。这是一点额外的信息，不同的，只是让你知道一些事情实际上已经做了。总的来说，200到299，如果你愿意，200以内的任何东西，都代表成功的条件。</p><p id="8cf6" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">300级错误代码，主要是重定向命令。与其说是某件事成功了，不如说是失败了。只是，“嘿，我要给你指一个不同的方向，因为这不是你应该找的地方。它实际上应该在这里。”</p><p id="3e29" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">然后你有400级代码。发生的错误有。400级错误表明您的呼叫者可能做错了什么。这并不是后端出了问题。其实是你有问题。您发送了一个格式错误或意外的请求，该请求无效。</p><p id="fef3" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:或者是不存在的东西。</p><p id="5517" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对，没错。然后是500级错误代码。500级错误代码是，“嘿，当我试图满足你的请求时出错了。我这边有问题。不是你的错，来电者。这是我的错。”</p><p id="566e" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">这些是一般类别。它们变得很重要，因为如果你，作为一个呼叫者，得到一个400级别的错误代码，那么你知道这意味着呼叫者搞砸了。我需要更改一些可能与我的请求，然后我可以重新提交它，希望得到一个成功的响应。相比之下，如果我得到一个500级代码，我知道不是我搞砸了。这是后端。因此，我可以重新提交请求，稍后可能会成功。</p><p id="a3ec" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">保持与API的约定是非常重要的。当你回报200对400对500时，要非常一致。然后，也要非常清楚每一个有意义的范围内的各种代码。如果你在做一个GET，一个安全有效的操作，它会返回一个资源表示，比如200，200 OK。如果你要在资源集合中创建一个新的条目，那么应该是201。201说:“是的，我成功创建了它。我在里面放了一个内容，很成功。”如果我正在执行一个删除操作，而API实现返回的响应说除了一个状态代码之外没有任何东西可以返回，因为你已经删除了它，我将返回状态代码204。基本上204就是成功但身体空虚。没有与之相关的内容。在实现API时，理解基本的公共代码是非常重要的。</p><p id="1fb8" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:好的，克里斯。我见过的最常见的误用状态代码的情况之一是，在服务器端，即使没有执行请求所要求的操作，也只是返回200，并通过200状态代码返回某种错误消息。我经常看到这种情况，如果在400或500范围内就更好了。如果真的发生了错误，就让客户知道。</p><p id="bfd0" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">我记得你的一件特别的事。你和我没有在凯尔萨斯共事。我在凯尔萨斯工作，而你在另一家公司工作。我们不得不协商一个变通方法，因为我正在使用的一个库在任何类型的错误代码上都完全左转，我需要这个错误，你要返回到200范围内，这样我就不会在这个库提供的错误处理的黑暗地牢中结束。我需要在200米的快乐的地方，你就像，“不，我不能这样做。”我们最终不得不这样做。它必须工作。所以，如果你正在写库，确保客户也能够意识到不是所有的错误代码都是坏的。有时，有些错误代码在客户端内部应该很容易管理。</p><p id="2b34" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:我想这也适用于400级代码。有很多事情可能会导致客户端请求在后端无法实现。你提到的一个非常典型的例子是内容不在那里。我通过资源ID请求了一个特定的实体，但是它并不存在，因为可能其他客户端已经删除了它，或者其他人已经删除了它。我可能会返回一个404 Not Found，每个人都从web浏览器中知道这一点。你在你的浏览器栏中输入了一个地址，对于一个在特定网站上不存在的地址，你将得到一个404错误。在你的API中应该做类似的事情。</p><p id="7008" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">一般来说，错误请求的错误代码是400。您的请求格式有误，您返回了400。另一个很常见的是409，代表冲突。这是服务器让客户端知道的一种方式，“嘿，你试图做一些与后端状态不一致的事情，所以你可能是不同步的调用者。”你可以用这些信息来纠正你自己。</p><p id="c227" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:[……]展示了你的熊陷阱记忆。我发誓就是这样。</p><p id="f16f" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:我肯定是。我相信这是应用程序在做一些简单的事情，比如你有一个项目的提要，你希望能够将这些项目标记为其中一些是收藏夹而不是收藏夹。你可以打开多个应用程序来完成这项工作。我可以将其中一个应用程序标记为收藏夹，但在另一个应用程序上，它仍然认为它不是收藏夹，所以我可以点击收藏夹。它向服务器发送“将此标记为收藏”。所以服务器看着它说，“你试图将状态标记为收藏夹，但是它已经作为收藏夹存在了。你刚给我发了些莫名其妙的东西。我认为您的状态可能不是最新的，所以我将发送一个错误代码，让您知道我没有将它标记为收藏夹，因为它已经是了。这表示存在冲突，所以我将返回一个409错误代码。”作为一个客户，这是对你的一个暗示，现在去刷新你的状态，这样你就可以把它恢复到原来的样子。你只是不在这个州。</p><p id="9e14" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">显然，当客户端出于性能原因缓存信息时，这非常有用。这是让您知道您的缓存现在需要失效的方式。我想这就是我们遇到的情况。</p><p id="0931" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:是的。我想你是对的。让我们谈谈另一个400型问题，因为我认为它经常出现。我不知道这个问题的正确答案，但是基本上，如果你向一个API发出一个请求，并且你有一些小问题，也许每个首字母都应该大写，或者JSON字符串的一部分需要是一个字符串而不是JSON对象。当API告诉你你做错了什么的时候真是太好了。这是一个超级高效的界面和一个需要很多血腥的手指在键盘上一天又一天，试图找出什么错误和为什么你发送给API的东西不工作的界面之间的区别。</p><p id="77ed" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">我们没有时间真正记录错误响应并使它们易于理解。这是有可能发生的，我明白。但是我听到了一些关于不要在公共API或私有API上这样做的争论，这些API不应该对公众开放，因为这可能会带来安全风险，因为它可能会让某些人通过发送太多关于你给它的信息而对API进行逆向工程。你也听过这个吗，克里斯？</p><p id="7ed7" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对。同样，这是一个非常开放的领域，它对您的API和情况非常具体，但是您确实需要考虑安全性以及您放弃了多少信息。你想返回对来电者有帮助的信息，但又不想泄露比他们应该知道的更多的信息。</p><p id="565f" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">这种情况最常见的一种情况是，it gets拥有登录帐户。我登录用户名和密码，然后我得到是否成功的响应。如果你返回这样的信息，“嗯，你给的用户名是正确的，但密码是错误的，”并返回一个错误代码，你得到一个401，你没有授权，所以你得到一个401错误代码，然后错误的细节我会告诉你，“哦，你的密码是不正确的。”</p><p id="d582" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">通过这样做，你给了我一些信息，“哦，这是一个有效的用户名。这是一个有效的电子邮件地址。这是我以前没有的信息。现在，我知道它是一个有效的帐户，我现在可以使用该信息不仅计算出密码是什么，“相反，如果您返回一些更普通的信息，如“您的用户名或密码不正确”，您就不会泄露额外的信息。</p><p id="0f9b" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">我想这是其中一个例子。其他人可能会得到更多的500级错误代码，因为后端出了问题。可能是数据库关闭或类似情况，您尝试连接到您的PostgreSQL数据库服务器，但失败了。或者更糟的是，可能配置错误，连接字符串的密码是错误的，或者类似的情况。这可能会在后端引发一个错误，并显示错误消息，表明您的错误资产可能确实有一个字符串，“嘿，连接失败是因为凭据和调试原因或其他原因，它包括他使用的连接字符串。”如果您只是在错误响应中一字不差地返回该字符串，这是非常不允许的。您只是将您的数据库连接字符串泄露给了任何调用者。我做到了。这绝对是一个你需要净化你的错误的例子。</p><p id="b128" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">错误清理对于500级代码来说非常重要，几乎总是如此。你永远也不会想给出它变坏的原因。在调用者的后端，你只需要让他们知道它确实返回了，因为他们也无能为力。它们没有导致数据库连接问题。这并不是说他们不需要一个信息，他们不能用这个信息做任何事情，除了不好的东西，所以不要返回。</p><p id="8009" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">对于400级的东西，你也要记住这一点。你必须根据具体情况来考虑。小心点。您不需要返回所有这些信息，但是如果他们向您发送了一个错误的请求，那么肯定是因为这个特定的查询参数超出了范围。您应该向他们提供信息，让他们知道这超出了范围。这就是那个要求不好的原因。</p><p id="f3d3" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:我离开是为了记住不要在你返回给客户的500级错误中泄露你的秘密。只是，这是一个很好的方式来乘坐快速电梯登上黑客新闻的第一名。人们喜欢看到有人在500 API回复和帖子中公开他们的不可告人的秘密。每个人都喜欢添油加醋，谈论那个人那样做是多么愚蠢。</p><p id="db55" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对。如此糟糕的晋升方式。它发生了。我们都想在那里受欢迎，但那是错误的方式。不要那样做。</p><p id="66fa" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">我认为这大体上涵盖了错误处理和400对500级别的错误。我认为一个重要的细微差别是，在这个微服务的世界中，后端实现正在向上游调用其他服务，这很有趣，后端服务变成了其他服务的客户端。现在，当它调用相关的微服务并返回400错误时，400错误现在很可能代表原始调用者的500错误。</p><p id="feed" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">你不能总是说，“哦，每当它是一个400级的错误，它是这个，而不是一个500级的错误。你必须问自己，“谁是呼叫者，这是什么意思？“如果我的API实现向依赖的服务发出格式错误的请求，这可能代表我的后端代码中的错误，我不应该向我的客户返回400，因为我的客户认为这是他们的错。这不是他们的错。这实际上是服务器的错。所以正确翻译是非常重要的。对于发起客户端来说，这应该变成500级错误。</p><p id="fc66" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:对。这让我最近陷入了AWS中一个非常常见的架构模式，我从API网关返回了一个500错误，一个502，502实际上是因为API网关调用的Lambda函数没有返回API网关期望的结果。</p><p id="62cc" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:是的，没错。肯定有一些非常常见的约定和一些您可以做的最佳实践，但是您必须始终考虑谁是调用者，谁是提供者。只要记住这一点，并且知道当你遍历整个系统的调用链时，你需要进行翻译。</p><p id="f0ff" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:太好了。我想我们还有几分钟。我向每个人保证，我们至少会看到一个我不会发音的单词，因为我不知道它是什么。好像是HateOps或者HateOS什么的。我不知道这是什么。那是什么？</p><p id="dd85" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:完全披露。我不确定除了我之外，我是否真的听到过别人发这个音，所以我不能保证其他人就是这样发的。我总是称之为HATEOAS。这是作为应用程序状态引擎的超媒体的缩写。描述这一点的更简单的方法基本上就是超媒体。是超媒体API。它真正的意思是，这是一种API风格，在这种风格中，调用者只需从非常少的已知端点开始，然后，API的其余部分就可以被来自该API的响应发现。</p><p id="8c0b" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">你可以把它想象成《选择你自己的冒险书》。这可能不是完美的类比，但你从一个页面或一个入口点开始，你得到回应，然后回应基本上告诉你你下一步可以做什么选择。可能有些信息是这样的，“哦，如果你想去获取这个资源，这是方法。如果你想更新这个资源，你可以这样做。如果你想删除…”</p><p id="ee41" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:我明白了。让我们把它具体化。“给我下达所有的命令。我知道怎么拿到所有的订单。好的，它们在这里，每一个都有一个URL来找到那个特定的。如果你想做一个新的，这里还有一个。这里有一个你可以打电话做一个新的。此外，对于这里的每一个，"就像你说的，"这里是你如何删除订单。"</p><p id="5580" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对。这些超媒体API就是这样。真的，这里的圣杯是完全自动化的东西。通过这种数据驱动的与后端交互的方式，您基本上实现了API消费的自动化。原则上，这是非常吸引人和非常强大的东西。实际上，它最终变得不那么神奇了。承诺是，除了那些众所周知的端点之外，客户端实际上不需要知道任何东西。他们从某个路径开始，他们进行调用，然后他们从有效载荷中获得所有需要的信息，该有效载荷为他们提供了他们下一步可以做的所有各种选项，然后从那里开始。</p><p id="2099" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">顺便说一下，这都是基于网络。这就是网络的工作方式。把它想象成谷歌。你只要去谷歌，然后输入你的搜索，你会看到一堆不同的链接。然后你点击一个链接，它会做什么？它会把你带到另一个页面，在那里你会看到另一堆链接。然后你可以决定当你点击一个链接时做什么。那就是超媒体。它实际上采用了相同的思想，并扩展到，这就是你的API如何工作。</p><p id="68e3" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon:不同之处在于，在你给出的例子中，能够处理超媒体API的决策机器是wetware。是我们的大脑。我们知道如何处理意外信息，以及如何应对。我们可以像人那样做，但据我所知，还没有胡萝卜能做到。</p><p id="0237" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Chris:不仅如此，这个例子中的动作列表也非常有限。你可以选择一个链接。真的，唯一的思维过程是这样的，“我下一步想点击哪个链接？”但是操作只是点击，而不是RESTful超媒体API，你可以说，“哦，这是你如何删除，这是你如何更新，这是你如何获取，这是你如何修补，”或者诸如此类的话。那些动作的语义是什么？</p><p id="44c3" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon:“删除按钮是什么，当我删除时会发生什么？我该拿这个回答怎么办？”</p><p id="dedc" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:是的。你的客户必须理解这些语义，并且能够根据这些包含在响应中的超媒体链接来识别如何影响这些动作。这就是它变得真正模糊不清的地方，这种数据驱动的API带来了一些光彩。综上所述，我已经构建了超媒体API，并且运行得相当好。</p><p id="86c2" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon:我还是有点纠结，因为有时为客户做这些工作，使用返回的超媒体信息，有时这是项目中更全面的工作，而不仅仅是像这样，“好吧，当你想删除时就调用这个。”在程序之外告诉我，就像你和我一样，你是开发者，我是开发者，你用文字告诉我的人脑去做这件事，而不是通过代码告诉我。因为那样的话，我就必须编写代码，知道如何用？</p><p id="f76e" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">我想这真的取决于，比如你的应用程序中有多少是响应未知事物的通用模式，比如，“我们不知道URL会是什么，但每次你得到这种资源，你都知道你会用它来做这件事。”在这种情况下，就像“哦，是的，超媒体，”但在许多其他情况下，就像“只是硬编码端点来查看，或者不是整个端点，而只是路径。”</p><p id="4216" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Chris:我应该指出，想要使用超媒体API的最大原因之一是它提供了推出新功能的可能性，增加了API的功能，而无需对客户端进行任何更改。这是这里的圣杯。我认为在某些情况下这样做是有意义的。</p><p id="d149" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">如果你有一个非常简单的应用程序，但你知道你想能够扩展它，也许添加，它可能只是新东西上的crud。这就像你从可能的订单，然后还包括发货，销售，无论它可能是什么，其他事情。也许类似的东西很适合这样的东西，你可以来保持它相当离散和语义，但你想继续扩大涉及的资源类型的覆盖面。</p><p id="cbc5" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">你不必对你的客户做任何更新。你可以有一个移动应用程序，你不必向商店推送任何新的更新就可以使用新的API，因为它都是数据驱动的。这很有吸引力，但你必须再次平衡这一点，比如，“好吧，我真的可以在客户端中充分覆盖这一语义，以利用这一条件吗？”</p><p id="f7ed" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:是的。这是一件非常重要的事情，做出是否使用超媒体的决定，因为它不包含团队的学习，没有时间来构建东西。我只是想指出，如果你在构建一个订单系统或销售系统，那么对该系统中各种不同类型的资源或对象的反应更有可能是针对你正在做的事情的。因此，您处理订单的方式与处理发票的方式完全不同。</p><p id="5514" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">因此，这种系统可能不太适合超媒体，而不适合社交媒体系统，“嘿，可能会有帖子。我可以分享一张地图，我可以分享一个视频，我可以分享一张照片，我可以分享一个关于我自己的想法或者我在手机上画的一个友好的小部件。我可以分享各种不同的东西，”它们都是不同的对象，可能在数据库的不同表中，或者出于某种原因，所以它们可能有不同的端点。</p><p id="b2bd" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">但是最终，应用程序可能能够使用类似的机制来显示每一个。"让我把应该展示给用户的东西拿过来."在这种情况下，这样做真的很方便，因为我可以向它扔一个新的超媒体API，我就可以在不改变客户端的情况下向我的提要添加一个VR视频。</p><p id="348f" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:对，你提出了一个很好的观点。不一定要全有或全无。你的整个API不一定是超媒体API。你可以把它用在一些有意义的地方。尽管如此，超媒体API是有趣的，但实现和使用它们的现实实用性并不简单。鉴于此，我做了很多API。我在里面放了很多API，其中有一个是超媒体API。所以，接受它的价值吧。这是它的一个有限的用例，但它是值得了解和考虑的事情。</p><p id="3b71" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon:我们真的没有时间了，但是接下来我们将讨论开发API的工具？也许我们可以简单地说养蜂场很酷。让你做一些事情，让你定义API，甚至让你以一种模仿的方式滥用它，Swagger是一种定义API的语言，你可以在Apiary内部或其他工具中使用。我想你会想快速补充一下。</p><p id="257e" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Chris:再一次，如果你正在构建API，无论如何，请帮你自己一个忙，去使用这些工具中的一个。外面有很多这样的人。他们都很棒。Apiary，Swagger，Kong，他们都允许你定义你的API，为它提供了很好的文档，他们为你提供了模拟，这样你就可以开始运行了。您的客户端实际上可以点击API并获得响应，而无需编写任何代码。这真的是一个很好的方式，让我们开始真正关注实际的开发、规范和API的定义。所以，当你构建API的时候，一定要使用这些工具中的一个。</p><p id="9663" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:非常酷。很棒的谈话，谢谢你把这些放在一起，Rich，如果你还在的话。</p><p id="a104" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">里奇:是啊。抱歉，静音了。里奇睡着了。API…API…</p><p id="a4a0" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">Jon: Rich的公司Secret Stache一直在为我们开发一个API，供我们的客户建筑指导服务使用。最重要的是，里奇没有睡着，他自己也从中得到了一点好处。</p><p id="bf40" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">里奇:我是。</p><p id="62fa" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:太棒了。</p><p id="99ba" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:好的，非常感谢，克里斯和里奇。下周再聊。</p><p id="5f4f" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">克里斯:好吧。谢谢伙计们。再见。再见。</p><p id="1b59" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">乔恩:再见。</p><p id="5d01" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">里奇:以后吧。</p><p id="051b" class="pw-post-body-paragraph je jf hu jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb hn dt translated">亲爱的听众，你坚持到了最后。感谢您抽出时间，并邀请您继续与我们在线交流。这一集，以及显示笔记和其他宝贵的资源可在mobycast.fm/49.如果你有任何问题或额外的见解，我们鼓励你给我们留下评论。谢谢你，我们下周再见。</p></div></div>    
</body>
</html>