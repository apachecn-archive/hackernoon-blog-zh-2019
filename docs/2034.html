<html>
<head>
<title>PostgreSQL’s Exciting features, you should know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL 令人兴奋的特性，你应该知道</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/postgresqls-exciting-features-you-should-know-a516a441b8c4#2019-03-28">https://medium.com/hackernoon/postgresqls-exciting-features-you-should-know-a516a441b8c4#2019-03-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a120b72032dd13c397c2b50990c66634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIOuPjsDGmgRw8jzTFnsJg.jpeg"/></div></div></figure><p id="5738" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PostgreSQL 是一个强大的对象关系数据库系统，它扩展了 SQL 语言，并结合了许多功能，可以安全地存储和扩展最复杂的数据工作负载。</p><p id="6257" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PostgreSQL 附带了许多功能，旨在帮助开发人员构建应用程序，帮助管理员保护数据完整性和构建容错环境，以及管理无论大小的数据集的数据。</p><p id="b5c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我挑选了一些您可能没有看过但确实应该看的 PostgreSQL 特性，因为它们可以帮助您更快地将代码投入生产，使之更容易，并且通常可以用更少的代码和更少的工作量完成工作。</p><h1 id="3aa5" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">遗产</h1><p id="7db5" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">表继承允许将一组公共列提取到父表中，子表定义附加字段。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="2586" class="lm kb hu li b fv ln lo l lp lq">CREATE TABLE invoices (<br/>    invoice_number   int  NOT NULL PRIMARY KEY,<br/>    issued_on        date NOT NULL DEFAULT now()<br/>);<br/><br/>CREATE TABLE government_invoices (<br/>    department_id    text NOT NULL<br/>) INHERITS (invoices);</span></pre><p id="5bd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这反映了政府发票都是发票，只是多了一个属性的情况。上面的“政府发票”表共有 3 列。</p><p id="e9e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">添加行就像表是独立的一样:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="3a44" class="lm kb hu li b fv ln lo l lp lq">INSERT INTO invoices (invoice_number) VALUES (100);<br/><br/>INSERT INTO government_invoices<br/>    (invoice_number, department_id) VALUES (101, 'DOD');</span></pre><p id="57dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是当你选择:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="7dcb" class="lm kb hu li b fv ln lo l lp lq"><strong class="li hv">SELECT * FROM government_invoices;</strong></span><span id="e392" class="lm kb hu li b fv lr lo l lp lq"> invoice_number | issued_on  | department_id<br/>----------------+------------+---------------<br/>            101 | 2018-06-19 | DOD<br/></span><span id="ec6c" class="lm kb hu li b fv lr lo l lp lq"><strong class="li hv">SELECT * FROM invoices;</strong></span><span id="b299" class="lm kb hu li b fv lr lo l lp lq"> invoice_number | issued_on<br/>----------------+------------<br/>            100 | 2018-06-19<br/>            101 | 2018-06-19</span></pre><p id="e7be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在 Postgres 中使用表继承有一些主要原因。</p><p id="29d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">比方说，我们有一些发票所需的表格，这些表格每个月都要创建和填写:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="db94" class="lm kb hu li b fv ln lo l lp lq">invoices<br/>    - <!-- -->invoices<!-- -->_2010_04 (inherits <!-- -->invoices<!-- -->)<br/>    - <!-- -->invoices<!-- -->_2010_05 (inherits <!-- -->invoices<!-- -->)</span></pre><p id="44b3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么是什么让继承成为一个很酷的特性呢——为什么拆分数据很酷呢？</p><ul class=""><li id="2743" class="ls lt hu je b jf jg jj jk jn lu jr lv jv lw jz lx ly lz ma dt translated"><strong class="je hv">性能</strong>:在选择数据时，我们从日期在 X 和 Y 之间的发票中选择*，Postgres 只使用有意义的表格。例如，SELECT * FROM invoices WHERE date BETWEEN ' 2010–04–01 ' AND ' 2010–04–15 '只扫描 invoices_2010_04 表，其他所有表都不会被触动！</li><li id="efd8" class="ls lt hu je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je hv">索引大小</strong>:我们没有在列日期有大索引的大表。我们每个月都有小表和小索引，读取速度更快。</li><li id="f7b7" class="ls lt hu je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated"><strong class="je hv">维护</strong>:我们可以在每个月表上运行 vacuum full、reindex、cluster，而不锁定所有其他数据</li></ul><h1 id="6124" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">数据类型</h1><p id="f93e" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">PostgreSQL 为用户提供了丰富的原生数据类型。用户可以使用 CREATE TYPE 命令向 PostgreSQL 添加新类型。</p><p id="d5d4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了数字、浮点、字符串、布尔和日期类型，PostgreSQL 还支持 uuid、货币、枚举、几何、二进制、网络地址、位字符串、文本搜索、xml、json、数组、复合和范围类型，以及一些用于对象标识和日志位置的内部类型。平心而论，MySQL、MariaDB 和 Firebird 都不同程度地拥有其中的一些，但只有 PostgreSQL 支持全部。</p><p id="ec35" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们仔细看看其中的几个:</p><h1 id="dc8a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">JSON</h1><p id="2820" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">PostgreSQL 支持原生 JSON 数据类型。它提供了许多操作 JSON 数据的函数和操作符。</p><p id="e173" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们开始练习 JSON 数据类型。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="afd3" class="lm kb hu li b fv ln lo l lp lq">CREATE TABLE orders (<br/>ID serial NOT NULL PRIMARY KEY,<br/>info json NOT NULL <br/>);</span></pre><p id="5100" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">插入 JSON 数据</strong></p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a614" class="lm kb hu li b fv ln lo l lp lq">INSERT INTO orders (info)<br/>VALUES(<br/>'{ "customer": "John Doe", "items": {"product": "Bag",qty": 6}}'<br/>);</span></pre><p id="2767" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们同时插入多行。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="e1db" class="lm kb hu li b fv ln lo l lp lq">INSERT INTO orders (info)<br/>VALUES<br/>('{ "customer": "Lily Bush", "items": {"product": "Diaper","qty": 24}}'<br/>),<br/>('{ "customer": "Josh William", "items": {"product": "Toy Car","qty": 1}}'<br/>),<br/>('{ "customer": "Mary Clark", "items": {"product": "Toy Train","qty": 2}}'<br/>);</span></pre><p id="9932" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">查询 JSON 数据</strong></p><p id="d9da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要查询 JSON 数据，可以使用<code class="eh mg mh mi li b"><a class="ae mj" href="http://www.postgresqltutorial.com/postgresql-select/" rel="noopener ugc nofollow" target="_blank">SELECT</a></code>语句，这类似于查询其他本地数据类型:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="f5d5" class="lm kb hu li b fv ln lo l lp lq">SELECT info FROM orders;</span></pre><p id="8e00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">输出:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="25e5" class="lm kb hu li b fv ln lo l lp lq">info         <br/>----------------------------------------------------------------<br/> { "customer": "John Doe", "items": {"product": "Bag",qty": 6}}<br/> { "customer": "Lily Bush", "items": {"product": "Diaper","qty": 24}}'<br/>{ "customer": "Josh William", "items": {"product": "Toy Car","qty": 1}}<br/> '{ "customer": "Mary Clark", "items": {"product": "Toy Train","qty": 2}}</span></pre><p id="0c21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PostgreSQL 提供了两个本地操作符<code class="eh mg mh mi li b">-&gt;</code>和<code class="eh mg mh mi li b">-&gt;&gt;</code>来帮助您查询 JSON 数据。</p><ul class=""><li id="7cff" class="ls lt hu je b jf jg jj jk jn lu jr lv jv lw jz lx ly lz ma dt translated">运算符<code class="eh mg mh mi li b">-&gt;</code>通过键返回 JSON 对象字段。</li><li id="bf75" class="ls lt hu je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated">操作符<code class="eh mg mh mi li b">-&gt;&gt;</code>通过文本返回 JSON 对象字段。</li></ul><p id="0f78" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下查询使用运算符<code class="eh mg mh mi li b">-&gt;</code>以 JSON 的形式获取所有客户:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="eff5" class="lm kb hu li b fv ln lo l lp lq">SELECT info -&gt; 'customer' AS customer<br/>FROM orders;</span></pre><p id="e833" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的查询使用运算符<code class="eh mg mh mi li b">-&gt;&gt;</code>以文本形式获取所有客户:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="ccb1" class="lm kb hu li b fv ln lo l lp lq">SELECT info -&gt;&gt; 'customer' AS customer<br/>FROM orders;</span></pre><p id="434d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mg mh mi li b">-&gt;</code>操作符返回一个 JSON 对象，你可以用操作符<code class="eh mg mh mi li b">-&gt;&gt;</code>链接它来检索一个特定的节点。例如，以下语句返回所有售出的产品:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="75de" class="lm kb hu li b fv ln lo l lp lq">SELECT<br/>info -&gt; 'items' -&gt;&gt; 'product' as product<br/>FROM orders<br/>ORDER BY product;</span></pre><p id="35f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在 WHERE 子句中使用 JSON 运算符</strong></p><p id="a1c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以在<code class="eh mg mh mi li b"><a class="ae mj" href="http://www.postgresqltutorial.com/postgresql-where/" rel="noopener ugc nofollow" target="_blank">WHERE</a></code>子句中使用 JSON 操作符来过滤返回的行。例如，为了找出谁买了<code class="eh mg mh mi li b">Diaper</code>，我们使用以下查询:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="e3f2" class="lm kb hu li b fv ln lo l lp lq">SELECT<br/>info -&gt;&gt; 'customer' AS customer<br/>FROM orders<br/>WHERE info -&gt; 'items' -&gt;&gt; 'product' = 'Diaper'</span></pre><p id="ed1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了找出谁一次购买了两种产品，我们使用以下查询:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="0a12" class="lm kb hu li b fv ln lo l lp lq">SELECT<br/>info -&gt;&gt; 'customer' AS customer,<br/>info -&gt; 'items' -&gt;&gt; 'product' AS product<br/>FROM orders<br/>WHERE<br/>CAST ( info -&gt; 'items' -&gt;&gt; 'qty' AS INTEGER ) = 2</span></pre><h1 id="b701" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">排列</h1><p id="3ff2" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">数组在 PostgreSQL 中起着重要的作用。PostgreSQL 允许您将列定义为任何有效数据类型的数组，包括内置类型、用户定义类型或枚举类型。</p><p id="eee9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的 CREATE TABLE 语句创建了一个将<code class="eh mg mh mi li b">phones</code>列定义为文本数组的<code class="eh mg mh mi li b">contacts</code>表。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="f5b0" class="lm kb hu li b fv ln lo l lp lq">CREATE TABLE contacts (<br/>id serial PRIMARY KEY,<br/>name VARCHAR (100),<br/>phones TEXT []<br/>);</span></pre><p id="4ce9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mg mh mi li b">phones</code>列是一个一维数组，保存一个联系人可能有的各种电话号码。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="42b2" class="lm kb hu li b fv ln lo l lp lq">INSERT INTO contacts (name, phones)<br/>VALUES<br/>('John Doe',ARRAY [ '(408)-589-5846','(408)-589-5555' ]<br/>);</span></pre><p id="540b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">插入 PostgreSQL 数组值</strong></p><p id="1775" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下语句将新联系人插入到<code class="eh mg mh mi li b">contacts</code>表中。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="57fc" class="lm kb hu li b fv ln lo l lp lq">INSERT INTO contacts (name, phones)<br/>VALUES<br/>('Lily Bush','{"(408)-589-5841"}'<br/>),<br/>('William Gate','{"(408)-589-5842","(408)-589-58423"}'<br/>);</span></pre><p id="231c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">查询数组数据</strong></p><p id="11a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以使用 SELECT 语句查询数组数据，如下所示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="3904" class="lm kb hu li b fv ln lo l lp lq">SELECT name,phones<br/>FROM contacts;</span></pre><p id="d00b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用方括号<code class="eh mg mh mi li b">[]</code>中的下标来访问数组元素。默认情况下，PostgreSQL 对数组元素使用从 1 开始的编号。这意味着第一个数组元素从数字 1 开始。假设，我们想要获得联系人的姓名和第一个电话号码，我们使用以下查询:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="80b7" class="lm kb hu li b fv ln lo l lp lq">SELECT name, phones [ 1 ]<br/>FROM contacts;</span></pre><p id="1077" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以在 WHERE 子句中使用数组元素作为过滤行的条件。例如，为了找出谁的第二个电话号码是电话号码(408)-589–58423，我们使用以下查询。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="70e6" class="lm kb hu li b fv ln lo l lp lq">SELECT name<br/>FROM  contacts<br/>WHERE phones [ 2 ] = '(408)-589-58423';</span></pre><p id="5497" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">修改 PostgreSQL 数组</strong></p><p id="240e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PostgreSQL 允许您更新数组的每个元素或整个数组。以下语句更新了 William Gate 的第二个电话号码。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="ce75" class="lm kb hu li b fv ln lo l lp lq">UPDATE contacts<br/>SET phones [ 2 ] = '(408)-589-5843'<br/>WHERE<br/>ID = 3;</span></pre><h1 id="968d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">hstore</h1><p id="b899" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">hstore 模块实现了 hstore 数据类型，用于将键值对存储在单个值中。hstore 数据类型在许多情况下非常有用，例如半结构化数据或具有许多很少被查询的属性的行。</p><p id="d309" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在使用 hstore 数据类型之前，需要启用 hstore 扩展。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="4726" class="lm kb hu li b fv ln lo l lp lq">CREATE EXTENSION hstore;</span></pre><p id="cf60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用 CREATE TABLE 语句创建 books 表，如下所示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="c59b" class="lm kb hu li b fv ln lo l lp lq">CREATE TABLE books (<br/> id serial primary key,<br/> title VARCHAR (255),<br/> attr hstore<br/>);</span></pre><p id="0a3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用 INSERT 语句将数据插入 hstore 列，如下所示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="238d" class="lm kb hu li b fv ln lo l lp lq">INSERT INTO books (title, attr)<br/>VALUES<br/> (<br/> 'PostgreSQL Tutorial',<br/> '"paperback" =&gt; "243",<br/>  "publisher" =&gt; "postgresqltutorial.com",<br/>  "language"  =&gt; "English",<br/>  "ISBN-13"   =&gt; "978-1449370000",<br/>  "weight"    =&gt; "11.2 ounces"'<br/> );</span></pre><p id="7b31" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Postgresql hstore 提供了<code class="eh mg mh mi li b">-&gt;</code>操作符来查询 hstore 列中特定键的值。例如，如果我们想知道<code class="eh mg mh mi li b">books</code>表中所有可用书籍的 ISBN-13，我们可以如下使用<code class="eh mg mh mi li b">-&gt;</code>操作符:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="06c8" class="lm kb hu li b fv ln lo l lp lq">SELECT <br/>attr -&gt; 'ISBN-13' AS isbn <br/>FROM <br/>books;</span></pre><h1 id="1968" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">数据完整性</h1><p id="1e33" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">PostgreSQL 更可靠，因为它是 ACID(原子性、一致性、隔离性和持久性)兼容的，这意味着查询将保持数据完整性，并无错误地返回相同的输出。PostgreSQL 以其坚如磐石的引用和事务完整性而闻名。主键、限制和级联外键、唯一约束、非空约束、检查约束和其他数据完整性功能确保只存储经过验证的数据。</p><p id="d5cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">MySQL 和 MariaDB 正在努力使 InnoDB/XtraDB 存储引擎符合 SQL 标准。他们现在提供了一个使用 SQL 模式的<code class="eh mg mh mi li b">STRICT</code>选项，它决定了所使用的数据验证检查；但是，根据您使用的模式，在更新时可能会插入或创建无效的、有时会被静默截断的数据。这两个数据库目前都不支持 check 约束，而且对于外键约束也有许多警告。</p><h1 id="0042" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated"><strong class="ak">区分大小写</strong></h1><p id="3f58" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">对于字符串比较，PostgreSQL 区分大小写。字段“史密斯”与字段“史密斯”不同。在查询中使用正确的大小写。(即其中 name='Smith ')。PostgreSQL 有一个不区分大小写的操作符，比如 ILIKE</p><h1 id="341d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">自定义类型和函数</h1><p id="2825" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">PostgreSQL 提供了强大的内置运算符和函数，包括那些支持专用数据类型的运算符和函数，但它也允许您创建自己的运算符和函数(包括聚合)以及自定义存储过程和触发器。让我们看一个简单的函数例子。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="a290" class="lm kb hu li b fv ln lo l lp lq">CREATE TYPE datetext AS (</span><span id="fc53" class="lm kb hu li b fv lr lo l lp lq">date date,</span><span id="e7e4" class="lm kb hu li b fv lr lo l lp lq">date_as_text text);</span><span id="955f" class="lm kb hu li b fv lr lo l lp lq">CREATE FUNCTION show_date_as_text(date)</span><span id="f671" class="lm kb hu li b fv lr lo l lp lq">RETURNS datetext -- this is our composite type</span><span id="d52a" class="lm kb hu li b fv lr lo l lp lq">AS   $$ SELECT $1, to_char($1, 'FMMonth FMDD, YYYY') $$</span><span id="ab2c" class="lm kb hu li b fv lr lo l lp lq">LANGUAGE SQL;</span><span id="ddf4" class="lm kb hu li b fv lr lo l lp lq">SELECT show_date_as_text('2015-01-01');</span><span id="2cf2" class="lm kb hu li b fv lr lo l lp lq">-- Returns: (2015-01-01,"January 1, 2015")</span></pre><h1 id="bc35" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">错误处理</h1><p id="ff1e" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">发生错误时，Postgresql 会返回正确的错误消息。请看下面的图片。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/c8423db22cdde358cb9086a5b0cca694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-s02PNp_7MUGd6h1L8Few.png"/></div></div><figcaption class="ml mm fg fe ff mn mo bd b be z ek">postgresql error message</figcaption></figure><p id="3a3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是当执行上述相同的 sql 时，什么返回 mysql。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/445aa35bf31814560d3b984b425fcd8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQlkuYWhLAwMYU_c96TnnQ.png"/></div></div></figure><h1 id="e669" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">组合查询</h1><p id="2f42" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">PostgreSQL 为<code class="eh mg mh mi li b">SELECT</code>语句之间的交互提供了<code class="eh mg mh mi li b">UNION</code>、<code class="eh mg mh mi li b">INTERSECT</code>和<code class="eh mg mh mi li b">EXCEPT</code>子句。<code class="eh mg mh mi li b">UNION</code>会将第二条<code class="eh mg mh mi li b">SELECT</code>语句的结果追加到第一条语句的结果中。<code class="eh mg mh mi li b">INTERSECT</code>只返回与两个<code class="eh mg mh mi li b">SELECT</code>语句都匹配的行。<code class="eh mg mh mi li b">EXCEPT</code>只返回第一个<code class="eh mg mh mi li b">SELECT</code>语句中与第二个<code class="eh mg mh mi li b">SELECT</code>语句中的行不匹配的行。</p><p id="d097" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然 MySQL、MariaDB 和 Firebird 都支持<code class="eh mg mh mi li b">UNION</code>，但它们都不支持<code class="eh mg mh mi li b">INTERSECT</code>或<code class="eh mg mh mi li b">EXCEPT</code>。但是，通过在查询中使用连接和<code class="eh mg mh mi li b">EXISTS</code>条件，可以获得与 PostgreSQL 相同的结果。</p><h1 id="9e2f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">窗口功能</h1><p id="9038" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">一个<em class="mq">窗口函数</em>在一组与当前行有某种关系的表格行上执行计算。这与聚合函数可以完成的计算类型相当。</p><p id="ac4b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">与聚合函数类似，窗口函数对一组行进行操作，但它不会减少查询返回的行数。</p><p id="1ecc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mg mh mi li b">OVER</code>关键字，可选与<code class="eh mg mh mi li b">PARTITION BY</code>和<code class="eh mg mh mi li b">ORDER BY</code>一起使用，表示正在使用窗口功能。注意，<code class="eh mg mh mi li b">WINDOW</code>子句在带有窗口函数的查询中不是必需的，但是它允许您创建和命名窗口，以帮助保持事物的完整性。</p><p id="e0b8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个示例，展示了如何将每个员工的工资与其所在部门的平均工资进行比较:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="db03" class="lm kb hu li b fv ln lo l lp lq">SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;</span></pre><p id="c1c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">输出:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="16ee" class="lm kb hu li b fv ln lo l lp lq">depname  | empno | salary |          avg          <br/>-----------+-------+--------+-----------------------<br/> develop   |    11 |   5200 | 5020.0000000000000000<br/> develop   |     7 |   4200 | 5020.0000000000000000<br/> develop   |     9 |   4500 | 5020.0000000000000000<br/> develop   |     8 |   6000 | 5020.0000000000000000<br/> develop   |    10 |   5200 | 5020.0000000000000000<br/> personnel |     5 |   3500 | 3700.0000000000000000<br/> personnel |     2 |   3900 | 3700.0000000000000000<br/> sales     |     3 |   4800 | 4866.6666666666666667<br/> sales     |     1 |   5000 | 4866.6666666666666667<br/> sales     |     4 |   4800 | 4866.6666666666666667</span></pre><p id="15a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">前三个输出列直接来自表<code class="eh mg mh mi li b">empsalary</code>，表中的每一行都有一个输出行。第四列表示与当前行具有相同<code class="eh mg mh mi li b">depname</code>值的所有表格行的平均值。(这实际上与非窗口的<code class="eh mg mh mi li b">avg</code>集合是同一个函数，但是<code class="eh mg mh mi li b">OVER</code>子句使得它被当作一个窗口函数，并在整个窗口框架中进行计算。)</p><h1 id="c44c" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">检查约束</h1><p id="f185" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">以下语句定义了一个<code class="eh mg mh mi li b">employees</code>表。</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="91fe" class="lm kb hu li b fv ln lo l lp lq">CREATE TABLE employees (</span><span id="3cb5" class="lm kb hu li b fv lr lo l lp lq">id serial PRIMARY KEY,</span><span id="0e84" class="lm kb hu li b fv lr lo l lp lq">first_name VARCHAR (50),</span><span id="5a51" class="lm kb hu li b fv lr lo l lp lq">last_name VARCHAR (50),</span><span id="e4f7" class="lm kb hu li b fv lr lo l lp lq">birth_date DATE CHECK (birth_date &gt; '1900-01-01'),</span><span id="af41" class="lm kb hu li b fv lr lo l lp lq">joined_date DATE CHECK (joined_date &gt; birth_date),</span><span id="fe93" class="lm kb hu li b fv lr lo l lp lq">salary numeric CHECK(salary &gt; 0)</span><span id="0b1d" class="lm kb hu li b fv lr lo l lp lq">);</span></pre><p id="bba8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mg mh mi li b">employees</code>工作台有三个<code class="eh mg mh mi li b">CHECK</code>约束:</p><ul class=""><li id="fc0c" class="ls lt hu je b jf jg jj jk jn lu jr lv jv lw jz lx ly lz ma dt translated">首先，员工的出生日期(<code class="eh mg mh mi li b">birth_date</code>)必须大于<code class="eh mg mh mi li b">01/01/1900</code>。如果您试图在<code class="eh mg mh mi li b">01/01/1900</code>之前插入出生日期，您将会收到一条错误消息。</li><li id="cb4d" class="ls lt hu je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated">第二，加入日期(<code class="eh mg mh mi li b">joined_date</code>)必须大于出生日期(<code class="eh mg mh mi li b">birth_date</code>)。这项检查将防止根据语义更新无效日期。</li><li id="b932" class="ls lt hu je b jf mb jj mc jn md jr me jv mf jz lx ly lz ma dt translated">第三，工资必须大于零，这一点很明显。</li></ul><h1 id="a0c5" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">分片</h1><p id="0ad3" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">分片只是数据库“水平分区”的另一个名称。分片是将单个数据库分成更小、更易管理的块，并将这些块分布在多个服务器上，以便分散负载并保持高吞吐量</p><p id="81f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，它有助于最小化数据库查询的响应时间。</p><p id="d61f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二，你可以使用更便宜的“低端”机器来存放你的数据，而不是一个大型服务器，后者可能已经不够用了。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/1ac71a2c40d53bfaf42b45b35ff020e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5cxOyczY7I3vi4YC"/></div></div></figure><p id="4530" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PostgreSQL 为以下形式的分区提供了内置支持:</p><p id="456c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">范围划分</strong></p><p id="eee3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该表被划分为由一个键列或一组列定义的“范围”，分配给不同分区的值的范围之间没有重叠。例如，可以按日期范围或特定业务对象的标识符范围进行分区。</p><p id="d94d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">列表分区</strong></p><p id="2c36" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过明确列出每个分区中出现的键值来对表进行分区。</p><p id="5482" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="418d" class="lm kb hu li b fv ln lo l lp lq">CREATE TABLE measurement (<br/>    city_id         int not null,<br/>    logdate         date not null,<br/>    peaktemp        int,<br/>    unitsales       int<br/>) PARTITION BY RANGE (logdate);</span><span id="a1e5" class="lm kb hu li b fv lr lo l lp lq">CREATE TABLE measurement_y2006m02 PARTITION OF measurement<br/>    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');<br/><br/>CREATE TABLE measurement_y2006m03 PARTITION OF measurement<br/>    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');</span></pre><p id="df88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">PostgreSQL 一天比一天丰富，具有内置特性和无数种方式，我们可以定制或扩展它来满足我们的需求。</p><p id="8a34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然我已经介绍了一些使 PostgreSQL 有别于其他开源 SQL 解决方案的功能——还有更多的功能，但我希望这篇文章能帮助您大致了解为什么选择 PostgreSQL。</p><p id="7761" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读。</p></div></div>    
</body>
</html>