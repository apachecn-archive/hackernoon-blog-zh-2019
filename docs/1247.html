<html>
<head>
<title>Is a Shared Database in Microservices Actually an Anti-pattern?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务中的共享数据库实际上是反模式吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4?source=collection_archive---------1-----------------------#2019-02-21">https://medium.com/hackernoon/is-shared-database-in-microservices-actually-anti-pattern-8cc2536adfe4?source=collection_archive---------1-----------------------#2019-02-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c2a41a6250f550db8af4fcffa43e9189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EJtfNAzw-0vgXS_A"/></div></div></figure><p id="1a91" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我曾经参与过几个利用微服务理念的项目。一直存在的一个问题(除了部署，但是有足够的DevOps资源，这个问题基本上是可以解决的)是关注点的分离。</p><p id="f0b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你看看关于微服务架构的书籍、博客帖子和推文(已经有几百万了)，你会发现每个人都声明了几乎相同的想法——微服务必须是独立的。这完全说得通。但是在文字上。</p><p id="2902" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，如果你想构建精确的微服务，而不仅仅是带有一些辅助服务的整体，你必须考虑拆分你的业务领域。在这里你不太可能找到任何好的建议。首先，在许多情况下，这是无法完全解决的，其次，在与项目经理会面后，你的业务领域将会改变，打破所有现有的架构。你可能知道经理们对重构的态度。</p><p id="40e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以人们通常所做的，最终都是妥协。好吧，我们的服务会有点耦合，但是我们有我们的交叉服务API，为什么不利用它呢。</p><h1 id="7bb0" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">应用程序接口</h1><p id="09f4" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">让我们考虑一下经典的例子，我们有两个服务:用户和订单。我们决定遵循<em class="ld">信息隐藏</em>模式，其中每个服务封装自己的数据库(或者是数据库的一部分)。</p><p id="b39a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">显然，我们的<em class="ld">订单</em>服务需要来自<em class="ld">用户</em> one的一些信息。例如，我们有API端点<em class="ld">报告</em>，它给出了某一天用户所有订单的扩展信息。在报告中，我们需要用户的名字，姓氏和联系人。这样的端点是关注点分离的一个很好的例子。我们需要两个微服务的数据。但是没有回头路，服务是分的，有任务，需要做。我们有哪些选择？</p><h2 id="1629" class="le kb hu bd kc lf lg lh kg li lj lk kk jn ll lm ko jr ln lo ks jv lp lq kw lr dt translated">同步API</h2><p id="979b" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">一般都是HTTP。大多数情况下是REST，但可以是任何基于HTTP的API框架，比如GraphQL、OData甚至gRPC。所以流程非常简单，<em class="ld">订单</em>服务从数据库中获取数据，它可以访问数据库。然后，它向用户服务发送请求，以获取缺失的用户信息。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/60a74ef84352e155616ae3b2d1e4c7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*BHLa_zL9PX8gMn-kua3hhw.png"/></div></figure><p id="2599" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在<em class="ld">订单</em>服务从<em class="ld">用户</em>服务获得数据之前，我们的请求者不会获得响应。如果<em class="ld">用户</em>失败，<em class="ld">订单</em>也失败。</p><p id="ae4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是同步API的问题，是直接依赖。</p><h2 id="e1a0" class="le kb hu bd kc lf lg lh kg li lj lk kk jn ll lm ko jr ln lo ks jv lp lq kw lr dt translated">异步API</h2><p id="0678" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">因此，我们可以将API改为异步传输，例如流。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/b6848bf2a0e0e97612d317d04dccec10.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*VXGtV0wDEjS7HIGWvso1Vw.png"/></div></figure><p id="2470" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但现在唯一的区别是，我们不会收到任何来自用户服务的响应，而不是立即失败。因此，请求者可能会以超时结束。</p><h1 id="8f7c" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">为什么我们要分割数据库</h1><p id="6938" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">我们分开访问数据的原因是旧的好的<strong class="je hv">封装</strong>。我们降低了一些奇怪的服务对数据进行意外修改的风险。这就是为什么我们在OOP中将类变量私有，并使用容器来运行我们的服务。问题是数据不属于我们微服务。它属于数据库，是完全不同的服务。用用户微服务封装数据库数据，我们基本上把它作为数据库的<strong class="je hv">代理</strong>。当然，也有服务对数据进行充分转换的情况，但在这种情况下，它已经是新数据，属于该微服务。这样的数据肯定可以通过服务API请求。</p><p id="9431" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是当我们的服务只是一个数据库的CRUD接口时，我们做了大量额外的工作，增加了复杂性和网络负载(因此我们看到有人试图使用像<strong class="je hv">服务网格</strong>这样的技术来解决这个问题),只是因为我们想要遵循规则。</p><h1 id="2058" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">有什么解决办法？</h1><p id="76bb" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">所以让我们暂时抛开偏见，建立一个共享的数据库。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/0969fface1715273f3f423688548a02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*jcGvX6sXKdxc9yOc4_tw4Q.png"/></div></figure><p id="a82d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了偏见，我们还消除了额外的API、网络负载(可以通过一次查询从数据库中连接和检索数据)以及应用程序的充分改进的性能。</p><p id="54ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是当然也有新的问题:</p><ol class=""><li id="ad52" class="lx ly hu je b jf jg jj jk jn lz jr ma jv mb jz mc md me mf dt translated">订单服务必须知道用户服务表</li><li id="e401" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated"><em class="ld">用户</em>可以改变其表的模式</li><li id="bafe" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated"><em class="ld">订单</em>服务可以写给用户并修改它的数据</li><li id="0bd6" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated">我们必须为两种微服务使用一个数据库</li></ol><p id="0440" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">看起来我们又一次打破了关注点的分离。但是让我们考虑所有的问题。</p><ol class=""><li id="6ac9" class="lx ly hu je b jf jg jj jk jn lz jr ma jv mb jz mc md me mf dt translated">是的，<em class="ld"> Orders </em>基本上必须知道所有的表和数据库模式。但是在信息隐藏设计的情况下，服务必须知道API方法，这仍然是同类的额外知识。</li><li id="554c" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated">改变模式是一个真正的问题。但是基本上改变DB模式和服务API没有太大区别。在这两种情况下，你可以使它向后兼容，在这两种情况下，你可以打破一切。所以这纯粹是纪律问题。当然，你的服务团队分离得越多，那么你可能应该更多地转向API的方向。</li><li id="ff6f" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated">是的，默认情况下，我们的<em class="ld"> Orders </em>服务可以修改数据库中的所有表。但是如果您的数据库允许，您可以利用DB ACL来实现这一点。大多数主流数据库都支持表级ACL。因此，您可以像对待私有变量和方法一样避免意外修改的风险。</li><li id="133e" class="lx ly hu je b jf mg jj mh jn mi jr mj jv mk jz mc md me mf dt translated">是的，你必须使用一个数据库。但是我们只考虑拆分业务域的情况。如果您的服务需要一种特殊类型的数据库，那么使用API与它通信无疑是一个很好的例子。</li></ol><p id="fde9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，开发人员达成了共识(如果可能的话),在最开始你可能不需要微服务。从monolith开始，看看你将来是否真的需要它们。</p><p id="5b8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，当您这样做时，更容易保持共享数据库，只需为每个微服务创建单独的用户以限制数据访问。</p><p id="cbea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望这是有用的，我真的很感谢任何关于您的经验的反馈。</p><p id="e858" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ml" href="http://twitter.com/@raxpost" rel="noopener ugc nofollow" target="_blank"> Twitter </a>中找到我</p></div></div>    
</body>
</html>