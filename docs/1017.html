<html>
<head>
<title>JSON Web Tokens (JWT) Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JSON Web 令牌(JWT)揭秘</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/json-web-tokens-jwt-demystified-f7e202249640#2019-02-11">https://medium.com/hackernoon/json-web-tokens-jwt-demystified-f7e202249640#2019-02-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/cd80ee438f0d3a163a5f4ec6ed8bd90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDUa3wiFQft0ILDZJfn9JQ.png"/></div></div></figure><p id="c1fa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JSON Web Token (JWT，通常读作“jot”)是一个强大的工具，可以通过令牌在双方之间可靠地传输数据。这些团体可以由用户、服务器或任何其他服务组合组成。基于开放标准(RFC-7519)，jwt 使用加密算法进行数字签名，因此接收方可以信任其中包含的信息。在计算机安全中这个概念被称为<em class="ka">数据</em> <em class="ka">完整性。</em></p><p id="7e37" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用 JWT 的一个主要好处是它非常紧凑(假设发行者使用<em class="ka"> JWS 紧凑序列化</em>，这是推荐的)。它们通常足够小，可以通过 POST 请求、在 HTTP 头中发送，甚至作为 URL 中的查询字符串发送。然而，你添加到 JWT 的声明越多，它就变得越臃肿。您<em class="ka">可以</em>在理论上创建一个超过 URL 最大长度的 JWT(大约 2000 个字符)，但是不要这样做！最好只添加接收方<em class="ka">需要</em>的信息。</p><p id="5e11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JWT 也是自包含的，这意味着 JWT 可以巧妙地包含:</p><ul class=""><li id="2a7e" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">关于用户的识别信息</li><li id="a903" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">用户可以访问的内容</li><li id="53c3" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">截止日期</li><li id="26db" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">用于内容验证的签名</li><li id="ae12" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><em class="ka">任何其他可序列化的信息</em></li></ul><p id="80e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，任何人都可以在不知道私钥的情况下解码 JWT 中包含的信息。由于这个原因，你不应该把密码或密钥这样的秘密信息放在 JWT 中。JWT 的目的不是加密数据，使其无法在传输过程中被读取(这就是 SSL)，而是让接收方相信接收到的数据在传输过程中没有被更改。这样一来，我们就可以深入了解 JWT 的构成了。</p><h1 id="0685" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">JWT 的结构</h1><p id="7003" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">每个 JWT 都是用相同的结构生成的。有三个部分，中间用句号隔开。每个部分都由包含该令牌特定信息的<code class="eh ls lt lu lv b">base64url</code>编码的 JSON 组成。让我们来分解下面的各个部分:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lw"><img src="../Images/35c79e809052f8f73f848fbaf5c1ead9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AW6wxjHdpr4TlJgSpnS4EQ.png"/></div></div></figure><p id="26d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">表头:</strong></p><p id="2730" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一部分被称为<em class="ka">割台</em>。这是包含一些关键信息的地方:</p><ul class=""><li id="6e3e" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">alg</code>:用于令牌签名的算法(例如<code class="eh ls lt lu lv b">HS256</code>用于<em class="ka"> HMAC SHA-256，或者</em> <code class="eh ls lt lu lv b">RS256</code>用于 RSA SHA-256)。建议使用<code class="eh ls lt lu lv b">RS256</code>,因为它使用非对称(公共/私有)密钥，而不是依赖共享的私有密钥。</li><li id="77d5" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">x5t</code>:可选的证书指纹，包含对应于所使用的加密密钥的<code class="eh ls lt lu lv b">X.509</code>证书的<code class="eh ls lt lu lv b">base64url</code>编码的 SHA-1。</li><li id="292c" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">jku</code>:JSON Web Key(JWK)URL。我们将在下面的 JWK(S) <strong class="je hv"> </strong>小节中介绍这一点。</li><li id="c8d9" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">kid</code>:可选参数，表示使用了哪个加密密钥。这可以用作向接收者发出密钥已被更改的信号。</li><li id="2874" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">typ</code>:令牌的类型。该参数是完全可选的，但是如果是预置的，建议该值为“JWT”(总是大写)</li></ul><p id="9c49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这并不是您在本节中可以找到的所有参数的完整列表，而是您可能会遇到的一些更常见参数的重点。你可能已经注意到这一部分的主题是加密——这也是为什么你可能会看到这一部分被称为<em class="ka"> JSON Web Encryption (JWE)头</em>。</p><p id="ac88" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">有效载荷(索赔):</strong></p><p id="0174" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二部分是<em class="ka">有效负载</em>(也称为<em class="ka">声明</em>)，JWT 发行者可以在其中为接收方存储自定义信息。有效载荷中可以使用三种类型的声明:<em class="ka">公共</em>、<em class="ka">私有</em>和<em class="ka">注册</em>。</p><ul class=""><li id="0fde" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">公共声明必须是抗冲突的——所以它们应该是非常独特的，以确保没有两个公共声明有相同的名字。所有公共声明都应该在<em class="ka"> IANA JSON Web 令牌注册中心</em>中定义，或者定义为包含唯一名称空间的 URI。</li><li id="c17f" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je hv">另一方面，私有声明</strong>不必是抗冲突的，并且可以被命名为任何名称，只要发布方和接收方双方同意声明的使用。由于显而易见的原因，它也不能与公开的或注册的权利主张相冲突。</li><li id="3da2" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><strong class="je hv">已注册的权利要求</strong>是为特定目的保留的通用定义的权利要求。一些常见的注册索赔是:</li><li id="0428" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">aud</code>:代币受众(代币面向谁)</li><li id="5a8b" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">exp</code>:numeric date 格式的令牌过期。</li><li id="71cd" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">iat</code>:令牌发布时间(发布时间)</li><li id="b9d8" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">iss</code>:令牌发放者</li><li id="5cfb" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">jti</code>:令牌的唯一标识符</li><li id="575f" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">nbf</code>:不接受令牌之前的时间(不是之前)</li><li id="5acb" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><code class="eh ls lt lu lv b">sub</code>:令牌的主题</li></ul><p id="5c2c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">签名:</strong></p><p id="e46f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一部分是<em class="ka">签名</em>。这使得 JWT 安全，并确保您的 JWT 在运输过程中的完整性。签名只是用 JWT 生成的所有内容的散列。这意味着，如果 JWT 的任何部分发生变化，签名将失效，从而导致 JWT 的畸形。一个 JWT 用一个<em class="ka"> JSON Web 算法(JWA) </em>签名。生成<code class="eh ls lt lu lv b">RS256</code>签名的算法如下所示:</p><pre class="lx ly lz ma fq mb lv mc md aw me dt"><span id="d26c" class="mf kq hu lv b fv mg mh l mi mj">RSASHA256(<br/>  <em class="ka">base64UrlEncode</em>(<strong class="lv hv">header</strong>) + "." + <em class="ka">base64UrlEncode</em>(<strong class="lv hv">payload</strong>),<br/>  <strong class="lv hv">secret</strong><br/>)</span></pre><p id="1b57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如您所看到的，该算法将经过<code class="eh ls lt lu lv b">base64url</code>编码的<em class="ka">报头</em>和<em class="ka">有效载荷</em>与一个句点<em class="ka"> </em>连接在一起，并用一个<code class="eh ls lt lu lv b">secret</code>密钥对其进行签名，该密钥只有生成 JWT 的服务才知道。你也可以看到这被称为<em class="ka"> JSON 网络签名(JWS) </em>。</p><ul class=""><li id="4489" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je hv">重要提示</strong> : <em class="ka">总是</em>在接收端验证你的 jwt。假设 JWT 中的声明只是简单的<code class="eh ls lt lu lv b">base64url</code>编码，您可以解码 JWT，而不需要实际验证它来自哪里，或者它是否被正确签名。如果在解码时不验证 JWT，任何人都可以向您的应用程序发送定制的 JWT，从而使安全性变得无用。大多数 JWT 包和中间件会自动为您处理验证，但不要认为它们都会。</li></ul><p id="5bd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您的发行者使用<code class="eh ls lt lu lv b">RS256</code>(或另一种不对称算法)来签署令牌，您将需要一个公钥来验证令牌。但是如何获得公钥呢？很棒的问题！也是我们下一个话题的完美引子。</p><h1 id="8de3" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">JWK</h1><p id="3115" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">JSON Web Key (JWK)是一个 JSON 对象，它包含一个众所周知的公钥，可用于验证已签名 JWT 的签名。</p><p id="b490" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您的 JWT 的发行者使用非对称密钥来签署 JWT，它可能会托管一个名为 JSON Web Key Set (JWKS)的文件。JWKS 是一个包含属性<code class="eh ls lt lu lv b">keys</code>的 JSON 对象，该属性反过来保存一个 JWK 对象数组。请参见下面的 JWKS 示例:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/b467ebedc986d214a697ca55aef9da44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ynnc9JVorE0izJjOENn23A.png"/></div></div></figure><p id="5609" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该服务可能仅使用一个 JWK 来验证 web 令牌，但是如果该服务轮换签名证书，则 JWK 可能包含多个密钥。检索 JWK 的端点可能会有所不同，应该为您的发行者记录下来。例如，auth0 的标准位置是:<code class="eh ls lt lu lv b">https://YOUR-TENANT.auth0.com/.well-known/jwks.json</code>。另一方面，Okta 利用<code class="eh ls lt lu lv b">jwks_uri</code>元数据来存储端点。其他人可以利用上面讨论的<code class="eh ls lt lu lv b">jku</code> JWE 报头参数。</p><p id="b7e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每当您的应用程序验证一个 JWT 时，它都会尝试从发行者那里检索 JWK，以确保 JWT 签名与内容匹配。像<code class="eh ls lt lu lv b">node-jsonwebtoken</code>这样的开源包使这个过程变得简单。</p><h1 id="a7ae" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">JWT 用法</h1><p id="2763" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">JWT 通常通过 HTTP <code class="eh ls lt lu lv b">Authorization</code>报头作为承载令牌附加到 HTTP 请求上。请参见下面的示例(为便于阅读，添加了换行符):</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/c89eec84742279e7b2a42240151ccbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFhWURmT4dM3iIx2QO_mGw.png"/></div></div></figure><p id="045c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个请求都必须将 JWT 发送到后端，这是一个需要考虑的权衡。这种方法的最大好处是，它提供了一种无状态的身份验证形式，因为服务器不必记住会话存储中的用户信息，从而大大减少了在后端管理该状态所需的工作量。一个缺点是，由于 jwt 是无状态的，如果不存储会话状态，就不能使它们无效。jwt 在过期后会自动失效，但是根据过期时间的长短(通常为 10 小时)，用户可以在删除后保留对服务的访问。</p><h1 id="5ec1" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">把所有的放在一起</h1><p id="339f" class="pw-post-body-paragraph jc jd hu je b jf ln jh ji jj lo jl jm jn lp jp jq jr lq jt ju jv lr jx jy jz hn dt translated">理解生成和使用 JWT 背后的理论是很重要的，但我总是发现一个实际的例子有助于巩固理解。因此，我将为大家展示一个使用 JWT 的典型流程图:</p><figure class="lx ly lz ma fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/7870638a2b878fc211e0b289141c9464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44ZHD87hEdm2zNm7OHnrlg.png"/></div></div></figure><p id="c352" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想通过指出仅仅为了发送 JWT 而向服务器发送 JWT 是很奇怪的来澄清步骤 4-7。JWT 应该伴随实际的协议请求，如 HTTP 请求(<code class="eh ls lt lu lv b">POST</code> / <code class="eh ls lt lu lv b">PUT</code> / <code class="eh ls lt lu lv b">GET</code> / <code class="eh ls lt lu lv b">DELETE</code>)，作为该特定请求的凭证。此外，通过使用<code class="eh ls lt lu lv b">Authorization</code>头，它使您的查询字符串和有效负载没有多余的数据，因此它们可以保持整洁和集中。</p><p id="31a3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读，如果你觉得有用，请留下一些掌声！</p></div></div>    
</body>
</html>