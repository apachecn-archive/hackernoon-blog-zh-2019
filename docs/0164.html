<html>
<head>
<title>The evolution of asynchronous programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中异步编程的发展</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-evolution-of-asynchronous-programming-in-javascript-50c85859473d?source=collection_archive---------27-----------------------#2019-01-07">https://medium.com/hackernoon/the-evolution-of-asynchronous-programming-in-javascript-50c85859473d?source=collection_archive---------27-----------------------#2019-01-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7bff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我想谈谈我最近建立的一些东西，但首先我想提供背景，以便它可以被更广泛的观众理解。我将讲述多年的背景知识，并尝试解释一些术语，以便JavaScript开发新手也能理解本文。</p><h1 id="1ca1" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">回调地狱</h1><p id="7934" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">JavaScript本质上是异步的，但这意味着什么呢？一个<strong class="it hv">异步</strong>函数只是一个当函数返回时结果还没有准备好的函数。你可以把调用一个异步函数想象成调度一些要完成的工作，这些工作在将来可能最终会产生价值，也可能不会。我们如何获得这个值？一般的机制是传递一个函数，该函数将接收它作为一个参数，即一个<strong class="it hv">回调</strong>。</p><p id="7b33" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">链接异步函数，这样通过从一个回调到另一个异步函数调用一个异步函数，一个feed的结果进入另一个feed，可以导致所谓的<a class="ae ks" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">回调hell </strong> </a>:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h1 id="bdfa" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">承诺</h1><p id="c9cf" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">第一个提升是作为库解来的:<a class="ae ks" href="http://exploringjs.com/es6/ch_promises.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">承诺</strong> </a>。异步函数不接受回调，而是返回一个promise对象。最终，承诺要么<strong class="it hv">用一个值解析</strong>，要么<strong class="it hv">用一个错误拒绝</strong>。无论哪种方式，它都完成了。要知道这是什么时候发生的，可以分别用方法<code class="eh la lb lc ld b">then</code>和<code class="eh la lb lc ld b">catch</code>附加成功和/或失败回调。这些方法返回一个新的承诺，可以附加进一步的回调。如果一个回调函数返回值，它将被传递给链中的下一个<code class="eh la lb lc ld b">then</code>回调函数。如果它抛出一个异常，它将被传递给下一个<code class="eh la lb lc ld b">catch</code>回调。如果它返回一个承诺，它就被插入到链中的那个点。Promises通过用链式回调替换嵌套回调提供了缓解，链式回调通常被认为更容易阅读:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="5baa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(我将示例切换为使用与承诺同时到达语言标准的<a class="ae ks" href="http://exploringjs.com/es6/ch_arrow-functions.html" rel="noopener ugc nofollow" target="_blank">箭头函数</a>。我想用这些例子来展示艺术发展的现状。)</p><p id="6b6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，promises让我们可以整合多个异步函数的错误处理程序，就像一个try-catch语句可以处理多个函数调用一样。</p><p id="6e92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">承诺伴随着他们自己的问题。我们仍然在使用回调，它们只是被链接而不是嵌套。在多个回调之间共享一个异步结果的最流行的方法是将它保存到回调之外的变量中。异常用回调来处理，而不是我们熟悉的try-catch结构。与同步代码相比，它的可读性仍然较差。</p><h1 id="8170" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">发电机</h1><p id="cfc0" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="http://exploringjs.com/es6/ch_generators.html" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">生成器函数</strong> </a>是JavaScript函数，在最终返回之前<strong class="it hv">可能会产生</strong>多个值。它们是用特殊的<code class="eh la lb lc ld b">function*</code>语法在JavaScript中定义的:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="877a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">调用生成器函数不会开始执行该函数。相反，它返回一个代表函数调用的<strong class="it hv">生成器对象</strong>。您可以通过调用函数的<code class="eh la lb lc ld b">next</code>方法来单步执行该函数。第一次调用<code class="eh la lb lc ld b">next</code>时，它从头至尾执行函数，返回产生的值。<a class="ae ks" href="#b524" rel="noopener ugc nofollow"> </a>第二次调用<code class="eh la lb lc ld b">next</code>时，它会在产生的地方重新进入函数，用你传递给<code class="eh la lb lc ld b">next</code>的任何参数替换产生的表达式，并继续下一个<code class="eh la lb lc ld b">yield</code>。每次调用<code class="eh la lb lc ld b">next</code>都重复这个过程，直到函数最终返回或抛出(<a class="ae ks" href="https://repl.it/repls/TatteredPlasticProject" rel="noopener ugc nofollow" target="_blank"> REPL </a>):</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="72c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">代替<code class="eh la lb lc ld b">next</code>，你可以调用<code class="eh la lb lc ld b">throw</code>从yield表达式中抛出一个异常。生成器函数中的try-catch块可以捕获它，但是如果它未被捕获，它会将调用堆栈向上传递到您调用<code class="eh la lb lc ld b">throw</code> ( <a class="ae ks" href="https://repl.it/repls/MutedFatherlySuperuser" rel="noopener ugc nofollow" target="_blank"> REPL </a>)的作用域:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><p id="3319" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在学习发电机时，您可能会遇到几个相关的术语。步进代码(通过调用方法<code class="eh la lb lc ld b">next</code>和<code class="eh la lb lc ld b">throw</code>)和发生器(通过<code class="eh la lb lc ld b">yield</code>、<code class="eh la lb lc ld b">throw</code>、<code class="eh la lb lc ld b">return</code>)之间来回传递控制的方式称为<a class="ae ks" href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="noopener ugc nofollow" target="_blank">协同多任务</a>。这种“弹跳”就是为什么踏码被称为<a class="ae ks" href="https://en.wikipedia.org/wiki/Trampoline_(computing)" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">蹦床</strong> </a>的原因。最后，生成器是一种协程。</p><p id="0fcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">想象一下，如果我们写一个能产生承诺的生成器。我们可以将其与一个特殊的蹦床配对，该蹦床拦截每个产生的承诺，并添加成功和失败回调，通过分别调用<code class="eh la lb lc ld b">next</code>或<code class="eh la lb lc ld b">throw</code>将它们的参数传递回生成器。trampoline本身返回一个承诺，该承诺用生成器的返回值解决(或者用它唯一未捕获的异常拒绝)。这让我们能够以同步的方式编写异步代码:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h1 id="da95" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">异步函数</h1><p id="9972" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">这种模式被证明是如此受欢迎，以至于它被包含在带有本机语法的语言中，称为<a class="ae ks" href="https://developers.google.com/web/fundamentals/primers/async-functions" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">异步函数</strong> </a>。唯一的区别是<code class="eh la lb lc ld b">async(function* (...) {...})</code>变成了<code class="eh la lb lc ld b">async function (...) {...}</code>并且<code class="eh la lb lc ld b">yield</code>变成了<code class="eh la lb lc ld b">await</code>:</p><figure class="kt ku kv kw fq kx"><div class="bz el l di"><div class="ky kz l"/></div></figure><h2 id="aeaa" class="le jq hu bd jr lf lg lh jv li lj lk jz jc ll lm kd jg ln lo kh jk lp lq kl lr dt translated">脚注</h2><p id="1f95" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated"><a class="ae ks" href="#c9cf" rel="noopener ugc nofollow"> </a>实际上，<code class="eh la lb lc ld b">then</code>接受成功和失败两种回调，但两者都是可选的。<code class="eh la lb lc ld b">catch</code>只接受失败回调，与调用<code class="eh la lb lc ld b">then</code>回调不成功相同。</p><p id="b524" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae ks" href="#877a" rel="noopener ugc nofollow"> </a>实际上，<code class="eh la lb lc ld b">next</code>返回的是类似<code class="eh la lb lc ld b">{ value: any, done: bool }</code>的结构。<code class="eh la lb lc ld b">done</code>字段指示该值是来自返回语句(<code class="eh la lb lc ld b">true</code>)还是来自产出表达式(<code class="eh la lb lc ld b">false</code>)。</p></div></div>    
</body>
</html>