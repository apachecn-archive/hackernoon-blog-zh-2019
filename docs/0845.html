<html>
<head>
<title>Threads without efforts in Odi (Node.js)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Odi (Node.js)中没有努力的线程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/odi-threads-8bb9c3c94f6a?source=collection_archive---------7-----------------------#2019-02-04">https://medium.com/hackernoon/odi-threads-8bb9c3c94f6a?source=collection_archive---------7-----------------------#2019-02-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/94fc5aac2edad318aa894dd7b0100133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XYtsb2qHGC4fcRvwJIP3AQ.png"/></div></div></figure><h1 id="86b5" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="3cd1" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">多线程是同时执行两个或更多线程的过程。大多数编程语言都提供了一个API来方便地处理线程和并行性。开发人员可以专注于应用程序逻辑，而不是通信通道、同步或架构设置。</p><p id="c1fa" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="kc hv">节点10.5 </strong>增加了对带实验标志的<strong class="kc hv"> </strong> <code class="eh ld le lf lg b">worker_threads</code>模块的支持。但是从<strong class="kc hv">节点11.7 </strong>开始，此功能开箱即可使用。这是Node中多线程范例的良好开端。</p><p id="6468" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh ld le lf lg b">worker_threads</code>有巨大的潜力，所以Odi在早期就加入了对这个模块的支持。一如既往，Odi的目标是提供方便、干净和极简的API(用神奇的🧙‍♂️)，这样开发者就可以专注于开发，而不是设置。</p><h1 id="ee91" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">项目设置</h1><p id="82c4" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">从上一篇文章中，Odi获得了新的CLI命令，它初始化项目、定义脚本并安装所有需要的依赖项。</p><pre class="lh li lj lk fq ll lg lm ln aw lo dt"><span id="5069" class="lp jd hu lg b fv lq lr l ls lt">odi init</span></pre><p id="2a79" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">目前，只有几种选择:</p><pre class="lh li lj lk fq ll lg lm ln aw lo dt"><span id="ddcb" class="lp jd hu lg b fv lq lr l ls lt">-j, --jsx-templating  add jsx templates<br/>-d, --database        add typeorm integration</span></pre><h2 id="70b8" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">结构</h2><p id="b672" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">默认情况下，项目将具有以下结构。</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/fbe845987a29565042bdeb5f0a28d98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*rM0JN4xIll0-ZkYHi2-9Jw.png"/></div></figure><p id="704c" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">在命令执行期间，将根据模板类型安装所有必需的依赖项。此外，如果提供了<code class="eh ld le lf lg b">-j</code>标志，那么<strong class="kc hv">视图</strong>文件夹将被添加到项目根目录中。</p><h2 id="9bd3" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">源文件</h2><p id="23a5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">基本模板中有两个预定义的源文件。</p><p id="8868" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">包含基本Odi配置的<code class="eh ld le lf lg b">index.ts</code>文件。默认情况下，服务器端口设置为<code class="eh ld le lf lg b">8080</code></p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="d39b" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">和带有简单控制器定义的<code class="eh ld le lf lg b">home.controller.ts</code>文件。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="fc96" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">从Odi和开发入手就够了。</p><h2 id="48e8" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">剧本</h2><p id="5a34" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">目前，唯一的<code class="eh ld le lf lg b">npm start</code>脚本是现成的。在下一个版本中，<code class="eh ld le lf lg b">npm test</code>命令将可以使用Mocha和Chai。</p><p id="65a1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">只需运行以下命令</p><pre class="lh li lj lk fq ll lg lm ln aw lo dt"><span id="5132" class="lp jd hu lg b fv lq lr l ls lt">npm start</span></pre><p id="3189" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这个脚本包括编译和实际运行，所以完成后，你可以很容易地打开浏览器，检查<code class="eh ld le lf lg b">http://localhost:8080</code>网址。</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/dff764cf6fa019510a3a4c68b16d97a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*r57qiTH3VLPszvUJit3S2g.png"/></div></figure><h1 id="a059" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">线</h1><p id="5e82" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">根据设计，节点是单线程的，具有非阻塞I/O。这种方法有许多优点和缺点。主要优点是简单。开发者不需要关心线程操作、数据同步等等。但是任何资源密集型任务都会阻塞事件循环。</p><p id="3cdb" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">工作线程可以处理资源密集型操作，因此主线程始终可用。这对服务器端应用程序来说非常重要，因为任何阻塞任务都会延迟接受和处理新的客户端请求。</p><h2 id="6d6e" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">工作</h2><p id="3e11" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">让我们创建一个资源密集型(阻塞)函数，用于基于随机值生成获得答案(<em class="ml">是</em>或<em class="ml">否</em>)。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="4381" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">数学运算在大多数情况下是CPU密集型的，所以这是我们目标的一个很好的例子。使用<code class="eh ld le lf lg b">200_000_000</code>因子运行该功能需要花费<strong class="kc hv"> 5秒</strong>来执行。</p><h2 id="8c6b" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">阻塞</h2><p id="9c2a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">如上所述，任何阻塞操作在完成之前都不允许其他任务执行。</p><p id="90e5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">理解阻塞的最好方法是UI。举个例子，让我们使用<code class="eh ld le lf lg b">Ora</code>库将简单的CLI加载器添加到我们的应用程序中。</p><p id="4497" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">首先，我们需要安装它。</p><pre class="lh li lj lk fq ll lg lm ln aw lo dt"><span id="e202" class="lp jd hu lg b fv lq lr l ls lt">npm install ora @types/ora</span></pre><p id="8106" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">并按以下方式更改控制器方法。当处理程序被触发时，加载程序将出现在终端中，并一直旋转，直到我们的计算完成。此外，还将打印用于请求处理的时间。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="9588" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">让我们从浏览器启动我们的服务器和触发器处理程序。</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/01bbd7b4ae95727383179852b39de3b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/1*ngdqa4ZF_i26RfR2PS3plA.gif"/></div></figure><p id="1b16" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">加载器不旋转，因为我们的计算阻塞了进程。加载器必须有可能每隔<code class="eh ld le lf lg b">80</code>毫秒重新渲染一次帧，但是它不能这么做，因为事件循环被<code class="eh ld le lf lg b">getAnswer</code>调用阻塞了。</p><h2 id="b719" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">结果</h2><p id="005d" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">让我们想象一下，我们在实际的应用程序中有这样的代码。处理程序将阻止接受和处理新的客户端请求。会严重影响客户端体验。此类操作必须放入其他应用程序或其他线程中。</p><h1 id="0705" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">工人</h1><p id="f8d1" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Odi为多线程提供了方便的API。开发人员不需要考虑任何类型的设置。</p><h2 id="4309" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">定义</h2><p id="dfef" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在Odi应用程序和容器中定义<code class="eh ld le lf lg b">Worker</code>真的很容易。与<code class="eh ld le lf lg b">Service</code>定义有一些相似之处。我们来包装一下<code class="eh ld le lf lg b">getAnswer</code>函数。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="eaad" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">定义只需要<code class="eh ld le lf lg b">Worker</code>装饰器。现在我们可以将它作为其他依赖项注入到控制器中。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="55df" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">注意，<code class="eh ld le lf lg b">await</code>关键字必须在worker方法调用之前添加，即使它不是异步的，因为线程之间的通信是以异步方式完成的。</p><p id="f2bd" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">仅此而已！🧙‍♂️该方法将在另一个线程中执行，结果将返回给主线程。</p><h2 id="c395" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">回顾</h2><p id="315e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">现在，可以测试带有UI加载器的示例了。</p><figure class="lh li lj lk fq iv fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/1ec112d245521802f959e7d79ea21504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/1*5vuSyhjwYUO5jS9T3ZX7OQ.gif"/></div></figure><p id="8fd5" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一切正常。加载器正在旋转，因为代码在另一个线程中运行，所以UI可以重新呈现帧。</p><h2 id="5ec4" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">支票</h2><p id="ab32" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">为了确保该方法是在另一个线程中处理的，只需以下面的方式更改<code class="eh ld le lf lg b">getAnswer</code>。</p><figure class="lh li lj lk fq iv"><div class="bz el l di"><div class="mi mj l"/></div></figure><p id="91f1" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">关于线程的信息将在控制台中显示。</p><h2 id="29aa" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">比较</h2><p id="c8a1" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">正如您在上面看到的，workes设置和处理不需要任何配置。不需要像官方<a class="ae mn" href="https://nodejs.org/api/worker_threads.html#worker_threads_worker_threads" rel="noopener ugc nofollow" target="_blank">示例</a>中那样的事件发射器、事件处理程序、文件名等。Odi关心初始化、消息传递、方法调用和错误处理。</p><h2 id="94ab" class="lp jd hu bd je lu lv lw ji lx ly lz jm kl ma mb jq kp mc md ju kt me mf jy mg dt translated">限制</h2><p id="2ad5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">除了基本的，没有其他限制。请记住，worker类似于另一个应用程序，因此运行时实例不能在不同的线程之间访问。另外，<strong class="kc hv">依赖注入</strong>容器不能通过线程访问，所以每个线程都有自己的容器。</p><h1 id="c43f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">用例</h1><p id="70c5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">基本上，工作线程可以用于下一种方法:</p><ol class=""><li id="52d9" class="mo mp hu kc b kd ky kh kz kl mq kp mr kt ms kx mt mu mv mw dt translated">背景和计划任务</li><li id="2d52" class="mo mp hu kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw dt translated">资源密集型操作</li><li id="a3e5" class="mo mp hu kc b kd mx kh my kl mz kp na kt nb kx mt mu mv mw dt translated">基于队列的处理</li></ol><p id="2ce6" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这些方法可以很容易地改进和适应每一个特定的需求，但所有这些方法都可以提高性能和应用程序的灵活性。</p><h1 id="78f7" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">更大的</h1><p id="35d4" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">你可以在GitHub上查看Odi repo。</p><div class="nc nd fm fo ne nf"><a href="https://github.com/Odi-ts/odi" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hv fv z el nk eo ep nl er et ht dt translated">Odi-ts/odi</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">🌪🌌自以为是的、声明性的、惯用的框架，用于构建可扩展的、可支持的企业应用程序和…</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ja nf"/></div></div></a></div><p id="4f8d" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">另外，还有一篇关于Odi的有趣文章。</p><div class="nc nd fm fo ne nf"><a href="https://hackernoon.com/building-chat-with-odi-node-js-e77ecd3891b2" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hv fv z el nk eo ep nl er et ht dt translated">用Odi建立聊天(Node.js)</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">实时通信、项目设置、模板等等</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">hackernoon.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ja nf"/></div></div></a></div><p id="4f34" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">感谢阅读！欢迎留下任何反馈、想法或问题。</p><div class="nc nd fm fo ne nf"><a href="https://odi.nolt.io/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab ej"><div class="nh ab ni cl cj nj"><h2 class="bd hv fv z el nk eo ep nl er et ht dt translated">Nolt上的Odi</h2><div class="nm l"><h3 class="bd b fv z el nk eo ep nl er et ek translated">让我们知道如何改进。投票表决现有的想法或提出新的建议。用Nolt收集和组织反馈</h3></div><div class="nn l"><p class="bd b gc z el nk eo ep nl er et ek translated">odi.nolt.io</p></div></div><div class="no l"><div class="nv l nq nr ns no nt ja nf"/></div></div></a></div><p id="b1e4" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果你喜欢Odi，只需在GitHub上支持我们的start。🌟✨</p><p id="2d05" class="pw-post-body-paragraph ka kb hu kc b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">继续阅读，更多有趣的东西将在下一次更新中推出！😉🧙‍♂️</p></div></div>    
</body>
</html>