<html>
<head>
<title>Swift 5.0: What’s new, what’s changed, what’s missing, and what’s next?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.0:有什么新功能，有什么变化，缺少什么，下一步是什么？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/swift-5-0-whats-new-whats-changed-and-whats-missing-65d3fbf46f4#2019-01-28">https://medium.com/hackernoon/swift-5-0-whats-new-whats-changed-and-whats-missing-65d3fbf46f4#2019-01-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="db69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">距离 swift 5 的最终分支还有一个多月，我们应该会很快看到它，因为它宣布将于今年年初发布。有人说它将在 4 月晚些时候到来，因为 Swift 4.2 使用了相同的方法；它的最终分支是 2018 年 4 月 20 日，它于 2018 年 9 月 17 日发布。</p><p id="1026" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无论如何，我们急切地等待 swift 5.0，因为它将允许我们以一种漂亮的方式开发应用程序。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/716d2605403fe197ca2c3aa445c5929c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jey6kKZmDQArmCQvPeimgQ.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">The improving swift</figcaption></figure><h1 id="028a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">ABI 稳定性</h1><p id="9441" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">Swift 目前的首要任务之一是跨未来 Swift 版本的兼容性。其中的一个主要组成部分是 ABI 稳定性，这使得用不同版本的 Swift 编译的应用程序和库之间能够二进制兼容。</p><p id="f614" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果 Swift 成为 ABI 稳定版，Swift 将存在于 iOS 操作系统中，其 ABI 将与 Swift 的每个版本兼容。也就是说<code class="eh li lj lk ll b">App1</code>使用的是 Swift 5.0，而<code class="eh li lj lk ll b">App2</code>使用的是 Swift 5.3，他们都使用嵌入在操作系统中的 Swift ABI。</p><p id="3ec7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">我们会喜欢这个，因为</strong></p><ul class=""><li id="0331" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">包的大小将会减小</li><li id="3322" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">语言的变化会更小，更不频繁</li><li id="511f" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">需要较少的迁移工作</li><li id="8373" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">开发人员可以在 swift 中创建预编译框架(目前框架是在编译您的应用程序时编译的)</li></ul><p id="47d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来源:<a class="ae ma" href="https://swift.org/abi-stability/" rel="noopener ugc nofollow" target="_blank">https://swift.org/abi-stability/</a></p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="479b" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated">结果类型</h1><p id="0f43" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">这是许多人期待已久的功能！<code class="eh li lj lk ll b">Result</code>类型迫使程序员在获得实际值之前显式处理失败和成功案例。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="ebf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Swift 目前缺乏表达这种不可能性的能力。在相同的场景中使用<code class="eh li lj lk ll b">Result</code>可以得到更加优雅的代码:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="baf0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，我们可以编写更简洁、更易读的代码，来约束可能返回的确切错误类型。</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="223c" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated"><code class="eh li lj lk ll b">New BinaryInteger — isMultiple</code></h1><p id="39b6" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">目前，测试一个值是否为倍数的最常见方法是使用余数运算符(<code class="eh li lj lk ll b">%</code>)检查余数为零:<br/> <code class="eh li lj lk ll b">12 % 2 == 0 // returns true. 12 is a multiple of 2</code></p><p id="5a87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似地，测试一个值是<em class="mp">不是</em>另一个值的倍数是通过检查一个不为零的余数来完成的:<br/> <code class="eh li lj lk ll b">13 % 2 != 0 // returns true. 13 is not a multiple of 2</code></p><p id="9170" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个代码存在许多问题，例如</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="2c97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，现在我们在 swift 5.0 中有了一些新的东西，这将让许多人松一口气。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Love it</figcaption></figure></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="4d1a" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated">在编译条件中支持“小于”运算符</h1><p id="a454" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">在编译条件下引入新的“</p><p id="427d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，如果我们只想在 Swift 版本低于 4.2 时编译一段代码，现在我们必须编写以下代码:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="5ebe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过引入对“</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="8d25" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated"> 【T0】 </h1><p id="8b27" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">Counting the number of objects that pass a test has a wide range of uses in many domains. However, Swift currently doesn’t give its users a simple way to perform this operation. While the behavior can currently be approximated with a  【T1】  and a  【T2】 , this approach creates an intermediate array which it immediately discards. This is a bit wasteful.</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="db00" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">To correctly avoid a potentially expensive intermediate array, you can use the Swift’s  【T3】  subsystem:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="2587" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">However, using  【T4】  comes with the downside of being forced to use an  【T5】  block. Lastly, you could rely on an eminently unreadable  【T6】 :</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="2644" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">These three solutions lie on a spectrum between “easy to write, but include performance traps” to “performant, but require Swift arcana to write”.</p><p id="e869" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">的支持，Swift 5.0 </strong>将避免性能陷阱，并为用户提供一个简单的读写界面。Autocomplete 也应该很方便地呈现给他们。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="7432" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated">字典— <code class="eh li lj lk ll b">compactMapValues</code></h1><p id="36f1" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们有时需要同时变换和过滤一个<code class="eh li lj lk ll b">Dictionary</code>的值，而<code class="eh li lj lk ll b">Dictionary</code>目前还没有提供直接支持紧凑贴图值的操作。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="26dc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Swift 5.0 现在推出了紧凑地图，这很棒，请参见以下内容:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="e562" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">生活越来越轻松了吧？</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="2afc" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated">可选试试？</h1><p id="49ea" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">Swift 的<code class="eh li lj lk ll b">try?</code>语句目前很容易引入嵌套可选。用户很难推理嵌套选项，Swift 试图避免在其他常见情况下产生嵌套选项。</p><p id="9bd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在 Swift 5 中，<code class="eh li lj lk ll b">try? someExpr()</code>将反映<code class="eh li lj lk ll b">foo?.someExpr()</code>的行为:</p><ul class=""><li id="93c5" class="lm ln hu it b iu iv iy iz jc lo jg lp jk lq jo lr ls lt lu dt translated">如果<code class="eh li lj lk ll b">someExpr()</code>产生一个非可选值，它将被包装在一个可选值中。</li><li id="6cfe" class="lm ln hu it b iu lv iy lw jc lx jg ly jk lz jo lr ls lt lu dt translated">如果<code class="eh li lj lk ll b">someExpr()</code>产生一个<code class="eh li lj lk ll b">Optional</code>，则不增加额外的可选性。</li></ul><p id="7e0e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将导致<code class="eh li lj lk ll b">try?</code>表达式的类型发生以下变化:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="db85" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated">我们错过了异步/等待模式—在 swift 5.0 中不再有</h1><p id="dc65" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">这是一个在其他流行的编程语言中使用的众所周知的解决方案——非常成功的有<code class="eh li lj lk ll b">C#</code>、<code class="eh li lj lk ll b">Python</code>、<code class="eh li lj lk ll b">Javascript</code>。这是我最想要的特性之一:(<br/>它消除了回调地狱和异步 API 难以工作的问题。当执行多个操作时，错误处理、回调会产生复杂的控制流。</p><p id="e5e1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没有它们，swift 会怎样:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure><p id="28af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看异步等待模式会是什么样子:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mn mo l"/></div></figure></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><h1 id="ac6f" class="kf kg hu bd kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky mm la lb lc dt translated">结论</h1><p id="d544" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">无论如何，我们在即将到来的版本中没有 async-await，但是有很多改进，我们可以从中受益。<br/>还有很多其他的改进没有在文章中提到，比如字符串语言级别的支持，标准库的改进等等。</p><p id="64bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请对您了解到的改进进行评论，并请让我知道您对 swift 5.0 有何看法，以及您最喜欢此次更新中的什么功能:)</p></div></div>    
</body>
</html>