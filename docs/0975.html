<html>
<head>
<title>Sudokus and Schedules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数独和时间表</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/sudokus-and-schedules-4b4693b07c2b#2019-02-08">https://medium.com/hackernoon/sudokus-and-schedules-4b4693b07c2b#2019-02-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4a33" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">用树搜索解决调度问题</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/138c3548b2f64b8d9580cc7915da5ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qmQYsvJfr5KB1pwf.jpg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Pan Am’s Reservation Center in the 1950’s</figcaption></figure><p id="96cf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如今，机器学习非常流行，以至于人们很容易忽视“人工智能”领域还有其他算法的事实。事实上，这些算法是如此的重要，以至于忽视它们是很容易的。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="kw kx l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Video version of this article</figcaption></figure><p id="053a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">假设你需要安排课程和教室。有 36 节课、36 个房间和 800 个讲座作为你的时间表。想猜猜有多少种可能的配置吗？这里是答案:1⁰ ⁴⁹⁰可能的配置。客观地说，宇宙中有 1⁰⁸⁰可观测的原子。即使像教室安排这样平凡的任务也要处理天文数字和排列，并冒险进入<a class="ae kv" href="https://youtu.be/YX40hbAHx3s" rel="noopener ugc nofollow" target="_blank"> NP 难领域</a>。但是我可以告诉你如何及时地用算法解决这些问题。</p><p id="03f8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">运筹学领域并不新鲜，但它的技术和算法对日常实际问题至关重要。在工厂产能如此有限的情况下，如何在多条产品线中实现利润最大化？你如何安排一家医院的 200 名护士，他们有不同的休假要求、职位、工会限制和工作时间规定？如果你需要<a class="ae kv" href="https://en.wikipedia.org/wiki/Traveling_tournament_problem" rel="noopener ugc nofollow" target="_blank">安排体育比赛并最小化团队旅行距离</a>该怎么办？如何优化列车网络的准点性能？还是简单的解一个数独？</p><p id="722e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有许多算法可以解决优化性质的问题。其中包括<a class="ae kv" href="https://en.wikipedia.org/wiki/Linear_programming" rel="noopener ugc nofollow" target="_blank">线性规划</a>、<a class="ae kv" href="https://en.wikipedia.org/wiki/Metaheuristic" rel="noopener ugc nofollow" target="_blank">元启发式</a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/Integer_programming" rel="noopener ugc nofollow" target="_blank">整数规划</a>等等。我个人觉得这些优化和搜索算法非常迷人，并且有大量的实际问题需要用它们来解决。有趣的是，这些算法中的一些如何直接应用于机器学习，因为机器学习本身在其核心是一个优化问题。</p><p id="9ef5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但今天，我想谈谈如何安排大学课堂，以及解决数独。您可以使用这种整数规划方法在基于规则的约束下安排员工、工厂生产线、云服务器作业、运输车辆和其他资源。我们可以使用数学建模实现神奇的一键生成时间表，而不是依赖迭代的强力策略来将事件放入时间表中(这可能是无药可救的低效)。你甚至可以<a class="ae kv" href="https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977" rel="noopener ugc nofollow" target="_blank">采用这些方法来构建象棋人工智能算法</a>或者进行任何基于离散的回归。</p><blockquote class="ky kz la"><p id="daa1" class="jz ka lb kb b kc kd iv ke kf kg iy kh lc kj kk kl ld kn ko kp le kr ks kt ku hn dt translated">在我开始之前，我强烈推荐这个具有挑战性但很有用的<a class="ae kv" href="https://www.coursera.org/learn/discrete-optimization/" rel="noopener ugc nofollow" target="_blank"> Coursera 离散优化课程</a>。这门课相当雄心勃勃，但是很有价值，很有用，也很有趣。这是值得的时间和精力，即使你不得不放慢自己的步伐。</p></blockquote><p id="ed70" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">做好准备，对于你们这些技术人员来说，将会有相当多的代码！重要的是要着眼于大局，从概念上理解模型。所以我鼓励你在第一次阅读这篇文章的时候忽略掉这段代码(或者干脆跳过它)。如果您决定深入研究，请确保您熟悉面向对象和函数式编程。</p><h2 id="8f6b" class="lf lg hu bd lh li lj lk ll lm ln lo lp ki lq lr ls km lt lu lv kq lw lx ly lz dt translated">定义问题</h2><p id="2ba5" class="pw-post-body-paragraph jz ka hu kb b kc ma iv ke kf mb iy kh ki mc kk kl km md ko kp kq me ks kt ku hn dt translated">在本文中，我们将针对一个教室生成每周大学课程表。我们将在两个维度上绘制占领状态网格:班级与 15 分钟离散间隔的时间线。如果我们想要安排多个房间，那将是三个维度:班级对时间线对房间。我们现在将坚持前者，做一个房间，稍后我将解释如何做多个房间。</p><p id="596b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这些课程时间长短不一，可能会在一周内“重复出现”。每个重复会话必须在一天中的同一时间开始。</p><p id="0418" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">以下是这些类:</p><ul class=""><li id="9f9c" class="mf mg hu kb b kc kd kf kg ki mh km mi kq mj ku mk ml mm mn dt translated">心理学 101 (1 小时，2 节课/周)</li><li id="ad20" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">英语 101 (1.5 小时，2 节课/周)</li><li id="2c52" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">数学 300 (1.5 小时，每周 2 节课)</li><li id="9b5d" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">心理学 300(每周 3 小时 1 节课)</li><li id="b705" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">微积分 I (2 小时，2 节课/周)</li><li id="84a4" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">线性代数 I (2 小时，每周 3 节课)</li><li id="0b94" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">社会学 101 (1 小时，2 节课/周)</li><li id="ed4c" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">生物 101 (1 小时，2 节课/周)</li><li id="a06b" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">供应链 300 (2.5 小时，每周 2 次会议)</li><li id="1b8b" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">定位 101 (1 小时，1 节课/周)</li></ul><p id="d94f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">一天应该以 15 分钟为间隔，并且只能以这些间隔来安排课程。换句话说，一节课只能在整点的 00、15、30 或 45 开始。</p><p id="4b3f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">运营周是周一至周五。营业时间为上午 11:30 至下午 1:00，休息时间如下:</p><ul class=""><li id="2485" class="mf mg hu kb b kc kd kf kg ki mh km mi kq mj ku mk ml mm mn dt translated">上午 8 时至 11 时 30 分</li><li id="f6e9" class="mf mg hu kb b kc mo kf mp ki mq km mr kq ms ku mk ml mm mn dt translated">下午 1 时至 5 时</li></ul><p id="77db" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">你的目标:</strong>创建一个模型，安排这些课程，没有重叠，并符合这些要求。</p><p id="3cb1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">剧透提示:</strong>这是我们最终将使用我们从头构建的“人工智能”算法来计算的解决方案。如果你想知道这是如何做到的，请继续阅读。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/4d9117f49f2c0641e8822fe932e42ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*7RLPHYWT5aFP_kroUS0YeQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">SPOIILER ALERT: Here is the schedule our algorithm will build by the end of this article</figcaption></figure><h1 id="ad6e" class="mu lg hu bd lh mv mw mx ll my mz na lp ja nb jb ls jd nc je lv jg nd jh ly ne dt translated">奠定基础</h1><p id="a1f3" class="pw-post-body-paragraph jz ka hu kb b kc ma iv ke kf mb iy kh ki mc kk kl km md ko kp kq me ks kt ku hn dt translated">好吧，不知所措了吗？有很多规则，要探索的排列数量是天文数字。但是一旦我向您展示了这种技术，它将有望非常直接地实现。</p><p id="f238" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">关于这个问题，你应该注意的第一件事是每件事是如何被分成“15 分钟”块的。这不是一个连续的/线性的问题，而是一个离散的问题，这就是现实世界中大多数计划是如何建立的。假设我们已经为整个周创建了一个时间表，分成 15 分钟的时间段，如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/1186f2cbfa3f15a17b0930bcdc4efc09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/0*J_Ve76YRODxx39dV"/></div></figure><p id="c73e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意，“…”只是一个折叠的占位符，因为我们没有足够的空间来显示一周的 672 个数据块(672 = 7 天* 24 小时*一小时 4 个数据块)。</p><p id="4c2e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在让我们扩展这个概念，把类作为时间轴的轴。每个交叉点/单元是一个可以是 1 或 0 的<code class="eh ng nh ni nj b">Slot</code>。这个二进制变量将被求解，以指示<code class="eh ng nh ni nj b">Slot</code>是否是该类第一次循环的开始时间。我们现在将它们都设置为 0，如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nk"><img src="../Images/ca5ea8bb6a60b590eb3601baca45230c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SvYiZYT79Z-rYjal"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A grid of our decision variables</figcaption></figure><p id="851e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这个网格对于从逻辑上思考这个问题至关重要。这将是一个有效的视觉辅助，因为我们的约束将集中在网格内的区域。</p><p id="a8bc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我将使用<a class="ae kv" href="http://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>作为编程语言，它与 Java 库配合得非常好，但比 Java 更易读、更简洁。我们将利用 Java 8 强大的<code class="eh ng nh ni nj b">LocalDate</code> / <code class="eh ng nh ni nj b">LocalTime</code> API 来简化我们的日历工作。</p><blockquote class="ky kz la"><p id="4bdb" class="jz ka lb kb b kc kd iv ke kf kg iy kh lc kj kk kl ld kn ko kp le kr ks kt ku hn dt translated">如果你不熟悉 Kotlin，它基本上是一个类似 Swift 的“dumbed down Scala”，大量用于 Android 开发。它本质上利用了 Java、C#、Scala、Groovy 和 Python 的实用特性来创建一种实用的工业语言。它还可以编译成 Java 字节码，并与 Java 库无缝互操作。</p></blockquote><p id="2011" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们像这样设置我们的基本规则参数:</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="2d0a" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">import </strong>java.time.LocalDate<br/><strong class="nj hv">import </strong>java.time.LocalTime<br/></span><span id="f998" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">// Any Monday through Friday date range will work<br/></em><strong class="nj hv">val </strong><em class="lb">operatingDates </em>= <br/>    LocalDate.of(2017,10,16)..LocalDate.of(2017,10,20)</span><span id="fbde" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">val </strong><em class="lb">operatingDay </em>= LocalTime.of(8,0)..LocalTime.of(17,0)</span><span id="76ba" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">val </strong><em class="lb">breaks </em>= <em class="lb">listOf</em>&lt;ClosedRange&lt;LocalTime&gt;&gt;(<br/>        LocalTime.of(11,30)..LocalTime.of(12,59)<br/>)</span></pre><p id="301a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来让我们声明<code class="eh ng nh ni nj b">ScheduledClass</code>,它保存了我们想要调度的给定类的属性。</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="8776" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">data class </strong>ScheduledClass(<strong class="nj hv">val id</strong>: Int,<br/>                          <strong class="nj hv">val name</strong>: String,<br/>                          <strong class="nj hv">val hoursLength</strong>: Double,<br/>                          <strong class="nj hv">val recurrences</strong>: Int,<br/>                          <strong class="nj hv">val recurrenceGapDays</strong>: Int = 2)</span></pre><p id="b598" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ng nh ni nj b">recurrenceGapDays</code>是每次重复的开始时间之间所需的最少天数。例如，以<code class="eh ng nh ni nj b">Psych 100</code>为例，它需要 2 次重复，默认间隔为 2 天。如果第一堂课是在星期一上午 8 点，那么第二堂课必须安排在两天(48 小时)后，也就是星期三上午 8 点。我们将把这个值默认为<code class="eh ng nh ni nj b">2</code>，这将使每个会话的开始间隔 48 小时。</p><p id="ec08" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来我们可以在一个<code class="eh ng nh ni nj b">List</code>中声明所有的<code class="eh ng nh ni nj b">ScheduledClass</code>实例:</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="1942" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">val </strong><em class="lb">scheduledClasses </em>= <em class="lb">listOf</em>(<br/>        ScheduledClass(<br/>            id=1, <br/>            name=<strong class="nj hv">"Psych 101"</strong>,<br/>            hoursLength=1.0,<br/>            recurrences=2<br/>        ),<br/>        ScheduledClass(<br/>            id=2, <br/>            name=<strong class="nj hv">"English 101"</strong>,  <br/>            hoursLength=1.5, <br/>            recurrences=3<br/>        ),<br/>        ScheduledClass(<br/>            id=3, <br/>            name=<strong class="nj hv">"Math 300"</strong>, <br/>            hoursLength=1.5, <br/>            recurrences=2<br/>        ),<br/>        ScheduledClass(<br/>            id=4, <br/>            name=<strong class="nj hv">"Psych 300"</strong>,  <br/>            hoursLength=3.0, <br/>            recurrences=1<br/>        ),<br/>        ScheduledClass(<br/>            id=5, <br/>            name=<strong class="nj hv">"Calculus I"</strong>, <br/>            hoursLength=2.0, <br/>            recurrences=2<br/>        ),<br/>        ScheduledClass(<br/>            id=6, <br/>            name=<strong class="nj hv">"Linear Algebra I"</strong>, <br/>            hoursLength=2.0, <br/>            recurrences=3<br/>        ),<br/>        ScheduledClass(<br/>            id=7, <br/>            name=<strong class="nj hv">"Sociology 101"</strong>, <br/>            hoursLength=1.0, <br/>            recurrences=2<br/>        ),<br/>        ScheduledClass(<br/>            id=8, <br/>            name=<strong class="nj hv">"Biology 101"</strong>, <br/>            hoursLength=1.0, <br/>            recurrences=2<br/>        ),<br/>        ScheduledClass(<br/>            id=9, <br/>            name=<strong class="nj hv">"Supply Chain 300"</strong>, <br/>            hoursLength=2.5, <br/>            recurrences=2<br/>        ),<br/>        ScheduledClass(<br/>            id=10, <br/>            name=<strong class="nj hv">"Orientation 101"</strong>,<br/>            hoursLength=1.0, <br/>            recurrences=1<br/>        )<br/>    )</span></pre><p id="cd56" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh ng nh ni nj b">Block</code>类将代表每个离散的 15 分钟时间段。我们将使用一个 Kotlin <code class="eh ng nh ni nj b">Sequence</code>结合 Java 8 的<code class="eh ng nh ni nj b">LocalDate/LocalTime</code> API 来为整个规划窗口生成所有块。我们还将创建几个助手属性来提取<code class="eh ng nh ni nj b">timeRange</code>以及它是否是<code class="eh ng nh ni nj b">withinOperatingDay</code>。<code class="eh ng nh ni nj b">withinOperatingDay</code>属性将确定此<code class="eh ng nh ni nj b">Block</code>是否在可安排的时间窗口内(例如，未安排在午夜或休息时段内)。</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="1eae" class="lf lg hu nj b fv np nq l nr ns"><em class="lb">/** A discrete, 15-minute chunk of time a class can be scheduled on */<br/></em><strong class="nj hv">data class </strong>Block(<strong class="nj hv">val range</strong>: ClosedRange&lt;LocalDateTime&gt;) {</span><span id="537c" class="lf lg hu nj b fv nt nq l nr ns">    <strong class="nj hv">val timeRange </strong>=     <br/>       <strong class="nj hv">range</strong>.<strong class="nj hv">start</strong>.toLocalTime()..<strong class="nj hv">range</strong>.<strong class="nj hv">endInclusive</strong>.toLocalTime()</span><span id="b91e" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">/** indicates if this block is in operating day/break<br/>    constraints */<br/>    </em><strong class="nj hv">val withinOperatingDay get</strong>() =  <br/>        <em class="lb">breaks</em>.<em class="lb">all </em><strong class="nj hv">{ timeRange</strong>.<strong class="nj hv">start !in it } </strong>&amp;&amp;<br/>            <strong class="nj hv">timeRange</strong>.<strong class="nj hv">start in </strong><em class="lb">operatingDay </em>&amp;&amp;<br/>            <strong class="nj hv">timeRange</strong>.<strong class="nj hv">endInclusive in </strong><em class="lb">operatingDay</em></span><span id="093b" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">    // manage instances<br/>    </em><strong class="nj hv">companion object </strong>{</span><span id="3faa" class="lf lg hu nj b fv nt nq l nr ns">        <em class="lb">/* <br/>        All operating blocks for the entire week, broken up in 15<br/>        minute increments.<br/>        Lazily initialize to prevent circular construction issues <br/>       */<br/>        </em><strong class="nj hv">val all by </strong><em class="lb">lazy </em><strong class="nj hv">{</strong></span><span id="f78a" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">generateSequence</em>(<em class="lb">operatingDates</em>.<strong class="nj hv">start</strong>.atStartOfDay()){<br/>                dt <strong class="nj hv">-&gt; </strong>dt.plusMinutes(15)<br/>                  .<em class="lb">takeIf </em><strong class="nj hv">{ it</strong>.plusMinutes(15) &lt;= <br/>                       <em class="lb">operatingDates</em>.<strong class="nj hv">endInclusive</strong>.atTime(23,59) <br/>                   <strong class="nj hv">}<br/>            }</strong>.<em class="lb">map </em><strong class="nj hv">{ </strong>Block(<strong class="nj hv">it</strong>..<strong class="nj hv">it</strong>.plusMinutes(15)) <strong class="nj hv">}<br/>             </strong>.<em class="lb">toList</em>()<br/>        <strong class="nj hv">}<br/>        <br/>        </strong><em class="lb">/* only returns blocks within the operating times */ <br/>        </em><strong class="nj hv">val allInOperatingDay by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>            all</strong>.<em class="lb">filter </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">withinOperatingDay }<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="be76" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">注意我将使用一个<code class="eh ng nh ni nj b"><a class="ae kv" href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy" rel="noopener ugc nofollow" target="_blank">lazy { }</a></code> <a class="ae kv" href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy" rel="noopener ugc nofollow" target="_blank">委托</a>为每个域对象初始化项目。这是为了防止循环构造问题，方法是在第一次调用这些项之前不构造它们。</p><p id="2bce" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，<code class="eh ng nh ni nj b">Slot</code>类将代表一个<code class="eh ng nh ni nj b">ScheduledClass</code>和一个<code class="eh ng nh ni nj b">Block</code>之间的交集/单元。我们将通过将每个<code class="eh ng nh ni nj b">ScheduledClass</code>与每个<code class="eh ng nh ni nj b">Block</code>配对来生成它们。我们还将创建一个未赋值的<code class="eh ng nh ni nj b">selected</code>二进制变量，它将是<code class="eh ng nh ni nj b">null</code>，直到我们给它赋值为<code class="eh ng nh ni nj b">1</code>或<code class="eh ng nh ni nj b">0</code>。</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="388a" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">data class </strong>Slot(<strong class="nj hv">val block</strong>: Block, <br/>                <strong class="nj hv">val scheduledClass</strong>: ScheduledClass) {</span><span id="b1a9" class="lf lg hu nj b fv nt nq l nr ns">    <strong class="nj hv">var selected</strong>: Int? = <strong class="nj hv">null</strong></span><span id="7431" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">    companion object </strong>{</span><span id="e2b3" class="lf lg hu nj b fv nt nq l nr ns">        <strong class="nj hv">val all by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>            </strong>Block.<strong class="nj hv">all</strong>.<em class="lb">asSequence</em>().<em class="lb">flatMap </em><strong class="nj hv">{ </strong>b <strong class="nj hv">-&gt;<br/>                </strong>ScheduledClass.<strong class="nj hv">all</strong>.<em class="lb">asSequence</em>().<em class="lb">map </em><strong class="nj hv">{ </strong>Slot(b,<strong class="nj hv">it</strong>)<strong class="nj hv">}<br/>            }</strong>.<em class="lb">toList</em>()<br/>        <strong class="nj hv">}<br/>    </strong>}<br/>}</span></pre><h1 id="7f3b" class="mu lg hu bd lh mv mw mx ll my mz na lp ja nb jb ls jd nc je lv jg nd jh ly ne dt translated">建模约束</h1><p id="80ec" class="pw-post-body-paragraph jz ka hu kb b kc ma iv ke kf mb iy kh ki mc kk kl km md ko kp kq me ks kt ku hn dt translated">在我进入模型的实现之前，我应该强调你可以使用混合整数解算器库来建模带有线性函数的约束，并让它求解<code class="eh ng nh ni nj b">selected</code>变量。在 Python 中你可以使用<a class="ae kv" href="https://github.com/coin-or/pulp" rel="noopener ugc nofollow" target="_blank">纸浆</a>或者<a class="ae kv" href="https://www.pyomo.org/" rel="noopener ugc nofollow" target="_blank"> PyOmo </a>。在 Java 平台上，您可以使用<a class="ae kv" href="https://github.com/optimatika/ojAlgo" rel="noopener ugc nofollow" target="_blank"> ojAlgo </a>或<a class="ae kv" href="https://www.optaplanner.org/" rel="noopener ugc nofollow" target="_blank"> OptaPlanner </a>。对于许多这样的库，我还可以加入一个$10K <a class="ae kv" href="https://www.ibm.com/analytics/data-science/prescriptive-analytics/cplex-optimizer" rel="noopener ugc nofollow" target="_blank"> IBM CPLEX 许可证</a>，它可以更快地解决更大、更复杂的问题。</p><p id="8484" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但是我将展示如何从头开始构建一个解决方案。在没有任何库的情况下进行优化的好处是，您可以对启发式算法(搜索策略)进行大量控制，并根据您的领域来表达模型。</p><p id="9e57" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我们开始求解每个<code class="eh ng nh ni nj b">Slot</code>中的<code class="eh ng nh ni nj b">selected</code>变量之前，让我们做一些思维实验来理解我们的约束。我可能浪费了 50 张纸来做这个模型，但我发现了一些有用的东西。它有点抽象，但是对于这个特殊的问题来说是强大而有效的。</p><p id="b7f1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">同样，我们将为每个<code class="eh ng nh ni nj b">Slot</code>分配一个<code class="eh ng nh ni nj b">1</code>或<code class="eh ng nh ni nj b">0</code> <em class="lb">来指示第一节课重复</em>的开始。这是我们的求解器可能会想到的一个可能的迭代，其中第一节心理学 101 课在周一上午 9:00 开始，社会学 101 课在周一上午 9:15 开始。这是我们的地图:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nu"><img src="../Images/65633e29212853edf29eadbbd3551c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m_TfYww3uFNEaXsNYpr13g.png"/></div></div></figure><p id="e448" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">仔细研究这个场景。你明白为什么这是一个无效的案例了吗？在周一上午 9:45，心理学 101(需要四个街区)和社会学 101(也需要四个街区)相互冲突。视觉上，你也许能看到冲突。但是怎么形容呢？</p><p id="3619" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">“影响”上午 9:45 时间段的计划班时段的总和必须小于或等于<code class="eh ng nh ni nj b">1</code>。总和<code class="eh ng nh ni nj b">1</code>实际上意味着只有一个类占用那个块，而<code class="eh ng nh ni nj b">0</code>意味着根本没有类占用那个块(也有效)。以下情况也是失败，因为“影响”槽的总和是<code class="eh ng nh ni nj b">2</code>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nv"><img src="../Images/01c6f508fe9c3958567fcea854fd1b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jvon3rzSMRBBVRirs38myA.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nv"><img src="../Images/0d4385753d7452dc7a01b1a029a14897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1XqkBIGhjc1EuCvTLG3Sg.png"/></div></div></figure><p id="32ae" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果我们将社会学 101 移到上午 10:00，那么总和将是<code class="eh ng nh ni nj b">1</code>，一切都好(如下所示):</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nw"><img src="../Images/5654dadbde1d0b519431ae5b0621a075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2hTt71tDx0V0XR-_-GF0g.png"/></div></div></figure><p id="3ec1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们需要将这个逻辑应用于整个时间线上的每个块的<em class="lb">，查询占据这个块的每个类的更早的槽，并规定它们的总和必须不大于 1。这个抽象但强大的想法实现了我们在约束方面需要的一切。下面是实际情况，所有影响上午 9:45 的时间段都用蓝色突出显示。所有这些蓝色时间段的总和必须不超过 1，这样上午 9:45 的时间段才不会被重复预订。</em></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nx"><img src="../Images/5b7dccc92410d57f6de0dbbe991311f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N6avnuqMU_Qsl9zQjVmudw.png"/></div></div></figure><p id="7c25" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这甚至可以解释复发的原因。毕竟，我们在一个槽中放了一个<code class="eh ng nh ni nj b">1</code>来表示第一个类的候选开始时间<em class="lb">。如果我们正在查看星期五上午 9:45 的时间段，我们将查询一周中会导致星期五上午 9:45 的时间段被占用的时间段(一直到星期一)。下面是一个大视野。这些蓝色槽的总和必须不大于 1。</em></p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ny"><img src="../Images/cdb7171d7c5b04d69a14dca6490d901f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ge1VfDR84XggCecz"/></div></div></figure><p id="ed26" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好的，你开始头晕了吗？这个模型的强大之处不在于数学，而在于每个块能够查询影响它的槽，并要求它们的总和不超过 1。这是艰苦工作发生的地方。另一个好处是，我们不需要创建任何新的变量来模拟约束，并且可以用一系列简单的求和约束来约束现有的槽二元变量。</p><h1 id="ec8f" class="mu lg hu bd lh mv mw mx ll my mz na lp ja nb jb ls jd nc je lv jg nd jh ly ne dt translated">提取重复和受影响的插槽</h1><p id="c835" class="pw-post-body-paragraph jz ka hu kb b kc ma iv ke kf mb iy kh ki mc kk kl km md ko kp kq me ks kt ku hn dt translated">为了执行影响给定块的槽的想法，我们首先需要做的是为给定块上的每个类识别这些槽，并且说它们的总和必须是“1”。这个代码库的明星是针对给定的<code class="eh ng nh ni nj b">List</code>项的 Kotlin 函数:</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="8f28" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">enum class </strong>RecurrenceMode { <strong class="nj hv">PARTIAL_ONLY</strong>, <strong class="nj hv">FULL_ONLY</strong>, <strong class="nj hv">ALL </strong>}</span><span id="615c" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">fun </strong>List&lt;T&gt;.affectedWindows(slotsNeeded: Int, <br/>       gap: Int, <br/>       recurrences: Int,<br/>       mode: RecurrenceMode = RecurrenceMode.<strong class="nj hv">FULL_ONLY</strong>) =</span><span id="8677" class="lf lg hu nj b fv nt nq l nr ns">(0..<strong class="nj hv">size</strong>).<em class="lb">asSequence</em>().<em class="lb">map </em><strong class="nj hv">{ </strong>i <strong class="nj hv">-&gt;<br/>            </strong>(1..recurrences).<em class="lb">asSequence</em>().<em class="lb">map </em><strong class="nj hv">{ </strong>(<strong class="nj hv">it </strong>- 1) * gap <strong class="nj hv">}<br/>                    </strong>.<em class="lb">filter </em><strong class="nj hv">{ it </strong>+ i &lt; <strong class="nj hv">size }<br/>                    </strong>.<em class="lb">map </em><strong class="nj hv">{ </strong>r <strong class="nj hv">-&gt;<br/>                        </strong>subList(i + r, <br/>                           (i + r + slotsNeeded)<br/>                             .<em class="lb">let </em><strong class="nj hv">{ if </strong>(<strong class="nj hv">it </strong>&gt; <strong class="nj hv">size</strong>) <strong class="nj hv">size else it }</strong>)<br/>                    <strong class="nj hv">}<br/>                    </strong>.<em class="lb">toList</em>()<br/>        <strong class="nj hv">}</strong>.<em class="lb">filter </em><strong class="nj hv">{<br/>            when </strong>(mode) {<br/>                RecurrenceMode.<strong class="nj hv">ALL </strong>-&gt; <strong class="nj hv">true</strong></span><span id="6c34" class="lf lg hu nj b fv nt nq l nr ns">RecurrenceMode.<strong class="nj hv">FULL_ONLY </strong>-&gt; <br/>                     <strong class="nj hv">it</strong>.<strong class="nj hv">size </strong>== recurrences &amp;&amp; <br/>                         <strong class="nj hv">it</strong>.<em class="lb">all </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">size </strong>== slotsNeeded <strong class="nj hv">}</strong></span><span id="f1d0" class="lf lg hu nj b fv nt nq l nr ns">RecurrenceMode.<strong class="nj hv">PARTIAL_ONLY </strong>-&gt; <br/>                     <strong class="nj hv">it</strong>.<strong class="nj hv">size </strong>&lt; recurrences || <br/>                         <strong class="nj hv">it</strong>.<em class="lb">any </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">size </strong>&lt; slotsNeeded <strong class="nj hv">}<br/>            </strong>}<br/>        <strong class="nj hv">}</strong></span></pre><p id="c553" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我将让您自己深入研究这个函数的实现。现在，更有效的方法是覆盖它所完成的任务，即获取任何<code class="eh ng nh ni nj b">List&lt;Slot&gt;</code>并执行一个专门的窗口操作，在每次循环之间注入一个<code class="eh ng nh ni nj b">gap</code>。这将返回一个列表列表，<code class="eh ng nh ni nj b">List&lt;List&lt;T&gt;&gt;</code>，其中每个列表都是一个循环，列表中的元素是受影响的元素。注意<code class="eh ng nh ni nj b">gap</code>是窗口每次开始之间的元素数量。</p><p id="51e1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了了解这种模式，我们可以将整数 1 到 20 分成 4 个一组，每个循环开始之间的间隔为 6，并且有 3 个循环。我们将只考虑完整的而不是部分的组，所以<code class="eh ng nh ni nj b">mode</code>将被设置为<code class="eh ng nh ni nj b">RecurrenceMode.FULL_ONLY</code>。</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="226b" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">fun </strong>main(args: Array&lt;String&gt;) {</span><span id="b16d" class="lf lg hu nj b fv nt nq l nr ns">(1..20).<em class="lb">toList</em>()<br/>            .<em class="lb">affectedWindows</em>(slotsNeeded = 4,<br/>                    gap = 6,<br/>                    recurrences = 3,<br/>                    mode = RecurrenceMode.<strong class="nj hv">FULL_ONLY<br/>            </strong>)<br/>            .<em class="lb">forEach </em><strong class="nj hv">{ </strong><em class="lb">println</em>(<strong class="nj hv">it</strong>) <strong class="nj hv">}<br/></strong>}</span></pre><p id="4b51" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">输出:</strong></p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="4fe0" class="lf lg hu nj b fv np nq l nr ns">[[1, 2, 3, 4], [7, 8, 9, 10], [13, 14, 15, 16]]<br/>[[2, 3, 4, 5], [8, 9, 10, 11], [14, 15, 16, 17]]<br/>[[3, 4, 5, 6], [9, 10, 11, 12], [15, 16, 17, 18]]<br/>[[4, 5, 6, 7], [10, 11, 12, 13], [16, 17, 18, 19]]<br/>[[5, 6, 7, 8], [11, 12, 13, 14], [17, 18, 19, 20]]</span></pre><p id="6ac2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果我们将<code class="eh ng nh ni nj b">mode</code>设置为<code class="eh ng nh ni nj b">RecurrenceMode.PARTIAL_ONLY</code>，它将给出无法产生长度为<code class="eh ng nh ni nj b">4</code>的<code class="eh ng nh ni nj b">3</code>循环的“破碎”组。这将有助于稍后识别必须为 0 的槽，因为我们无法获得给定块所需的所有槽(例如，它们溢出超过 5pm 限制)。</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="6c48" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">fun </strong>main(args: Array&lt;String&gt;) {<br/>    (1..20).<em class="lb">toList</em>()<br/>            .<em class="lb">affectedWindows</em>(slotsNeeded = 4,<br/>                    gap = 6,<br/>                    recurrences = 3,<br/>                    mode = RecurrenceMode.<strong class="nj hv">PARTIAL_ONLY<br/>            </strong>)<br/>            .<em class="lb">forEach </em><strong class="nj hv">{ </strong><em class="lb">println</em>(<strong class="nj hv">it</strong>) <strong class="nj hv">}<br/></strong>}</span></pre><p id="5017" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">输出:</strong></p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="23df" class="lf lg hu nj b fv np nq l nr ns">[[6, 7, 8, 9], [12, 13, 14, 15], [18, 19, 20]]<br/>[[7, 8, 9, 10], [13, 14, 15, 16], [19, 20]]<br/>[[8, 9, 10, 11], [14, 15, 16, 17], [20]]<br/>[[9, 10, 11, 12], [15, 16, 17, 18]]<br/>[[10, 11, 12, 13], [16, 17, 18, 19]]<br/>[[11, 12, 13, 14], [17, 18, 19, 20]]<br/>[[12, 13, 14, 15], [18, 19, 20]]<br/>[[13, 14, 15, 16], [19, 20]]<br/>[[14, 15, 16, 17], [20]]<br/>[[15, 16, 17, 18]]<br/>[[16, 17, 18, 19]]<br/>[[17, 18, 19, 20]]<br/>[[18, 19, 20]]<br/>[[19, 20]]<br/>[[20]]</span></pre><p id="a18b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们可以使用这个<code class="eh ng nh ni nj b">affectedWindows()</code>函数来处理课程重复，并在周一到周五的时间规划窗口内生成所有可能的排列。然后，我们可以使用它来查找影响特定块的特定类的槽。我们还将“清除”属于损坏组的插槽。例如，在下午 4:15 开始生物 101 将导致它溢出超过下午 5:00。因此，这个槽应该被固定为“0 ”,甚至在我们稍后进行的搜索中不被考虑。</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="e903" class="lf lg hu nj b fv np nq l nr ns"><em class="lb">/** A discrete, 15-minute chunk of time a class can be scheduled on */<br/></em><strong class="nj hv">data class </strong>Block(<strong class="nj hv">val range</strong>: ClosedRange&lt;LocalDateTime&gt;) {</span><span id="73ca" class="lf lg hu nj b fv nt nq l nr ns">    <strong class="nj hv">val timeRange </strong>=     <br/>       <strong class="nj hv">range</strong>.<strong class="nj hv">start</strong>.toLocalTime()..<strong class="nj hv">range</strong>.<strong class="nj hv">endInclusive</strong>.toLocalTime()</span><span id="3384" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">/** indicates if this block is zeroed due to operating <br/>         day/break constraints */<br/>    </em><strong class="nj hv">val withinOperatingDay get</strong>() =  <br/>        <em class="lb">breaks</em>.<em class="lb">all </em><strong class="nj hv">{ timeRange</strong>.<strong class="nj hv">start !in it } </strong>&amp;&amp;<br/>            <strong class="nj hv">timeRange</strong>.<strong class="nj hv">start in </strong><em class="lb">operatingDay </em>&amp;&amp;<br/>            <strong class="nj hv">timeRange</strong>.<strong class="nj hv">endInclusive in </strong><em class="lb">operatingDay</em></span><span id="d01c" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">    </em><strong class="nj hv">val affectingSlots by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>        </strong>ScheduledClass.<strong class="nj hv">all</strong>.<em class="lb">asSequence</em>()<br/>                .<em class="lb">flatMap </em><strong class="nj hv">{<br/>                    it</strong>.affectingSlotsFor(<strong class="nj hv">this</strong>).<em class="lb">asSequence</em>()<br/>                <strong class="nj hv">}</strong>.<em class="lb">toSet</em>()<br/>    <strong class="nj hv">}</strong></span><span id="c68b" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">    companion object </strong>{</span><span id="1896" class="lf lg hu nj b fv nt nq l nr ns">        <em class="lb">/* <br/>        All operating blocks for the entire week, broken up in 15<br/>        minute increments.<br/>        Lazily initialize to prevent circular construction issues <br/>       */<br/>        </em><strong class="nj hv">val all by </strong><em class="lb">lazy </em><strong class="nj hv">{</strong></span><span id="4e08" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">generateSequence</em>(<em class="lb">operatingDates</em>.<strong class="nj hv">start</strong>.atStartOfDay()){<br/>                dt <strong class="nj hv">-&gt; </strong>dt.plusMinutes(15)<br/>                  .<em class="lb">takeIf </em><strong class="nj hv">{ it</strong>.plusMinutes(15) &lt;= <br/>                       <em class="lb">operatingDates</em>.<strong class="nj hv">endInclusive</strong>.atTime(23,59) <br/>                   <strong class="nj hv">}<br/>             }</strong>.<em class="lb">map </em><strong class="nj hv">{ </strong>Block(<strong class="nj hv">it</strong>..<strong class="nj hv">it</strong>.plusMinutes(15)) <strong class="nj hv">}<br/>             </strong>.<em class="lb">toList</em>()<br/>        <strong class="nj hv">}<br/>        <br/>        </strong><em class="lb">/* only returns blocks within the operating times */ <br/>        </em><strong class="nj hv">val allInOperatingDay by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>            all</strong>.<em class="lb">filter </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">withinOperatingDay }<br/>        }<br/>    </strong>}<br/>}<br/></span><span id="a216" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">data class </strong>ScheduledClass(<strong class="nj hv">val id</strong>: Int,<br/>                          <strong class="nj hv">val name</strong>: String,<br/>                          <strong class="nj hv">val hoursLength</strong>: Double,<br/>                          <strong class="nj hv">val recurrences</strong>: Int,<br/>                          <strong class="nj hv">val recurrenceGapDays</strong>: Int = 2) {</span><span id="e8a4" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">/** the # of slots between each recurrence */<br/>    </em><strong class="nj hv">val gap </strong>= <strong class="nj hv">recurrenceGapDays </strong>* 24 * 4</span><span id="e83e" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">/** the # of slots needed for a given occurrence */<br/>    </em><strong class="nj hv">val slotsNeededPerSession </strong>= (<strong class="nj hv">hoursLength </strong>* 4).toInt()</span><span id="446e" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">/** yields slots for this given scheduled class */<br/>    </em><strong class="nj hv">val slots by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>        </strong>Slot.<strong class="nj hv">all</strong>.<em class="lb">asSequence</em>()<br/>             .<em class="lb">filter </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">scheduledClass </strong>== <strong class="nj hv">this }<br/>             </strong>.<em class="lb">toList</em>()<br/>    <strong class="nj hv">}</strong></span><span id="31cc" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">    </strong><em class="lb">/** yields slot groups for this scheduled class */<br/>    </em><strong class="nj hv">val recurrenceSlots by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>        slots</strong>.<em class="lb">affectedWindows</em>(slotsNeeded = <strong class="nj hv">slotsNeededPerSession</strong>,<br/>                gap = <strong class="nj hv">gap</strong>,<br/>                recurrences = <strong class="nj hv">recurrences</strong>,<br/>                mode = RecurrenceMode.<strong class="nj hv">FULL_ONLY<br/>             </strong>).<em class="lb">toList</em>()<br/>    <strong class="nj hv">}</strong></span><span id="40fe" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">     </strong><em class="lb">/** yields slots that affect the given block for this  <br/>         scheduled class */<br/>    </em><strong class="nj hv">fun </strong>affectingSlotsFor(block: Block) = <br/>          <strong class="nj hv">recurrenceSlots</strong>.<em class="lb">asSequence</em>()<br/>            .<em class="lb">filter </em><strong class="nj hv">{ </strong>blk <strong class="nj hv">-&gt; <br/>                 </strong>blk.<em class="lb">flatMap </em><strong class="nj hv">{ it }<br/>                     </strong>.<em class="lb">any </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">block </strong>== block <strong class="nj hv">} <br/>            }<br/>            </strong>.<em class="lb">map </em><strong class="nj hv">{ it</strong>.<em class="lb">first</em>().<em class="lb">first</em>() <strong class="nj hv">}</strong></span><span id="6913" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">    </strong><em class="lb">/** These slots should be fixed to zero **/<br/>    </em><strong class="nj hv">val slotsFixedToZero by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>        </strong><em class="lb">// broken recurrences<br/>        </em><strong class="nj hv">slots</strong>.<em class="lb">affectedWindows</em>(slotsNeeded = <strong class="nj hv">slotsNeededPerSession</strong>,<br/>                gap = <strong class="nj hv">gap</strong>,<br/>                recurrences = <strong class="nj hv">recurrences</strong>,<br/>                mode = RecurrenceMode.<strong class="nj hv">PARTIAL_ONLY<br/>        </strong>) .<em class="lb">flatMap </em><strong class="nj hv">{ it</strong>.<em class="lb">asSequence</em>() <strong class="nj hv">} //flatten the groups!<br/>          </strong>.<em class="lb">flatMap </em><strong class="nj hv">{ it</strong>.<em class="lb">asSequence</em>() <strong class="nj hv">}</strong><em class="lb"><br/>            </em>.<em class="lb">plus</em>(<br/>                    <strong class="nj hv">recurrenceSlots</strong>.<em class="lb">asSequence</em>()<br/>                            .<em class="lb">flatMap </em><strong class="nj hv">{ it</strong>.<em class="lb">asSequence</em>() <strong class="nj hv">}<br/>                            </strong>.<em class="lb">filter </em><strong class="nj hv">{ </strong>slot <strong class="nj hv">-&gt; <br/>                                 </strong>slot.<em class="lb">any </em><strong class="nj hv">{ <br/>                                   </strong>!<strong class="nj hv">it</strong>.<strong class="nj hv">block</strong>.<strong class="nj hv">withinOperatingDay <br/>                                 }<br/>                            }<br/>                            </strong>.<em class="lb">map </em><strong class="nj hv">{ it</strong>.<em class="lb">first</em>() <strong class="nj hv">}<br/>            </strong>)<br/>            .<em class="lb">distinct</em>()<br/>            .<em class="lb">onEach </em><strong class="nj hv">{<br/>                it</strong>.<strong class="nj hv">selected </strong>= 0<br/>            <strong class="nj hv">}<br/>            </strong>.<em class="lb">toList</em>()<br/>    <strong class="nj hv">}</strong></span><span id="1207" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv"> </strong><em class="lb">/**translates and returns the optimized start time of the class */<br/>    </em><strong class="nj hv">val start get</strong>() = <br/>        <strong class="nj hv">slots</strong>.<em class="lb">asSequence</em>()<br/>             .<em class="lb">filter </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">selected </strong>== 1 <strong class="nj hv">}<br/>             </strong>.<em class="lb">map </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">block</strong>.<strong class="nj hv">dateTimeRange</strong>.<strong class="nj hv">start }<br/>             </strong>.<em class="lb">min</em>()!!</span><span id="ebe6" class="lf lg hu nj b fv nt nq l nr ns">   <em class="lb">/** translates and returns the optimized end time of the class */<br/>    </em><strong class="nj hv">val end get</strong>() = <strong class="nj hv">start</strong>.plusMinutes(<br/>         (<strong class="nj hv">hoursLength </strong>* 60.0).toLong()<br/>    )</span><span id="2801" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">/** returns the DayOfWeeks where recurrences take place */<br/>    </em><strong class="nj hv">val daysOfWeek get</strong>() = (0..(<strong class="nj hv">recurrences</strong>-1)).<em class="lb">asSequence</em>()<br/>         .<em class="lb">map </em><strong class="nj hv">{ <br/>           start</strong>.<em class="lb">dayOfWeek</em>.plus(<strong class="nj hv">it</strong>.toLong() * <strong class="nj hv">recurrenceGapDays</strong>) <br/>         <strong class="nj hv">}</strong>.<em class="lb">sorted</em>()</span><span id="0498" class="lf lg hu nj b fv nt nq l nr ns">    <strong class="nj hv">companion object </strong>{<br/>        <strong class="nj hv">val all by </strong><em class="lb">lazy </em><strong class="nj hv">{ </strong><em class="lb">scheduledClasses </em><strong class="nj hv">}<br/>    </strong>}<br/>}</span></pre><h1 id="9987" class="mu lg hu bd lh mv mw mx ll my mz na lp ja nb jb ls jd nc je lv jg nd jh ly ne dt translated">求解变量</h1><p id="719e" class="pw-post-body-paragraph jz ka hu kb b kc ma iv ke kf mb iy kh ki mc kk kl km md ko kp kq me ks kt ku hn dt translated">现在我们已经建立了一个有效的基础设施来查询影响给定块的槽，我们现在准备求解符合我们的约束的变量。希望你对编写递归算法相当熟悉。如果没有，这里有一个练习的机会！</p><p id="3fed" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但是首先我要用一个更简单明了的例子来证明这个想法:数独。在我回到调度问题之前，它将演示如何使用分支算法求解变量。</p><h2 id="69f8" class="lf lg hu bd lh li lj lk ll lm ln lo lp ki lq lr ls km lt lu lv kq lw lx ly lz dt translated">想想数独游戏</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nz kx l"/></div></figure><p id="11de" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但愿数独是一个熟悉的益智游戏。您将看到一个 9x9 的单元格网格，其中一些单元格已经有了可能的数字 1-9。您需要找到其余空白单元格的值，以便每一行、每一列和 3×3 的正方形都有数字 1-9。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oa"><img src="../Images/f0a9c445c22a539559808572f3d65f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*8C_lYVu-nPqboc9ygvvGbQ.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A typical Sudoku puzzle</figcaption></figure><p id="6b07" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那么如何求解空白值呢？强行搜索效率会非常低，所以我们需要一个更聪明的搜索策略。</p><p id="ef44" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请允许我向您介绍树搜索。感觉类似于决策树，但是我们处理的是离散变量(整数)而不是连续变量(小数)。</p><p id="8fa8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">首先获取单元格，并在列表中根据它们拥有的候选值的数量对它们进行排序。例如，单元格[4，4]只能是一个值 5，所以它先出现，而单元格[2，6]应该是最后一个，因为它有 6 个可能的值。然后创建一个函数，作为分支算法递归地探索每个可能的值。以下是这种递归算法如何探索可能值的视觉效果:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ob"><img src="../Images/e704b6f7b4fb3e3fecaed60f6829a34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfJn_Yfpfr0mriQCdcqkng.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">With this sorted list, create a recursive tree that explores each Sudoku cell and its possible values.</figcaption></figure><p id="04a3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意我们是如何首先从最受约束的单元格开始的，这大大缩小了我们的搜索空间。搜索策略的这种用法被称为“启发式”。当一个给定的分支被认为不可行时(违反了数独规则)，该分支立即终止并转移到下一个替代分支。上图中，单元格[4，2]不能被赋值为“3”，因为单元格[3，2]已经被赋值为“3”。这意味着“3”已经存在于列 2 中，所以没有理由继续搜索那个分支，我们<em class="lb">修剪</em>它。</p><p id="8d98" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我们找到一个探索了所有 91 个值的分支，并且没有违反任何约束时，我们就解决了我们的数独游戏！然后，我们可以将分支值折叠回游戏板，如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oc"><img src="../Images/625d87b757e74511aed3c9b88a8b5871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*r58odTSdV4k6IX7ROknY8g.png"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">We have solved our Sudoku!</figcaption></figure><p id="5ad5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你想看数独解算器的源代码，你可以在这里找到。<a class="ae kv" href="https://github.com/thomasnield/kotlin-sudoku-solver/blob/master/src/main/kotlin/Solvers.kt#L12-L103" rel="noopener ugc nofollow" target="_blank">这部分代码</a>是递归树发生的地方。</p><div class="od oe fm fo of og"><a href="https://github.com/thomasnield/kotlin-sudoku-solver" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hv fv z el ol eo ep om er et ht dt translated">托马斯尼尔德/科特林数独求解器</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">一个用 Kotlin 写的 suduko 游戏解算器。有助于托马斯尼尔德/科特林数独解决方案的开发，通过创建一个…</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou jt og"/></div></div></a></div><h2 id="a0c4" class="lf lg hu bd lh li lj lk ll lm ln lo lp ki lq lr ls km lt lu lv kq lw lx ly lz dt translated">回到调度问题</h2><p id="8a3d" class="pw-post-body-paragraph jz ka hu kb b kc ma iv ke kf mb iy kh ki mc kk kl km md ko kp kq me ks kt ku hn dt translated">那么数独和日程安排问题有什么关系呢？嗯，实际上很多！我们可以应用这种技术，通过使用搜索树来解决 1 或 0 值的槽。在每一个被探索的分支上，你可以像数独游戏一样检查你的约束是否仍然被满足，确保课程没有被安排在已经被占用的时间段。</p><p id="6f6a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">从概念上讲，这是我们的递归搜索树的样子:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ov"><img src="../Images/960340cdae7f61a7dac9318573f17494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*kv4mpSyt84p5ofD3wU2bUg.png"/></div></figure><p id="7979" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下面是我如何从零开始实现这个野蛮的算法(请原谅我的代码格式或<a class="ae kv" href="https://github.com/thomasnield/optimized-scheduling-demo/blob/master/kotlin_from_scratch_solution/src/main/kotlin/BranchingAlgorithm.kt" rel="noopener ugc nofollow" target="_blank">只看源代码</a>)。请注意我是如何使用<code class="eh ng nh ni nj b">BranchNode</code>来表示正在搜索的分支的顶端的，我可以在分支上向后遍历，以评估到目前为止所做的决策是否与我当前的决策不冲突。然后我可以创建一个<code class="eh ng nh ni nj b">traverse()</code>函数来递归地探索整个树，直到找到解决方案。</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="f405" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">import </strong>java.time.DayOfWeek</span><span id="4e18" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">class </strong>BranchNode(<strong class="nj hv">val selectedValue</strong>: Int,<br/>                 restOfTree: List&lt;Slot&gt;,<br/>                 <strong class="nj hv">val previous</strong>: BranchNode? = <strong class="nj hv">null</strong>) {</span><span id="c5bd" class="lf lg hu nj b fv nt nq l nr ns">    <strong class="nj hv">val slot </strong>= restOfTree.<em class="lb">first</em>()</span><span id="f00e" class="lf lg hu nj b fv nt nq l nr ns">    <strong class="nj hv">val traverseBackwards </strong>=  <em class="lb">generateSequence</em>(<strong class="nj hv">this</strong>) <strong class="nj hv">{ <br/>        it</strong>.<strong class="nj hv">previous <br/>    }</strong>.<em class="lb">toList</em>()</span><span id="39bb" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">// calculate remaining slots and prune where constraint propagates<br/>    </em><strong class="nj hv">val remainingSlots by </strong><em class="lb">lazy </em><strong class="nj hv">{<br/>        if </strong>(<strong class="nj hv">selectedValue </strong>== 0)<br/>            restOfTree.<em class="lb">minus</em>(<strong class="nj hv">slot</strong>)<br/>        <strong class="nj hv">else </strong>{</span><span id="82c6" class="lf lg hu nj b fv nt nq l nr ns">       <em class="lb">// if this slot is occupied, affected slots can be pruned<br/>            </em><strong class="nj hv">val </strong>affectedSlotsPropogated = Block.<strong class="nj hv">allInOperatingDay<br/>               </strong>.<em class="lb">asSequence</em>().<em class="lb">filter </em><strong class="nj hv">{<br/>                    slot in it</strong>.<strong class="nj hv">affectingSlots<br/>                }</strong>.<em class="lb">flatMap </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">affectingSlots</strong>.<em class="lb">asSequence</em>() <strong class="nj hv">}<br/>                </strong>.<em class="lb">filter </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">selected </strong>== <strong class="nj hv">null }<br/>                </strong>.<em class="lb">toSet</em>()</span><span id="0b45" class="lf lg hu nj b fv nt nq l nr ns">            restOfTree.<em class="lb">asSequence</em>()<br/>                    .<em class="lb">filter </em><strong class="nj hv">{<br/>                        it</strong>.<strong class="nj hv">scheduledClass </strong>!= <strong class="nj hv">slot</strong>.<strong class="nj hv">scheduledClass <br/>                            </strong>&amp;&amp; <strong class="nj hv">it !in </strong>affectedSlotsPropogated<br/>                    <strong class="nj hv">}</strong>.<em class="lb">toList</em>()<br/>        }<br/>    <strong class="nj hv">}<br/></strong></span><span id="33d8" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">    val scheduleMet get</strong>() = <strong class="nj hv">traverseBackwards<br/>            </strong>.<em class="lb">asSequence</em>()<br/>            .<em class="lb">filter </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">selectedValue </strong>== 1 <strong class="nj hv">}<br/>            </strong>.<em class="lb">map </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">slot</strong>.<strong class="nj hv">scheduledClass }<br/>            </strong>.<em class="lb">distinct</em>()<br/>            .<em class="lb">count</em>() == ScheduledClass.<strong class="nj hv">all</strong>.<em class="lb">count</em>()</span><span id="5514" class="lf lg hu nj b fv nt nq l nr ns">    <strong class="nj hv">val isContinuable get</strong>() = !<strong class="nj hv">scheduleMet </strong>&amp;&amp; <br/>         <strong class="nj hv">remainingSlots</strong>.<em class="lb">count</em>() &gt; 0</span><span id="ccb3" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">val isSolution get</strong>() = <strong class="nj hv">scheduleMet</strong></span><span id="33f2" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">    fun </strong>applySolution() {<br/>        <strong class="nj hv">slot</strong>.<strong class="nj hv">selected </strong>= <strong class="nj hv">selectedValue<br/>    </strong>}<br/>}</span><span id="00a9" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">fun </strong>executeBranchingSearch() {</span><span id="2fd0" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">// pre-constraints<br/>    </em>ScheduledClass.<strong class="nj hv">all</strong>.<em class="lb">flatMap </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">slotsFixedToZero }<br/>        </strong>.<em class="lb">forEach </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">selected </strong>= 0 <strong class="nj hv">}</strong></span><span id="4f2f" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">    </strong><em class="lb">// Encourage most "constrained" slots to be searched first<br/>    </em><strong class="nj hv">val </strong>sortedSlots = Slot.<strong class="nj hv">all</strong>.<em class="lb">asSequence</em>()<br/>        .<em class="lb">filter </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">selected </strong>== <strong class="nj hv">null }</strong>.<em class="lb">sortedWith</em>(<br/>            <em class="lb">compareBy</em>(<br/>                    <strong class="nj hv">{<br/>                    </strong><em class="lb">// prioritize slots dealing with recurrences<br/>                        </em><strong class="nj hv">val </strong>dow = <strong class="nj hv">it</strong>.<strong class="nj hv">block</strong>.<strong class="nj hv">range</strong>.<strong class="nj hv">start</strong>.<em class="lb">dayOfWeek<br/>                        </em><strong class="nj hv">when </strong>{<br/>                            dow == DayOfWeek.<strong class="nj hv">MONDAY </strong>&amp;&amp; <br/>                              <strong class="nj hv">it</strong>.<strong class="nj hv">scheduledClass</strong>.<strong class="nj hv">recurrences </strong>== 3 <br/>                                 -&gt; -1000</span><span id="8596" class="lf lg hu nj b fv nt nq l nr ns">dow != DayOfWeek.<strong class="nj hv">MONDAY </strong>&amp;&amp; <br/>                               <strong class="nj hv">it</strong>.<strong class="nj hv">scheduledClass</strong>.<strong class="nj hv">recurrences </strong>== 3 <br/>                                 -&gt; 1000</span><span id="9474" class="lf lg hu nj b fv nt nq l nr ns">dow <strong class="nj hv">in  <br/>                           </strong>DayOfWeek.<strong class="nj hv">MONDAY</strong>..DayOfWeek.<strong class="nj hv">WEDNESDAY <br/>                             </strong>&amp;&amp; <strong class="nj hv">it</strong>.<strong class="nj hv">scheduledClass</strong>.<strong class="nj hv">recurrences </strong>== 2 <br/>                                -&gt; -500</span><span id="532a" class="lf lg hu nj b fv nt nq l nr ns">dow <strong class="nj hv">!in <br/>                           </strong>DayOfWeek.<strong class="nj hv">MONDAY</strong>..DayOfWeek.<strong class="nj hv">WEDNESDAY <br/>                           </strong>&amp;&amp; <strong class="nj hv">it</strong>.<strong class="nj hv">scheduledClass</strong>.<strong class="nj hv">recurrences </strong>== 2 <br/>                                -&gt; 500</span><span id="2e5a" class="lf lg hu nj b fv nt nq l nr ns">dow <strong class="nj hv">in <br/>                           </strong>DayOfWeek.<strong class="nj hv">THURSDAY</strong>..DayOfWeek.<strong class="nj hv">FRIDAY </strong>&amp;&amp; <br/>                              <strong class="nj hv">it</strong>.<strong class="nj hv">scheduledClass</strong>.<strong class="nj hv">recurrences </strong>== 1 <br/>                                -&gt; -300</span><span id="6e77" class="lf lg hu nj b fv nt nq l nr ns">dow <strong class="nj hv">!in <br/>                           </strong>DayOfWeek.<strong class="nj hv">THURSDAY</strong>..DayOfWeek.<strong class="nj hv">FRIDAY </strong>&amp;&amp; <br/>                              <strong class="nj hv">it</strong>.<strong class="nj hv">scheduledClass</strong>.<strong class="nj hv">recurrences </strong>== 1 -<br/>                                 &gt; 300</span><span id="eed8" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">else </strong>-&gt; 0<br/>                        }<br/>                    <strong class="nj hv">}</strong>,</span><span id="6271" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">// make search start at beginning of week<br/></em>                    <strong class="nj hv">{ it</strong>.<strong class="nj hv">block</strong>.<strong class="nj hv">range</strong>.<strong class="nj hv">start }</strong>,</span><span id="6e1e" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">// followed by class length               <br/>                    </em><strong class="nj hv">{</strong>-<strong class="nj hv">it</strong>.<strong class="nj hv">scheduledClass</strong>.<strong class="nj hv">slotsNeededPerSession } </strong><em class="lb"><br/>            </em>)<br/>    ).<em class="lb">toList</em>()</span><span id="11eb" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">// this is a recursive function for exploring nodes <br/>    // in a branch-and-bound tree<br/>    </em><strong class="nj hv">fun </strong>traverse(currentBranch: BranchNode? = <strong class="nj hv">null</strong>): BranchNode? {</span><span id="1812" class="lf lg hu nj b fv nt nq l nr ns">        <strong class="nj hv">if </strong>(currentBranch != <strong class="nj hv">null </strong>&amp;&amp; <br/>            currentBranch.<strong class="nj hv">remainingSlots</strong>.isEmpty()) {<br/>            <strong class="nj hv">return </strong>currentBranch<br/>        }</span><span id="6883" class="lf lg hu nj b fv nt nq l nr ns"> <strong class="nj hv">for </strong>(candidateValue <strong class="nj hv">in </strong>intArrayOf(1,0)) {<br/>            <strong class="nj hv">val </strong>nextBranch = BranchNode(candidateValue, <br/>                 currentBranch?.remainingSlots?: sortedSlots,<br/>                currentBranch<br/>            )</span><span id="1856" class="lf lg hu nj b fv nt nq l nr ns">            <strong class="nj hv">if </strong>(nextBranch.isSolution)<br/>                <strong class="nj hv">return </strong>nextBranch</span><span id="ecaf" class="lf lg hu nj b fv nt nq l nr ns">            <strong class="nj hv">if </strong>(nextBranch.isContinuable) {<br/>                <strong class="nj hv">val </strong>terminalBranch = traverse(nextBranch)<br/>                <strong class="nj hv">if </strong>(terminalBranch?.isSolution == <strong class="nj hv">true</strong>) {<br/>                    <strong class="nj hv">return </strong>terminalBranch<br/>                }<br/>            }<br/>        }<br/>        <strong class="nj hv">return null<br/>    </strong>}<br/></span><span id="c3c7" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">// start with the first Slot and set it as the seed<br/>    // recursively traverse from the seed and get a solution<br/>    </em><strong class="nj hv">val </strong>solution = traverse()</span><span id="d7d0" class="lf lg hu nj b fv nt nq l nr ns">    solution?.traverseBackwards?.forEach <strong class="nj hv">{ </strong>it.applySolution() <strong class="nj hv">}</strong>?: <strong class="nj hv">throw </strong>Exception(<strong class="nj hv">"Infeasible"</strong>)<br/>}</span><span id="e0a3" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">import </strong>java.time.LocalDate<br/><strong class="nj hv">import </strong>java.time.LocalTime<br/></span><span id="e9a4" class="lf lg hu nj b fv nt nq l nr ns"><em class="lb">// Any Monday through Friday date range will work<br/></em><strong class="nj hv">val </strong><em class="lb">operatingDates </em>= <br/>    LocalDate.of(2017,10,16)..LocalDate.of(2017,10,20)</span><span id="fa44" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">val </strong><em class="lb">operatingDay </em>= LocalTime.of(8,0)..LocalTime.of(17,0)</span><span id="49f9" class="lf lg hu nj b fv nt nq l nr ns"><strong class="nj hv">val </strong><em class="lb">breaks </em>= <em class="lb">listOf</em>&lt;ClosedRange&lt;LocalTime&gt;&gt;(<br/>        LocalTime.of(11,30)..LocalTime.of(12,59)<br/>)</span></pre><p id="bb0a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我还使用启发式搜索“最受约束”的位置，这意味着它们更有可能被分配“1”。例如，3-recurrence 类必须安排在星期一，所以我们应该首先评估它在星期一的时间段。启发式算法还会优先搜索高重现类(比如 3 和 2 ),这样我们就可以完成搜索。毕竟高递归类没有太大的灵活性，应该先评估。</p><p id="4ae9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">请注意，我们还积极地“提前”删除我们不再有理由搜索的未探索的值。例如，如果我的分支刚刚为生物 101 的 9:30AM 时间段分配了“1 ”,我应该为该 9:30AM 时间段和生物 101 提前修剪所有时间段，因为这两个时间段都已被该分支占用。</p><p id="7f54" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在我剩下要做的就是调用这个递归函数并打印结果！</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="d9d6" class="lf lg hu nj b fv np nq l nr ns"><strong class="nj hv">fun </strong>main(args: Array&lt;String&gt;) {</span><span id="c3e4" class="lf lg hu nj b fv nt nq l nr ns">    <em class="lb">executeBranchingSearch</em>()</span><span id="43e7" class="lf lg hu nj b fv nt nq l nr ns">ScheduledClass.<strong class="nj hv">all</strong>.<em class="lb">sortedBy </em><strong class="nj hv">{ it</strong>.<strong class="nj hv">start }<br/>        </strong>.<em class="lb">forEach </em><strong class="nj hv">{<br/>            </strong><em class="lb">println</em>(<strong class="nj hv">"${it</strong>.<strong class="nj hv">name}-   <br/>              ${it</strong>.<strong class="nj hv">daysOfWeek</strong>.<em class="lb">joinToString</em>(<strong class="nj hv">"/"</strong>)<strong class="nj hv">} <br/>              ${it</strong>.<strong class="nj hv">start</strong>.toLocalTime()<strong class="nj hv">}-${it</strong>.<strong class="nj hv">end</strong>.toLocalTime()<strong class="nj hv">}"</strong>)<br/>         <strong class="nj hv">}</strong><br/>}</span></pre><p id="8dc0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你像我一样设置你的试探法和参数，下面是它生成的时间表:</p><pre class="jk jl jm jn fq nl nj nm nn aw no dt"><span id="9207" class="lf lg hu nj b fv np nq l nr ns">Linear Algebra I- MONDAY/WEDNESDAY/FRIDAY 08:00-10:00<br/>English 101- MONDAY/WEDNESDAY/FRIDAY 10:00-11:30<br/>Supply Chain 300- MONDAY/WEDNESDAY 13:00-15:30<br/>Math 300- MONDAY/WEDNESDAY 15:30-17:00<br/>Calculus I- TUESDAY/THURSDAY 08:00-10:00<br/>Psych 101- TUESDAY/THURSDAY 10:00-11:00<br/>Sociology 101- TUESDAY/THURSDAY 13:00-14:00<br/>Biology 101- TUESDAY/THURSDAY 14:00-15:00<br/>Orientation 101- THURSDAY 15:00-16:00<br/>Psych 300- FRIDAY 13:00-16:00</span></pre><p id="285c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">验证输出。不错吧？如果我们要直观地绘制出来，时间表应该是这样的:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/4d9117f49f2c0641e8822fe932e42ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*7RLPHYWT5aFP_kroUS0YeQ.png"/></div></figure><p id="e2e8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">很酷，不是吗？除了调度员工和其他资源，我们还可以使用完全相同的方法。它还可以用于任何需要找到可行或最优值以找到更好的解决方案的离散模型。这在最意想不到的情况下非常方便。我不能分享细节，但我有一个项目，似乎有预测/回归的性质。当我放弃了传统的连续回归模型，并离散地使用树搜索技术时，它非常有效，并且比任何<a class="ae kv" href="https://facebook.github.io/prophet/" rel="noopener ugc nofollow" target="_blank">回归库</a>更好地解决了我的具体问题。</p><p id="ba6b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我结束之前，如果您想要针对多个教室进行调度，只需针对时间段、班级和房间设置每个二进制<code class="eh ng nh ni nj b">Slot</code>变量，使其成为三维的，如下所示。然后，您可以创建约束，以确保任何房间都不会被占用两次。否则，建模工作是一样的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ow"><img src="../Images/d5a4a44f1c4b2d0c8e9d8cf247e1093c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYrA0AM-7QkWJG94V53oqQ.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">A 3-dimensional model that defines variables against multiple rooms</figcaption></figure><p id="500a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">希望你们觉得这很有趣并且有用。我也希望这能让你看到其他已经存在了几十年却很少曝光的“人工智能”模型。如果你想了解更多，一定要看看 Coursera 上的<a class="ae kv" href="https://www.coursera.org/learn/discrete-optimization/" rel="noopener ugc nofollow" target="_blank">离散优化课程，从运筹学领域了解更多的秘密。</a></p><p id="5061" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">源代码:</strong></p><div class="od oe fm fo of og"><a href="https://github.com/thomasnield/optimized-scheduling-demo/tree/master/kotlin_from_scratch_solution" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab ej"><div class="oi ab oj cl cj ok"><h2 class="bd hv fv z el ol eo ep om er et ht dt translated">托马斯尼尔德/优化调度演示</h2><div class="on l"><h3 class="bd b fv z el ol eo ep om er et ek translated">创建教室时间表的分支定界求解器—Thomas nield/优化时间表演示</h3></div><div class="oo l"><p class="bd b gc z el ol eo ep om er et ek translated">github.com</p></div></div><div class="op l"><div class="ox l or os ot op ou jt og"/></div></div></a></div></div></div>    
</body>
</html>