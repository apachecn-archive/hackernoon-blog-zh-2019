<html>
<head>
<title>Multiple Ways to Build a Banner Generation Tool with PhantomJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PhantomJS构建横幅生成工具的多种方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/multiple-ways-to-build-a-banner-generation-tool-with-phantomjs-616287a463f5?source=collection_archive---------30-----------------------#2019-02-04">https://medium.com/hackernoon/multiple-ways-to-build-a-banner-generation-tool-with-phantomjs-616287a463f5?source=collection_archive---------30-----------------------#2019-02-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0d82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">作者:</em> <a class="ae jq" href="https://www.linkedin.com/in/yurii-vlasiuk-132511101/" rel="noopener ugc nofollow" target="_blank"> <em class="jp">尤里·弗拉西克</em> </a></p><p id="0757" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">今天，我们想分享我们的经验，实现后端工具，从HTML模板生成图形横幅。WebbyLab的客户对基于准备好的模板的广告横幅定制自动化感兴趣。基本上，你有一个index.html与领域，你可以插入不同的组件，如按钮，图像或文本。因此，我将讲述我们用来实现这种功能的方法。对于我们的项目，我们选择了幻想曲。你可能会说在npm库中有更多创新的解决方案。但是当我们开始的时候，这些库都还不稳定或者没有很好的文档记录(例如，<a class="ae jq" href="https://github.com/GoogleChrome/puppeteer" rel="noopener ugc nofollow" target="_blank">puppet er</a>——一个Node.js库，它提供了一个高级的<a class="ae jq" href="https://hackernoon.com/tagged/api" rel="noopener ugc nofollow" target="_blank"> API </a>来控制基于Chromium的无头引擎；它最显著的特点之一是强大的截屏功能。该项目的规格要求有很大的稳定性。这就是为什么我们决定采用经过检验的、记录良好的幻想曲。任务是创建一个无头Chrome截图功能，如David Schnurr 在<a class="ae jq" rel="noopener" href="/@dschnr/using-headless-chrome-as-an-automated-screenshot-tool-4b07dffba79a">文章</a>中所述。</p><p id="6798" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好了，介绍够了。让我们仔细看看我们决定使用的框架。<a class="ae jq" href="http://phantomjs.org/" rel="noopener ugc nofollow" target="_blank">PhantomJS</a>(<a class="ae jq" href="https://github.com/ariya/phantomjs" rel="noopener ugc nofollow" target="_blank">https://github.com/ariya/phantomjs</a>)是一个无头的WebKit浏览器，可以用<a class="ae jq" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a> API编写脚本。</p><p id="ee21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据创建者列出的功能列表如下:</p><ul class=""><li id="5a4c" class="jr js hu it b iu iv iy iz jc jt jg ju jk jv jo jw jx jy jz dt translated">无头web测试；</li><li id="8dab" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">页面自动化；</li><li id="6e39" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">截屏；</li><li id="6a70" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">网络监控。</li></ul><p id="1606" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我不会深入讨论每一个问题，而是集中讨论解决问题的任务和方法。该任务意味着实施以下功能:</p><ul class=""><li id="7c5c" class="jr js hu it b iu iv iy iz jc jt jg ju jk jv jo jw jx jy jz dt translated">基于HTML模板的图像生成(可以定制)；</li><li id="20b5" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">图像压缩——以适应特定的尺寸限制；</li><li id="79e2" class="jr js hu it b iu ka iy kb jc kc jg kd jk ke jo jw jx jy jz dt translated">缩放图像以提高Retina屏幕的质量。</li></ul><h1 id="efa8" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">准备</h1><p id="d0d3" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">要设置stage，首先需要使用npm下载并安装PhantomJS。我已经设置了具有两条路径的small express server一条用于静态托管，另一条用于发送生成请求(完整的示例可以在我的<a class="ae jq" href="https://github.com/unsigned6/phantomjs-image-generator" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到)。</p><p id="7f42" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，我们必须为图像生成创建一个核心类。首先创建一个Phantom实例，并使用它来创建页面，这将在我们的后端提供图像渲染。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="8c2b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们必须使用<code class="eh lp lq lr ls b">viewportSize</code>属性和<code class="eh lp lq lr ls b">clipRect</code>将属性设置为页面大小，以定义要呈现的矩形的坐标:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="be11" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们需要打开将返回操作状态的页面:</p><pre class="li lj lk ll fq lt ls lu lv aw lw dt"><span id="e43a" class="lx kg hu ls b fv ly lz l ma mb">const status = await page.open(config.templatePath);</span></pre><p id="9a63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也有可能在网页的上下文中评估JavaScript代码。为此，使用了<code class="eh lp lq lr ls b">evaluate()</code>函数，它接受另一个函数作为参数。我们使用<code class="eh lp lq lr ls b">evalFunction</code>在渲染到图像之前对模板进行修改。</p><pre class="li lj lk ll fq lt ls lu lv aw lw dt"><span id="0354" class="lx kg hu ls b fv ly lz l ma mb">await page.evaluate(evalFunction);</span></pre><p id="ac9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是在开始的时候，我们会把它去掉，因为它是可选的，并且实际上对于获取图像是不需要的。</p><p id="7813" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无头模式下截屏所需的最后一步是启动实际的渲染并退出我们的PhantomJS实例:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="2818" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外一个好的做法是检查映像是否创建成功，否则抛出“错误”。这允许处理Phantom无法打开模板的情况。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="b987" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们可以将所有的片段收集到图像生成类中。我们将这个类的操作分为三个部分:创建页面、设置页面大小和生成图像。以下是清单:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="67f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，从模板渲染图像的基本功能已经就绪，实际上，这已经是一个工作示例。如果您调用<code class="eh lp lq lr ls b">generate()</code>方法并向其传递带有templatePath(您要渲染到图像中的HTML模板的位置)和destinationPath(输出图像文件的位置)键的页面大小和配置对象，这将创建JPEG格式的图像。此外，我们将使用附加选项来扩展这个示例。</p><h1 id="a3e5" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">错误处理和调试</h1><p id="e2eb" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">方法<code class="eh lp lq lr ls b">page.open()</code>返回操作的状态。一个好的做法是检查打开页面是否结束，否则抛出一个异常。这将允许处理Phantom无法打开模板的情况。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="6fbc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了控制在无头模式下页面呈现期间发生的事情，我使用<code class="eh lp lq lr ls b">onConsoleMessage</code>属性将日志记录添加到幻像页面实例中，以将页面消息输出到终端控制台。这个和平可以添加到我们的<code class="eh lp lq lr ls b">ImageGenerator</code>类的<code class="eh lp lq lr ls b">_createPage()</code>方法中。</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="bdf6" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">模板定制</h1><p id="39a5" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">例如，我使用带有迷因的图像创建了一个简单的模板，这在2017年夏天很流行。下面是“index.html”的列表:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="3bad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CSS样式仅在定位和调整文本块大小时需要。所有与模板相关的文件都位于“static/templates”目录中。当您准备好模板后，就该用<code class="eh lp lq lr ls b">evaluate</code>函数扩展类示例，并向模板添加您可能额外需要的任何JS脚本了。请记住，模板中的任何JavaScript代码都将由Phantom评估和执行，它不识别任何特定于ES6的特性(例如，没有字符串模板，只有连接)。我个人觉得不好玩。此外，Phantom不支持一些在现代浏览器中广泛使用的CSS属性。例如，如果你热衷于使用Flexbox，你可以在准备模板时忘记它——当用Phantom渲染它们时，所有不支持的功能都将被忽略甚至导致错误。</p><p id="4904" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为在eval函数中定制页面文本最简单的方法是使用<code class="eh lp lq lr ls b">getElementById</code>，然后替换所选节点中的<code class="eh lp lq lr ls b">innerHtml</code>，或者改变<code class="eh lp lq lr ls b">img</code>标签中的<code class="eh lp lq lr ls b">src</code>属性。另外，我没有在<code class="eh lp lq lr ls b">imageGenerator</code>类本身中声明这个函数，而是在调用<code class="eh lp lq lr ls b">generate()</code>方法之前声明的。这提供了在不同情况下传递不同函数的灵活性。例如，您可以将这样的函数传递给<code class="eh lp lq lr ls b">page.evaluate()</code>:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="8ee6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可能已经注意到，您还应该标准化模板和内容id的格式，因为它们将被评估函数使用。这就是为什么最好保持所有模板的命名约定一致，以免为每个模板编写不同的求值函数。<code class="eh lp lq lr ls b">page.evaluate()</code>的第二个参数用于将参数传递给<code class="eh lp lq lr ls b">evaluateFunc</code>:</p><pre class="li lj lk ll fq lt ls lu lv aw lw dt"><span id="1367" class="lx kg hu ls b fv ly lz l ma mb">await page.evaluate(evaluateFunc, config);</span></pre><h1 id="2790" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">图像压缩</h1><p id="ff8a" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">我们使用PhantomJS的项目对输出图像有另一个要求。在项目开发的平台上有文件大小和图像尺寸(固定的高度和宽度)的限制。在满足限制的同时，图像应该尽可能地高质量。PhantomJS为PNG和JPEG格式提供了选择质量(或压缩级别)的选项:</p><pre class="li lj lk ll fq lt ls lu lv aw lw dt"><span id="6d0b" class="lx kg hu ls b fv ly lz l ma mb">await page.render(config.destinationPath, { format: 'jpeg', quality: ‘96’ });</span></pre><p id="2891" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">范围在0到100之间，默认值为75。因此，我们必须在渲染之前计算出所需的压缩级别。在大多数情况下，我使用了一种通过解析内容组合的简单比例来计算值的方法。它给了我最大的图像尺寸和质量参数的经验值。使用这个值，可以计算系数(当然，我们不应该忘记压缩级别和输出文件大小是成反比的)。</p><p id="8a64" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下面的例子中，96是压缩级别，<code class="eh lp lq lr ls b">size</code>是输出图像的高度和宽度的乘积(已知值)，而<code class="eh lp lq lr ls b">x</code>是我们寻求的压缩级别:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/2789f391b0934a9531aae45ea6115e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*Q8r9lKdHtJ69-c0HznJ6kQ.png"/></div></figure><p id="9e20" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，我们用根据图像尺寸计算压缩级别的方法扩展了<code class="eh lp lq lr ls b">imageGenerator</code>:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="8e54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这还不是全部。其他内容(例如不同的背景)也可能超过大小限制。此外，压缩后，文件大小不会线性减小，如下图所示(质量与文件大小的相关性):</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mf"><img src="../Images/614b8da8fabaf12c4a75a56213dfc4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6dJAIKN6N0OBxxPT"/></div></div></figure><p id="bcfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们采用了另一种方法，这种方法仍然很简单，但是很有效。如果内容超出大小限制，我们开始迭代图像渲染，逐步降低质量，并从<code class="eh lp lq lr ls b">generate</code>方法返回找到的质量值:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="be3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这两种方法的组合(预先计算的因子和迭代质量递减)在性能上提供了更好的结果，因为图像渲染是一种高负载操作。在实践中，在大多数情况下，静态系数可以立即达到可接受的结果，只有一些图片需要2-3次额外的迭代(我认为这是一个不错的结果)。</p><h1 id="fb43" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">图像质量改善</h1><p id="798a" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">另一个有趣的任务是提高最终图像的质量。由于限制，在幻像中渲染会产生压缩图像。这就是为什么在浏览器中打开的HTML模板看起来比固定尺寸的渲染图像更好，即使质量设置为100。由于原始图像的维度更高，压缩后的图像看起来永远不会像原始图像那样清晰——是原始图像的两倍甚至更多倍。在下面的示例中很明显，左边是由Phantom生成的图像，分辨率为1152*768，质量设置为100，右边是在浏览器中打开的原始图像:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mk"><img src="../Images/5cede18164e4ea3b9f1f6b4624ac67a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9rv0JgSEhuFvX1Bv"/></div></div></figure><p id="8191" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在左图中，你可以注意到像素颗粒，这在缩放时变得更加明显。</p><p id="4d58" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是为什么尽管图像尺寸限制，我们也包括了生成更大的图片，但文件大小限制相同的可能性。这是可能的，因为一些图片在正常尺寸下根本没有达到尺寸限制。顺便说一句，使用Phantom，这可以简单地完成。为此，设置了<code class="eh lp lq lr ls b">zoomFactor</code>属性，该属性指定图像应该缩放多少倍:</p><pre class="li lj lk ll fq lt ls lu lv aw lw dt"><span id="9803" class="lx kg hu ls b fv ly lz l ma mb">page.property('zoomFactor', 2);</span></pre><p id="00c1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">高度和宽度都必须乘以该值，否则只会渲染缩放图像的裁剪部分。</p><p id="4f1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了使其可选，我们传递了一个标志来将缩放模式切换到<code class="eh lp lq lr ls b">ImageGenerator</code>类的<code class="eh lp lq lr ls b">generate</code>方法的参数:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="9962" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">事件</h1><p id="161d" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">PhantomJS中另一个可以用于模板呈现的强大机制是页面事件系统。在模板中定义了一些反应的情况下，这可能很有用——例如，在悬停或鼠标点击时。下面是如何在模板中的(10，10)坐标处启动鼠标单击事件:</p><pre class="li lj lk ll fq lt ls lu lv aw lw dt"><span id="d903" class="lx kg hu ls b fv ly lz l ma mb">await page.sendEvent('click', 10, 10, 'left');</span></pre><p id="d824" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">其他支持的事件类型有“mouseup”、“mousedown”、“mousemove”、“双击”。代表事件鼠标位置的两个参数是可选的。最后一个表示应该“点击”哪个鼠标按钮，默认为左。</p><p id="0039" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，Phantom支持发送键盘事件，但我不会在本文中涉及它们。如果你感兴趣，你可以在图书馆的<a class="ae jq" href="http://phantomjs.org/api/webpage/method/send-event.html" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="dcf6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">原载于</em><a class="ae jq" href="https://blog.webbylab.com/banner-generation-tool-phantomjs/" rel="noopener ugc nofollow" target="_blank"><em class="jp"/></a><em class="jp">。</em></p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="ms lo l"/></div></figure></div></div>    
</body>
</html>