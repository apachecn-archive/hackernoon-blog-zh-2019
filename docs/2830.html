<html>
<head>
<title>Using CloudWatch and Lambda to implement ad-hoc scheduling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CloudWatch和Lambda实现临时调度</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/using-cloudwatch-and-lambda-to-implement-ad-hoc-scheduling-8dd83f982bed?source=collection_archive---------8-----------------------#2019-05-03">https://medium.com/hackernoon/using-cloudwatch-and-lambda-to-implement-ad-hoc-scheduling-8dd83f982bed?source=collection_archive---------8-----------------------#2019-05-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2b46" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">前阵子我写过关于<a class="ae jp" href="https://theburningmonk.com/2019/03/dynamodb-ttl-as-an-ad-hoc-scheduling-mechanism/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">使用DynamoDB TTL实现临时调度</strong> </a>。这引发了一些健康的辩论，你们中的一些人提到了替代方案，包括使用阶跃函数。因此，让我们来看看这些替代方法，从最简单的开始——使用cron作业。</p><p id="352b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用上一篇文章中列出的相同标准来评估这种方法:</p><ul class=""><li id="26db" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated"><strong class="it hv">精度</strong>:任务的执行离我的预定时间有多近？越近越好。</li><li id="6194" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv"> Scale(未完成任务的数量)</strong>:解决方案能否扩展以支持许多未完成的任务。即已调度但尚未执行的任务。</li><li id="d23b" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><strong class="it hv">扩展(热点):</strong>该解决方案能否扩展到在大约同一时间执行许多任务？例如，数百万人设置了一个计时器来提醒自己观看超级碗，所以所有的计时器都在接近开球时间时启动。</li></ul><h1 id="fc01" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">CloudWatch计划和Lambda</h1><p id="eaf4" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">设置非常简单:</p><ul class=""><li id="8fb9" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">存储所有计划任务的数据库(如DynamoDB ),包括它们应该何时执行。</li><li id="6813" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">每X分钟运行一次的CloudWatch计划(cron)。</li><li id="ae51" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">从数据库中读取过期任务并执行它们的Lambda函数。</li></ul><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/0731feb8e14797c462e09dfa1776454f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*VWEtIcplE1QXW4NO.png"/></div></figure><h2 id="bd25" class="lp kf hu bd kg lq lr ls kk lt lu lv ko jc lw lx ks jg ly lz kw jk ma mb la mc dt translated">可扩展性(未完成任务的数量)</h2><p id="7975" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">由于打开任务的数量只是转化为数据库中的项目数量，这种方法可以扩展到数百万个打开任务。</p><h2 id="3b5d" class="lp kf hu bd kg lq lr ls kk lt lu lv ko jc lw lx ks jg ly lz kw jk ma mb la mc dt translated">精确</h2><p id="fbb4" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">使用CloudWatch事件，您可以每分钟运行一次计划任务。这是使用这种方法可以获得的最高精度。</p><p id="35f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，这种方法经常受到每次迭代中可以处理的任务数量的限制。当需要同时执行的任务太多时，它们可能会堆积起来，导致延迟。这些延迟是这种方法的最大挑战——处理热点——的一个症状。</p><h2 id="98b6" class="lp kf hu bd kg lq lr ls kk lt lu lv ko jc lw lx ks jg ly lz kw jk ma mb la mc dt translated">可扩展性(热点)</h2><p id="f526" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">当Lambda函数执行时，它会查找处于或超过其预定执行时间的任务。例如，现在的时间是00:00 UTC，我们的函数将查找<code class="eh md me mf mg b">scheduled_time</code>为≤ <code class="eh md me mf mg b">00:00 UTC</code>的任务。</p><p id="589a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果它发现有太多任务无法在下一个周期于00:01 UTC开始之前完成，会发生什么情况？为了避免同一个任务被多次执行，我们通常会将函数的<code class="eh md me mf mg b">Reserved Concurrency</code>设为1。这确保了在任何时刻，只有一个Lambda函数的实例在运行。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/72a44f9492e7ef551207363f7906d74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*guBQ-ffO7xxRQTkn.png"/></div></div></figure><p id="fb49" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，这意味着在第一批任务完成之前，不会处理计划在00:02 UTC执行的任务(见上文)。这可能会产生不可预测的延迟，并会显著影响系统的精度。</p><p id="d475" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，如果您可以将一个任务标记为有<code class="eh md me mf mg b">started</code>,那么您就可以防止后续的周期再次拾起它，除非是在失败的情况下。一个这样的方案可能是给任务定义添加一个<code class="eh md me mf mg b">started_at</code>属性。当cron函数寻找要执行的任务时，它会忽略已经开始但尚未完成或超时的任务。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/f78b742d1a4576290d32ad5da7348ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AhiXnn3Cveh4pE6B.png"/></div></div></figure><p id="6f69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样做将允许您运行cron函数的多个实例，而不必冒多次处理一个任务的风险。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/5ec5fbafcc3045658f59af77417f2a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zxr891znqIu0Rl5w.png"/></div></div></figure><p id="0040" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这仍然留下了一个问题，热点可能会造成一些真正的损害:</p><ul class=""><li id="ebe3" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">该函数在能够处理整个批处理之前可能会超时</li><li id="e37d" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">该系统的精度是高度不可预测的。如果一个函数花了整整15分钟来处理批处理，那么一些任务将在预定时间后15分钟执行。</li></ul><p id="f5d0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然，您可以在代码中并行处理这些任务。但是这增加了业务逻辑的复杂性，并带来了其他故障模式，例如:</p><ul class=""><li id="351b" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">内存不足异常——如果您启动了太多并发的<code class="eh md me mf mg b">Promise</code>(在节点中)或线程，那么您可能会在运行时遇到可怕的<code class="eh md me mf mg b">OutOfMemoryException</code>。</li><li id="a652" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated"><code class="eh md me mf mg b">Promise.all</code>在Node.js中如果有任何个人承诺拒绝就会拒绝。如果您有一个未处理的异常，那么它可以拒绝所有其他的承诺，而不知道最终哪个会成功。</li></ul><p id="4d5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我个人认为，更好的方法是将任务交给SQS队列。这个SQS队列可以触发另一个Lambda函数。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/74d6fd90ab53d63eb0e6c9801bc2df3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/0*ZnM1GO10W2GL_Qbo.png"/></div></figure><p id="7178" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用SQS，您可以获得内置的重试和死信队列(DLQ)支持。Lambda函数将成批处理SQS任务(最多10个)。Lambda服务还会根据流量自动调整并发执行的数量。这两个特征都有助于提高吞吐量。</p><p id="a728" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，由于这是一个额外的跳跃，它将增加任务被按时执行的延迟。这影响了系统的精度。所以，也许你不是一直这样。相反，如果批量很小，应该立即处理。只有当批处理超过一定大小时，才通过SQS队列推迟处理。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/a96405a00f42f75cb92bff036bb534f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*wy3mU0I0LJDaHZB5.png"/></div></figure><h1 id="4838" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">数据库选择</h1><p id="26ab" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">我在这篇文章的所有例子中使用了DynamoDB，因为它易于使用，并且可以满足许多用例。然而，它并不擅长处理热键。不幸的是，这正是我们在这里要做的…</p><p id="e6a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您受到每个分区3000个读取吞吐量单位的限制。因此，如果您的系统需要扩展到每批几千个以上的任务，那么DynamoDB可能不适合您。</p><h1 id="b160" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">结论</h1><p id="99a9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc le je jf jg lf ji jj jk lg jm jn jo hn dt translated">这种基于批处理的方法不被认为是现代的。但是对于许多用例来说，这也是安排临时任务的最简单的方法。</p><p id="5a4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">例如，如果您的用例是这样的:</p><ul class=""><li id="519a" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">你可以容忍任务晚执行几分钟。</li><li id="7b32" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">任务平均分布在一天中，不太可能形成热点。</li></ul><p id="e6d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么这种使用CloudWatch计划和Lambda的方法可能足以满足您的需求。即使你将经历一些热点，也有办法在一定程度上减轻它们。正如我们在这篇文章中讨论的，你可以做几件事来增加你的吞吐量:</p><ul class=""><li id="1daf" class="jq jr hu it b iu iv iy iz jc js jg jt jk ju jo jv jw jx jy dt translated">您可以跟踪任务的状态。这允许cron函数的多个实例重叠。</li><li id="114c" class="jq jr hu it b iu jz iy ka jc kb jg kc jk kd jo jv jw jx jy dt translated">你可以先把任务交给SQS。这让您可以利用SQS和Lambda提供的批处理和并行支持。你还可以免费获得DLQ的支持。</li></ul><p id="d51b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望你喜欢这篇文章，作为这个系列的一部分，我们将讨论其他几种安排临时任务的方法。看好这个空间；-)</p><h1 id="6b3d" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">阅读其他方法</h1><ul class=""><li id="717c" class="jq jr hu it b iu lc iy ld jc mo jg mp jk mq jo jv jw jx jy dt translated"><a class="ae jp" href="https://theburningmonk.com/2019/03/dynamodb-ttl-as-an-ad-hoc-scheduling-mechanism/" rel="noopener ugc nofollow" target="_blank"> DynamoDB TTL作为临时调度机制</a></li></ul></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff my"><img src="../Images/4eb6cea681d54079d11b89dc08536980.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/0*taN_w6YGFcT4XC46.png"/></div></figure><p id="6b77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗨，我叫<strong class="it hv">崔琰</strong>。我是一个<a class="ae jp" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> AWS无服务器英雄</strong> </a>和<a class="ae jp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过<a class="ae jp" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae jp" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae jp" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看我的新课程，<a class="ae jp" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">AWS步骤功能完全指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击获取您的副本<a class="ae jp" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="it hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以通过代码<strong class="it hv"> ytcui </strong>获得票面价格的<strong class="it hv"> 40% </strong>。</p><p id="6b69" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击获取您的副本<a class="ae jp" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mr ms hc mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="hn ho hp hq hr"><p id="de18" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mz">原载于2019年5月3日</em><a class="ae jp" href="https://theburningmonk.com/2019/05/using-cloudwatch-and-lambda-to-implement-ad-hoc-scheduling/" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://theburningmonk.com</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>