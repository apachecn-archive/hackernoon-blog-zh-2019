<html>
<head>
<title>The 100% Code Coverage Myth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">100%代码覆盖率的神话</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-100-code-coverage-myth-900b83d20d3d?source=collection_archive---------0-----------------------#2019-02-12">https://medium.com/hackernoon/the-100-code-coverage-myth-900b83d20d3d?source=collection_archive---------0-----------------------#2019-02-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/09318ad51d1ca59d5c500744e2b0b492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcwuJXPS5Lz-IpbnmFPGFQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Licensed from Adobe Stock Photo</figcaption></figure><p id="8e77" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt ke translated">现在互联网上有很多建议说100%的覆盖率不是一个值得追求的目标。</p><p id="5199" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我强烈反对。</p><p id="097a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通常，代码难以测试是需要重构的标志。</p><p id="0c07" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我明白了。几年前，我的测试很糟糕。我以为这只是会让我走得更慢的东西。</p><p id="c5ed" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当我开始编码的时候，人们很少这么做。如果是的话，通常是一个独立的QA团队负责。几年前，虽然它成为一个真正的热门话题。面试开始期望候选人知道如何写测试，越来越多的组织自上而下地推动它作为一个质量倡议。</p><p id="440d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我总是努力做到最好，我决定走进面试时说“测试不是我的强项”不再是一个好的选择，所以我决定从那时起我要对我的所有测试进行100%的覆盖。</p><p id="df4f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当时，我真的不确定我能从中得到什么好处，或者真的有什么好处。</p><p id="d2ec" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我<em class="kn">老老实实</em>不回去了。当100%覆盖率的代码库出现问题时，您的测试很可能会告诉您具体的位置和方式。</p><p id="a506" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这并不是说单元测试就是你所需要的。它不是。但是在我看来，让代码未经测试也不是一个好的选择。</p><p id="5cd3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">跟我回去吧，回到我也不相信测试覆盖的好处的时候。</p><h1 id="9f44" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated"><strong class="ak">第一部分:学习行话</strong></h1><p id="de03" class="pw-post-body-paragraph jg jh hu ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hn dt translated">当时交易的工具是<a class="ae lr" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>、<a class="ae lr" href="https://sinonjs.org/" rel="noopener ugc nofollow" target="_blank">西农</a>和<a class="ae lr" href="https://www.chaijs.com/" rel="noopener ugc nofollow" target="_blank">柴</a>的组合。Mocha是测试者，sinon提供了创建“模拟”和“间谍”的能力，而chai是一个断言库，因此您可以以人类语言友好的方式键入断言。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/5842b1e36ea3d750cb72c07bdd4c7777.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*zl99dbB99Re74HqugjqEzA.jpeg"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Is this a spy?</figcaption></figure><p id="bcfa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我根本不知道这意味着什么。在我变得有效率之前，首先要做的是学习语言。</p><p id="1fc7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以，首先，到底是间谍还是骗子？</p><p id="024c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">虽然我首先想到的是詹姆斯·邦德或者伊森·亨特。这绝对不是我们在这里谈论的，尽管这不是一个可怕的比喻。</p><p id="0c23" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在阅读了一些文档后，我最终了解到spy是一个被测试框架修改过的函数，它提供了关于它如何被使用的元信息。它暗中监视它。有点像人们如何通过苹果最近的FaceTime Bug来监视你。有点像詹姆斯·邦德。</p><p id="e678" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">模仿和间谍很相似，但是它被修改得更多。除了提供和跟踪特定函数的使用情况，它还改变了其行为，使其变得可预测。</p><p id="e2ce" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我还了解到有几种测试。不限于最常见的三种:单元测试、集成测试和E2E测试。</p><p id="76ce" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当我们进行“单元测试”时，这意味着我们需要能够将代码分解成单独的单元。该特定单元之外的任何东西都是被嘲笑的对象，比如其他函数或整个模块。Jest是我选择的单元测试工具。单元测试是唯一测量覆盖率的测试类型。</p><p id="3b2c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">当我们进行集成测试时，我们是在测试我们的软件与其他软件的集成，例如通过Kafka传递我们的服务应该接收到的消息的测试，并且之后可以在数据库中找到其结果。在创建集成测试时，我也经常开玩笑。</p><p id="0a55" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">E2E测试有点像使用你的应用程序的机器人。你把它编程为在浏览器中加载站点，点击东西，并确保从用户的角度来看一切都按预期工作。在这方面，Cypress是我最喜欢的工具，但是在我学习的时候它还不存在。Selenium是当时的大玩家，老实说，这是一个足够大的领域，我很乐意让QA自动化工程师来处理这一部分。</p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><p id="5cdb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有了新知识，现在是困难的部分:把它付诸实践。</p><p id="dabb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我花了几个月的时间来确保我写的每一段代码都有测试覆盖率。起初，我承认，这很困难。我花了很多时间在StackOverflow上查找嘲讽和刺探的例子。到最后，我发现我对我的代码的信心大大提高了。</p><p id="509c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">另一个好处是，当我的测试出现问题时，通常会告诉我确切的位置。当其他工程师对我的代码进行修改时，我可以更快地检查它。当重要的API改变时，人们通过失败的测试得到警告，要么快速更新它，要么重新考虑他们的改变。</p><p id="7643" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">不仅如此，我开始编写更好的代码。我了解到，通常如果有些东西很难测试，或者很难完全覆盖，这通常意味着我没有写好代码，它可以被重构，从而产生更易维护和更灵活的API。为此，试图达到100%的覆盖率鼓励我将匿名函数提取到命名函数中，并理解许多重构中的部分应用程序和依赖注入。</p><p id="42a7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在完成集成测试之后，我甚至放弃了GitFlow，转而进行基于主干的开发。几年前，我认为致力于master是一件疯狂的事情，现在，我每天都在一个由近15名工程师组成的团队中这样做。</p><div class="me mf fm fo mg mh"><a href="https://hackernoon.com/i-have-a-confession-to-make-i-commit-to-master-6a804f334beb" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">我要向你坦白…我向师父承诺。</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">我曾经鼓吹Git Flow来保持我的代码可发布、可回滚，并保持一个干净的历史。但现在不是了——</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">hackernoon.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ja mh"/></div></div></a></div></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><h1 id="8a6c" class="ko kp hu bd kq kr mw kt ku kv mx kx ky kz my lb lc ld mz lf lg lh na lj lk ll dt translated">第2部分:以身作则</h1><p id="d289" class="pw-post-body-paragraph jg jh hu ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hn dt translated">在我对我的新测试栈越来越有信心的时候，另一个工具被引入市场，许多人声称它使单元测试更加简单:Jest。</p><p id="8d43" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Jest是由脸书首创的自动化测试框架。</p><p id="74c2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Jest做了一件非常棒的工作，将我以前使用的库浓缩到一个连贯的框架中，这个框架是一个测试运行器，以及一组用于模仿、监视和断言的API。除了提供满足所有单元测试需求的单一库之外，Jest在简化一些概念和模式以及强大而简单的模拟方面做得很好。</p><p id="82a3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为我认为Jest更容易使用和理解，所以我将继续使用Jest作为例子。</p><p id="ffbf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你只是和我一起写这篇文章，那很好——到目前为止你所读到的内容是独立的。然而，我一直在记录使用Parcel with Streaming SSR构建React应用程序的过程，本文将从上一部分停止的地方继续。</p><p id="a509" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我的上一篇文章(链接如下)中，我展示了如何用代码覆盖率设置Jest，并说在下一篇文章中我将展示如何获得高达100%的覆盖率。</p><div class="me mf fm fo mg mh"><a href="https://hackernoon.com/enforcing-code-quality-for-node-js-c3b837d7ae17" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">强制Node.js的代码质量</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">使用林挺、格式化和带有代码覆盖的单元测试来实施质量标准</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">hackernoon.com</p></div></div><div class="mq l"><div class="nb l ms mt mu mq mv ja mh"/></div></div></a></div><p id="28d3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我认为展示100%覆盖率的最好方式是展示如何到达那里。在整个过程中，我们可能会发现几个地方的代码可以重构，以提高可测试性。因此，我将从我停止的地方继续，并使这个项目的覆盖率达到100%，并展示要做什么样的重构，在哪里使用部分应用程序和依赖注入，以及当覆盖率难以达到时，在这个过程中要模仿什么。</p><p id="9c30" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那么…让我们开始吧。这是我将要做的项目:</p><div class="me mf fm fo mg mh"><a href="https://github.com/patrickleet/streaming-ssr-react-styled-components" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">Patrick let/streaming-SSR-react-styled-组件</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">流式ssr反应风格组件与包裹。贡献给Patrick let/streaming-SSR-react-styled-components…</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">github.com</p></div></div><div class="mq l"><div class="nc l ms mt mu mq mv ja mh"/></div></div></a></div><p id="5faa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">该项目在<code class="eh nd ne nf ng b">app</code>文件夹中有一个react应用程序，以及一个包含SSR逻辑的<code class="eh nd ne nf ng b">server</code>文件夹。让我们从应用程序测试开始。</p><h2 id="5937" class="nh kp hu bd kq ni nj nk ku nl nm nn ky jr no np lc jv nq nr lg jz ns nt lk nu dt translated">应用测试</h2><p id="e5df" class="pw-post-body-paragraph jg jh hu ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hn dt translated">在<a class="ae lr" href="https://hackernoon.com/enforcing-code-quality-for-node-js-c3b837d7ae17" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中，在配置Jest之后，我开始对一个简单的组件进行简单的测试。我有几个同样简单的React组件。</p><p id="0b65" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这也是功能组件真正强大的原因之一。函数比类更容易测试。它们没有状态，而是有输入和输出。给定输入X，它们有输出y。当有状态时，它可以存储在组件的外部。</p><p id="90fc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">新的React Hooks API在这方面很好，因为它鼓励创建功能组件，并且有一个容易模仿的机制来为组件提供状态。Redux在测试方面提供了同样的好处。</p><p id="ed41" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们从敲出其余的简单组件开始。我们基本上只需要渲染它们，并检查一些重要的信息是否被渲染。</p><p id="a37c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我通常将代码内嵌在文章中，但是这些测试中并没有什么新的东西，所以我决定链接到实际的提交，并且只展示一个完整的例子:</p><p id="0d1d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看看“关于”页面:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="3499" class="nh kp hu ng b fv nz oa l ob oc">import React from 'react'<br/>import Helmet from 'react-helmet-async'<br/>import Page from '../components/Page'</span><span id="65bf" class="nh kp hu ng b fv od oa l ob oc">const About = () =&gt; (<br/>  &lt;Page&gt;<br/>    &lt;Helmet&gt;<br/>      &lt;title&gt;About Page&lt;/title&gt;<br/>    &lt;/Helmet&gt;</span><span id="0750" class="nh kp hu ng b fv od oa l ob oc">    &lt;div&gt;This is the about page&lt;/div&gt;<br/>  &lt;/Page&gt;<br/>)</span><span id="fd8c" class="nh kp hu ng b fv od oa l ob oc">export default About</span></pre><p id="5883" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是测试:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="cad0" class="nh kp hu ng b fv nz oa l ob oc">import React from 'react'<br/>import { shallow } from 'enzyme'<br/>import About from 'app/pages/About.jsx'</span><span id="20e8" class="nh kp hu ng b fv od oa l ob oc">describe('app/pages/About.jsx', () =&gt; {<br/>  it('renders About page', () =&gt; {<br/>    expect(About).toBeDefined()<br/>    const tree = shallow(&lt;About /&gt;)<br/>    expect(tree.find('Page')).toBeDefined()<br/>    expect(<br/>      tree<br/>        .find('Helmet')<br/>        .find('title')<br/>        .text()<br/>    ).toEqual('About Page')<br/>    expect(tree.find('div').text()).toEqual('This is the about page')<br/>  })<br/>})</span></pre><p id="a937" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下提交中的所有测试都非常相似:</p><ul class=""><li id="9cd1" class="oe of hu ji b jj jk jn jo jr og jv oh jz oi kd oj ok ol om dt translated"><a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/3a81d9e2cdad6d025527f27e7d73e6ce9a670a8c" rel="noopener ugc nofollow" target="_blank">修复:页面测试</a></li><li id="5ead" class="oe of hu ji b jj on jn oo jr op jv oq jz or kd oj ok ol om dt translated"><a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/49ff4a2a4fedecb03be9292c32a36ca7258188a5" rel="noopener ugc nofollow" target="_blank">修复:组件测试</a></li><li id="a175" class="oe of hu ji b jj on jn oo jr op jv oq jz or kd oj ok ol om dt translated"><a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/5a05a969f35bd8d2f7c68dacb8b8a03f9618819d" rel="noopener ugc nofollow" target="_blank">测试:样式组件渲染测试</a></li></ul><p id="0147" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">正如你所看到的，仅仅确保我们的组件渲染就足以让这些组件获得100%的覆盖率。更详细的交互最好留给E2E测试，这超出了本文的范围。</p><p id="e50b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下一个组件<code class="eh nd ne nf ng b">app/App.jsx</code>稍微复杂一些。在编写了一个渲染测试之后，您会注意到路由器中仍然有一个不可到达的匿名函数用于渲染About页面。</p><p id="8090" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了访问和测试它，我们想做一个小的重构，将函数提取到一个命名函数中，这样我们就可以导出它并进行测试。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff os"><img src="../Images/6d5575cad760d7fe1d438000d37e98cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trTwGt6wXVf5dcIz88TqYA.png"/></div></div></figure><p id="235b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在很容易测试:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ot"><img src="../Images/eeacddf55347e1516649a76b4ad2c75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsz_5ULRuW4zA_p1w4868A.png"/></div></div></figure><p id="6ac4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因为我们对上面的About页面有另一组测试，我们将把它的更具体的测试留在那里，只需要检查它在这里的呈现。</p><p id="c8da" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这样，我们的应用程序中剩下的唯一要测试的文件是<code class="eh nd ne nf ng b">app/client.js</code>，然后我们可以继续完成服务器端测试。</p><p id="bcbd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看一下代码:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="fb77" class="nh kp hu ng b fv nz oa l ob oc">import React from 'react'<br/>import ReactDOM from 'react-dom'<br/>import { HelmetProvider } from 'react-helmet-async'<br/>import { BrowserRouter } from 'react-router-dom'<br/>import { rehydrateMarks } from 'react-imported-component'<br/>import importedComponents from './imported' // eslint-disable-line<br/>import App from './App'</span><span id="934f" class="nh kp hu ng b fv od oa l ob oc">const element = document.getElementById('app')<br/>const app = (<br/>  &lt;HelmetProvider&gt;<br/>    &lt;BrowserRouter&gt;<br/>      &lt;App /&gt;<br/>    &lt;/BrowserRouter&gt;<br/>  &lt;/HelmetProvider&gt;<br/>)</span><span id="bee4" class="nh kp hu ng b fv od oa l ob oc">// In production, we want to hydrate instead of render<br/>// because of the server-rendering<br/>if (process.env.NODE_ENV === 'production') {<br/>  // rehydrate the bundle marks<br/>  rehydrateMarks().then(() =&gt; {<br/>    ReactDOM.hydrate(app, element)<br/>  })<br/>} else {<br/>  ReactDOM.render(app, element)<br/>}</span><span id="461a" class="nh kp hu ng b fv od oa l ob oc">// Enable Hot Module Reloading<br/>if (module.hot) {<br/>  module.hot.accept()<br/>}</span></pre><p id="4854" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我注意到的第一件事是对全局变量的依赖——<code class="eh nd ne nf ng b">document</code>、<code class="eh nd ne nf ng b">process</code>和<code class="eh nd ne nf ng b">module</code>。第二件事是没有导出任何东西，所以可能很难用不同的输入运行多次。</p><p id="b902" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们可以通过一些重构来解决这个问题:</p><ol class=""><li id="50b8" class="oe of hu ji b jj jk jn jo jr og jv oh jz oi kd ou ok ol om dt translated">将所有的逻辑打包成一个可以导出的函数。该函数将接受一个选项对象及其所有依赖项。这被称为<strong class="ji hv">依赖注入</strong>。如果我们愿意，这将允许我们轻松地传递一堆事物的模拟版本。</li><li id="e4f4" class="oe of hu ji b jj on jn oo jr op jv oq jz or kd ou ok ol om dt translated">我们有一个在生产模式中的匿名函数，它应该被提取为一个命名函数。</li></ol><p id="5d69" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们还想模仿一些外部模块:<code class="eh nd ne nf ng b">react-dom</code>、<code class="eh nd ne nf ng b">react-imported-component</code>和<code class="eh nd ne nf ng b">app/imported.js</code>。模块本身就是依赖注入的一种形式。</p><p id="ed55" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，这里是新重构的文件，更改以粗体显示:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="f69d" class="nh kp hu ng b fv nz oa l ob oc">import React from 'react'<br/>import ReactDOM from 'react-dom'<br/>import { HelmetProvider } from 'react-helmet-async'<br/>import { BrowserRouter } from 'react-router-dom'<br/>import { rehydrateMarks } from 'react-imported-component'<br/>import importedComponents from './imported' // eslint-disable-line<br/>import App from './App'</span><span id="9864" class="nh kp hu ng b fv od oa l ob oc">// use "partial application" to make this easy to test<strong class="ng hv"><br/>export const hydrate = (app, element) =&gt; () =&gt; {<br/>  ReactDOM.hydrate(app, element)<br/>}</strong></span><span id="4db2" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">export const start = ({ <br/>  isProduction,<br/>  document,<br/>  module,<br/>  hydrate<br/> }) =&gt; {</strong><br/>  const element = document.getElementById('app')<br/>  const app = (<br/>    &lt;HelmetProvider&gt;<br/>      &lt;BrowserRouter&gt;<br/>        &lt;App /&gt;<br/>      &lt;/BrowserRouter&gt;<br/>    &lt;/HelmetProvider&gt;<br/>  )</span><span id="52e8" class="nh kp hu ng b fv od oa l ob oc">  // In production, we want to hydrate instead of render<br/>  // because of the server-rendering<br/>  if (<strong class="ng hv">isProduction</strong>) {<br/>    // rehydrate the bundle marks from imported-components, <br/>    // then rehydrate the react app<br/>    rehydrateMarks().then(<strong class="ng hv">hydrate(app, element)</strong>)<br/>  } else {<br/>    ReactDOM.render(app, element)<br/>  }</span><span id="50b0" class="nh kp hu ng b fv od oa l ob oc">  // Enable Hot Module Reloading<br/>  if (module.hot) {<br/>    module.hot.accept()<br/>  }<br/>}</span><span id="70e7" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">const options = {<br/>  isProduction: process.env.NODE_ENV === 'production',<br/>  document: document,<br/>  module: module,<br/>  hydrate<br/>}</strong></span><span id="506e" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">start(options)</strong></span></pre><p id="3354" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们实际上可以使用各种选项访问和测试start，并独立于启动逻辑测试水合物。</p><p id="f58b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">测试有点长，所以我在里面放了注释来解释发生了什么。以下是对该文件的测试:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="b21d" class="nh kp hu ng b fv nz oa l ob oc">import React from 'react'<br/>import fs from 'fs'<br/>import path from 'path'<br/>import { start, hydrate } from 'app/client'<br/>import { JSDOM } from "jsdom"</span><span id="3c0e" class="nh kp hu ng b fv od oa l ob oc">jest.mock('react-dom')<br/>jest.mock('react-imported-component')<br/>jest.mock('app/imported.js')</span><span id="9251" class="nh kp hu ng b fv od oa l ob oc">// mock DOM with actual index.html contents<br/>const pathToIndex = path.join(process.cwd(), 'app', 'index.html')<br/>const indexHTML = fs.readFileSync(pathToIndex).toString()<br/>const DOM = new JSDOM(indexHTML)<br/>const document = DOM.window.document</span><span id="db90" class="nh kp hu ng b fv od oa l ob oc">// this doesn't contribute to coverage, but we<br/>// should know if it changes as it would<br/>// cause our app to break<br/>describe('app/index.html', () =&gt; {<br/>  it('has element with id "app"', () =&gt; {<br/>    const element = document.getElementById('app')<br/>    expect(element.id).toBe('app')<br/>  })<br/>})</span><span id="7c26" class="nh kp hu ng b fv od oa l ob oc">describe('app/client.js', () =&gt; {</span><span id="d2e7" class="nh kp hu ng b fv od oa l ob oc">  // Reset counts of mock calls after each test<br/>  afterEach(() =&gt; {<br/>    jest.clearAllMocks()<br/>  })</span><span id="82df" class="nh kp hu ng b fv od oa l ob oc">  describe('#start', () =&gt; {<br/>    it('renders when in development and accepts hot module reloads', () =&gt; {<br/>      // this is mocked above, so require gets the mock version<br/>      // so we can see if its functions are called<br/>      const ReactDOM = require('react-dom')<br/>      <br/>      // mock module.hot<br/>      const module = {<br/>        hot: {<br/>          accept: jest.fn()<br/>        }<br/>      }</span><span id="8fd9" class="nh kp hu ng b fv od oa l ob oc">      // mock options<br/>      const options = {<br/>        isProduction: false,<br/>        module,<br/>        document<br/>      }</span><span id="c4c2" class="nh kp hu ng b fv od oa l ob oc">      start(options)<br/>      expect(ReactDOM.render).toBeCalled()<br/>      expect(module.hot.accept).toBeCalled()<br/>    })<br/>    <br/>    it('hydrates when in production does not accept hot module reloads', () =&gt; {<br/>      const ReactDOM = require('react-dom')<br/>      const importedComponent = require('react-imported-component')<br/>      importedComponent.rehydrateMarks.mockImplementation(() =&gt; Promise.resolve())</span><span id="bbec" class="nh kp hu ng b fv od oa l ob oc">      // mock module.hot<br/>      const module = {}</span><span id="4440" class="nh kp hu ng b fv od oa l ob oc">      // mock rehydrate function<br/>      const hydrate = jest.fn()</span><span id="52b5" class="nh kp hu ng b fv od oa l ob oc">      // mock options<br/>      const options = {<br/>        isProduction: true,<br/>        module,<br/>        document,<br/>        hydrate<br/>      }</span><span id="31f9" class="nh kp hu ng b fv od oa l ob oc">      start(options)<br/>      expect(ReactDOM.render).not.toBeCalled()<br/>      expect(hydrate).toBeCalled()<br/>    })</span><span id="69f5" class="nh kp hu ng b fv od oa l ob oc">  })</span><span id="3cd0" class="nh kp hu ng b fv od oa l ob oc">  describe('#hydrate', () =&gt; {<br/>    it('uses ReactDOM to hydrate given element with an app', () =&gt; {<br/>      const ReactDOM = require('react-dom')<br/>      const element = document.getElementById('app')<br/>      const app = (&lt;div&gt;&lt;/div&gt;)<br/>      const doHydrate = hydrate(app, element)</span><span id="5b2c" class="nh kp hu ng b fv od oa l ob oc">      expect(typeof doHydrate).toBe('function')</span><span id="d0c1" class="nh kp hu ng b fv od oa l ob oc">      doHydrate()<br/>      expect(ReactDOM.hydrate).toBeCalledWith(app, element)<br/>    })<br/>  })</span><span id="5c54" class="nh kp hu ng b fv od oa l ob oc">})</span></pre><p id="9e24" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，当我们运行测试时，我们应该100%覆盖<code class="eh nd ne nf ng b">app</code>文件夹，除了<code class="eh nd ne nf ng b">app/imported.js</code>是一个生成的文件，测试没有意义，因为它可能会在未来版本中生成不同的文件。</p><p id="719d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们更新jest配置，从覆盖率统计中忽略它，并检查结果。</p><p id="5440" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<code class="eh nd ne nf ng b">jest.config</code>添加:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="e485" class="nh kp hu ng b fv nz oa l ob oc">"coveragePathIgnorePatterns": [<br/>  "&lt;rootDir&gt;/app/imported.js",<br/>  "/node_modules/"<br/>]</span></pre><p id="3ab1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，当我们运行<code class="eh nd ne nf ng b">npm run test</code>时，我们得到以下结果。</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ov"><img src="../Images/5788dcb1c7e89157a9dcf307ab11c3b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6xMIBuHA4LvmUrt7-GovQ.png"/></div></div></figure><div class="me mf fm fo mg mh"><a href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/c5fcfe9fdfb24d1708fb1d23b7126058d7b44fe4" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">test: client.js测试Patrick let/streaming-SSR-react-styled-components @ C5 fcfe 9</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">流式ssr反应风格组件与包裹。贡献给Patrick let/streaming-SSR-react-styled-components…</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">github.com</p></div></div><div class="mq l"><div class="ow l ms mt mu mq mv ja mh"/></div></div></a></div><p id="6ecd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我想指出的一点是，当我开发测试时，我通常使用“观察”模式来这样做，所以当测试改变时，它们会自动重新运行。</p><p id="35d3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">应用程序测试完成后，让我们继续讨论服务器。</p><h2 id="3c82" class="nh kp hu bd kq ni nj nk ku nl nm nn ky jr no np lc jv nq nr lg jz ns nt lk nu dt translated">服务器测试</h2><p id="ee98" class="pw-post-body-paragraph jg jh hu ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hn dt translated">在上一篇文章中，我为一个应用程序文件和一个服务器文件编写了测试，所以我们已经为<code class="eh nd ne nf ng b">server/index.js</code>编写了测试。现在我们需要测试<code class="eh nd ne nf ng b">server/lib</code>中剩余的三个文件。</p><p id="b96a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">先说<code class="eh nd ne nf ng b">server/lib/client.js</code>:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="545f" class="nh kp hu ng b fv nz oa l ob oc">import fs from 'fs'<br/>import path from 'path'<br/>import cheerio from 'cheerio'</span><span id="436f" class="nh kp hu ng b fv od oa l ob oc">export const htmlPath = path.join(process.cwd(), 'dist', 'client', 'index.html')<br/>export const rawHTML = fs.readFileSync(htmlPath).toString()</span><span id="64ee" class="nh kp hu ng b fv od oa l ob oc">export const parseRawHTMLForData = (template, selector = '#js-entrypoint') =&gt; {<br/>  const $template = cheerio.load(template)<br/>  let src = $template(selector).attr('src')</span><span id="262e" class="nh kp hu ng b fv od oa l ob oc">  return {<br/>    src<br/>  }<br/>}</span><span id="2ada" class="nh kp hu ng b fv od oa l ob oc">const clientData = parseRawHTMLForData(rawHTML)</span><span id="f8ad" class="nh kp hu ng b fv od oa l ob oc">const appString = '&lt;div id="app"&gt;'<br/>const splitter = '###SPLIT###'<br/>const [startingRawHTMLFragment, endingRawHTMLFragment] = rawHTML<br/>  .replace(appString, `${appString}${splitter}`)<br/>  .split(splitter)</span><span id="7be3" class="nh kp hu ng b fv od oa l ob oc">export const getHTMLFragments = ({ drainHydrateMarks }) =&gt; {<br/>  const startingHTMLFragment = `${startingRawHTMLFragment}${drainHydrateMarks}`<br/>  return [startingHTMLFragment, endingRawHTMLFragment]<br/>}</span></pre><p id="f508" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，我注意到有一大块代码甚至没有在项目中使用，这些代码来自以前放弃的策略。从<code class="eh nd ne nf ng b"> export const parseRawHTMLForData</code>到<code class="eh nd ne nf ng b">const clientData</code>的一切。</p><p id="ef74" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我先把它删掉。代码越少，存在bug的地方就越少。还有几个我从未使用过的导出，它们可以保持模块私有。</p><p id="59cc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以下是更新后的文件:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="637c" class="nh kp hu ng b fv nz oa l ob oc">import fs from 'fs'<br/>import path from 'path'</span><span id="953f" class="nh kp hu ng b fv od oa l ob oc">const htmlPath = path.join(process.cwd(), 'dist', 'client', 'index.html')<br/>const rawHTML = fs.readFileSync(htmlPath).toString()</span><span id="e3da" class="nh kp hu ng b fv od oa l ob oc">const appString = '&lt;div id="app"&gt;'<br/>const splitter = '###SPLIT###'<br/>const [startingRawHTMLFragment, endingRawHTMLFragment] = rawHTML<br/>  .replace(appString, `${appString}${splitter}`)<br/>  .split(splitter)</span><span id="42a0" class="nh kp hu ng b fv od oa l ob oc">export const getHTMLFragments = ({ drainHydrateMarks }) =&gt; {<br/>  const startingHTMLFragment = `${startingRawHTMLFragment}${drainHydrateMarks}`<br/>  return [startingHTMLFragment, endingRawHTMLFragment]<br/>}</span></pre><p id="6433" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">看起来一个测试就可以解决这个问题。然而，在这个计划中有一个小问题:这个文件依赖于之前运行的构建，因为它读入了生成的构建。</p><p id="4142" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从技术上来说，这是有意义的，因为如果没有构建好的应用程序要呈现，你永远不会尝试在服务器上呈现应用程序。</p><p id="87d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">考虑到这种约束，我会说这是可以的，而且可能不值得努力重构，因为我们只能确保我们的管道调用在测试之前构建。如果我们想有真正纯粹的单元隔离，我们可能会考虑更多的重构，因为从技术上来说，整个应用程序是SSR的依赖，所以它可能会被嘲笑。另一方面，使用实际的构建可能更有用。在编写测试的过程中，您会经常遇到这样的权衡。</p><p id="af3a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">也就是说，下面是全面覆盖本模块的测试:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="40de" class="nh kp hu ng b fv nz oa l ob oc">import { getHTMLFragments } from 'server/lib/client.js'</span><span id="9b82" class="nh kp hu ng b fv od oa l ob oc">describe('client', () =&gt; {<br/>  it('exists', () =&gt; {<br/>    const drainHydrateMarks = '&lt;!-- mock hydrate marks --&gt;'<br/>    const [start, end] = getHTMLFragments({ drainHydrateMarks })<br/>    expect(start).toContain('&lt;head&gt;')<br/>    expect(start).toContain(drainHydrateMarks)<br/>    expect(end).toContain('script id="js-entrypoint"')<br/>  })<br/>})</span></pre><p id="a494" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以及提交:<a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/792da703e246726f63b04390588251dbccbfe910" rel="noopener ugc nofollow" target="_blank">修复:删除解析模板</a>未使用的代码，<a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/e757402d7c27ff59c46ec7d733ef0d4bb0323f26" rel="noopener ugc nofollow" target="_blank">测试:服务器/库/客户端测试</a>。</p><p id="f3e0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，<code class="eh nd ne nf ng b">server/lib/server.js</code>非常小，所以让我们把它敲出来。以下是它的代码，提醒你一下，或者如果你刚刚加入我们:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="92d8" class="nh kp hu ng b fv nz oa l ob oc">import express from 'express'</span><span id="403c" class="nh kp hu ng b fv od oa l ob oc">export const server = express()<br/>export const serveStatic = express.static</span></pre><p id="e3f1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">测试是:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="bdc7" class="nh kp hu ng b fv nz oa l ob oc">import express from 'express'<br/>import { server, serveStatic } from 'server/lib/server.js'</span><span id="acc3" class="nh kp hu ng b fv od oa l ob oc">describe('server/lib/server', () =&gt; {<br/>  it('should provide server APIs to use', () =&gt; {<br/>    expect(server).toBeDefined()<br/>    expect(server.use).toBeDefined()<br/>    expect(server.get).toBeDefined()<br/>    expect(server.listen).toBeDefined()<br/>    expect(serveStatic).toEqual(express.static)<br/>  })<br/>})</span></pre><p id="6026" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">看起来我们基本上只是把所有的责任都推给了express，我们希望express提供这个合同，我们只需简单地确保它提供，超出这个范围就没有什么意义了。</p><p id="c83e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，我们只剩下一个文件需要测试:<code class="eh nd ne nf ng b">server/lib/ssr.js</code>。</p><p id="8577" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是我们的<code class="eh nd ne nf ng b">ssr</code>模块:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="91a3" class="nh kp hu ng b fv nz oa l ob oc">import React from 'react'<br/>import { renderToNodeStream } from 'react-dom/server'<br/>import { HelmetProvider } from 'react-helmet-async'<br/>import { StaticRouter } from 'react-router-dom'<br/>import { ServerStyleSheet } from 'styled-components'<br/>import { printDrainHydrateMarks } from 'react-imported-component'<br/>import log from 'llog'<br/>import through from 'through'<br/>import App from '../../app/App'<br/>import { getHTMLFragments } from './client'<br/>// import { getDataFromTree } from 'react-apollo';</span><span id="895f" class="nh kp hu ng b fv od oa l ob oc">export default (req, res) =&gt; {<br/>  const context = {}<br/>  const helmetContext = {}</span><span id="f37e" class="nh kp hu ng b fv od oa l ob oc">  const app = (<br/>    &lt;HelmetProvider context={helmetContext}&gt;<br/>      &lt;StaticRouter location={req.originalUrl} context={context}&gt;<br/>        &lt;App /&gt;<br/>      &lt;/StaticRouter&gt;<br/>    &lt;/HelmetProvider&gt;<br/>  )</span><span id="a0ad" class="nh kp hu ng b fv od oa l ob oc">  try {<br/>    // If you were using Apollo, you could fetch data with this<br/>    // await getDataFromTree(app);</span><span id="3099" class="nh kp hu ng b fv od oa l ob oc">    const sheet = new ServerStyleSheet()<br/>    const stream = sheet.interleaveWithNodeStream(<br/>      renderToNodeStream(sheet.collectStyles(app))<br/>    )</span><span id="7e29" class="nh kp hu ng b fv od oa l ob oc">    if (context.url) {<br/>      res.redirect(301, context.url)<br/>    } else {<br/>      const [startingHTMLFragment, endingHTMLFragment] = getHTMLFragments({<br/>        drainHydrateMarks: printDrainHydrateMarks()<br/>      })<br/>      res.status(200)<br/>      res.write(startingHTMLFragment)<br/>      stream<br/>        .pipe(<br/>          through(<br/>            function write (data) {<br/>              this.queue(data)<br/>            },<br/>            function end () {<br/>              this.queue(endingHTMLFragment)<br/>              this.queue(null)<br/>            }<br/>          )<br/>        )<br/>        .pipe(res)<br/>    }<br/>  } catch (e) {<br/>    log.error(e)<br/>    res.status(500)<br/>    res.end()<br/>  }<br/>}</span></pre><p id="e354" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有点长，要执行的路径也不多。我确实想做一些小的重构，让隔离变得更容易一些，比如提取逻辑以将应用程序生成到一个单独的函数中，并使用partial application来注入应用程序流渲染器，这样我们就可以轻松地模拟一些重定向。</p><p id="438f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">另外<code class="eh nd ne nf ng b">write</code>和<code class="eh nd ne nf ng b">end</code>有点难到达，所以我们也可以使用部分应用将它们拉得更高。</p><p id="2d10" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是一个更新的版本:</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="a602" class="nh kp hu ng b fv nz oa l ob oc">import React from 'react'<br/>import { renderToNodeStream } from 'react-dom/server'<br/>import { HelmetProvider } from 'react-helmet-async'<br/>import { StaticRouter } from 'react-router-dom'<br/>import { ServerStyleSheet } from 'styled-components'<br/>import { printDrainHydrateMarks } from 'react-imported-component'<br/>import log from 'llog'<br/>import through from 'through'<br/>import App from '../../app/App'<br/>import { getHTMLFragments } from './client'<br/>// import { getDataFromTree } from 'react-apollo';</span><span id="beb8" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">const getApplicationStream = (originalUrl, context) =&gt; {</strong><br/>  const helmetContext = {}<br/>  const app = (<br/>    &lt;HelmetProvider context={helmetContext}&gt;<br/>      &lt;StaticRouter location={originalUrl} context={context}&gt;<br/>        &lt;App /&gt;<br/>      &lt;/StaticRouter&gt;<br/>    &lt;/HelmetProvider&gt;<br/>  )</span><span id="1ba0" class="nh kp hu ng b fv od oa l ob oc">  const sheet = new ServerStyleSheet()<br/>  return sheet.interleaveWithNodeStream(<br/>    renderToNodeStream(sheet.collectStyles(app))<br/>  )<br/>}</span><span id="41fc" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">export function write (data) {<br/>  this.queue(data)<br/>}</strong></span><span id="50cf" class="nh kp hu ng b fv od oa l ob oc">// partial application with ES6 is quite succinct<br/>// it just means a function which returns another function<br/>// which has access to values from a closure<br/><strong class="ng hv">export const end = endingHTMLFragment =&gt;<br/>  function end () {<br/>    this.queue(endingHTMLFragment)<br/>    this.queue(null)<br/>  }</strong></span><span id="2c63" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">export const ssr = getApplicationStream =&gt; (req, res) =&gt; {</strong><br/>  try {<br/>    // If you were using Apollo, you could fetch data with this<br/>    // await getDataFromTree(app);</span><span id="f226" class="nh kp hu ng b fv od oa l ob oc">    const context = {}<br/>    const stream = getApplicationStream(req.originalUrl, context)</span><span id="aae6" class="nh kp hu ng b fv od oa l ob oc">    if (context.url) {<br/>      return res.redirect(301, context.url)<br/>    }</span><span id="d5a4" class="nh kp hu ng b fv od oa l ob oc">    const [startingHTMLFragment, endingHTMLFragment] = getHTMLFragments({<br/>      drainHydrateMarks: printDrainHydrateMarks()<br/>    })</span><span id="4477" class="nh kp hu ng b fv od oa l ob oc">    res.status(200)<br/>    res.write(startingHTMLFragment)<br/>    stream.pipe(through(write, end(endingHTMLFragment))).pipe(res)<br/>  } catch (e) {<br/>    log.error(e)<br/>    res.status(500)<br/>    res.end()<br/>  }<br/><strong class="ng hv">}</strong></span><span id="a9e3" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">const defaultSSR = ssr(getApplicationStream)</strong></span><span id="93ec" class="nh kp hu ng b fv od oa l ob oc"><strong class="ng hv">export default defaultSSR</strong></span></pre><p id="027f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里有一个链接来看看Github中的区别:<a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/8d91c3d3a07bcb1949df6cc0f4d8b1fac3a6d2ea" rel="noopener ugc nofollow" target="_blank">苦差事:重构ssr将其分解/使其更容易阅读</a>，以及<a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/a6cceddd929676799f0c3ffdc7ae8862f5282360" rel="noopener ugc nofollow" target="_blank">苦差事:更多地重构SSR</a>。</p><p id="ae7a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在让我们写一些测试。我们需要为这个文件专门为node设置jest-environment，否则styled-components部分将不起作用。</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="6df3" class="nh kp hu ng b fv nz oa l ob oc">/**<br/> * <a class="ae lr" href="http://twitter.com/jest" rel="noopener ugc nofollow" target="_blank">@jest</a>-environment node<br/> */<br/>import defaultSSR, { ssr, write, end } from 'server/lib/ssr.js'</span><span id="9c59" class="nh kp hu ng b fv od oa l ob oc">jest.mock('llog')</span><span id="2e04" class="nh kp hu ng b fv od oa l ob oc">const mockReq = {<br/>  originalUrl: '/'<br/>}</span><span id="177b" class="nh kp hu ng b fv od oa l ob oc">const mockRes = {<br/>  redirect: jest.fn(),<br/>  status: jest.fn(),<br/>  end: jest.fn(),<br/>  write: jest.fn(),<br/>  on: jest.fn(),<br/>  removeListener: jest.fn(),<br/>  emit: jest.fn()<br/>}</span><span id="8b94" class="nh kp hu ng b fv od oa l ob oc">describe('server/lib/ssr.js', () =&gt; {<br/>  describe('ssr', () =&gt; {<br/>    it('redirects when context.url is set', () =&gt; {<br/>      const req = Object.assign({}, mockReq)<br/>      const res = Object.assign({}, mockRes)<br/>      const getApplicationStream = jest.fn((originalUrl, context) =&gt; {<br/>        context.url = '/redirect'<br/>      })<br/>      const doSSR = ssr(getApplicationStream)</span><span id="4321" class="nh kp hu ng b fv od oa l ob oc">      expect(typeof doSSR).toBe('function')<br/>      doSSR(req, res)<br/>      expect(res.redirect).toBeCalledWith(301, '/redirect')<br/>    })</span><span id="d894" class="nh kp hu ng b fv od oa l ob oc">    it('catches error and logs before returning 500', () =&gt; {<br/>      const log = require('llog')<br/>      const req = Object.assign({}, mockReq)<br/>      const res = Object.assign({}, mockRes)<br/>      const getApplicationStream = jest.fn((originalUrl, context) =&gt; {<br/>        throw new Error('test')<br/>      })<br/>      const doSSR = ssr(getApplicationStream)<br/>      expect(typeof doSSR).toBe('function')<br/>      doSSR(req, res)<br/>      expect(log.error).toBeCalledWith(Error('test'))<br/>      expect(res.status).toBeCalledWith(500)<br/>      expect(res.end).toBeCalled()<br/>    })<br/>  })</span><span id="240c" class="nh kp hu ng b fv od oa l ob oc">  describe('defaultSSR', () =&gt; {<br/>    it('renders app with default SSR', () =&gt; {<br/>      const req = Object.assign({}, mockReq)<br/>      const res = Object.assign({}, mockRes)<br/>      defaultSSR(req, res)<br/>      expect(res.status).toBeCalledWith(200)<br/>      expect(res.write.mock.calls[0][0]).toContain('&lt;!DOCTYPE html&gt;')<br/>      expect(res.write.mock.calls[0][0]).toContain(<br/>        'window.___REACT_DEFERRED_COMPONENT_MARKS'<br/>      )<br/>    })<br/>  })</span><span id="daf2" class="nh kp hu ng b fv od oa l ob oc">  describe('#write', () =&gt; {<br/>    it('write queues data', () =&gt; {<br/>      const context = {<br/>        queue: jest.fn()<br/>      }<br/>      const buffer = new Buffer.from('hello')<br/>      write.call(context, buffer)<br/>      expect(context.queue).toBeCalledWith(buffer)<br/>    })<br/>  })</span><span id="22cf" class="nh kp hu ng b fv od oa l ob oc">  describe('#end', () =&gt; {<br/>    it('end queues endingFragment and then null to end stream', () =&gt; {<br/>      const context = {<br/>        queue: jest.fn()<br/>      }<br/>      const endingFragment = '&lt;/html&gt;'<br/>      const doEnd = end(endingFragment)<br/>      doEnd.call(context)<br/>      expect(context.queue).toBeCalledWith(endingFragment)<br/>      expect(context.queue).toBeCalledWith(null)<br/>    })<br/>  })<br/>})</span></pre><p id="abe8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">由于这个文件比其他一些文件稍微复杂一点，所以需要更多的测试来测试所有的分支。为了清楚起见，每个函数都包装在自己的描述块中。</p><p id="f51b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">下面是Github上的提交:<a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/bc6ce3cdd9d82be7fbf58538f9af5f6bf4a44eec" rel="noopener ugc nofollow" target="_blank">测试:ssr单元测试</a>。</p><p id="50d4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，当我们运行我们的测试时，我们有100%的覆盖率！</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ox"><img src="../Images/2aecdbde1fcae5b9d67d8b0e84960a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFJWIX74R5aCtrNMUIfH3g.png"/></div></div></figure><p id="b6c7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，在结束之前，我将对我的<code class="eh nd ne nf ng b">jest.config</code>做一个小小的修改，以实现100%的覆盖率。保持覆盖率比第一次获得覆盖率要容易得多。我们测试的许多模块几乎不会改变。</p><pre class="lt lu lv lw fq nv ng nw nx aw ny dt"><span id="61cb" class="nh kp hu ng b fv nz oa l ob oc">  "coverageThreshold": {<br/>    "global": {<br/>      "branches": 100,<br/>      "functions": 100,<br/>      "lines": 100,<br/>      "statements": 100<br/>    }<br/>  },</span></pre><p id="7db3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">搞定了。下面是Github上的承诺:<a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components/commit/1d00345beacf6141062faf94fcc929e2dacb5d8b" rel="noopener ugc nofollow" target="_blank">苦差事:要求100%覆盖</a>。</p><h1 id="e95f" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">结论</h1><p id="0f28" class="pw-post-body-paragraph jg jh hu ji b jj lm jl jm jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd hn dt translated">本文的目标是展示重构代码所需的技术，或者使用模拟和依赖注入来隔离单元，使难以测试的代码变得容易，并讨论达到100%覆盖率的一些优点。此外，从起点使用TDD要容易得多。</p><p id="6020" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我坚信，如果很难达到100%的覆盖率，那是因为代码需要重构。</p><p id="d114" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在许多情况下，E2E测试对某些事情来说是更好的测试。在此基础上的一个<a class="oy oz gr" href="https://medium.com/u/47c842e55929?source=post_page-----900b83d20d3d--------------------------------" rel="noopener" target="_blank"> Cypress.io </a>套件可以加载应用程序并点击，这将大大增加我们的信心。</p><p id="a5bd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我相信在一个拥有100%覆盖率的代码库中工作，在增加你对每个版本的信心方面做得很好，因此增加了你做出和检测突破性变化的速度。</p><p id="044a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">和往常一样，如果你觉得这很有用，请留下一些掌声，关注我，在GitHub项目<a class="ae lr" href="https://github.com/patrickleet/streaming-ssr-react-styled-components" rel="noopener ugc nofollow" target="_blank">上留下一颗星</a>，和/或在社交网络上分享！</p><p id="558b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在即将到来的下一部分中，我们将添加一个生产就绪的docker文件，并探索如何仅使用另一个docker文件就可以将我们的应用程序打包为一个使用Nginx的静态站点，以及这两种方法之间的一些权衡。</p><p id="6b20" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><br/>最好，<a class="ae lr" href="https://twitter.com/pat_scott" rel="noopener ugc nofollow" target="_blank">李雅达·斯科特</a></p></div><div class="ab cl lx ly hc lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hn ho hp hq hr"><p id="c16e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">查看本系列的其他文章！这是第四部分。</p><div class="me mf fm fo mg mh"><a href="https://hackernoon.com/move-over-next-js-and-webpack-ba367f07545" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">第1部分:讨论Next.js和Webpack🤯</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">简单流服务器端渲染(SSR)反应+样式-组件与包裹</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">hackernoon.com</p></div></div><div class="mq l"><div class="pa l ms mt mu mq mv ja mh"/></div></div></a></div><div class="me mf fm fo mg mh"><a href="https://hackernoon.com/a-better-way-to-develop-node-js-with-docker-cd29d3a0093" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">第2部分:用Docker开发Node.js的更好方法</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">并保持您的热代码重载</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">hackernoon.com</p></div></div><div class="mq l"><div class="pb l ms mt mu mq mv ja mh"/></div></div></a></div><div class="me mf fm fo mg mh"><a href="https://hackernoon.com/enforcing-code-quality-for-node-js-c3b837d7ae17" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">第3部分:加强Node.js的代码质量</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">使用林挺、格式化和带有代码覆盖的单元测试来实施质量标准</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">hackernoon.com</p></div></div><div class="mq l"><div class="nb l ms mt mu mq mv ja mh"/></div></div></a></div><div class="me mf fm fo mg mh"><a href="https://hackernoon.com/a-tale-of-two-docker-multi-stage-build-layers-85348a409c84" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab ej"><div class="mj ab mk cl cj ml"><h2 class="bd hv fv z el mm eo ep mn er et ht dt translated">第5部分:两层(Docker多阶段构建)的故事</h2><div class="mo l"><h3 class="bd b fv z el mm eo ep mn er et ek translated">Node.js的生产就绪docker文件</h3></div><div class="mp l"><p class="bd b gc z el mm eo ep mn er et ek translated">hackernoon.com</p></div></div><div class="mq l"><div class="pc l ms mt mu mq mv ja mh"/></div></div></a></div></div></div>    
</body>
</html>