# 在 Solidity 中实现打桩

> 原文：<https://medium.com/hackernoon/implementing-staking-in-solidity-1687302a82cf>

通过几行 solidity 代码，您可以实现一个赌注机制，这是令牌经济学中最强大的激励机制之一。

![](img/1475c7c628b3b9c99474aa28b566f3a2.png)

Photo by [rawpixel.com](https://www.pexels.com/@rawpixel?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) from [Pexels](https://www.pexels.com/photo/white-ipad-955447/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

> 我犯的任何错误都是对我未来的投资。罗丝·纳马朱娜斯

# 打桩简介

当某人贡献一些资产以换取对企业活动的某种程度的控制、影响或参与时，他就被认为在企业中拥有股份。

在加密货币领域，这被理解为给予用户某种权利或奖励，只要他们不转移他们拥有的一些令牌。赌注机制通常鼓励代币持有，反对代币交易，这反过来又会推高代币估值。

在 [TechHQ](http://www.techhq.io) 我们相信知识是为了共享而存在的，在这篇文章中，我们将展示如何在 solidity 中实现一个 staking 机制。整个项目包括开发环境和测试都可以从[我们的公共 github](https://github.com/HQ20/StakingToken) 获得。

为了建立这种锁定机制，我们需要:

*   一个标记。
*   跟踪利害关系、利益相关者和回报的数据结构。
*   创建和移除标桩的方法。
*   奖励制度。

让我们继续吧。

# 标桩令牌

可以创建一个作为 ERC20 标记的标记标记。稍后我将需要 SafeMath 和 Ownable，所以让我们也导入并使用它们。

就这样，其他什么都不需要。

# 利益相关者

在这个实现中，我们将跟踪利益相关者，以便在以后促进激励的稳健分布。理论上，不像普通的 ERC20 令牌那样跟踪他们是可能的，但在实践中，如果你不跟踪他们，就很难确保利益相关者不会利用分销系统。

为了实现，我们将只使用利益相关者地址的动态数组。

以下方法添加利益相关者、移除利益相关者并验证地址是否属于利益相关者。其他更有效的实现当然是可能的，但我喜欢这个可读性。

# 赌注

最简单的股权形式需要记录*股权大小*和*股权持有人。*一个非常简单的实现可能只是从利益相关者的地址到股份大小的映射。

我将遵循 ERC20 中的函数名，并创建等效函数来从 stakes 映射中获取数据。

我们现在将赋予 STK 持有者创造和移除股权的能力。我们将在标记时烧毁代币，以阻止用户转移代币，直到标记被移除。

请注意，如果用户尝试下注比他拥有的更多的令牌，则在下注创建时，burn 将会恢复，而在下注移除时，如果尝试移除更多已下注的令牌，则赌注映射的更新将会恢复。

最后，我们使用 addStakeholder 和 removeStakeholder 来记录谁拥有股份，以便稍后在奖励系统中使用。

# 奖励

奖励机制可以有许多不同的实现方式，并且运行起来相当繁重。对于该合同，我们将实现一个非常简单的版本，其中利益相关者定期获得相当于其个人股份 1%的 STK 代币奖励。

在更复杂的合同中，当满足某些条件时，奖励的分配会自动触发，但在这种情况下，我们将让所有者手动触发它。根据最佳实践，我们还将跟踪奖励，并实施一种方法来提取奖励。

和以前一样，为了使代码可读，我们遵循了 ERC20.sol 合同中的命名约定，首先是数据结构和数据管理方法:

按照以下方法计算、分配和提取奖励:

# 测试

没有一套全面的测试，任何合同都是不完整的。我倾向于至少在每个函数中产生一个 bug，而且事情经常不像我想的那样工作。你可以说我大部分时间都会犯错，而且肯定不止我一个人这样。

除了允许你产生有效的代码，测试在开发建立和使用契约的过程中也是非常有用的。我总是从设置测试环境的代码开始编写入门文档。

接下来摘录了测试环境是如何设置和使用的。我们将铸造 1000 个 STK 代币，并把它们给一个用户来玩这个系统。我们使用松露进行测试，这给了我们可以使用的账户。

当创建测试时，我总是编写使代码恢复的测试，但是这些测试看起来并不有趣。createStake 的测试显示了创建一个桩需要做什么，以及之后应该改变什么。

需要注意的是，在这个标桩合同中，我们有两个并行的数据结构，一个用于 STK 余额，一个用于标桩，以及它们的总和如何在标桩创建和移除过程中保持不变。在这个例子中，我们给用户 3 STK 威，该用户的余额加上赌注的总和将总是 3。

对于奖励，下面的测试显示了所有者如何分配费用，用户获得 1%的奖励。

当分配奖励时，STK 的总供应量增加，这个测试显示了三个数据结构(余额、赌注和奖励)如何相互关联。现有的和承诺的 STK 的数量将永远是在创造时铸造的数量加上在奖励中分配的数量，奖励可能被铸造也可能不被铸造。在分配完成之前，在创建时铸造的 STK 的数量将等于余额和赌注的总和。

# 结论

赌注和奖励机制是一个强大的激励工具，只需要我们想让它有多复杂就有多复杂。ERC20 标准和 SafeMath 中提供的方法允许我们用大约 200 行稀疏代码对其进行编码。

请随意使用[我们的公共 github](https://github.com/HQ20/StakingToken) 中的代码用于您自己的目的，或者如果您希望我们帮助实现该模式的生产版本，请联系[我们](https://www.techhq.io/#GetinTouch)。我们也非常感谢任何其他反馈。

# 谢谢

感谢[弗拉德·弗卡司](https://www.linkedin.com/in/vladsilviufarcas/)启发了这些代码，感谢[塞尔吉奥·佩雷拉](https://www.linkedin.com/in/sergiomcpereira/)和[蒂亚戈·马丁斯](https://www.linkedin.com/in/temmartins/)发表评论，特别感谢[贝尔纳多·维埃拉](https://www.linkedin.com/in/obernardovieira/)教我如何做真实世界的区块链应用。