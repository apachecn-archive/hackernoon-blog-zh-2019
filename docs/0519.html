<html>
<head>
<title>Recursion vs. Looping in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的递归与循环</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/recursion-vs-looping-in-python-9261442f70a5?source=collection_archive---------2-----------------------#2019-01-21">https://medium.com/hackernoon/recursion-vs-looping-in-python-9261442f70a5?source=collection_archive---------2-----------------------#2019-01-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1b9cbffd5be1d1bd1c3e1c6a1ca841f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yg8bBB4m51CHOAgd.jpg"/></div></div></figure><p id="c1d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编程中最基本的工具之一是循环。虽然有许多不同类型的循环，但几乎每种类型的循环都有相同的基本功能:迭代数据以分析或操作数据。递归是另一种流行的函数类型，虽然它也可以像循环一样分析和操作数据序列，但在许多情况下，递归可能不太为人所理解，而且经常会有些混乱。几乎所有的递归函数都可以重写为循环，反之亦然。然而，每种类型的函数都有优点和缺点，知道什么时候使用一种函数优于另一种函数是我们在这里要研究的。在下面的帖子中，我们将尝试回答以下问题:</p><ol class=""><li id="86df" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated"><strong class="je hv">T5什么是For循环？ </strong></li><li id="451d" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><strong class="je hv"> <em class="kj">什么是递归？</em>T11】</strong></li><li id="aac4" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><strong class="je hv"> <em class="kj">每种方法的实际例子是什么？</em>T15】</strong></li><li id="b2b7" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><strong class="je hv"> <em class="kj">这两种方法应该分别在什么时候使用？</em>T19】</strong></li><li id="ee00" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated"><strong class="je hv"> <em class="kj">什么是递归数据结构？</em> </strong></li></ol><p id="01db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从两种方法中似乎更简单的一种开始，循环。</p><h1 id="1a75" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">对于循环</h1><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/ef51232f93681b1c908cc0e9499147b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*YVsxFQ8yjv8B7PGco2NrCg.png"/></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">For Loop Flow</figcaption></figure><p id="92cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">for循环用于遍历序列(列表、元组、字典、集合或字符串)。只要到达数据序列的末尾，for循环就会终止。</p><p id="7d2a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们想把所有小于5的数字相加，得到总数。当然，我们可以简单地加上1+2+3+4+5。但是如果我们把它变成一个函数，它允许我们重复使用同一个函数来添加10以下的数字，或者20，或者其他数字。可能会有这样的情况，我们需要将两个值相加，但不知道值是什么，因此拥有一个返回低于某个值的数字之和的函数可能会很方便。</p><p id="0327" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这种情况下，我们可以做如下的事情</p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/d8b945aafcba3c3a2c45df1ba455e19d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*jyPzqhUIdMN9Riz06FQAaw.png"/></div></figure><p id="97e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使这个循环工作，我们需要将所有的数字存储为一个列表，这样我们就可以遍历每个元素并将其加到总数中。</p><h2 id="e989" class="lx kq hu bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk dt translated">让我们看看这在实际代码中会是什么样子:</h2><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="c80c" class="lx kq hu mm b fv mq mr l ms mt">def getTotal(n):<br/>    total = 0<br/>    for number in list(range(n+1)):<br/>        print number<br/>        total = total + number<br/>    return total</span><span id="6571" class="lx kq hu mm b fv mu mr l ms mt">print getTotal(5)</span></pre><p id="3a67" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的函数从接受一个数字作为参数开始。这里，我们将使用5作为参数。然后，我们将我们的总数设置为0。最后，我们迭代0和<code class="eh mv mw mx mm b">n+1</code>之间的数字列表。我们在这里使用<code class="eh mv mw mx mm b">n+1</code>,因为<code class="eh mv mw mx mm b">list(range(n)) </code>会给出小于n的数字，但不包括n，在本例中是0，1，2，3，4。因为我们想包含5，我们将使用<code class="eh mv mw mx mm b">n+1.</code></p><p id="5b9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们运行这段代码，我们可以看到在每次迭代中，我们得到了我们期望的数字，并且我们得到了总数。</p><h2 id="400e" class="lx kq hu bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk dt translated">我们的打印输出如下所示:</h2><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="b786" class="lx kq hu mm b fv mq mr l ms mt">0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>15</span></pre><h1 id="dc60" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">递归</h1><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/08dae4fb907b2eeb0646ef05e3f8c634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*fRTXgLKPanRlrZTd8V02yw.png"/></div></figure><p id="4db5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">任何函数调用自身时都会发生递归。递归和循环的最大区别之一是递归函数终止的方式。在上面的例子中，for循环在它所循环的序列的末尾结束。然而，递归函数可以无限地继续下去，因为它不一定有数据序列。相反，递归函数有一个基本条件。基本条件是当条件满足时将终止循环的条件。</p><h2 id="db4c" class="lx kq hu bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk dt translated">让我们举上面的例子，用递归重写一遍。从视觉上看，这可能是这样的:</h2><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/4a657b1ebb1398301bd04b939fee801a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2tUyFJT1f-cm4VjS2cTvGA.jpeg"/></div></div></figure><p id="3dd5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在每个函数中，函数要么用新的输入调用自己，要么返回值。</p><h2 id="d618" class="lx kq hu bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk dt translated">让我们看看这在实际代码中会是什么样子:</h2><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="ecaf" class="lx kq hu mm b fv mq mr l ms mt">def getTotal(n, total):<br/>    print n<br/>    if n == 0:  # base condition<br/>        return total<br/>    else:<br/>        return getTotal(n-1, (total+(n)))</span><span id="9604" class="lx kq hu mm b fv mu mr l ms mt">print getTotal(5, 0)</span></pre><p id="36c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们可以传入一个起始数和一个总变量。第一次调用函数时，总数为0，数字为5。我们检查数字是否为0。如果没有，我们再次调用该函数…但这次不是用0和5调用它，而是用5–1和0+5调用它，并重复这个过程，直到数字为0，这时我们返回总变量15。</p><h1 id="ffc2" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">用递归和循环计算复利</h1><p id="0199" class="pw-post-body-paragraph jc jd hu je b jf na jh ji jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz hn dt translated">作为一个稍微难一点的练习，让我们用复利来确定贷款或投资的价值。为了确定这个值，我们需要4样东西:</p><ol class=""><li id="6c9a" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki dt translated">持续时间(年)</li><li id="456b" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">利率</li><li id="d24b" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">每年复利的次数</li><li id="bb42" class="ka kb hu je b jf kk jj kl jn km jr kn jv ko jz kf kg kh ki dt translated">本金金额</li></ol><h2 id="97a8" class="lx kq hu bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk dt translated">计算复利的公式如下:</h2><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/b39f641f6597317e991c20d55463062a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqPzTlpM_Ny1VoBjeim39g.png"/></div></div></figure><p id="f7a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，这将一次性计算出全部金额。相反，我们希望在循环中或者用递归来实现。在这种情况下，我们的时间变量(nt)实际上将在迭代中处理。</p><p id="7df8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这两种方法中，我们都将使用这些数字作为变量，所以我们可以继续声明它们，并为每个方法使用相同的变量。</p><p id="580d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">变量可以这样定义:</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="d5ad" class="lx kq hu mm b fv mq mr l ms mt">durationInYears = 10<br/>interestRate = .06<br/>compoundedPerYear = 12 <br/>principalAmount = 4000</span></pre><p id="aee0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> — —循环复利计算</strong></p><p id="fd69" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使循环中的计算更容易，我们首先要做的是获得复利的总次数。如果它将按月复利，正如我们在变量中设置的那样，总年数是10，那么结果将是120，或10*12。现在，我们可以循环该范围内的每个数字，计算每次迭代的复利，并将其添加到本金中。</p><h2 id="da54" class="lx kq hu bd kr ly lz ma kv mb mc md kz jn me mf ld jr mg mh lh jv mi mj ll mk dt translated">代码可能是这样的:</h2><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="3faa" class="lx kq hu mm b fv mq mr l ms mt">def compoundInterest(principal, compounded, duration, rate):<br/>    totalCompounded = duration * compounded<br/>    for i in range(1, (totalCompounded+1)):<br/>        principal = principal*(1+(rate/compounded))<br/>    return principal</span><span id="b751" class="lx kq hu mm b fv mu mr l ms mt">print (compoundInterest(principalAmount, compoundedPerYear, durationInYears, interestRate))</span></pre><p id="f5d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这与更简单的例子之间的唯一区别是，我们只是在每次迭代中多做一些计算。我们实际上迭代的是数字1到120，而不是序列5，这代表了复利的总次数。</p><p id="84b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">如果我们记录输出，我们应该得到一个值:</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="940a" class="lx kq hu mm b fv mq mr l ms mt">7277.58693613</span></pre><p id="de5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> — —递归复利计算</strong></p><p id="2a14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在前面的例子中，我们的数据序列是120，它表示本金将复利的次数。到达序列末尾后，循环将终止。对于递归，我们可以用类似的方式来设置它。我们可以给出函数的总持续时间，基本上有两个条件:</p><ul class=""><li id="9c91" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz ng kg kh ki dt translated"><strong class="je hv">条件1:持续时间不为0。</strong></li></ul><blockquote class="nh ni nj"><p id="42e2" class="jc jd kj je b jf jg jh ji jj jk jl jm nk jo jp jq nl js jt ju nm jw jx jy jz hn dt translated">做复利计算。将新的iterest添加到本金金额中。从总持续时间中减去1。用新的本金金额和新的期限再次调用sub。</p></blockquote><ul class=""><li id="07bd" class="ka kb hu je b jf jg jj jk jn kc jr kd jv ke jz ng kg kh ki dt translated"><strong class="je hv">条件2(基础条件) :持续时间为0。</strong></li></ul><blockquote class="nh ni nj"><p id="b12b" class="jc jd kj je b jf jg jh ji jj jk jl jm nk jo jp jq nl js jt ju nm jw jx jy jz hn dt translated">归还本金。</p></blockquote><p id="ed1c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们之前的递归例子中，我们从5开始，当它达到0时终止函数。</p><p id="c857" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">在这里，我们会做同样的事情，但会从120开始。</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="3f55" class="lx kq hu mm b fv mq mr l ms mt">def compoundRecursion(principal, compounded, duration, rate, numberOfRecursions):<br/>    if numberOfRecursions == 0:<br/>        totalDuration = compounded * duration<br/>    elif numberOfRecursions != 0:<br/>        totalDuration = duration<br/>    if duration == 0:<br/>        return principal<br/>    else:<br/>        newDuration = totalDuration - 1<br/>        amount = principal*(1+(rate/compounded))<br/>        return compoundRecursion(amount, compounded, newDuration, rate, 1)</span><span id="2280" class="lx kq hu mm b fv mu mr l ms mt">print (compoundRecursion(principalAmount, compoundedPerYear, durationInYears, interestRate, 0))</span></pre><p id="189c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里，我们要么再次调用该函数，要么返回修改后的本金金额。每次我们调用新函数时，我们调用它，但是传入持续时间减1。当持续时间等于0时，我们只返回本金。</p><h1 id="705a" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">何时使用递归</h1><p id="617f" class="pw-post-body-paragraph jc jd hu je b jf na jh ji jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz hn dt translated">使用递归或循环可能在很大程度上取决于我们使用的语言，或者我们想要解决的问题。例如，在JavaScript中，当在满足基本条件之前达到堆栈限制时，使用递归会导致堆栈帧错误。如果是这种情况，循环可能会更好。</p><p id="5715" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的例子也给了我们一个很好的例子，说明递归比循环更有效。</p><p id="e317" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们想象一下，我们不像上面那样只跟踪数字，我们还想跟踪每个复合区间的其他数据。例如，我们可能要考虑定期还款会如何影响贷款期限。我们可能希望在序列结束前终止循环。如果贷款的复利总次数是120，那么我们的列表长度是120。但是，如果在仅仅100次迭代之后贷款金额为0，那么在我们的列表末尾就有20个未使用的和不必要的列表元素。使循环场景更加复杂的是，贷款金额等变量的值取决于前一次迭代中贷款金额的值。不是说这个特别难，而是很乱。</p><p id="86e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">从视觉上看，这些问题可能是这样的:</strong></p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nn"><img src="../Images/52063ff34f11207607f3eadc5ee104ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DxIgwaja_ikvLSxCI4U6g.png"/></div></div></figure><h1 id="ee6c" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">递归数据结构</h1><p id="3606" class="pw-post-body-paragraph jc jd hu je b jf na jh ji jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz hn dt translated">这正是递归数据结构派上用场的时候。如果一个数据结构可以用它自身的一个更小的版本来定义，那么它就是递归的。列表是递归数据结构的一个例子。</p><p id="728b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">举个例子，我们来看下面这个列表:</strong></p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div class="fe ff no"><img src="../Images/76208cb86b88dfc0910f3e2a027aa593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*KuP8qcgSO2QEghlCLD1qzw.png"/></div></figure><p id="406e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">现在，让我们从原来的列表中创建两个更小的列表:</strong></p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div class="fe ff np"><img src="../Images/e2a68ab45913e5e08cfe37aef1094f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*91VFyiYK-LbIHN1FE6tXYA.png"/></div></figure><p id="e395" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">如果我们打印两个列表，我们将得到以下结果:</strong></p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/340433948668f877cd8ada70f31d22fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*v_hjw4pAfNKy3qt7UeuFMw.png"/></div></figure><p id="a212" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个功能如此强大的原因是，使用递归函数和递归数据结构，我们可以一次修改整个列表，或者一个大列表的一小部分。当我们考虑循环的这个问题时，我们一次只能改变一个索引的一个值。</p><p id="897e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">作为如何做到这一点的示例，考虑以下内容:</strong></p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nr"><img src="../Images/9d8c9a9cacffb7e2133823c8d2bcc7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zA5DopcxjHj8IczTMkb5ng.png"/></div></div></figure><p id="6ddd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我们保存了大列表中的这些小部分，我们就可以调用相同的函数(递归)并向它发送小列表(递归数据结构)。</p><p id="c076" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">让我们看看这是如何与我们之前的复利例子一起工作的:</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="1b7a" class="lx kq hu mm b fv mq mr l ms mt">def recursiveData(data):<br/>    # Base Condition ( if principal amount == 0 or if duration == 0)<br/>    <br/>    # Else Condition ( recalculate the times compounded, duration &amp; principal amount)</span><span id="aac6" class="lx kq hu mm b fv mu mr l ms mt">print (recursiveData(array))</span></pre><p id="15f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的函数基本上由一个if else语句组成。虽然如果我们愿意的话，事情会变得更复杂，但是我们可以在这里完成所有我们想做的事情。最后，我们希望返回完成的数据，该数据将包含贷款金额和贷款复利的每个间隔的当前付款。</p><p id="b9d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">我们的数据输出可能如下所示:</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="4b3c" class="lx kq hu mm b fv mq mr l ms mt">[<br/>{<br/>    'times compounded': 0,<br/>    'duration remaining': 10,<br/>    'interest rate': .06,<br/>    'current payment': 100,<br/>    'compounded per year': 12,<br/>    'principal amount': 4000<br/>},<br/>{<br/>    'times compounded': 1,<br/>    'duration remaining': 10,<br/>    'interest rate': .06,<br/>    'current payment': 100,<br/>    'compounded per year': 12,<br/>    'principal amount': 3900<br/>}<br/>]</span></pre><p id="145c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">记住这一点，并且回头看看我们的较小列表的例子，这个过程可能是这样的:</strong></p><figure class="lo lp lq lr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ns"><img src="../Images/ddc13e985cd2eb9423aa8256abb37eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qkkYtArELARVeOCCpszqA.png"/></div></div></figure><p id="9f90" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于每个递归调用，我们将从列表中取出数组中的第一个元素。然后，我们将修改该元素的值，并再次调用该函数，但这次将array[:1]和array[1:]作为参数传递给它。正如我们所看到的，在列表的中间，我们应该有两个相同大小的列表，到最后，我们将完全转移和修改第一个列表的所有元素，并将它们都添加到第二个列表中。接下来，我们将一步一步地用实际代码创建这个函数。</p><p id="5289" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第一步。创建数组</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="3b50" class="lx kq hu mm b fv mq mr l ms mt">durationInYears = 10<br/>compoundedPerYear = 12</span><span id="d9f7" class="lx kq hu mm b fv mu mr l ms mt">array = [{<br/>    'times compounded': 0,<br/>    'duration remaining': 10,<br/>    'interest rate': .06,<br/>    'current payment': 50,<br/>    'compounded per year': 12,<br/>    'principal amount': 4000,<br/>    'total compounded': compoundedPerYear*durationInYears<br/>}]*(compoundedPerYear*durationInYears)</span></pre><p id="d2e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这一点上，我们有一个长度为贷款总复利次数的数组。每个元素包含相同的数据，我们将递归地改变这些数据。</p><p id="8b2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第二步。创建函数&amp;基础条件</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="ffcf" class="lx kq hu mm b fv mq mr l ms mt">def recursiveData(inputArr, outputArr):<br/>    if len(inputArr) == 0 or inputArr[-1]['principal amount'] &lt;= 0:<br/>        return outputArr</span></pre><p id="1323" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，我们的基本条件涵盖了我们想要终止函数的两种情况。如果我们已经到达期限的末尾(<code class="eh mv mw mx mm b">len(inputArr) == 0</code>)或者我们已经还清了全部贷款(<code class="eh mv mw mx mm b">inputArr[-1][‘principal amount’] &lt;= 0</code>)。</p><p id="7115" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第三步。创建else语句，并定义当前的inputArray &amp; outputArray变量</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="2745" class="lx kq hu mm b fv mq mr l ms mt">else:<br/>        current = inputArr[:1][0]<br/>        inputArrayLength = len(inputArr[1:])<br/>        outputArray = outputArr</span></pre><p id="af26" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，我们从<code class="eh mv mw mx mm b">inputArr</code>中弹出的当前元素是<code class="eh mv mw mx mm b">current</code>。我们的输出数组也被定义了。如果我们以后需要访问我们的输入数组，我们可以用变量<code class="eh mv mw mx mm b">inputArr</code>来实现。</p><p id="6575" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第四步。如果输出数组长度为0，则弹出输入数组的第一个元素，(当前)并将其放入输出中，不做任何更改。</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="709e" class="lx kq hu mm b fv mq mr l ms mt">if len(outputArray) == 0:<br/>            outputArray.append(current)<br/>            return recursiveData(inputArr[1:], outputArray)</span></pre><p id="3b2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，当递归函数被初始调用时，我们的两个数组应该像上面的图表一样。</p><p id="d880" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第五步。如果输出数组大于0，修改当前元素的所有值。</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="d153" class="lx kq hu mm b fv mq mr l ms mt">else:<br/>            newTimesCompounded = outputArray[-1]['times compounded'] + 1<br/>            newDurationRemaining = current['duration remaining']<br/>            if ((outputArray[-1]['times compounded'] + 1) % 12) == 0:<br/>                newDurationRemaining = outputArray[-1]['duration remaining'] - 1<br/>            principal = (outputArray[-1]['principal amount'])*(1+(outputArray[-1]<br/>                                                                  ['interest rate']/outputArray[-1]['compounded per year']))<br/>            currentPayment = current['current payment']<br/>            if currentPayment &gt; principal:<br/>                currentPayment = principal<br/>            newPrincipalAmount = (principal - currentPayment)<br/>            newTotalCompounded = outputArray[-1]['total compounded'] - 1<br/>            newCurrent = {<br/>                'times compounded': newTimesCompounded,<br/>                'duration remaining': newDurationRemaining,<br/>                'interest rate': current['interest rate'],<br/>                'current payment': currentPayment,<br/>                'compounded per year': current['compounded per year'],<br/>                'principal amount': newPrincipalAmount,<br/>                'total compounded': newTotalCompounded<br/>            }</span></pre><p id="6a3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，我们可以打印我们的<code class="eh mv mw mx mm b">newCurrent</code>变量，它是修改后的<code class="eh mv mw mx mm b">current</code>变量，在它被复合并支付贷款后，它将拥有所有的新数据。接下来，我们需要将这个变量添加到输出数组中。</p><p id="493a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第六步。将新的当前变量添加到输出数组</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="d1dd" class="lx kq hu mm b fv mq mr l ms mt">outputArray.append(newCurrent)</span></pre><p id="8d0e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">第七步。用新参数</strong>调用递归函数</p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="2685" class="lx kq hu mm b fv mq mr l ms mt">return recursiveData(inputArr, outputArray)</span></pre><p id="d3e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">我们完成了！让我们来看一下完整的代码块:</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="cf21" class="lx kq hu mm b fv mq mr l ms mt">durationInYears = 10<br/>compoundedPerYear = 12</span><span id="0fff" class="lx kq hu mm b fv mu mr l ms mt">array = [{<br/>    'times compounded': 0,<br/>    'duration remaining': 10,<br/>    'interest rate': .06,<br/>    'current payment': 2000,<br/>    'compounded per year': 12,<br/>    'principal amount': 4000,<br/>    'total compounded': compoundedPerYear*durationInYears<br/>}]*(compoundedPerYear*durationInYears)</span><span id="3712" class="lx kq hu mm b fv mu mr l ms mt">def recursiveData(inputArr, outputArr):<br/>    if len(inputArr) == 0 or inputArr[-1]['principal amount'] &lt;= 0:<br/>        return outputArr<br/>    else:<br/>        current = inputArr[:1][0]<br/>        inputArrayLength = len(inputArr[1:])<br/>        outputArray = outputArr<br/>        if len(outputArray) == 0:<br/>            outputArray.append(current)<br/>            return recursiveData(inputArr[1:], outputArray)<br/>        else:<br/>            newTimesCompounded = outputArray[-1]['times compounded'] + 1<br/>            newDurationRemaining = current['duration remaining']<br/>            if ((outputArray[-1]['times compounded'] + 1) % 12) == 0:<br/>                newDurationRemaining = outputArray[-1]['duration remaining'] - 1<br/>            principal = (outputArray[-1]['principal amount'])*(1+(outputArray[-1]<br/>                                                                  ['interest rate']/outputArray[-1]['compounded per year']))<br/>            currentPayment = current['current payment']<br/>            if currentPayment &gt; principal:<br/>                currentPayment = principal<br/>            newPrincipalAmount = (principal - currentPayment)<br/>            newTotalCompounded = outputArray[-1]['total compounded'] - 1<br/>            newCurrent = {<br/>                'times compounded': newTimesCompounded,<br/>                'duration remaining': newDurationRemaining,<br/>                'interest rate': current['interest rate'],<br/>                'current payment': currentPayment,<br/>                'compounded per year': current['compounded per year'],<br/>                'principal amount': newPrincipalAmount,<br/>                'total compounded': newTotalCompounded<br/>            }<br/>            outputArray.append(newCurrent)<br/>            inputArr = [newCurrent]*inputArrayLength<br/>            return recursiveData(inputArr, outputArray)</span><span id="4fa2" class="lx kq hu mm b fv mu mr l ms mt">returnData = recursiveData(array, [])<br/>for i in returnData:<br/>    print (i)</span></pre><p id="ffb1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了确保它按照我们想要的方式工作，让我们将我们的支付金额提高到非常高的水平，以确保我们只得到我们想要的回报，并且我们的基本条件得到满足。</p><p id="1cec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">如果我们将付款金额更改为2000，则在打印时会得到以下数据:</strong></p><pre class="lo lp lq lr fq ml mm mn mo aw mp dt"><span id="8698" class="lx kq hu mm b fv mq mr l ms mt">{'times compounded': 0, 'duration remaining': 10, 'interest rate': 0.06, 'current payment': 2000, 'compounded per year': 12, 'principal amount': 4000, 'total compounded': 120}</span><span id="6a68" class="lx kq hu mm b fv mu mr l ms mt">{'times compounded': 1, 'duration remaining': 10, 'interest rate': 0.06, 'current payment': 2000, 'compounded per year': 12, 'principal amount': 2019.9999999999995, 'total compounded': 119}</span><span id="c6c8" class="lx kq hu mm b fv mu mr l ms mt">{'times compounded': 2, 'duration remaining': 10, 'interest rate': 0.06, 'current payment': 2000, 'compounded per year': 12, 'principal amount': 30.099999999999227, 'total compounded': 118}</span><span id="632d" class="lx kq hu mm b fv mu mr l ms mt">{'times compounded': 3, 'duration remaining': 10, 'interest rate': 0.06, 'current payment': 30.25049999999922, 'compounded per year': 12, 'principal amount': 0.0, 'total compounded': 117}</span></pre><p id="914b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">厉害！它似乎工作正常，基本条件得到了满足，并返回了一组比我们原本可以得到的更干净的结果。</p><p id="6036" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想想看，如果我们使用一个循环来做这件事，并且仍然有120个元素要查看，其中大部分都是无用的/空的，那该有多烦人。</p><h1 id="0ffa" class="kp kq hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">概括起来</h1><p id="8ba2" class="pw-post-body-paragraph jc jd hu je b jf na jh ji jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz hn dt translated">一开始使用递归可能会令人望而生畏。但是在某些情况下，如果使用正确，它会是一个令人惊奇的工具。同样，根据具体情况，循环也可能是更好的选择。知道如何有效地做到这两点对于开发人员来说是一个很好的工具，也是在技术面试中给雇主留下深刻印象的好方法。</p></div></div>    
</body>
</html>