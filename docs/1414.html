<html>
<head>
<title>A Tale of Two (Docker Multi-Stage Build) Layers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两层(Docker 多阶段构建)的故事</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-tale-of-two-docker-multi-stage-build-layers-85348a409c84#2019-02-28">https://medium.com/hackernoon/a-tale-of-two-docker-multi-stage-build-layers-85348a409c84#2019-02-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="1378" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用 SSR 或 Nginx 的 Node.js 的生产就绪 docker 文件</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f15140a83cf46b08ecb32028020a10d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Amzj6V3ptbx5vs7RVsyfNw@2x.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Licensed from Adobe Stock Photos</figcaption></figure><p id="136d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt kv translated">在本系列的最后一篇文章中，我们完成了向我们的项目添加单元测试，以达到 100%的代码覆盖率。测试就绪后，下一步是为项目的部署做好准备。</p><p id="bd37" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们的应用程序为生产部署做好准备的最后一件事是 docker 文件。</p><p id="f68f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">docker 文件也是运行我们的单元测试的好地方，这就是为什么我决定先写测试。</p><p id="7eea" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们的构建有几个目标:</p><ol class=""><li id="7694" class="lf lg hu kb b kc kd kf kg ki lh km li kq lj ku lk ll lm ln dt translated">应该是安全的</li><li id="9d5b" class="lf lg hu kb b kc lo kf lp ki lq km lr kq ls ku lk ll lm ln dt translated">它应该尽可能的苗条</li><li id="8514" class="lf lg hu kb b kc lo kf lp ki lq km lr kq ls ku lk ll lm ln dt translated">如果没有达到质量标准，就不应该建造</li></ol><p id="6391" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有了目标，我们就开始吧。</p><p id="9ce5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Docker 本质上是一个供您的代码运行的隔离环境。就像配置服务器一样，您可以配置 docker 容器。正如在<a class="ae le" href="https://hackernoon.com/a-better-way-to-develop-node-js-with-docker-cd29d3a0093" rel="noopener ugc nofollow" target="_blank">用 Docker 开发 Node.js 的更好方法</a>中所讨论的，大多数流行的框架/语言都有来自 Docker Hub 的构建版本。似乎我们如何使用 Node，我们需要一个运行<code class="eh lt lu lv lw b">node</code>的环境。我们将以此开始我们的文档。</p><p id="cbe8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">但在此之前，我们先来讨论一下运行命令<code class="eh lt lu lv lw b">docker build</code>时会发生什么。首先发生的是 Docker 决定了构建运行的“上下文”。它从你当前的目录中吸收所有内容作为上下文，除了列在<code class="eh lt lu lv lw b">.dockerignore</code>文件中的文件或文件夹。</p><p id="2446" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们只想要构建过程所需的最低限度，所以让我们从创建一个<code class="eh lt lu lv lw b">.dockerignore</code>文件开始，忽略其他所有东西。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="4fb8" class="mb mc hu lw b fv md me l mf mg">.cache<br/>coverage<br/>dist<br/>node_modules</span></pre><p id="f0a2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">您的项目中的任何其他不需要成功构建/测试的重文件夹也应该被忽略。</p><p id="c835" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下面是使用和不使用<code class="eh lt lu lv lw b">.dockerignore</code>文件运行<code class="eh lt lu lv lw b">docker build . -t ssr</code>的区别:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="4c98" class="mb mc hu lw b fv md me l mf mg">➜  docker build . -t ssr<br/>Sending build context to Docker daemon  166.6MB<br/>➜  docker build . -t ssr<br/>Sending build context to Docker daemon  1.851MB</span></pre><p id="e574" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如你所见，这是一个非常显著的差异。</p><h1 id="99c1" class="mh mc hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">构建层</h1><p id="55bc" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">现在让我们逐行创建<code class="eh lt lu lv lw b">Dockerfile</code>:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="44af" class="mb mc hu lw b fv md me l mf mg">FROM node:11.10.0-alpine AS build</span></pre><p id="95ef" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">首先，正如我提到的，这是一个节点应用程序，所以从官方的节点映像开始是有意义的。这是生产，在生产中我们想要不可变的、可重复的构建，因此我使用了特定的节点版本<code class="eh lt lu lv lw b">11.10.0</code>。根据您的要求，您可能希望选择 Node 10 的最新 LTS 版本。我只是选了最新的。你可以在这里找到最新标签的列表:<a class="ae le" href="https://hub.docker.com/_/node?tab=tags" rel="noopener ugc nofollow" target="_blank">节点标签— Docker Hub </a>。</p><p id="cf01" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，请注意<code class="eh lt lu lv lw b">AS</code>指令。这表明这不是 Dockerfile 文件的最后阶段。稍后，我们可以将这个阶段中的工件<code class="eh lt lu lv lw b">COPY</code>放入我们的最终容器中。这样做的原因是为了产生具有最少伪像的图像。我们可以在第一阶段运行更昂贵的命令，它们结果的膨胀将在下一层被剥离，只留给我们运行应用程序的必需品。</p><p id="eb63" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">除了生成小得多的映像之外，使用多阶段构建也是一种很好的安全措施，因为所有的构建工具都是如此，因此，开发工具的安全漏洞被从最终层剥离出来。</p><p id="50dd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我还决定使用 node 的<code class="eh lt lu lv lw b">alpine</code>版本。这意味着基本操作系统是 Alpine Linux，一个大约 5MB 的最小 Linux 发行版，用于容器化。</p><p id="320f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，因为我们使用的是<code class="eh lt lu lv lw b">alpine</code>,并且它没有附带很多构建工具，所以我们应该安装<code class="eh lt lu lv lw b">node-gyp</code>工具集。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="bc53" class="mb mc hu lw b fv md me l mf mg">RUN apk add --update --no-cache \<br/>    python \<br/>    make \<br/>    g++</span></pre><p id="44b9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这样，我们就有了运行构建和测试的所有工具。如果您所依赖的包不需要通过跳过上一步使用 gyp 编译它们的任何依赖项，那么您可能会节省大约 10 秒的构建时间。然而，它将被从最终层中剥离出来，所以这不是一个巨大的节省，并且许多节点依赖关系<em class="nd">确实</em>需要它。</p><p id="9fd5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们的代码还不在容器内部，这对运行它非常有帮助！让我们将它复制到一个简单命名的<code class="eh lt lu lv lw b">src</code>目录中，并将该目录设置为我们的工作目录。该层中的所有未来命令都将在指定的工作目录中运行。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="5d8c" class="mb mc hu lw b fv md me l mf mg">WORKDIR /src<br/>COPY ./package* ./</span></pre><p id="d92f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，让我们安装节点依赖项。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="292c" class="mb mc hu lw b fv md me l mf mg">RUN npm ci</span></pre><p id="6382" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh lt lu lv lw b">npm ci</code>的工作方式与<code class="eh lt lu lv lw b">npm i</code>类似，但是跳过了昂贵的依赖项解析步骤，而是只安装在<code class="eh lt lu lv lw b">package-lock.json</code>文件中指定的依赖项。它基本上是在 CI 环境中使用的更快的<code class="eh lt lu lv lw b">npm i</code>。</p><p id="0eaa" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们在项目的其余部分之前复制包文件的原因是为了缓存优化。现在,<code class="eh lt lu lv lw b">npm ci</code>的结果将被缓存，直到它上面的层发生变化，这将是包文件，而不是所有的代码。</p><p id="5d46" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在我们可以复制其余的<code class="eh lt lu lv lw b">src</code>并继续。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="ad16" class="mb mc hu lw b fv md me l mf mg">COPY . .</span></pre><p id="3bf1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，我们可以运行质量检查和构建。如果它们没有通过，新的映像将无法成功创建，构建将会失败。这对于作为持续部署管道的一部分运行的构建来说非常好。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="4718" class="mb mc hu lw b fv md me l mf mg">RUN npm run lint<br/>RUN npm run build<br/>RUN npm run test</span></pre><p id="b1ca" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我的目标通常是尽可能快地失败，并且通常将<code class="eh lt lu lv lw b">test</code>放在<code class="eh lt lu lv lw b">build</code>之前，但是我们的服务器端测试依赖于构建一个应用程序来服务它，所以在这种情况下，我只是翻转了它们。</p><p id="4f3c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，对于这一层，我们现在要做的最后一件事是消除任何开发依赖，因为过了这一步就不再需要它们了。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="191a" class="mb mc hu lw b fv md me l mf mg">RUN npm prune --production</span></pre><p id="fa76" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">第一层就这样。为了便于阅读，这是第一层的全部内容:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="6c82" class="mb mc hu lw b fv md me l mf mg">FROM node:11.10.0-alpine AS build</span><span id="df11" class="mb mc hu lw b fv ne me l mf mg">RUN apk add --update --no-cache \<br/>    python \<br/>    make \<br/>    g++</span><span id="5e52" class="mb mc hu lw b fv ne me l mf mg">WORKDIR /src<br/>COPY ./package* ./</span><span id="fe77" class="mb mc hu lw b fv ne me l mf mg">RUN npm ci</span><span id="fb92" class="mb mc hu lw b fv ne me l mf mg">COPY . .</span><span id="c7de" class="mb mc hu lw b fv ne me l mf mg">RUN npm run format<br/>RUN npm run build<br/>RUN npm run test</span><span id="9a8b" class="mb mc hu lw b fv ne me l mf mg">RUN npm prune --production</span></pre><p id="51a6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在在第二层我们有一个选择。</p><p id="8b54" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们使用一个节点服务器来构建我们的应用程序，以进行流服务器端渲染。至此，在我们的 docker 文件中，我们已经构建了客户端应用程序。我们不一定<em class="nd">也需要</em>来使用服务器。我们可能决定只需要一个静态服务的客户端应用程序。在本文的下一部分，我将向您展示如何使用原始节点 SSR 服务器构建最终层，或者将应用程序打包到 Nginx 部署中。</p><h1 id="2cde" class="mh mc hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated"><strong class="ak">最终层选项#1:节点流 SSR 渲染应用</strong></h1><p id="d7cb" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">首先，让我们从 Dockerfile 的 Node SSR 版本开始，因为这是本系列到目前为止一直关注的内容。</p><p id="8149" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在第一阶段的正下方，我们现在要添加第二个<code class="eh lt lu lv lw b">FROM</code>语句。这一次，我们不会使用<code class="eh lt lu lv lw b">AS</code>，因为它是最后一层。我们还想继续操作，公开应用程序运行的端口，并像前面一样设置工作目录。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="4f9b" class="mb mc hu lw b fv md me l mf mg">FROM node:11.10.0-alpine AS build</span><span id="fe30" class="mb mc hu lw b fv ne me l mf mg">// ...</span><span id="5be8" class="mb mc hu lw b fv ne me l mf mg">RUN npm prune --production</span><span id="54d3" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">FROM node:11.10.0-alpine</strong></span><span id="e9bb" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">ENV PORT=1234<br/>EXPOSE $PORT</strong></span><span id="121b" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">WORKDIR /usr/src/service</strong></span></pre><p id="8f6d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">同样，请注意，我们从特定版本的相同 alpine 节点图像开始。当我们创建一个新的层，没有什么是从以前的层自动复制。这是一个新的开始。我们需要将工件，在我们的节点应用程序中，一些文件和文件夹，复制到我们的最终层。让我们接下来这样做:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="d33d" class="mb mc hu lw b fv md me l mf mg">COPY --from=build /src/node_modules node_modules<br/>COPY --from=build /src/dist dist</span></pre><p id="be62" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，我们可以使用<code class="eh lt lu lv lw b">node</code>运行我们的应用程序，但是我们希望在这样做之前将用户设置为非 root 用户。官方节点映像为此创建了一个名为<code class="eh lt lu lv lw b">node</code>的用户。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="0431" class="mb mc hu lw b fv md me l mf mg">USER node</span><span id="882a" class="mb mc hu lw b fv ne me l mf mg">CMD ["node", "./dist/server/index.js"]</span></pre><p id="d619" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在部署时，我们应该依靠 orchestrator 来管理应用程序的重启和扩展，比如 Kubernetes 或 Docker Swarm，所以没有必要使用像<code class="eh lt lu lv lw b">pm2</code>或<code class="eh lt lu lv lw b">forever</code>这样的工具。</p><p id="7e85" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">仅此而已！</p><p id="ed9c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是最终的 Dockerfile 文件:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="713a" class="mb mc hu lw b fv md me l mf mg">FROM node:11-alpine AS build</span><span id="6524" class="mb mc hu lw b fv ne me l mf mg">RUN apk add --update --no-cache \<br/>    python \<br/>    make \<br/>    g++</span><span id="3cdd" class="mb mc hu lw b fv ne me l mf mg">COPY . /src<br/>WORKDIR /src</span><span id="beea" class="mb mc hu lw b fv ne me l mf mg">RUN npm ci</span><span id="b3ce" class="mb mc hu lw b fv ne me l mf mg">RUN npm run format<br/>RUN npm run build<br/>RUN npm run test</span><span id="8c67" class="mb mc hu lw b fv ne me l mf mg">RUN npm prune --production</span><span id="2e46" class="mb mc hu lw b fv ne me l mf mg">FROM node:11.10.0-alpine</span><span id="22d3" class="mb mc hu lw b fv ne me l mf mg">EXPOSE 1234</span><span id="70f2" class="mb mc hu lw b fv ne me l mf mg">WORKDIR /usr/src/service</span><span id="423f" class="mb mc hu lw b fv ne me l mf mg">COPY --from=build /src/node_modules node_modules<br/>COPY --from=build /src/dist dist</span><span id="81ee" class="mb mc hu lw b fv ne me l mf mg">USER node</span><span id="1620" class="mb mc hu lw b fv ne me l mf mg">CMD ["node", "./dist/server/index.js"]</span></pre><p id="eb4b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">构建和运行应用程序:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="9b78" class="mb mc hu lw b fv md me l mf mg">➜  docker build . -t ssr<br/>➜  docker run -p 1234:1234 ssr<br/>{"level":30,"time":1551155555272,"msg":"Listening on port 1234...","pid":1,"hostname":"d5b0db2acfbc","v":1}</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nf"><img src="../Images/bc7b13b972d96f118949de041b38e156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGsTvsrTQgLdiP_T7NrgRg.png"/></div></div></figure><p id="67ac" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你正在关注或者之前读过其他 Docker 文章，你可能会注意到我还没有定义一个<code class="eh lt lu lv lw b">HEALTHCHECK</code>。<code class="eh lt lu lv lw b">HEALTHCHECK</code>是在某些 orchestrators 中运行时调用的命令，比如 Docker Swarm。在 Kubernetes 中运行时，我们依赖于 Kubernetes 的活性和就绪性探测。</p><p id="b926" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有关编写节点健康检查的更多信息，请查看<a class="ae le" rel="noopener" href="/@patrickleet/effective-docker-healthchecks-for-node-js-b11577c3e595">有效的 Docker node . js 健康检查</a>。为了完整起见，我们的 SSR 节点服务器非常简单，所以在这种情况下使用 curl 之类的东西就可以了。</p><p id="4160" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里有一个最后阶段的修改版本，定义了一个使用<code class="eh lt lu lv lw b">curl</code>的<code class="eh lt lu lv lw b">HEALTHCHECK</code>。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="2855" class="mb mc hu lw b fv md me l mf mg">// ... first layer ...</span><span id="e27e" class="mb mc hu lw b fv ne me l mf mg">FROM node:11.10.0-alpine</span><span id="c64a" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">RUN apk add --update --no-cache curl</strong></span><span id="a2a5" class="mb mc hu lw b fv ne me l mf mg">EXPOSE 1234</span><span id="5d5b" class="mb mc hu lw b fv ne me l mf mg">WORKDIR /usr/src/service</span><span id="c696" class="mb mc hu lw b fv ne me l mf mg">COPY --from=build /src/node_modules node_modules<br/>COPY --from=build /src/dist dist</span><span id="4185" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">HEALTHCHECK --interval=5s \<br/>            --timeout=5s \<br/>            --retries=6 \<br/>            CMD curl -fs </strong><a class="ae le" href="http://localhost:1234/" rel="noopener ugc nofollow" target="_blank"><strong class="lw hv">http://localhost:1234/</strong></a><strong class="lw hv"> || exit 1</strong></span><span id="34f1" class="mb mc hu lw b fv ne me l mf mg">USER node</span><span id="7ba1" class="mb mc hu lw b fv ne me l mf mg">CMD ["node", "./dist/server/index.js"]</span></pre><h1 id="8780" class="mh mc hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">最后一层选项#2: Nginx 服务静态客户端应用</h1><p id="b539" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">现在，让我们创建第二个 docker 文件，这是完成最后阶段的另一种方法。</p><p id="83ed" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们将从相同的构建层开始，但这一次，我们的最后阶段将使用<code class="eh lt lu lv lw b">nginx</code>静态地服务应用程序，而不是使用 Node 在服务器端呈现。</p><p id="e881" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在此之前，我们需要在 package.json 的<code class="eh lt lu lv lw b">script</code>部分创建一个新条目。添加以下脚本:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="c49f" class="mb mc hu lw b fv md me l mf mg">"build:nginx": "rimraf dist &amp;&amp; npm run generate-imported-components &amp;&amp; npm run create-bundle:nginx",</span><span id="ba0f" class="mb mc hu lw b fv ne me l mf mg">"create-bundle:nginx": "cross-env BABEL_ENV=client parcel build app/index.html -d dist/client <strong class="lw hv">--public-url .</strong>",</span></pre><p id="9188" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">与 SSR 构建的不同之处在于，我们在运行构建时将公共 url 设置为<code class="eh lt lu lv lw b">.</code>，因为在这种情况下我们希望它相对于<code class="eh lt lu lv lw b">index.html</code>文件。</p><p id="d1fe" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，创建<code class="eh lt lu lv lw b">./nginx/Dockerfile</code>:</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="ed12" class="mb mc hu lw b fv md me l mf mg">FROM node:11.10.0-alpine AS build</span><span id="b479" class="mb mc hu lw b fv ne me l mf mg">RUN apk add --update --no-cache \<br/>    python \<br/>    make \<br/>    g++</span><span id="09c0" class="mb mc hu lw b fv ne me l mf mg">WORKDIR /src<br/>COPY ./package* ./</span><span id="c664" class="mb mc hu lw b fv ne me l mf mg">RUN npm ci</span><span id="8eab" class="mb mc hu lw b fv ne me l mf mg">COPY . .</span><span id="88c2" class="mb mc hu lw b fv ne me l mf mg">RUN npm run format<br/><strong class="lw hv">RUN npm run build:nginx</strong><br/>RUN npm run test</span><span id="0bc8" class="mb mc hu lw b fv ne me l mf mg">RUN npm prune --production</span><span id="c685" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">FROM nginx:1.15.8-alpine</strong></span><span id="2119" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">RUN apk add --update --no-cache curl</strong></span><span id="4e78" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">WORKDIR /usr/src/service</strong></span><span id="e36d" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">COPY --from=build /src/dist ./dist<br/>COPY --from=build /src/nginx ./nginx</strong></span><span id="3ffb" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">HEALTHCHECK --interval=5s \<br/>            --timeout=5s \<br/>            --retries=6 \<br/>            CMD curl -fs </strong><a class="ae le" href="http://localhost:1234/" rel="noopener ugc nofollow" target="_blank"><strong class="lw hv">http://localhost:1234/</strong></a><strong class="lw hv"> || exit 1</strong></span><span id="9c99" class="mb mc hu lw b fv ne me l mf mg"><strong class="lw hv">RUN ["chmod", "+x", "./nginx/entrypoint.sh"]<br/>ENTRYPOINT [ "ash", "./nginx/entrypoint.sh" ]</strong></span></pre><p id="a2e3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里没有多少新东西，除了我们没有使用命令，而是使用了一个<code class="eh lt lu lv lw b">ENTRYPOINT</code>。这允许您运行脚本而不是命令。我们还想确保用<code class="eh lt lu lv lw b">ash</code>调用它的 alpine linux 版本的<code class="eh lt lu lv lw b">sh</code>。上面的<code class="eh lt lu lv lw b">RUN</code>行只是简单地更改 linux 权限，使文件可执行。</p><p id="e6e6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们稍后制作的脚本将使用一个配置文件启动 nginx，我们也需要创建该文件并将其存储在<code class="eh lt lu lv lw b">nginx</code>文件夹中。</p><p id="a02e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们从<code class="eh lt lu lv lw b">entrypoint.sh</code>脚本开始。我将在里面包含两个有用的片段，帮助使用注释掉的环境变量。我们在这个项目中不需要它们，但是这是一个常见的需求，比如当您想要使用 nginx 作为后端的代理，或者可能在 JS 包中包含一个分析令牌或键。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="7ebe" class="mb mc hu lw b fv md me l mf mg">#!/bin/bash</span><span id="f3da" class="mb mc hu lw b fv ne me l mf mg"># This script can be used when you have webpack or parcel builds that <br/># insert env variables at build time, usually as build args. <br/># Just set the build args to an a unique string for replacement,<br/># and do it post build instead. Uncomment `echo` through `done` and modify<br/># to match your env variables<br/># --- Start Insert ENV to JS bundle ---<br/># echo "Inserting env variables"<br/># for file in ./dist/**/*.js<br/># do<br/>#   echo "env sub for $file"<br/>#   sed -i "s/REPLACE_MIXPANEL_TOKEN/${MIXPANEL_TOKEN}/g" $file<br/># done<br/># --- End Insert ENV to JS bundle ---</span><span id="5492" class="mb mc hu lw b fv ne me l mf mg"># And if you need env variables in Nginx, use this instead of `cp`<br/># --- Start Insert ENV to Nginx---<br/># echo "Injecting Nginx ENV Vars..."<br/># envsubst '${GRAPHQL_URL}' &lt; nginx/nginx.conf.template &gt; /etc/nginx/nginx.conf<br/># --- End Insert ENV to Nginx---<br/>cp nginx/nginx.conf.template /etc/nginx/nginx.conf</span><span id="c16f" class="mb mc hu lw b fv ne me l mf mg">echo "Using config:"<br/>cat /etc/nginx/nginx.conf</span><span id="4972" class="mb mc hu lw b fv ne me l mf mg">echo "Starting nginx..."<br/>nginx -c '/etc/nginx/nginx.conf' -g 'daemon off;'</span></pre><p id="e34e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">基本上我们所做的就是将 Nginx 配置复制到<code class="eh lt lu lv lw b">/etc/nginx</code>文件夹，然后启动它。</p><p id="2704" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是 nginx 的配置——保存为<code class="eh lt lu lv lw b">./nginx/nginx.config.template</code>。如果取消上面的<code class="eh lt lu lv lw b">envsubst</code>行的注释，就可以在其中使用环境变量。</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="c338" class="mb mc hu lw b fv md me l mf mg">events {<br/>  worker_connections 1024;<br/>}</span><span id="71d5" class="mb mc hu lw b fv ne me l mf mg">http {<br/>  server {<br/>    include /etc/nginx/mime.types;<br/>    listen 1234;</span><span id="b7d1" class="mb mc hu lw b fv ne me l mf mg">    root   /usr/src/service/dist/client;<br/>    index  index.html;</span><span id="d9f4" class="mb mc hu lw b fv ne me l mf mg">    gzip on;<br/>    gzip_min_length 1000;<br/>    gzip_buffers 4 32k;<br/>    gzip_proxied any;<br/>    gzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css;<br/>    gzip_vary on;</span><span id="f221" class="mb mc hu lw b fv ne me l mf mg">    location ~* \.(?:css|js|eot|woff|woff2|ttf|svg|otf) {<br/>      # Enable GZip for static files<br/>      gzip_static on;</span><span id="0d6d" class="mb mc hu lw b fv ne me l mf mg">      # Indefinite caching for static files<br/>      expires max;</span><span id="7a79" class="mb mc hu lw b fv ne me l mf mg">      add_header Cache-Control "public";<br/>    }<br/>  }<br/>}</span></pre><p id="8077" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们试一试吧！</p><pre class="jk jl jm jn fq lx lw ly lz aw ma dt"><span id="50f3" class="mb mc hu lw b fv md me l mf mg">➜  docker run -p 1234:1234 nginx-server              <br/><br/>Starting nginx...</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ng"><img src="../Images/53432e9fb198713ffbcd499966dafa0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8O2lLFvEDlWpWPagDoBmvQ.png"/></div></div></figure><h1 id="fb93" class="mh mc hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">结论</h1><p id="ab08" class="pw-post-body-paragraph jz ka hu kb b kc my iv ke kf mz iy kh ki na kk kl km nb ko kp kq nc ks kt ku hn dt translated">在本文中，我在前面的样板文件的基础上添加了两个不同的 order 文件，用于生产。根据您的使用情况，在某些情况下，一种可能比另一种更有用。</p><p id="3a0d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这部分到此为止！</p><p id="8c0f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果您还没有确定，请查看本系列的其他文章！这是第五部分。</p><div class="nh ni fm fo nj nk"><a href="https://hackernoon.com/move-over-next-js-and-webpack-ba367f07545" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">第 1 部分:讨论 Next.js 和 Webpack🤯</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">简单流服务器端渲染(SSR)反应+样式-组件与包裹</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">hackernoon.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni fm fo nj nk"><a href="https://hackernoon.com/a-better-way-to-develop-node-js-with-docker-cd29d3a0093" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">第 2 部分:用 Docker 开发 Node.js 的更好方法</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">并保持您的热代码重载</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">hackernoon.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni fm fo nj nk"><a href="https://hackernoon.com/enforcing-code-quality-for-node-js-c3b837d7ae17" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">第 3 部分:加强 Node.js 的代码质量</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">使用林挺、格式化和带有代码覆盖的单元测试来实施质量标准</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">hackernoon.com</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni fm fo nj nk"><a href="https://hackernoon.com/the-100-code-coverage-myth-900b83d20d3d" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">第 4 部分:100%代码覆盖率的神话</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">现在互联网上有很多建议说 100%的覆盖率不是一个有价值的目标。是吗？</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">hackernoon.com</p></div></div><div class="nt l"><div class="ob l nv nw nx nt ny jt nk"/></div></div></a></div><p id="d2fc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所有这些文章都致力于构建这个样板文件:</p><div class="nh ni fm fo nj nk"><a href="https://github.com/patrickleet/streaming-ssr-react-styled-components" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab ej"><div class="nm ab nn cl cj no"><h2 class="bd hv fv z el np eo ep nq er et ht dt translated">Patrick let/streaming-SSR-react-styled-组件</h2><div class="nr l"><h3 class="bd b fv z el np eo ep nq er et ek translated">流式 ssr 反应风格组件与包裹。贡献给 Patrick let/streaming-SSR-react-styled-components…</h3></div><div class="ns l"><p class="bd b gc z el np eo ep nq er et ek translated">github.com</p></div></div><div class="nt l"><div class="oc l nv nw nx nt ny jt nk"/></div></div></a></div><p id="a827" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">所以，如果你觉得这个有用，一定要给它打个星！</p><p id="27d7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下次见！</p><p id="640e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">~ <a class="ae le" href="https://twitter.com/pat_scott" rel="noopener ugc nofollow" target="_blank">李雅达·斯科特</a></p></div></div>    
</body>
</html>