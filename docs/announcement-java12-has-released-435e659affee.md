# 公告:Java12 发布了！

> 原文：<https://medium.com/hackernoon/announcement-java12-has-released-435e659affee>

## 摘要:以非冗长的方式快速概述所有新的 Java12 特性。

![](img/f944e94a26fb26858b2721c40ff38477.png)

Photo by [Frankie](https://unsplash.com/@frankieis?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

oracle 开始了一个新的六个月的 Java 发布周期，从上次更新开始，Oracle 每六个月就快速发布一次新版本。我们可以期待以更快的速度为开发者提供一些很酷的新功能。我已经看到了一些你可以期待在 JDK 12 版本中看到的特性。你可以获得开放的 JDK 12 早期版本，并尝试这些*预览功能*。让我们仔细看看。

1.  **JEP 189: Shenandoah:一个低停顿时间的垃圾收集器(实验)。**

**2。JEP 230:微基准测试套件。**

3.JEP 325:切换表情。

4. **JEP 326:原始字符串文字(从 JDK 12 版本中删除)。**

5.JEP 334: JVM 常量 API。

6. **JEP 340:一个 AArch64 端口，而不是两个。**

7. **JEP 341:默认 CDS 档案。**

8. **JEP 344:为 G1 精心准备的混合收藏。**

9.JEP 346:立即从 G1 返回未使用的提交内存。

## 谢南多厄:一个低停顿时间的垃圾收集器:——

Java 开发团队将对 G1 垃圾收集器进行一些重大的修改。G1 垃圾收集器变化的主要目的是保持相同的一致暂停时间。它是在名为 Shenandoah 的新垃圾收集(GC)算法的帮助下实现的，该算法通过与程序上正在运行的 Java 线程同时执行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，这意味着无论堆是 200 MB 还是 200 GB，您都可以保持相同的暂停时间。

## **微基准测试套件:——**

> 向 JDK 源代码中添加一套基本的微基准，让开发人员可以轻松运行现有的微基准和创建新的微基准。

微基准测试套件将与 JDK 源代码放在同一个目录中，构建时将生成一个 JAR 文件。协同定位将简化开发过程中添加和定位基准的工作。在运行基准测试时，JMH 提供了强大的过滤功能，允许用户只运行当前感兴趣的基准测试。确切的位置还有待确定。

## **目标:**

1.  基于[Java 微基准测试工具(JMH)][1]
2.  稳定且经过调整的性能指标评测，旨在进行持续的性能测试
3.  在特性发布的特性完成里程碑之后，对于非特性发布来说，是一个稳定且不可移动的套件。
4.  支持与以前的 JDK 版本进行比较，以进行适用的测试

**简约**

1.  易于添加新的基准
2.  在开发过程中，当 API 和选项改变、被弃用或被删除时，易于更新测试
3.  易于构建
4.  易于查找和运行基准测试
5.  支持 JMH 更新
6.  在套件中包括大约一百个基准的初始集合

## **开关表达式:——**

扩展 switch 语句，使其既可以用作**语句**也可以用作**表达式**，并且这两种形式都可以使用“传统”或“简化”的作用域和控制流行为。这些变化将简化日常编码，也为在 switch 情况下使用模式匹配铺平了道路。

现有的 switch case 与 C、C++和 JavaScript 等编程语言密切相关。这些语言支持控制流中的失败切换条件，以避免问题开发团队对 JDK12 中的 switch 语句进行新的修改。

例如，在下面的代码中，有许多 break 语句使它变得不必要的冗长，并且这种视觉噪音经常掩盖难以调试的错误，对于程序员来说，缺少 break 语句意味着意外的失败。

```
switch (day) {
    case MONDAY:
    case FRIDAY:
    case SUNDAY:
        System.out.println(6);
        break;
    case TUESDAY:
        System.out.println(7);
        break;
    case THURSDAY:
    case SATURDAY:
        System.out.println(8);
        break;
    case WEDNESDAY:
        System.out.println(9);
        break;
}
```

上面的代码是 switch case 语句的传统风格。新的提案声明将是—

```
switch (day) {
    case MONDAY, FRIDAY, SUNDAY -> System.out.println(6);
    case TUESDAY                -> System.out.println(7);
    case THURSDAY, SATURDAY     -> System.out.println(8);
    case WEDNESDAY              -> System.out.println(9);
}
```

> 从 JDK12 开始，我们可以编写如上所述的 switch 语句。

**原始字符串文字(从 JDK 12 版本中删除):——**

JDK 12 的一个主要提议是移除原始字符串文字。根据 JEP，“一个原始字符串文字可以跨越多行源代码，并且不解释转义序列，如\n 或\uXXXX 形式的 Unicode 转义”。这就是他们删除字符串文字的原因。

**示例:-**

```
String myContent = "<html>\n" +
                   "    <body>\n" +
                   "		    <p>Hello World.</p>\n" +
                   "    </body>\n" +
                   “</html>\n";
```

从 JDK12 中，我们可以将上面的语句写成如下—

```
String myNewContent = `<html>
                           <body>
                              <p>Hello World.</p>
                           </body>
                       </html>
                       `;
```

**JVM 常量 API:——**

实现新常量 API 的目的是让操作类文件的程序更容易模拟字节码指令，字节码指令必须处理可加载的常量。

一般来说，每个 Java 类都有一个常量池，用来存储类中字节码指令的操作数。它还有一个常量池，表中的每个条目都是一个可加载的常量，格式如下:

```
cp_info {
    u1 tag;
    u1 info[];
}
```

**标签**指定了常量的类型——

> 例如:- 7 表示它是类，10 是方法引用，8 是字符串，等等...

**info** 数组根据常量类型给出更多关于常量的信息。

JVM 指令，例如 **LDC** 和**调用动态**指令，依赖于该表中的信息(而不是类、接口等的运行时布局)。当这些指令被执行时，可加载常量变成一个活值，例如类、字符串、整数等。

处理类文件的程序必须对这些字节码指令建模，并处理可加载的常量。如果常量类型是字符串或整数之类的东西，这没有问题，因为它们是原始数据类型。但是当涉及到类和接口时，就变得更加复杂了。

加载类并不总是简单明了的，有几种方式可能会失败，例如，如果类不存在或无法访问。那么它可能会引起一个问题，为了避免这个问题—

**这就是 JEP 334 的用武之地。**

在 Java 12 中，现在有了一个 API，所以这些值可以被符号化地处理。例如，有一个名为 ClassDesc 的接口，它可以用来象征性地表示 Class 类型的可加载常量，MethodHandleDesc 表示方法句柄常量，MethodTypeDesc 表示方法类型常量，等等。

## 一个 AArch64 端口，而不是两个:—

> 移除所有与 arm64 端口相关的源，同时保留 32 位 arm 端口和 64 位 aarch64 端口。

移除此端口将允许所有贡献者将其精力集中在单个 64 位 ARM 实现上，并消除维护两个端口所需的重复工作。实现这个特性是为了提高开发的效率。

**默认 CDS 档案:——**

> 增强 JDK 构建过程，在 64 位平台上使用默认类列表生成类数据共享(CDS)档案。

实现默认 CDS 档案的目标是—

1.  改善开箱即用的启动时间。
2.  用户无需运行`**-Xshare:dump**`即可从 CDS 中获益。

目前，JDK 映像在`**lib**`目录中包含一个在构建时生成的默认类列表。想要利用 CD 的用户，即使只有 JDK 提供的默认课程列表，也必须额外运行`**java -Xshare:dump**`。这个选项是有文档记录的，但是许多用户并不知道。为了解决这个问题，他们提供了默认的 CDS 档案—

> **由于他们将光盘存档设为自动，我们可以直接使用，但如果您想禁用它，请运行命令** `**-Xshare:off**`。

## **G1 可接受的混合托收:——**

如果 G1 混合收集可能会超出暂停目标，请使其可停止。关于 [JEP344](http://openjdk.java.net/jeps/344) 的完整描述。

**及时从 G1 返回未使用的提交内存:——**

> 增强 G1 垃圾收集器，在空闲时自动将 Java 堆内存返回给操作系统。

有关此功能的完整信息 [JEP346](http://openjdk.java.net/jeps/346) 。

# 结论

感谢您的阅读。

有了这么多令人兴奋和用户友好的特性，我认为 Java12 将满足开发者的期望。

**如果你喜欢这篇文章，请点击拍手，给我留下你宝贵的反馈。**

**忙碌的人们，你们好，我希望你们在阅读这篇文章时感到愉快，并且我希望你们在这里学到了很多！这是我尝试分享我所学到的东西。**

我希望你在这里看到了对你有用的东西。下次再见！😉🤓

**玩得开心！不断学习新事物，编码解决问题。😇**

看看我的[推特](https://twitter.com/Sri_Programmer)、 [Github](https://github.com/srimani-programmer) 和[脸书](https://www.facebook.com/srimani.programmer)。🙂