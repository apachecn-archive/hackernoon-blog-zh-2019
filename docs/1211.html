<html>
<head>
<title>Kadane’s Algorithm Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卡丹的算法解释了</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kadanes-algorithm-explained-50316f4fd8a6?source=collection_archive---------1-----------------------#2019-02-20">https://medium.com/hackernoon/kadanes-algorithm-explained-50316f4fd8a6?source=collection_archive---------1-----------------------#2019-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5dde07b788f23828e7de4d0470234938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuUYS-A4W7gk4RCrI4aAaw.jpeg"/></div></div></figure><p id="e208" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给定一个数组，求最大子数组和的算法称为Kadane算法。<br/>数组可以是任意维度。为了简单起见，让我们从1D数组开始。</p><p id="c751" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们来看一个索引为0的数组:</p><p id="5744" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">arr: [5，7，-3，2，9，6，16，22，21，29，-14，10，12]</p><p id="da46" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以在任何时候启动子阵列。<br/>假设我们从索引2开始，即arr[2] = -3。现在，在索引3处，和将是-3 + 2 = -1。如果我们从索引3开始子数组，索引3处的和是2，大于前面的和。</p><p id="52a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以我们有两个选择:要么从当前索引开始，要么将当前元素添加到前面的总和中。</p><p id="3d29" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们想要最大的子数组和，我们把当前元素加到0和先前和的最大值上(这里的0表示我们从当前元素重新开始)。</p><p id="caa6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个问题属于动态编程范式。</p><p id="85b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们取一个数组dp[]，其中每个dp[i]表示结束于索引I(包括I)的最大子数组和。</p><p id="0d62" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以这么说</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ka"><img src="../Images/fa2ffcdca988902002a841ce2b80fb68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4JsrEKrbZcwmFDz3R2ooQ.jpeg"/></div></div></figure><p id="2c14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本条件:<br/> <em class="kf"> dp[0] = arr[0] </em></p><p id="90de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">答:<br/>DP[]数组中的最大元素</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kg kh l"/></div></figure><p id="b18a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">时间复杂度:O(N) <br/>空间复杂度:O(N)</p><p id="66e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以通过将dp[i-1](之前的总和)放入一个变量来优化空间复杂度，从而消除对dp[]数组的需要。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kg kh l"/></div></figure><p id="c85d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">时间复杂度:O(N) <br/>空间复杂度:O(1)</p><p id="5541" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还可以找到具有最大和的子阵列的索引。</p><figure class="kb kc kd ke fq iv"><div class="bz el l di"><div class="kg kh l"/></div></figure></div><div class="ab cl ki kj hc kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hn ho hp hq hr"><p id="5e3b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们也可以将Kadane的方法应用于2D矩阵，在这里我们必须找到子矩阵的最大和。请随意尝试卡丹的2D矩阵。感谢您的阅读！😃</p></div></div>    
</body>
</html>