<html>
<head>
<title>You Might Not Need that Recursive Function in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能不需要JavaScript中的递归函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/you-might-not-need-that-recursive-function-in-javascript-275651522185?source=collection_archive---------8-----------------------#2019-03-04">https://medium.com/hackernoon/you-might-not-need-that-recursive-function-in-javascript-275651522185?source=collection_archive---------8-----------------------#2019-03-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0809ff8fa54ec5f4a28b6b190e856eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIdovfxwYhOh9jFSse2ZKw.png"/></div></div></figure><p id="f192" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">编辑:</strong>我收到了相当多的反馈，他们将这篇文章解读为递归函数不好，迭代方法总是更好。这与我的想法相去甚远——本文的目的只是讨论迭代作为一种替代工具！</p><p id="3273" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在编程中，我们经常会遇到这样的情况，答案似乎需要解决同一个问题不确定的次数。当我们遇到这样的问题时，我们倾向于使用递归——通常是通过创建一个函数，根据需要多次调用自己来实现的。递归在程序设计中非常重要，许多问题只能用它来解决。也就是说，递归可能会更慢，填满调用堆栈，并且在概念上更复杂。</p><p id="50e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我将探讨一个问题的例子，这个问题看似适合递归解决，但实际上可以通过理解JavaScript对象引用来更有效地解决。这个帖子例子的动机来自于我改编的一个优秀的<a class="ae ka" href="https://stackoverflow.com/a/18018037/6525724" rel="noopener ugc nofollow" target="_blank"> StackOverflow答案</a>。</p><p id="57aa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，请为它鼓掌👏(还是50！)来帮助传播消息！</p><p id="8fe8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">***</p><h2 id="5b33" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">通过注册我的免费时事通讯，在您的收件箱中获得快速JavaScript技巧！</h2><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="la lb l"/></div></figure><p id="8355" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">***</p><h1 id="173d" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">问题是</h1><p id="e230" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">在这个问题中，我们试图建立一个基于对象平面阵列的分层对象树结构。我们事先不知道树有多深，但是我们知道每个节点只能有一个父节点，并且可以有任意数量的子节点。我们可以使用的示例树的可视化如下:</p><figure class="kw kx ky kz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ly"><img src="../Images/0ba4166bab4f55a5a1d3f16d8afee29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YQ1t6ZVjdR9rNvpegFC4Qg.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Example Tree Structure</figcaption></figure><p id="274c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如前所述，我们接收到的构建这个树示例的数据是一个扁平的数组，格式如下。每个元素代表树中的一个节点，并且只能是一个父节点的子节点。节点8没有父节点，所以我们可以在下面的数组中看到，<code class="eh md me mf mg b">id</code> 8的对象有一个等于<code class="eh md me mf mg b">null</code>的<code class="eh md me mf mg b">parentId</code>。</p><pre class="kw kx ky kz fq mh mg mi mj aw mk dt"><span id="a455" class="kb kc hu mg b fv ml mm l mn mo">const flat = [<br/>  { id: 1, parentId: 3 },<br/>  { id: 3, parentId: 8 },<br/>  { id: 4, parentId: 6 },<br/>  { id: 6, parentId: 3 },<br/>  { id: 7, parentId: 6 },<br/>  { id: 8, parentId: null },<br/>  { id: 10, parentId: 8 }, <br/>  { id: 13, parentId: 14 },<br/>  { id: 14, parentId: 10 }<br/>]</span></pre><p id="c5e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要将这个平面数组重新排列成的最终结构如下:</p><pre class="kw kx ky kz fq mh mg mi mj aw mk dt"><span id="773a" class="kb kc hu mg b fv ml mm l mn mo">[<br/>  { <br/>    id: 8,<br/>    children: [<br/>      { <br/>        id: 3, <br/>        children: [<br/>          { <br/>            id: 1, <br/>            children: [] <br/>          }, <br/>          { <br/>            id: 6, <br/>            children: [ <br/>              { id: 4, children: [] }, <br/>              { id: 7, children: [] } <br/>            ]<br/>          }<br/>        ] <br/>      },<br/>      { <br/>        id: 10, <br/>        children: [ <br/>          { <br/>            id: 14, <br/>            children: [<br/>              { id: 13, children: [] }<br/>            ] <br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>]</span></pre><h1 id="49a9" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">解决方案</h1><p id="5d44" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">在这种情况下，您首先想到的可能是递归:我们得到了一棵长度不确定的树。我们设想可能需要创建一个函数来填充节点的子节点。然后，我们递归调用该函数，直到树被完全填充(即，不再找到子节点)。</p><p id="7848" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然这可能行得通，但还有更好的方法！</p><p id="2d9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以简单地遍历数组，并将每个对象分配给其父对象的<code class="eh md me mf mg b">children</code>数组。这可能没有直观意义，但请考虑以下逻辑:</p><ul class=""><li id="1fee" class="mp mq hu je b jf jg jj jk jn mr jr ms jv mt jz mu mv mw mx dt translated">对象<code class="eh md me mf mg b">3</code>被分配给对象<code class="eh md me mf mg b">8</code>的<code class="eh md me mf mg b">children</code>数组</li><li id="e7b3" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">对象<code class="eh md me mf mg b">6</code>被分配给对象<code class="eh md me mf mg b">3</code>的<code class="eh md me mf mg b">children</code>数组</li><li id="e9e3" class="mp mq hu je b jf my jj mz jn na jr nb jv nc jz mu mv mw mx dt translated">分配给对象<code class="eh md me mf mg b">8</code>的<code class="eh md me mf mg b">children</code>数组的对象<code class="eh md me mf mg b">3</code>实际上只是内存中对象<code class="eh md me mf mg b">3</code>的<strong class="je hv">引用</strong>…意味着它的<code class="eh md me mf mg b">children</code>数组将有对象<code class="eh md me mf mg b">6</code>引用。</li></ul><p id="f634" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个逻辑扩展到整个数组，这意味着我们只需要遍历一次数组就可以构建出我们的树！</p><p id="88da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是基于这一思想的潜在非递归解决方案:</p><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="nd lb l"/></div></figure><p id="abeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">非常简单，我们只遍历数组一次！</p><p id="2a33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我想做一个额外的优化:我们每次在循环中使用的<code class="eh md me mf mg b">findIndex</code>函数对于小示例树来说没什么大不了的，但是如果我们处理一棵大树，这实际上会变得很昂贵。让我们创建一个对象来缓存找到的父位置。</p><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="nd lb l"/></div></figure><p id="d70e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">成功！我们已经完成了树的构建，而没有实现递归函数。</p></div></div>    
</body>
</html>