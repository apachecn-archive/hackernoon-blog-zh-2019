<html>
<head>
<title>Infinite Data Structures In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的无限数据结构</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/infinite-data-structures-in-javascript-eb67ecbccdb?source=collection_archive---------2-----------------------#2019-01-02">https://medium.com/hackernoon/infinite-data-structures-in-javascript-eb67ecbccdb?source=collection_archive---------2-----------------------#2019-01-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0497" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">像Haskell这样的语言能够直接处理无限列表，但是这种能力能够应用到JavaScript的世界中吗？</p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><figure class="jy jz ka kb fq kc fe ff paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="fe ff jx"><img src="../Images/26cde2ee7aaecc36e7783c0cdb57ce96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIOaxoXzOTshuRG3Z9ZQ9g.png"/></div></div><figcaption class="kj kk fg fe ff kl km bd b be z ek"><a class="ae kn" href="https://codepen.io/fstokesman/pen/maBBQG" rel="noopener ugc nofollow" target="_blank">https://codepen.io/fstokesman/pen/maBBQG</a></figcaption></figure><p id="7741" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在现实世界中，我们一直在处理“无限”的想法。所有的正数是一个我们连眼睛都不会眨一下的无限概念的例子。但是通常当我们编程时，我们必须以一种<em class="jp">有限</em>的方式来考虑这些<em class="jp">无限</em>的概念。你不能拥有所有正数的数组(至少在JavaScript中不能！).</p><p id="8ded" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文中我要介绍的是一个<strong class="it hv">无限</strong> <strong class="it hv">列表</strong>数据结构的思想，它可以表示一些永无止境的序列，让我们使用常见的操作如<strong class="it hv"> <em class="jp">映射</em> </strong>和<strong class="it hv"> <em class="jp">过滤</em> </strong>来修改和创建新的序列。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="416b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们想<em class="jp">实际使用</em>的数据时，我们只需<strong class="it hv"> <em class="jp">取</em> </strong>的一些具体量即可。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><h1 id="8a63" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">创建无限列表</h1><p id="a8cf" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">为了创建上面定义的那种结构，我们首先需要某种方法来描述一个无限的东西，而不需要实际评估它(这会让计算机很快死亡)。为此，我们首先需要了解两件事:</p><ul class=""><li id="e862" class="lt lu hu it b iu iv iy iz jc lv jg lw jk lx jo ly lz ma mb dt translated"><em class="jp">迭代器</em>模式<em class="jp">模式</em></li><li id="67e9" class="lt lu hu it b iu mc iy md jc me jg mf jk mg jo ly lz ma mb dt translated"><em class="jp">发电机</em>功能</li></ul><h2 id="3f80" class="mh kr hu bd ks mi mj mk kw ml mm mn la jc mo mp le jg mq mr li jk ms mt lm mu dt translated">迭代器模式</h2><p id="d166" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">先从<em class="jp">迭代器</em> <em class="jp">模式</em>说起。<em class="jp">迭代器模式</em>是一种设计模式，在这种模式下，你可以一次产生一个值。它基本上只是一个带有<strong class="it hv"> <em class="jp">的物体。</em>下()</strong>方法。当该方法被调用时，它返回另一个带有2个键的对象:<strong class="it hv"> <em class="jp"> value </em> </strong>和<strong class="it hv"> <em class="jp"> done </em> </strong>。我们称之为<strong class="it hv"> <em class="jp">。接下来()，</em></strong><strong class="it hv"><em class="jp">done</em></strong>属性表示迭代器是否有更多的值给我们，<strong class="it hv"> <em class="jp"> value </em> </strong>当然是值。下面是一个简单的迭代器，返回值0到3:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="3b5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种模式在JavaScript中有一流的地位。<strong class="it hv"> <em class="jp">数组、对象、映射、</em> </strong>和<strong class="it hv"> <em class="jp">集合</em> </strong>都可以通过符合一个名为<a class="ae kn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterables" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"><em class="jp">Iterable</em></strong></a>的接口来实现<em class="jp">迭代器模式</em>。</p><h2 id="aca6" class="mh kr hu bd ks mi mj mk kw ml mm mn la jc mo mp le jg mq mr li jk ms mt lm mu dt translated">发电机功能</h2><p id="8ad7" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">生成器函数是JavaScript中一种特殊的函数，它是用<strong class="it hv"> <em class="jp">函数* </em> </strong>语法声明的。生成器函数用于创建<em class="jp">迭代器</em>对象(带有<strong class="it hv"> <em class="jp">的对象)。next() </em> </strong>方法)，但以更清晰、更简洁的方式。下面是一个<em class="jp">有限</em>生成器，它创建了一个等价的迭代器:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="0388" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，<strong class="it hv"> <em class="jp"> yield </em> </strong>关键字用来表示每次调用迭代器时返回的值。你可以想到函数<em class="jp">在每次<strong class="it hv"> <em class="jp">产生</em> </strong>后暂停</em>，并在<em class="jp">迭代器</em>的<strong class="it hv"> <em class="jp">时从它停止的地方继续。下一个()</em>再调用</strong>方法。</p><p id="1d23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要使这个<em class="jp">无限</em>生成器，只需将<strong class="it hv"><em class="jp">while(x&lt;4)</em></strong>循环变成<strong class="it hv"> <em class="jp"> while (true) </em> </strong>循环。为了更好的感受，这里有一个著名的斐波那契数列的无限生成器:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><h2 id="45d3" class="mh kr hu bd ks mi mj mk kw ml mm mn la jc mo mp le jg mq mr li jk ms mt lm mu dt translated">把它放在一起</h2><p id="dacd" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">迭代器看起来像是无限事物的一种表示，因为它让我们请求<strong class="it hv">。next() </strong>元素无限期。此外，<strong class="it hv"> <em class="jp">生成器</em> </strong>似乎是指定迭代器的好方法，因为我们可以为无穷级数编写简洁的算法，而无需手动制作迭代器的模板。</p><p id="2070" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但这仍然不够，因为尽管<strong class="it hv"> <em class="jp">发生器</em> </strong>功能强大，但它们并不是真正的<em class="jp">合成</em>。如果我想创建一个生成器，在那里我用<em class="jp">过滤</em>到所有以5结尾的斐波那契数，我不能轻易使用我现有的<strong class="it hv"><em class="jp">createfibsequiterator()</em></strong>来做这件事——也就是说，我不能在上面组合<em class="jp">原始生成器</em> + <em class="jp">一些新操作</em>的想法。</p><p id="477b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了解决这个问题，我们首先需要将生成器封装成一个数据类型，我们可以用一个类来完成:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="3287" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正是在这个类上，我们将实现类似于<strong class="it hv"> <em class="jp">滤镜</em> </strong>、<strong class="it hv"> <em class="jp">贴图</em> </strong>、<strong class="it hv"> <em class="jp">取</em> </strong>的操作。</p><h2 id="0e06" class="mh kr hu bd ks mi mj mk kw ml mm mn la jc mo mp le jg mq mr li jk ms mt lm mu dt translated">无限懒惰</h2><p id="052c" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">当你想到我们如何实现一个像<strong class="it hv"> <em class="jp">过滤</em> </strong>这样的操作时，你可能会感到困惑。答案很简单:我们懒洋洋地做<em class="jp"/>。实际上，我们并没有试图过滤我们的列表，我们只是在<strong class="it hv"> <em class="jp">无限</em> </strong>类中做了一个注释。然后当用户想要具体的<strong class="it hv"> <em class="jp">。取()</em> </strong>它的一些元素，我们就可以做实际业务中的<strong class="it hv"> <em class="jp">过滤</em> </strong> ing了。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="4c0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Infinite类得到一个新的<strong class="it hv"> <em class="jp">变换</em> </strong>属性，而<strong class="it hv"> <em class="jp">滤镜</em> </strong>用相同的生成器和<strong class="it hv"> <em class="jp">变换</em> </strong>数组创建一个新的Infinite，并将一个<em class="jp">变换</em>推入列表。</p><p id="507e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在拥有了编写<strong class="it hv"> <em class="jp">所需的所有组件。take() </em> </strong>这将使列表具体化。</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="3074" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们称<strong class="it hv">为<em class="jp">时。取(n) </em> </strong>，我们可以从生成器中创建一个迭代器，然后用<strong class="it hv"> <em class="jp"> n </em> </strong>元素初始化一个定长数组。这将是我们的具体清单。一个<strong class="it hv"> <em class="jp">索引</em> </strong>变量可以用来记录到目前为止我们已经收集了多少具体值。使用while循环，我们可以从迭代器中获取一个值，然后在其上运行我们的<strong class="it hv"> <em class="jp">转换</em> </strong>列表。如果其中一个转换是过滤器，并且它没有通过测试，我们简单地不把它添加到我们的<em class="jp">具体的</em>列表中，并且重复这个循环。当我们收集完<strong class="it hv"> <em class="jp"> n </em> </strong>元素后，我们就完成了，可以返回具体的列表了。</p><p id="d0d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看看前面的斐波纳契例子是怎样的:</p><figure class="jy jz ka kb fq kc"><div class="bz el l di"><div class="ko kp l"/></div></figure><p id="75b2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了实现<strong class="it hv"> <em class="jp">贴图</em> </strong>，我们可以使用与<strong class="it hv"> <em class="jp">滤镜</em> </strong>相同的方法。map方法本身只是克隆当前的<strong class="it hv"> <em class="jp">无限的</em> </strong>并将一个新的变换添加到列表中。在<strong class="it hv"> <em class="jp">里面取</em> </strong>，只要在变换循环里面加一个<em class="jp">else——if</em>就够了。</p><h2 id="d034" class="mh kr hu bd ks mi mj mk kw ml mm mn la jc mo mp le jg mq mr li jk ms mt lm mu dt translated">结论</h2><p id="d699" class="pw-post-body-paragraph ir is hu it b iu lo iw ix iy lp ja jb jc lq je jf jg lr ji jj jk ls jm jn jo hn dt translated">在本文中，我们探索了<em class="jp">迭代器模式</em>和<em class="jp">生成器函数</em>，以便构建一个<em class="jp">组合</em>和<em class="jp">延迟求值</em> <strong class="it hv">无限列表</strong>数据结构。</p><p id="65a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，本文中的<strong class="it hv">无限列表</strong>有一点局限性，因为它缺少一些真正有用的操作，比如地图实现、相关过滤或者将<strong class="it hv">无限列表</strong>组合在一起的能力(比如，将每个斐波那契数与一个质数配对)。</p><p id="2259" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">针对这些我创建了<a class="ae kn" href="https://github.com/francisrstokes/Lazy-Infinite-List" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/></a><strong class="it hv"/>一个更强大的无限链表结构，这符合<a class="ae kn" href="https://github.com/fantasyland/fantasy-land" rel="noopener ugc nofollow" target="_blank">幻境规范</a>。<a class="ae kn" href="https://github.com/francisrstokes/Lazy-Infinite-List" rel="noopener ugc nofollow" target="_blank">我很想让你看看github </a>，或者在你的下一个项目中尝试一下</p><p id="5a99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kn" href="https://www.npmjs.com/package/lazy-infinite" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="jp"> npm我懒-无限</em> </strong> </a></p></div><div class="ab cl jq jr hc js" role="separator"><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv jw"/><span class="jt bw bk ju jv"/></div><div class="hn ho hp hq hr"><p id="1b83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢这种对无限数据结构的探究，请在twitter @fstokesman 上联系我，并考虑给这篇文章一个👏。</p></div></div>    
</body>
</html>