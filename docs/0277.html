<html>
<head>
<title>Organizing Your React + Redux Application’s Codebase for Future Maintainability and Extensibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组织React + Redux应用程序的代码库，以便将来维护和扩展</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/organizing-your-react-redux-applications-codebase-for-future-maintainability-and-extensibility-ba66f9ff7d6c?source=collection_archive---------12-----------------------#2019-01-11">https://medium.com/hackernoon/organizing-your-react-redux-applications-codebase-for-future-maintainability-and-extensibility-ba66f9ff7d6c?source=collection_archive---------12-----------------------#2019-01-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="a322" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">随着React + Redux应用程序的范围、大小和特性集的增长，维护它的痛苦也在增加，特别是当您与一个大团队一起工作，并且有多人在您的应用程序中处理每个特性时。在本文中，我们将探讨如何组织您的代码库，以增加可维护性和可扩展性。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/3ef85ea77ce8f48ba2fb570b3fb72782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0e6fFQQRvkZ1LkeAHAMx7w.jpeg"/></div></div></figure><p id="05b6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当您第一次开始编写新的React应用程序时，功能集很小，React API很简单，但是足够灵活和强大，可以处理状态管理。然而，最终您的应用程序会变得更大，React的<code class="eh kr ks kt ku b">setState</code>在处理大型应用程序的状态管理方面的缺点变得很明显，令人痛苦。</p><p id="3b0e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，您做了一些研究，并发现<a class="ae kv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>是您处理应用程序不断增长的状态管理需求的最佳选择。Redux介绍<code class="eh kr ks kt ku b">actions</code>、<code class="eh kr ks kt ku b">actionCreators</code>、<code class="eh kr ks kt ku b">reducers</code>、<code class="eh kr ks kt ku b">middleware</code>、<code class="eh kr ks kt ku b">stores</code>。由于这是一个React应用程序，您需要将Redux连接到React组件，因此您还需要使用<a class="ae kv" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> React-Redux </a>。将所有这些加起来，你的应用程序很快就会变成一大堆杂乱无章的代码，除非你正确地组织你的应用程序。</p><p id="4a23" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">确保您的应用程序以易于整个团队理解的方式正确组织，可以在维护和扩展应用程序时为您节省大量时间和资源。在过去的三年多时间里，我一直在编写React应用程序，这些应用程序的复杂程度从简单到超复杂不等。</p><p id="44de" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在开发这些应用程序的过程中，我尝试了多种组织React应用程序的方法，我认为我最终确定了提供易用性和可维护性最佳平衡的模式。我将这种组织应用程序的模式称为<code class="eh kr ks kt ku b">State-View</code>模式。但在此之前，我们先来看看<code class="eh kr ks kt ku b">State-View</code>模式，让我们先来看看我经历过的其他模式，以及为什么我发现它们有所欠缺。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="a492" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">按功能/文件类型分组</strong></p><p id="95ae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在React + Redux应用程序中，我们可以有多个不同类型的文件，每个文件执行一个特定的功能。例如，我们有从给定状态派生新状态的<code class="eh kr ks kt ku b">reducers</code>和创建传递给<code class="eh kr ks kt ku b">reducers</code>的<code class="eh kr ks kt ku b">action</code>的<code class="eh kr ks kt ku b">action</code>、<code class="eh kr ks kt ku b">actionCreators</code>，保存应用程序状态并允许<code class="eh kr ks kt ku b">components</code>订阅对存储的更改的<code class="eh kr ks kt ku b">store</code>，创建在屏幕上呈现的视图的<code class="eh kr ks kt ku b">presentational components</code>，完成大部分繁重工作并提供业务逻辑、持久性等的<code class="eh kr ks kt ku b">container components</code>。</p><p id="84a8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">组织React + Redux应用程序的最常见方式是简单地按照文件的类型/功能对文件进行分组。这是绝大多数React + Redux应用程序的组织方式。如果你看看来自Redux Github库的<a class="ae kv" href="https://github.com/reduxjs/redux/tree/master/examples/real-world" rel="noopener ugc nofollow" target="_blank">真实世界的例子</a>，你会发现它是这样组织的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ld"><img src="../Images/d08359f4d353167e8ade09199b5e6ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kzjTRdvMvuIKYfmy.png"/></div></div></figure><p id="4a92" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在现实世界的示例项目中:</p><ul class=""><li id="a234" class="le lf hu jx b jy jz kb kc ke lg ki lh km li kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">configureStore.dev.js</code>、<code class="eh kr ks kt ku b">configureStore.prod.js</code>是两个<code class="eh kr ks kt ku b">stores</code>(根据应用的运行环境，只使用其中一个)，这些被分组在<code class="eh kr ks kt ku b">store</code>目录下。</li><li id="b41b" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">index.js</code>和<code class="eh kr ks kt ku b">paginate.js</code>均输出多个减速器，这些减速器被组合在<code class="eh kr ks kt ku b">reducers</code>目录下。</li><li id="8e82" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">api.js</code>提供一个Redux中间件，用于对Github的API进行API调用，并对结果进行归一化。这位于<code class="eh kr ks kt ku b">middleware</code>目录下。</li><li id="f7bf" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated">各种<code class="eh kr ks kt ku b">container components</code>被集中在<code class="eh kr ks kt ku b">containers</code>目录下。</li><li id="cddb" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated">各种各样的<code class="eh kr ks kt ku b">presentational components</code>被集中在<code class="eh kr ks kt ku b">components</code>目录下。</li><li id="30cf" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated">这些动作都被定义在一个单独的<code class="eh kr ks kt ku b">index.js</code>中，它位于<code class="eh kr ks kt ku b">actions</code>目录下。</li><li id="4f5f" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated">应用程序的入口点<code class="eh kr ks kt ku b">index.js</code>直接放在了根上。</li></ul><p id="f719" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过将具有相同功能的文件组合在一起来组织应用程序的优点是，您总是确切地知道特定类型的文件将在哪里。例如:如果您正在调试一个状态转换没有正确发生的问题，您知道状态转换唯一可能发生的地方是在一个<code class="eh kr ks kt ku b">reducer</code>中，并且所有的<code class="eh kr ks kt ku b">reducers</code>都位于<code class="eh kr ks kt ku b">reducers</code>目录中。</p><p id="d200" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">只要您的应用程序很小，只有几个组件和相关的<code class="eh kr ks kt ku b">actions</code>、<code class="eh kr ks kt ku b">reducers</code>和<code class="eh kr ks kt ku b">middleware</code>，这就很好。随着您的应用程序变得越来越大，您会发现自己在同一个目录中转储了越来越多的彼此无关的文件，并且检查这些文件以隔离特定的问题将开始消耗您更多的时间和资源。当多个开发人员在同一个代码库上工作，并且都接触同一个目录中的同一个文件以获得他们自己的单独功能时，这种情况只会加剧。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="9d37" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">按应用特性分组</strong></p><p id="79a6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">用“基于功能/类型的分组”方法来组织代码库的主要问题是，为了处理一个单一的特性，你必须处理分布在整个项目中多个不相关的目录中的文件。为了缓解这个问题，您可以通过将与应用程序的特定功能相关的文件分组在一起来组织React + Redux应用程序。</p><p id="7722" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将同一个Redux真实示例修改为group by application特性将使它看起来像这样:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ld"><img src="../Images/ebe0aad2e72166ba0fec154d50ae37a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*McFK0qdI7wLFzMT9.png"/></div></div></figure><p id="8168" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里，我们将代码分成不同的“特性”:</p><ul class=""><li id="40e7" class="le lf hu jx b jy jz kb kc ke lg ki lh km li kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">Root</code> -执行路由并呈现其他组件的根容器组件。因为它不维护或管理状态，所以它在目录中没有任何<code class="eh kr ks kt ku b">actions</code>或<code class="eh kr ks kt ku b">reducers</code>。我们还重命名了容器组件，并在文件后面加上了后缀<code class="eh kr ks kt ku b">Container</code>，以表明它是一个<code class="eh kr ks kt ku b">container</code>组件。</li><li id="cde0" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">App</code> -主要应用组件。因为它维护了一个状态来指示API调用是否出错，所以它在目录中有<code class="eh kr ks kt ku b">actions.js</code>和<code class="eh kr ks kt ku b">reducers.js</code>。您可能会注意到我们已经将<code class="eh kr ks kt ku b">Explore</code>组件重命名为<code class="eh kr ks kt ku b">ExploreComponent</code>。这是为了表明这是一个表象的组成部分。</li><li id="b0c7" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">DevTools</code> -负责DevTools，它记录每个动作转换时的状态。不管理它自己的任何状态，所以这个目录只包含组件。</li><li id="ca35" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">RepoPage</code>和<code class="eh kr ks kt ku b">UserPage</code>——这些目录对应于<code class="eh kr ks kt ku b">RepoPage</code>功能，列出回购的明星观察者，以及<code class="eh kr ks kt ku b">UserPage</code>功能，列出用户拥有的回购。这些组件管理它们自己的状态，特别是它们管理应用程序状态对象的<code class="eh kr ks kt ku b">entities</code>和<code class="eh kr ks kt ku b">pagination</code>属性。记住，这一点很快会变得重要。</li><li id="ee1d" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">common</code> -在多个特性之间共享的任何<code class="eh kr ks kt ku b">component</code>、<code class="eh kr ks kt ku b">middleware</code>、<code class="eh kr ks kt ku b">reducer</code>或<code class="eh kr ks kt ku b">action</code>都在这里。</li></ul><p id="36a7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这已经比“基于功能/类型的分组”好得多了。如果我们想要处理一个特定的特性，所有与该特性相关的文件都在同一个目录中。这包括<code class="eh kr ks kt ku b">actions</code>、<code class="eh kr ks kt ku b">reducers</code>、<code class="eh kr ks kt ku b">presentational components</code>和<code class="eh kr ks kt ku b">container components</code>。视图和状态相关的代码都位于同一个目录中，因此我们可以很容易地对特定的特性进行修改，而不必去修改五个不同目录中的五个不同的文件。</p><p id="953a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种方法通常适用于状态项和视图之间存在一对一映射的应用程序。例如，在待办事项列表中，每个待办事项仅通过单个呈现组件显示在屏幕上的一个位置。因此，我们能够根据利用该状态的特性清楚地分离应用程序的状态，并且我们可以将相关的<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>与该特性的视图组件组合在一起。</p><p id="f93d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是当状态项和视图组件之间的映射不是一对一的时候会发生什么呢？这正是我们正在分析的“真实世界redux示例”应用程序的情况。在这个应用中，<code class="eh kr ks kt ku b">RepoPage</code>和<code class="eh kr ks kt ku b">UserPage</code>功能都独立地使用状态对象的<code class="eh kr ks kt ku b">entities</code>和<code class="eh kr ks kt ku b">pagination</code>属性。这两个特征通过在它们之间共享相同的<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>来读取和写入这些属性。</p><p id="623a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这种情况下，我们如何将状态和视图组合在一起？哪些<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>应该和<code class="eh kr ks kt ku b">RepoPage</code>分在一组，哪些应该和<code class="eh kr ks kt ku b">UserPage</code>分在一组？将与状态相关的代码，主要是<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>用一个特性分组，打破了我们的分组模型，我们不再总是将与特定功能相关的所有代码放在一个目录中。将<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>放在<code class="eh kr ks kt ku b">common</code>中也会导致完全相同的问题。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="e7dc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">状态-视图模式</strong></p><p id="eb25" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最近，我一直在开发一个非常复杂的React + Redux应用程序，为此我尝试了一种组织应用程序代码库的新模式。这是组织代码的“基于特性的分组”方法的发展。基于特征的分组方法的唯一问题(尽管是主要问题)是状态的不可预测性，当状态与视图没有一一对应时。</p><p id="0750" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了消除这种不可预测性，我们将代码库分成两个独立的主目录，并且根据每个目录中的不同因素对文件进行分组。您可能已经猜到，这两个目录是<code class="eh kr ks kt ku b">state</code>和<code class="eh kr ks kt ku b">view</code>目录。</p><p id="6447" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">所有与状态管理相关的代码，包括所有的<code class="eh kr ks kt ku b">actions</code>、<code class="eh kr ks kt ku b">reducers</code>、<code class="eh kr ks kt ku b">middleware</code>和<code class="eh kr ks kt ku b">stores</code>都放在<code class="eh kr ks kt ku b">state</code>目录中。所有其他代码都放在<code class="eh kr ks kt ku b">view</code>目录中。那么这些目录是如何进一步组织的呢？</p><p id="d2e0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们首先看看当真实世界的Redux例子被重写以使用<code class="eh kr ks kt ku b">State-View</code>模式时，整个应用程序结构是什么样子的:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ls"><img src="../Images/a4da050fb527460da1e71ca1b94181d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FJEZZm_b9KwUVUQS.png"/></div></div></figure><p id="24d6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有两个主目录<code class="eh kr ks kt ku b">state</code>和<code class="eh kr ks kt ku b">view</code>。我们先来探索一下<code class="eh kr ks kt ku b">view</code>目录。</p><ul class=""><li id="2875" class="le lf hu jx b jy jz kb kc ke lg ki lh km li kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">Root</code> -执行路由和呈现其他组件的根容器组件。此处删除了所有与状态管理相关的代码，仅保留了特定于视图的代码。我们还重命名了容器组件，并在文件后面加上了后缀<code class="eh kr ks kt ku b">Container</code>,表示它是一个<code class="eh kr ks kt ku b">container</code>组件。</li><li id="9232" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">App</code> -主要应用组件。你可能会注意到我们已经将组件<code class="eh kr ks kt ku b">Explore</code>重命名为<code class="eh kr ks kt ku b">ExploreComponent</code>。这是为了表明这是一个表象的组成部分。</li><li id="a5e2" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">DevTools</code> -负责DevTools，它记录每个动作转换时的状态。</li><li id="d121" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">RepoPage</code>和<code class="eh kr ks kt ku b">UserPage</code>——这些目录对应于<code class="eh kr ks kt ku b">RepoPage</code>功能，列出回购的星级观察者，以及<code class="eh kr ks kt ku b">UserPage</code>功能，列出用户拥有的回购。正如您所看到的，这些目录只包含视图组件，所有的<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>都被删除了。</li><li id="41ab" class="le lf hu jx b jy ln kb lo ke lp ki lq km lr kq lj lk ll lm dt translated"><code class="eh kr ks kt ku b">_shared</code> -在多个特征之间共享的所有视图组件在这里被组合在一起。</li></ul><p id="6115" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如您所见，<code class="eh kr ks kt ku b">view</code>目录的组织方式与应用程序在基于特性的分组模式中的组织方式极其相似。原因很简单。在基于特性的分组模式中组织<code class="eh kr ks kt ku b">view</code>组件的方式没有真正的问题，所以我们只是让它保持原样。</p><p id="33e9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们来看看<code class="eh kr ks kt ku b">state</code>目录。这是基于特征的分组模式的大部分变化发生的地方。首先，您会注意到<code class="eh kr ks kt ku b">view</code>目录中子目录的名称与<code class="eh kr ks kt ku b">state</code>目录中子目录的名称完全不一致。这完全是有意的，这样做是为了强调状态与视图没有一对一的映射。</p><p id="c43b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们不是按照应用程序特性来组织<code class="eh kr ks kt ku b">state</code>目录内容，而是按照它们所负责的存储的属性来组织它们。在真实的redux示例中，应用程序的状态如下所示:</p><pre class="jk jl jm jn fq lt ku lu lv aw lw dt"><span id="58a4" class="lx ly hu ku b fv lz ma l mb mc">const state = { <br/>    errorMessage: null, <br/>    entities: {}, <br/>    pagination: {}<br/>};</span></pre><p id="001b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果我们回到<code class="eh kr ks kt ku b">state</code>目录，子目录对应于状态的属性。每个子目录都包含操作状态特定部分所需的<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>。任何常用的共享项目，都放在<code class="eh kr ks kt ku b">_shared</code>目录中。这些<code class="eh kr ks kt ku b">actions</code>和<code class="eh kr ks kt ku b">reducers</code>然后通过使用<code class="eh kr ks kt ku b">state</code>目录中的<code class="eh kr ks kt ku b">actions.js</code>和<code class="eh kr ks kt ku b">reducers.js</code>文件被卷起并组合，然后由<code class="eh kr ks kt ku b">index.js</code>导出。所以现在，如果我们需要在任何视图组件中使用特定的操作，我们可以这样要求它:</p><pre class="jk jl jm jn fq lt ku lu lv aw lw dt"><span id="fe44" class="lx ly hu ku b fv lz ma l mb mc">import { actions } from '../../state'; <br/>const { loadRepo, loadStargazers } = actions;</span></pre><p id="eed4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果您想看看真实世界redux示例应用程序的<code class="eh kr ks kt ku b">state-view</code>模式的代码，可以在<a class="ae kv" href="https://github.com/asleepysamurai/example-real-world-structure" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到源代码。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="20f9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，我们有效地将状态相关代码的组织方式与视图相关代码的组织方式分离开来。由于状态现在不再与视图组合在一起，我们的代码又有了一个非常可预测的模式。任何与视图相关的代码将始终位于<code class="eh kr ks kt ku b">view</code>目录中相应的特性子目录中。这些视图执行的任何状态操作都将位于子目录中，该子目录具有<code class="eh kr ks kt ku b">state</code>目录中相应的状态属性名称。因此，只要您知道您的视图在哪里(根据它是特性的一部分，这应该很容易弄清楚)，您就可以很容易地弄清楚它影响什么状态以及相应的状态操作代码驻留在哪里。</p><p id="a04a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">万岁。我们已经恢复了React + Redux应用程序结构的可预测性，这将使我们能够维护和扩展我们的应用程序，比我们以前做的要容易得多。</p><p id="da3d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我很想听听你对我在这篇文章中所写的东西的看法。所以，请在下面发表你的评论。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><p id="5de0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="md">原载于2019年1月11日</em><a class="ae kv" href="https://asleepysamurai.com/articles/organizing-your-react-redux-codebase?import=medium" rel="noopener ugc nofollow" target="_blank"><em class="md">asleepysamurai.com</em></a><em class="md">。</em></p></div></div>    
</body>
</html>