<html>
<head>
<title>A Better Way to Develop Node.js with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Docker开发Node.js的更好方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-better-way-to-develop-node-js-with-docker-cd29d3a0093?source=collection_archive---------0-----------------------#2019-01-21">https://medium.com/hackernoon/a-better-way-to-develop-node-js-with-docker-cd29d3a0093?source=collection_archive---------0-----------------------#2019-01-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="dda5" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">并保持您的热代码重载</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f7926a02cb09cdfd63b65bd5d9f92c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ky5FTIuzIlCNUTR8en_JOA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Licensed from Adobe Stock Photo</figcaption></figure><p id="2cc4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最近看到很多文章建议如何使用Docker进行开发。我还没见过能正确做到的。</p><p id="c237" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">显然，正确地说，是主观的，但是我想比较一下典型的智慧和我通常处理问题的方式。</p><h1 id="635b" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">传统智慧</h1><p id="9fe3" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">在很多教程中，首先介绍的就是Dockerfile。</p><blockquote class="ls"><p id="07eb" class="lt lu hu bd lv lw lx ly lz ma mb ku ek translated">在任何docker化应用的基础上，你都会发现一个<code class="eh mc md me mf b"><a class="ae mg" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">Dockerfile</a> — </code><a class="ae mg" href="https://blog.codeship.com/using-docker-compose-for-nodejs-development/" rel="noopener ugc nofollow" target="_blank">https://blog . codeship . com/using-docker-compose-for-nodejs-development/</a></p></blockquote><p id="fa1a" class="pw-post-body-paragraph jz ka hu kb b kc mh iv ke kf mi iy kh ki mj kk kl km mk ko kp kq ml ks kt ku hn dt translated">显然，这是基础。</p><p id="3771" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">谷歌上的前几个结果都表明，你首先需要的是一个Dockerfile文件。</p><p id="7616" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">毕竟，不创建Docker文件，怎么能有Docker环境呢？</p><p id="1311" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我在这里告诉大家，虽然这对于生产来说是正确的，但对于开发来说却是错误的方法。您不需要创建自己的。</p><p id="7cec" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">docker文件是打包应用程序的一种方式。您不需要打包您的应用程序进行开发，老实说，您真的不应该这样做。</p><p id="e3ca" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">开发和生产不是同一个环境。</p><p id="ddfe" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当你在MacBook上开发时，你安装的工具与你在生产中使用的不同。仅仅因为“它在任何地方都以同样的方式运行”并不意味着它应该如此。</p><p id="5977" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">您的应用程序在开发中的运行方式有所不同。</p><p id="1d67" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在一个需要灵活性和可塑性的时代对它进行打包，这就是为什么许多工程师得出Docker不适合开发的结论。</p><p id="0b50" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">例如，当依赖关系发生变化时，您需要构建新的容器，从而失去了开发的灵活性。</p><p id="70de" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当然，您可以在容器中执行并执行一些命令，安装一些库，但是在这一点上真的很容易吗？</p><p id="29c8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，上面的一些文章比其他文章更正确，但是如果您使用Dockerfile进行开发，您可能已经走得太远了。有些情况下，你会想要一个，但可能不是以你想的方式。</p><blockquote class="mm mn mo"><p id="3425" class="jz ka mp kb b kc kd iv ke kf kg iy kh mq kj kk kl mr kn ko kp ms kr ks kt ku hn dt translated"><strong class="kb hv">提示</strong>:如果你的docker文件包含一个<code class="eh mc md me mf b">npm install</code>，那你就太过分了。</p></blockquote><h1 id="79a1" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">docker-compose构建器模式</h1><p id="1876" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">先说一下Docker <em class="mp">是什么</em>。</p><p id="3200" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Docker是一种打包代码的方式。这是使用Docker的典型<em class="mp">上下文</em>。</p><p id="e75f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Docker也是一种创建能够执行特定类型应用程序的隔离环境的方法。</p><p id="ae01" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Docker允许您打包能够运行您的代码的环境。</p><p id="5d33" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当您使用Docker进行生产时，您使用的是您能制造的最专业的Docker容器。它们是为您的应用程序定制和专门构建的，以您构建应用程序的方式打包。为此，创建docker文件是有意义的。</p><p id="5bd9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当你为开发而设置你的计算机时，那不是你所做的。相反，您需要安装开发所需的工具。你只需要创建一个你的代码可以运行的环境。</p><p id="f6bc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这意味着您可以使用更通用的docker文件。通常，开发所需的这些通用docker文件已经存在。</p><p id="c32b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">例如，开发Node.js应用程序时，需要在机器上安装<code class="eh mc md me mf b">node</code>。就是这样。</p><p id="777e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你不需要alpine linux。您不需要将node_modules打包成不可变的版本。你不需要小容器来执行以做出重大改变。你只需要能够执行<code class="eh mc md me mf b">node</code>和<code class="eh mc md me mf b">npm</code>。</p><p id="58a1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因此，在一个容器中，这也是你所需要的，这意味着Docker Hub上的官方<code class="eh mc md me mf b">node</code>映像会做得很好。</p><p id="42c9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">事不宜迟，我用Docker开发的方法。</p><p id="6c3f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我的上一篇文章中，我展示了如何使用package进行开发和生产。让我们继续前进，在此基础上再接再厉。</p><p id="cefe" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我认为这是一个很好的例子，因为热模块重载对于高效开发React应用程序至关重要。</p><h2 id="522c" class="mt kw hu bd kx mu mv mw lb mx my mz lf ki na nb lh km nc nd lj kq ne nf ll ng dt translated">第一步</h2><p id="b57b" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">首先，我们需要一个<code class="eh mc md me mf b">docker-compose</code>文件。在其中，我们需要我们的开发环境。看起来我们正在制作一个<code class="eh mc md me mf b">node</code>应用程序，这意味着官方的<code class="eh mc md me mf b">node</code>图像可能是一个安全的赌注。</p><p id="2eb4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们添加一个文件<code class="eh mc md me mf b">docker-compose.yml</code>:</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="1f00" class="mt kw hu mf b fv nl nm l nn no">version: '3'</span><span id="efd5" class="mt kw hu mf b fv np nm l nn no">services:</span><span id="b1a8" class="mt kw hu mf b fv np nm l nn no">  dev:<br/>    image: node:11</span></pre><p id="7c3b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，我们需要我们的代码在环境中，但是我们不希望它被烘焙到映像中。如果我们使用这个进行开发，当我们的文件改变时，容器中的文件也需要改变。</p><p id="760c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为此，我们可以使用体积。我们将把当前目录<code class="eh mc md me mf b">.</code>挂载到容器中的<code class="eh mc md me mf b">/usr/src/service</code>。我们还需要告诉docker我们的“工作目录”在哪里。意思是——我们把代码放在哪个目录下了？</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="8c01" class="mt kw hu mf b fv nl nm l nn no">version: '3'</span><span id="4af3" class="mt kw hu mf b fv np nm l nn no">services:</span><span id="2833" class="mt kw hu mf b fv np nm l nn no">  dev:<br/>    image: node:11<br/>    <strong class="mf hv">volumes:<br/>      - .:/usr/src/service<br/>    working_dir: /usr/src/service</strong></span></pre><p id="0deb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，每次我们在本地机器上进行更改时，相同的文件更改都会反映在<code class="eh mc md me mf b">/usr/src/service</code>中。</p><p id="9a21" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，我们需要执行命令<code class="eh mc md me mf b">npm run dev</code>。这很容易用<code class="eh mc md me mf b">command</code>完成。我们还想在端口<code class="eh mc md me mf b">1234</code>上本地访问它。</p><p id="a816" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，默认情况下，热模块重新装载包发生在一个随机端口上，这对我们来说是不可行的，因为我们还需要映射HMR端口。</p><p id="c016" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">修改<code class="eh mc md me mf b">package.json</code>中的<code class="eh mc md me mf b">dev</code>脚本，以包含选项<code class="eh mc md me mf b">--hmr-port=1235</code>。</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="010b" class="mt kw hu mf b fv nl nm l nn no">"dev": "npm run generate-imported-components &amp;&amp; parcel app/index.html <strong class="mf hv">--hmr-port 1235</strong>",</span></pre><p id="b790" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">准备就绪后，让我们更新Docker文件，将本地机器上的端口映射到容器上的相同端口。</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="3068" class="mt kw hu mf b fv nl nm l nn no">version: '3'</span><span id="0144" class="mt kw hu mf b fv np nm l nn no">services:</span><span id="7806" class="mt kw hu mf b fv np nm l nn no">  dev:<br/>    image: node:11<br/>    volumes:<br/>      - .:/usr/src/service<br/>    working_dir: /usr/src/service<strong class="mf hv"><br/>    command: npm run dev<br/>    ports:<br/>      - 1234:1234<br/>      - 1235:1235</strong></span></pre><p id="2bd2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你已经做了足够的节点开发，你会注意到我们有一个问题。你不能不安装依赖项就运行一个节点应用。</p><p id="995a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">此外，您不能只在Mac或Windows上本地安装节点模块，然后期望它们在linux容器上工作。</p><p id="8c42" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当您运行一个构建时，在某些情况下，库是本地编译的，产生的工件只能在构建它的操作系统上工作！</p><p id="6305" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">作为第一次尝试，你可能想在一个命令中把<code class="eh mc md me mf b">npm install</code>和<code class="eh mc md me mf b">npm run dev</code>链接起来，当然这是可行的，但是这并不是我们想要的。这将要求我们每次使用容器启动开发模式时运行一次安装。</p><p id="cae9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">此外，有些服务除了需要安装之外，还可能需要一个构建步骤。在我们的例子中，开发客户端不需要这样做，因为parcel或nodemon会处理它，但不是所有的应用程序都是在过去一周用最新的技术构建的。</p><p id="0756" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">出于教育目的，链接命令的方式是使用<code class="eh mc md me mf b">bash</code>或<code class="eh mc md me mf b">ash</code>来执行命令。如果你尝试</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="5e6f" class="mt kw hu mf b fv nl nm l nn no">command: npm install &amp;&amp; npm run dev</span></pre><p id="0a80" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你会知道那是行不通的。相反，你可以用。</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="8b3e" class="mt kw hu mf b fv nl nm l nn no">command: bash -c "npm install &amp;&amp; npm run dev"</span></pre><p id="806f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这实际上是可行的，但不是我们想要的最佳解决方案。</p><p id="e5d3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这就把我们带到了第二步。</p><h2 id="403c" class="mt kw hu bd kx mu mv mw lb mx my mz lf ki na nb lh km nc nd lj kq ne nf ll ng dt translated">第二步</h2><p id="04fa" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">让我们创建另一个docker-compose文件，这次命名为<code class="eh mc md me mf b">docker-compose.builder.yml</code>。</p><p id="99ca" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这次我们将需要使用<code class="eh mc md me mf b">version: 2</code>来利用<code class="eh mc md me mf b">docker-compose</code>中的一个特性，这个特性在版本3规范中是不可用的。</p><p id="1307" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">第3版比第2版更适合在生产中使用，第2版有更多开发友好的特性。</p><blockquote class="mm mn mo"><p id="8d72" class="jz ka mp kb b kc kd iv ke kf kg iy kh mq kj kk kl mr kn ko kp ms kr ks kt ku hn dt translated">更新:V3现在也以稍微不同的语法支持这一点——希望有一个PR来更新它:)这里是文档:<a class="ae mg" href="https://docs.docker.com/compose/compose-file/#extension-fields" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/compose/compose-file/# extension-fields</a></p></blockquote><p id="c492" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们想在<code class="eh mc md me mf b">docker-compose.builder.yml</code>中定义的第一件事是一个基础图像。</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="3fed" class="mt kw hu mf b fv nl nm l nn no">version: '2'</span><span id="985d" class="mt kw hu mf b fv np nm l nn no">services:</span><span id="9bbf" class="mt kw hu mf b fv np nm l nn no">  base:<br/>    image: node:11<br/>    volumes:<br/>      - .:/usr/src/service<br/>    working_dir: /usr/src/service</span></pre><p id="13cb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这看起来应该很熟悉。这与我们在<code class="eh mc md me mf b">docker-compose.yml</code>文件中使用的基数相同。</p><p id="394b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，我们可以扩展基础来执行一大堆不同的命令。例如:</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="4727" class="mt kw hu mf b fv nl nm l nn no">version: '2'</span><span id="bf1b" class="mt kw hu mf b fv np nm l nn no">services:</span><span id="3fc4" class="mt kw hu mf b fv np nm l nn no">  base:<br/>    image: node:11<br/>    volumes:<br/>      - .:/usr/src/service/<br/>    working_dir: /usr/src/service/</span><span id="f8a3" class="mt kw hu mf b fv np nm l nn no"><strong class="mf hv">  install:<br/>    extends:<br/>      service: base<br/>    command: npm i</strong></span><span id="4862" class="mt kw hu mf b fv np nm l nn no"><strong class="mf hv">  build:<br/>    extends:<br/>      service: base<br/>    command: npm run build</strong></span><span id="4a1a" class="mt kw hu mf b fv np nm l nn no"><strong class="mf hv">  create-bundles:<br/>    extends:<br/>      service: base<br/>    command: npm run create-bundles</strong></span></pre><p id="5981" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，要使用与我们在<code class="eh mc md me mf b">docker-compose.yml</code>中的开发服务相匹配的<code class="eh mc md me mf b">node:11</code>映像来安装依赖项，我们可以运行:</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="b7d3" class="mt kw hu mf b fv nl nm l nn no">docker-compose -f docker-compose.builder.yml run --rm install</span></pre><p id="3fbf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">安装所需的二进制版本。</p><blockquote class="mm mn mo"><p id="7e2e" class="jz ka mp kb b kc kd iv ke kf kg iy kh mq kj kk kl mr kn ko kp ms kr ks kt ku hn dt translated"><strong class="kb hv">亲提示:</strong>诚然，<code class="eh mc md me mf b">docker-compose -f docker-compose.builder.yml run — rm install</code>，并不会真的“脱口而出”吧？我通常把它放在Makefile中，这样就可以运行<code class="eh mc md me mf b">make install</code>等。</p></blockquote><p id="6e0d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">运行安装程序后，<code class="eh mc md me mf b">docker-compose up</code>将打开我们的开发环境，它的工作方式和在本地机器上完全一样。</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="8694" class="mt kw hu mf b fv nl nm l nn no">➜  docker-compose up<br/>Creating stream-all-the-things_dev_1 ... done<br/>Attaching to stream-all-the-things_dev_1<br/>dev_1  |<br/>dev_1  | &gt; stream-all-the-things@1.0.0 dev /usr/src/service<br/>dev_1  | &gt; npm run generate-imported-components &amp;&amp; parcel app/index.html<br/>dev_1  |<br/>dev_1  |<br/>dev_1  | &gt; stream-all-the-things@1.0.0 generate-imported-components /usr/src/service<br/>dev_1  | &gt; imported-components app app/imported.js<br/>dev_1  |<br/>dev_1  | scanning app for imports...<br/>dev_1  | 1 imports found, saving to app/imported.js<br/>dev_1  | Server running at <a class="ae mg" href="http://localhost:1234" rel="noopener ugc nofollow" target="_blank">http://localhost:1234</a></span></pre><p id="3b24" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">当我们进行更改时，热代码重载会像预期的那样工作！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nq"><img src="../Images/1b19a1a1edf932286d8a10c060369f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WJ0Cc42zp257fynXSMwb8w.gif"/></div></div></figure><p id="6fcc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">全都没有文档！</p><h2 id="a527" class="mt kw hu bd kx mu mv mw lb mx my mz lf ki na nb lh km nc nd lj kq ne nf ll ng dt translated">奖金</h2><p id="0007" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">我只是想快速添加一个Makefile示例，使命令更容易记忆和使用。</p><p id="df73" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创建一个名为<code class="eh mc md me mf b">Makefile</code>的文件:</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="9433" class="mt kw hu mf b fv nl nm l nn no">install:<br/> docker-compose -f docker-compose.builder.yml run --rm install</span><span id="6599" class="mt kw hu mf b fv np nm l nn no">dev:<br/> docker-compose up</span></pre><p id="3ea5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Makefiles使用制表符，但是<a class="nr ns gr" href="https://medium.com/u/d0bbc53072f4?source=post_page-----cd29d3a0093--------------------------------" rel="noopener" target="_blank"> <strong class="kb hv">中工程</strong> </a> <strong class="kb hv">的</strong>编辑器不允许我键入制表符甚至粘贴进去。<strong class="kb hv"> Makefile不支持空格。😢 👋 😬</strong></p><p id="4f1f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在可以运行<code class="eh mc md me mf b">make install</code>和<code class="eh mc md me mf b">make dev</code>了。</p><h2 id="664a" class="mt kw hu bd kx mu mv mw lb mx my mz lf ki na nb lh km nc nd lj kq ne nf ll ng dt translated">结局？</h2><p id="3fd6" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">不完全是。似乎我在两个容器之间共享一个本地卷引起了一些混乱。许多人很快指出您可以使用卷，并建议如下:</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="320f" class="mt kw hu mf b fv nl nm l nn no">version: '3'<br/>services:<br/>  dev:<br/>    image: node:11<br/>    volumes:<br/>      - .:/usr/src/service  <br/><strong class="mf hv">      - :/usr/src/service/node_modules<br/></strong>    working_dir: /usr/src/service<br/>    command: npm run dev<br/>    ports:<br/>      - 1234:1234<br/>      - 1235:1235</span></pre><p id="a0bc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这将允许容器中的node_modules独立存在，与本地完全隔离。</p><p id="d57f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">虽然理论上听起来不错，但这将打破我们刚刚定义的在构建器和运行容器之间共享node_modules的过程。</p><p id="2d4f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">另一方面，如果你在本地和docker开发之间转换，不这样做就会导致问题，因为在每个转换之间需要删除<code class="eh mc md me mf b">node_modules</code>。</p><p id="e373" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">一个好的方法是使用“外部卷”而不是本地卷。首先，让我们更新我们的<code class="eh mc md me mf b">Makefile</code>来解决这个问题，用一个简单的调用<code class="eh mc md me mf b">docker volume create</code>命令的<code class="eh mc md me mf b">setup</code>脚本。</p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="400c" class="mt kw hu mf b fv nl nm l nn no">setup:<br/> docker volume create nodemodules</span></pre><p id="95a0" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">(再次强调，制表符而不是空格，尽管Medium在其“代码”部分缺乏这样做的能力)</p><p id="37ba" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创建卷后，我们现在可以从两个docker-compose文件的底部引用它。将以下内容添加到docker-compose文件中:</p><p id="1e87" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv"> docker-compose.yml </strong></p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="30da" class="mt kw hu mf b fv nl nm l nn no">version: '3'<br/>services:<br/>  dev:<br/>    image: node:11<br/>    volumes:<br/>      <strong class="mf hv">- nodemodules:/usr/src/service/node_modules</strong><br/>      - .:/usr/src/service<br/>    environment:<br/>      - NODE_ENV=development<br/>    working_dir: /usr/src/service<br/>    command: npm run dev<br/>    ports:<br/>      - 1234:1234<br/>      - 1235:1235</span><span id="c7b3" class="mt kw hu mf b fv np nm l nn no"><strong class="mf hv">volumes:<br/>  nodemodules:<br/>    external: true</strong></span></pre><p id="1f0d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">docker-compose . builder . yml</strong></p><pre class="jk jl jm jn fq nh mf ni nj aw nk dt"><span id="9ce4" class="mt kw hu mf b fv nl nm l nn no"># ...</span><span id="3a7b" class="mt kw hu mf b fv np nm l nn no">  base:<br/>    image: node:11<br/>    volumes:<br/><strong class="mf hv">      - nodemodules:/usr/src/service/node_modules<br/></strong>      - .:/usr/src/service/<br/>    working_dir: /usr/src/service/</span><span id="c036" class="mt kw hu mf b fv np nm l nn no"><strong class="mf hv">volumes:<br/>  nodemodules:<br/>    external: true</strong></span></pre><p id="92d8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这也稍微改变了我们的启动过程，因为在第一次运行时，我们需要用<code class="eh mc md me mf b">make setup</code>确保该卷存在。</p><h1 id="ee47" class="kv kw hu bd kx ky kz la lb lc ld le lf ja lg jb lh jd li je lj jg lk jh ll lm dt translated">结论</h1><p id="4f7c" class="pw-post-body-paragraph jz ka hu kb b kc ln iv ke kf lo iy kh ki lp kk kl km lq ko kp kq lr ks kt ku hn dt translated">使用Docker并不总是需要做一个Docker文件！通常，为了开发，你可以使用别人的！</p><p id="305a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我希望我已经向您展示了快速使用Docker和docker-compose for development的简单方法。</p><p id="336c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你觉得这有帮助，请给我一些掌声👏还是一份，一定要关注我！</p><p id="576f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">要了解如何在CI管道中为生产创建多阶段构建，或者如何使用docker-compose运行阶段测试，请查看我的文章:<a class="ae mg" href="https://hackernoon.com/i-have-a-confession-to-make-i-commit-to-master-6a804f334beb" rel="noopener ugc nofollow" target="_blank">我有一个坦白…我向master承诺。</a></p><p id="843d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在下一篇文章中，我将向您展示<a class="ae mg" href="https://hackernoon.com/enforcing-code-quality-for-node-js-c3b837d7ae17" rel="noopener ugc nofollow" target="_blank">如何使用林挺、格式化和代码覆盖率单元测试</a>来加强代码质量，这是我们完成生产就绪的多阶段docker文件来打包代码之前的关键步骤。</p><p id="8b52" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最好，<br/> <a class="ae mg" href="https://twitter.com/pat_scott" rel="noopener ugc nofollow" target="_blank">李雅达斯科特</a></p></div><div class="ab cl nt nu hc nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hn ho hp hq hr"><p id="751b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">查看本系列的其他文章！这是第二部分。</p><div class="oa ob fm fo oc od"><a href="https://hackernoon.com/move-over-next-js-and-webpack-ba367f07545" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab ej"><div class="of ab og cl cj oh"><h2 class="bd hv fv z el oi eo ep oj er et ht dt translated">第1部分:讨论Next.js和Webpack🤯</h2><div class="ok l"><h3 class="bd b fv z el oi eo ep oj er et ek translated">简单流服务器端渲染(SSR)反应+样式-组件与包裹</h3></div><div class="ol l"><p class="bd b gc z el oi eo ep oj er et ek translated">hackernoon.com</p></div></div><div class="om l"><div class="on l oo op oq om or jt od"/></div></div></a></div><div class="oa ob fm fo oc od"><a href="https://hackernoon.com/enforcing-code-quality-for-node-js-c3b837d7ae17" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab ej"><div class="of ab og cl cj oh"><h2 class="bd hv fv z el oi eo ep oj er et ht dt translated">第3部分:加强Node.js的代码质量</h2><div class="ok l"><h3 class="bd b fv z el oi eo ep oj er et ek translated">使用林挺、格式化和带有代码覆盖的单元测试来实施质量标准</h3></div><div class="ol l"><p class="bd b gc z el oi eo ep oj er et ek translated">hackernoon.com</p></div></div><div class="om l"><div class="os l oo op oq om or jt od"/></div></div></a></div><div class="oa ob fm fo oc od"><a href="https://hackernoon.com/the-100-code-coverage-myth-900b83d20d3d" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab ej"><div class="of ab og cl cj oh"><h2 class="bd hv fv z el oi eo ep oj er et ht dt translated">第4部分:100%代码覆盖率的神话</h2><div class="ok l"><h3 class="bd b fv z el oi eo ep oj er et ek translated">现在互联网上有很多建议说100%的覆盖率不是一个有价值的目标。是吗？</h3></div><div class="ol l"><p class="bd b gc z el oi eo ep oj er et ek translated">hackernoon.com</p></div></div><div class="om l"><div class="ot l oo op oq om or jt od"/></div></div></a></div><div class="oa ob fm fo oc od"><a href="https://hackernoon.com/a-tale-of-two-docker-multi-stage-build-layers-85348a409c84" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab ej"><div class="of ab og cl cj oh"><h2 class="bd hv fv z el oi eo ep oj er et ht dt translated">第5部分:两层(Docker多阶段构建)的故事</h2><div class="ok l"><h3 class="bd b fv z el oi eo ep oj er et ek translated">Node.js的生产就绪docker文件</h3></div><div class="ol l"><p class="bd b gc z el oi eo ep oj er et ek translated">hackernoon.com</p></div></div><div class="om l"><div class="ou l oo op oq om or jt od"/></div></div></a></div></div></div>    
</body>
</html>