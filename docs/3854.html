<html>
<head>
<title>ES2019: Javascript’s new features in 2019 🎉</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2019: Javascript 在 2019 年的新特性🎉</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/es2019-javascripts-new-features-in-2019-3427026af799#2019-06-27">https://medium.com/hackernoon/es2019-javascripts-new-features-in-2019-3427026af799#2019-06-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9ae4" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">我们钟爱的 ECMAScript，也就是 Javascript，有了更多惊人的变化。TC39(技术委员会)<em class="jj">刚刚发布了</em>第十版规范。如果你觉得自己很勇敢，想看几百页的原始说明书<a class="ae jk" href="https://www.ecma-international.org/ecma-262/10.0/index.html#Title" rel="noopener ugc nofollow" target="_blank">这是链接</a>。</h2></div><figure class="jm jn jo jp fq jq fe ff paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="fe ff jl"><img src="../Images/8f82dbe12af4499d4d7f45670c2c4ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZGnJCS4EQCYTopiVHXkKg.jpeg"/></div></div></figure><p id="a21d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">你有最新版本的 Chrome 吗？打开 Javascript 控制台，让我们一起编码。</p><h1 id="6ce6" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">1.可选 catch 绑定</h1><p id="2c82" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated">忘记写<code class="eh lq lr ls lt b">catch(err) {}</code>和不处理<code class="eh lq lr ls lt b">err</code>参数。现在它是可选的:</p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="4cd1" class="ly ku hu lt b fv lz ma l mb mc">try {<br/>  // some crazy code<br/>} catch {<br/>  // take an action<br/>}</span></pre><h1 id="d179" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">2.包含 JSON</h1><p id="be7a" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated">ECMAScript 声称 JSON 是<code class="eh lq lr ls lt b"><a class="ae jk" href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-json.parse" rel="noopener ugc nofollow" target="_blank">JSON.parse</a></code>中的超集(在数学中，JSON ⊂ ECMAScript):</p><blockquote class="md me mf"><p id="a023" class="jx jy mg jz b ka kb iv kc kd ke iy kf mh kh ki kj mi kl km kn mj kp kq kr ks hn dt translated">解析后，JSON 对象被实现为 ECMAScript 对象。JSON 数组被实现为 ECMAScript 数组实例。JSON 字符串、数字、布尔值和 null 被实现为 ECMAScript 字符串、数字、布尔值和 null</p></blockquote><p id="9dd2" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">但这不是真的(直到现在)。有些字符可以包含在 JSON 中，但不能包含在 ECMAScript 字符串中，比如行分隔符(U+2028)和段落分隔符(U+2029)。</p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="b68e" class="ly ku hu lt b fv lz ma l mb mc">// before you would receive SyntaxError<br/>JSON.parse('"\u2028"')</span></pre><h1 id="48b7" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated"><code class="eh lq lr ls lt b">3. Symbol.prototype.description</code></h1><p id="4fd5" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated">现在你可以访问一个<code class="eh lq lr ls lt b">Symbol</code>的<code class="eh lq lr ls lt b">description</code>，而不需要调用<code class="eh lq lr ls lt b">toString():</code></p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="35d2" class="ly ku hu lt b fv lz ma l mb mc">const sym = Symbol('Hello')<br/>sym.description // 'Hello'</span></pre><h1 id="0762" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated"><code class="eh lq lr ls lt b">4. Function.prototype.toString </code>修订</h1><p id="6f9e" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated">调用函数的<code class="eh lq lr ls lt b">toString()</code>返回其源代码。通过这一更改，返回值将不会像以前那样删除空格、注释和换行符。</p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="ec86" class="ly ku hu lt b fv lz ma l mb mc">function /* some comment here */ foo () {}</span><span id="dab8" class="ly ku hu lt b fv mk ma l mb mc">// before<br/>foo.toString() // <!-- -->function foo() {}</span><span id="b3da" class="ly ku hu lt b fv mk ma l mb mc">// now<br/>foo.toString() // function /* some comment here */ foo () {}</span></pre><h1 id="1243" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated"><code class="eh lq lr ls lt b">5. Object.fromEntries</code></h1><p id="2b13" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated"><code class="eh lq lr ls lt b">Object.fromEntries</code>与<code class="eh lq lr ls lt b">Object.entries</code>相反。让我们看看:</p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="8de2" class="ly ku hu lt b fv lz ma l mb mc">const obj = { color: 'yellow', size: 20 }</span><span id="caa9" class="ly ku hu lt b fv mk ma l mb mc">Object.entries(obj)<br/>// [[“color”,”yellow”],[“size”,20]]</span><span id="086a" class="ly ku hu lt b fv mk ma l mb mc">Object.fromEntries([[“color”,”yellow”],[“size”,20]])<br/>// { color: ‘yellow’, size: 20 }</span></pre><h1 id="48bf" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">6.格式良好的<code class="eh lq lr ls lt b">JSON.stringify</code></h1><p id="066b" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated">我们现在有了一种更友好、更安全的方式来使用 UTF-8 代码点(U+D800 到 U+DFFF)。</p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="be52" class="ly ku hu lt b fv lz ma l mb mc">// before<br/>JSON.stringify('\uD800') // “�”</span><span id="d1a4" class="ly ku hu lt b fv mk ma l mb mc">// now<br/>JSON.stringify('\uD800') // “"\ud800"”</span></pre><p id="f530" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">现在可以使用<code class="eh lq lr ls lt b">JSON.stringify()</code>将这些代码点表示为字符串，并使用<code class="eh lq lr ls lt b">JSON.parse()</code>将其转换回原始表示。</p><h1 id="8714" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated"><code class="eh lq lr ls lt b">7. String.prototype.{trimStart,trimEnd}</code></h1><p id="0e8c" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated">我们可以从字符串的开头(<code class="eh lq lr ls lt b">trimStart</code>)或结尾(<code class="eh lq lr ls lt b">trimEnd</code>)删除空格。</p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="dbb1" class="ly ku hu lt b fv lz ma l mb mc">const text = '     hello     '</span><span id="121e" class="ly ku hu lt b fv mk ma l mb mc">text.trimStart() // 'hello     '<br/>text.trimEnd()   // '     hello'</span></pre><h1 id="b0a7" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated"><code class="eh lq lr ls lt b">8. Array.prototype.{flat}</code></h1><p id="dc6f" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated"><code class="eh lq lr ls lt b">Array.prototype.flat(depth)</code>递归展平数组直到指定的<code class="eh lq lr ls lt b">depth</code>并返回一个新数组。默认值<code class="eh lq lr ls lt b">depth</code>为 1。</p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="f589" class="ly ku hu lt b fv lz ma l mb mc">const array = ['🍇', ['🍉', ['🍌', ['🍒']]]]</span><span id="9500" class="ly ku hu lt b fv mk ma l mb mc">array.flat()         // ['🍇', '🍉', ['🍌', ['🍒']]]<br/>array.flat(2)        // ['🍇', '🍉', '🍌', ['🍒']]<br/>array.flat(Infinity) // ['🍇', '🍉', '🍌', '🍒']</span></pre><h1 id="675f" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated"><code class="eh lq lr ls lt b">9. Array.prototype.{flatMap}</code></h1><p id="3a3a" class="pw-post-body-paragraph jx jy hu jz b ka ll iv kc kd lm iy kf kg ln ki kj kk lo km kn ko lp kq kr ks hn dt translated"><code class="eh lq lr ls lt b">Array.prototype.flatMap(depth)</code>映射数组中的每个元素，并将结果平铺到一个新的数组中。类似于<code class="eh lq lr ls lt b">map().flat()</code></p><pre class="jm jn jo jp fq lu lt lv lw aw lx dt"><span id="4e48" class="ly ku hu lt b fv lz ma l mb mc">const phrases = ['I like', 'rock music']</span><span id="85d5" class="ly ku hu lt b fv mk ma l mb mc">// with map and flat:<br/>const words = phrases.map(x =&gt; x.split(' '))<br/>// [['I', 'like'], ['rock', 'music']]<br/>words.flat()<br/>// ['I', 'like', 'rock', 'music']</span><span id="c653" class="ly ku hu lt b fv mk ma l mb mc">// with flatMap: <br/>phrases.flatMap(x =&gt; x.split(' '))<br/>// ['I', 'like', 'rock', 'music']</span></pre><p id="8a5d" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated">仅此而已。就这么简单。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="caaa" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><a class="ae jk" rel="noopener" href="/@flaviohfreitas"> <em class="mg">关注我</em> </a> <em class="mg">如果你想看更多我的文章</em>😘如果你喜欢这篇文章，一定要喜欢它，给我很多掌声——它对作者来说意味着整个世界。</p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="bcb3" class="pw-post-body-paragraph jx jy hu jz b ka kb iv kc kd ke iy kf kg kh ki kj kk kl km kn ko kp kq kr ks hn dt translated"><strong class="jz hv"> Flávio H. de Freitas </strong>是一名企业家、工程师、技术爱好者、梦想家和旅行家。曾在<strong class="jz hv">巴西</strong>、<strong class="jz hv">硅谷、欧洲</strong>担任<strong class="jz hv"> CTO </strong>。</p></div></div>    
</body>
</html>