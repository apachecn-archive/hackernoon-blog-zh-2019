<html>
<head>
<title>[Interview] Tackling Complex Architecture: Do’s and Don’ts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[采访]应对复杂的建筑:该做的和不该做的</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/interview-tackling-complex-architecture-dos-and-don-ts-d6f8f34d694d#2019-04-12">https://medium.com/hackernoon/interview-tackling-complex-architecture-dos-and-don-ts-d6f8f34d694d#2019-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/791e0c94b4fe27e99375dd79dda8dcb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kUXEVI5XS0TXdpOU"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="jg">Image credit: </em><a class="ae jh" href="https://www.pexels.com/photo/photography-of-person-typing-1181675/" rel="noopener ugc nofollow" target="_blank"><em class="jg">Pexels</em></a></figcaption></figure><p id="d39c" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在处理复杂的体系结构时应该使用什么方法？您如何构建易于支持和扩展的软件，以及应该避免哪些错误？</p><p id="13d0" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我有机会和 Sergiy Kukunin 坐在一起，他是<a class="ae jh" href="http://spotlightlabs.net/" rel="noopener ugc nofollow" target="_blank">聚光灯实验室</a>的全堆栈开发人员，有 10 多年的经验，我和他更详细地讨论了这些问题。</p><p id="09c5" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">第一个问题是，好的软件应该是什么样子的？</strong></p><p id="382b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们首先决定软件是什么，以及从非程序员的角度看它是什么样子。我们习惯于认为软件是解决业务任务和问题的工具。</p><p id="214b" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">想象你自己是一个需要解决这样一个任务的企业家。你有两个选择:选择一个现在可用的软件，它能正确地解决你的问题，但是完全无法维护；或者选择一个工具，它不完全适合你的情况，但是很容易根据你的需要改变。在许多情况下，第二种选择会更好——软件的主要价值在于它是软的，你可以改变它。即使在游戏行业，也有补丁和修复程序，尽管游戏通常被视为完全完成的产品。</p><p id="a6b7" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">关于编程，还有一些重要的事实需要考虑。任务本身是:</p><ul class=""><li id="9d23" class="kg kh hu jk b jl jm jp jq jt ki jx kj kb kk kf kl km kn ko dt translated">复杂—解决复杂的业务任务需要大量的脑力劳动，</li><li id="de38" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">风险——有很多公司开发软件却最终无法解决问题的故事，</li><li id="06d1" class="kg kh hu jk b jl kp jp kq jt kr jx ks kb kt kf kl km kn ko dt translated">昂贵——在这样的项目上可以花很多钱。</li></ul><p id="00da" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这就是为什么我们应该关心我们写的东西。因此，任何程序员的主要目标都是创建可维护和高效的软件。</p><p id="3033" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">软件应该满足什么样的要求才能称之为“好”？</strong></p><p id="bc34" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">有几个这样的方面，包括:</p><p id="d454" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">可维护性</strong>，即在不消耗大量资源的情况下对软件进行修改的能力。</p><p id="c700" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">僵硬</strong>——表示需要触摸多少地方才能改变。假设我们有一个带有数据库的 Rails 应用程序，一个用于验证的活动记存模型，活动记录和表单中的强参数以一对一的方式映射(这更简单)。现在让我们想象一下，需要做大量的工作来更改数据库中的字段名。我们将需要执行迁移，这意味着向下到控制器更新强参数，同时 UI 也参与改变显示的字段名。这就是刚性。</p><p id="3d13" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">另一个重要因素是<strong class="jk hv">脆性</strong>。软件每次被修改时，在很多地方都会崩溃。Rails 框架就其本质而言是脆弱的，所以您需要多次测试所有东西，以将脆弱性保持在可接受的水平。</p><p id="c976" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">不可移动性</strong>，即不能重用其他项目或同一项目部分的软件。许多红宝石可以作为不动的例子。通常，他们在 Rails 中有很多有用的依赖，这阻止了在 Sinatra 中使用相同的代码。</p><p id="d0a2" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">粘性</strong>——可能有两种形式:设计粘性和环境粘性。例如，在 Ruby 中，设计的粘性很高，因为我不希望一直使用它来开发更好的架构，有时对我来说，简单的方法就是简单地修补一些东西，然后走得更远。像这样做是如此容易，并且仍然以工作软件结束，以至于程序员被敦促不要考虑更好的解决方案。环境的粘性与平台对程序员的限制有关，比如耗时的测试，这导致测试执行的频率低于需要的频率。</p><p id="0e7a" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">第五个标准是<strong class="jk hv">独立部署能力</strong>。这意味着交付一个小的变化而不导致一个全新的发布周期的能力。如果你需要运行 Q &amp; A，staging，或者用户验收测试来做一个小的改变，这是不好的。此外，可部署性是不同团队在同一个项目上工作的能力。你需要以某种方式分割它。</p><p id="6f8c" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">最后一点是<strong class="jk hv">可理解性，</strong>这意味着无需额外努力就能理解编写的代码是多么容易。</p><p id="a78f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">为了达到这些标准，你做了些什么？</strong></p><p id="f789" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">抽象的层次是关键。每个应用程序都有多个方面(和团队成员一起工作),包括 UI、内容、基础设施优化、业务规则和交互(如运输)。但是应用程序部分应该只有一个改变的理由:如果你需要改变内容，你应该能够只改变内容而不触及 UI 或业务规则。大脑加载上下文的能力有限，所以一个好的应用程序不应该包含需要太多上下文来考虑的部分。</p><p id="269a" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在实践中，有这种分离的例子。在 Ruby 应用中，你可以有语义 HTML、MVC、本地化文件和存储库模式。</p><p id="61d6" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">如果我们需要更新内容，那么我们转到本地化文件，就这样。如果我们需要改变数据库存储数据的方式，我们可以在存储库中完成。这种方法减少了刚性、脆弱性和粘性，允许独立开发，并增加了可理解性。</p><p id="3c9c" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jk hv">那么，如果我们遵循这些指导方针，我们安全吗，我们会得到好的软件吗？</strong></p><p id="3391" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">不要太激动。主要的想法是当您处于最佳实践适用的级别时，使用最佳实践。在你没有面临不遵循指导方针的问题之前，实施它们可能是个坏主意。</p><p id="a26e" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">例如，我们正在讨论使用抽象有多好。但是错误的抽象可能会导致更高的刚性、粘性，以及更差的可理解性。此外，更多的抽象需要更多的集成测试。换句话说，试图遵循所有的最佳实践可能会带来太多的开销。</p><p id="ea20" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">例如，几年前我在做一个项目——我们需要用 Ruby 创建一个应用程序。我是这个项目唯一的开发者，至少在开始的时候是这样。这看起来像是一个机会。有生以来第一次，我能够选择任何我想要的技术，尝试所有可能的建筑方法。真是鼓舞人心！我研究了最佳实践、Edsger W. Dijkstra 的文章等等，并试图实现这些想法。</p><p id="8cd0" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">但最后，我们以巨大的开销告终；代码可能已经“正确”地完成了，但是要想取得结果，这种方式仍然需要付出太多的努力。通常需要一天时间的改变，我们需要一周时间才能完成。具有讽刺意味的是，我们是一个团队，所以除了我们的架构背后的“这是一种真实的方式”之外，没有其他原因。</p><p id="10e1" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们必须回滚许多新引入的东西。</p><p id="096f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">您能给出什么建议？您目前构建复杂基础设施的方法是什么，这将有助于避免这种情况？</p><p id="e64a" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">第一条建议是务实，而不是纯粹主义者。你不需要遵循所有的炒作方法，直到你得到了他们解决的问题。否则，事情可能会变得更糟。一个经验法则是根据工作团队来划分应用程序。一个团队有能力改变应用程序的任何方面，所以典型的 Rails 方法就足够了。</p><p id="d14f" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">当你尝试新事物时，你应该关心一致性。如果你的软件就像在它的生命周期中用不同的方法创建的层，在这样的开发风格中花费一段时间后，你将会以一个难以处理的完全混乱而告终。</p><p id="ce94" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">此外，注意确保你是在分享知识。当实现软件开发的新方法时，你应该确保你不是唯一知道正在发生什么的人。任何改变都应该与团队保持一致。最后，你应该随时准备扼杀一种方法。如果你已经尝试了一些事情，但没有成功，通常最好的决定是放弃它，继续前进。在引入一种新方法之前设定目标，这样你就可以防止“等一会儿，它会起作用，你会看到”的偏见。</p><p id="2946" class="pw-post-body-paragraph ji jj hu jk b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">不要一开始就急于实施一切；越迭代越安全。退回错误的方法比从头开始更难。</p></div></div>    
</body>
</html>