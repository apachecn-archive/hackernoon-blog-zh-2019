<html>
<head>
<title>Migrating Class Components to Functional using React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩将类组件迁移到函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-hooks-migrate-class-component-to-functional-and-use-hooks-36a59b130cdc?source=collection_archive---------25-----------------------#2019-05-14">https://medium.com/hackernoon/react-hooks-migrate-class-component-to-functional-and-use-hooks-36a59b130cdc?source=collection_archive---------25-----------------------#2019-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/03d37d9af23874a956ada5051ff52a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IlS6YuixKvGjfNXR"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@fomaolea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Olliss</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="707b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们都知道react钩子已经准备好了，我们中的许多人已经开始使用它了。但是，如果我们有一个现有的项目，我们想移动到有类组件的react hooks呢？</p><p id="d304" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章将指导你把一个现有的基于类的组件变成一个基于钩子的组件。这篇文章不打算深入钩子的细节。</p><p id="4818" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是文档中对<code class="eh kf kg kh ki b">hooks</code>的描述。</p><blockquote class="kj kk kl"><p id="fdb2" class="jh ji km jj b jk jl jm jn jo jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd ke hn dt translated">钩子让我们不用写类就可以使用状态和其他React特性。</p></blockquote><p id="3dee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们从一个示例应用程序开始。这是一个简单的计数器应用程序。代码如下所示:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="e29b" class="ky kz hu ki b fv la lb l lc ld">const initialData = {<br/>  count: 0,<br/>  maxLimit: 10<br/>};</span><span id="80bb" class="ky kz hu ki b fv le lb l lc ld">class Counter extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      count: this.props.initialCount<br/>    };<br/>  }<br/>  onIncrement = () =&gt; {<br/>    this.setState({ count: this.state.count + 1 });<br/>  };<br/>  onDecrement = () =&gt; {<br/>    this.setState({ count: this.state.count - 1 });<br/>  };<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;button<br/>          onClick={this.onDecrement}<br/>          disabled={this.state.count === this.props.initialCount}<br/>        &gt;<br/>          -<br/>        &lt;/button&gt;<br/>        &lt;div&gt;{this.state.count}&lt;/div&gt;<br/>        &lt;button<br/>          onClick={this.onIncrement}<br/>          disabled={this.state.count === this.props.maxLimit}<br/>        &gt;<br/>          +<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="1daa" class="ky kz hu ki b fv le lb l lc ld">class CounterApp extends React.Component {<br/>  render() {<br/>    const { initialData } = this.props;<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;h2&gt;Counter Example&lt;/h2&gt;<br/>        &lt;Counter<br/>          initialCount={initialData.count}<br/>          maxLimit={initialData.maxLimit}<br/>        /&gt;<br/>      &lt;/React.Fragment&gt;<br/>    )<br/>  }<br/>}</span><span id="6167" class="ky kz hu ki b fv le lb l lc ld">ReactDOM.render(<br/>  &lt;CounterApp initialData={initialData} /&gt;,<br/>  document.getElementById('root')<br/>)</span></pre><p id="ea44" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如你所见，我已经创建了一个简单的计数器应用程序。创建的类组件有:</p><ul class=""><li id="d5e4" class="lf lg hu jj b jk jl jo jp js lh jw li ka lj ke lk ll lm ln dt translated"><code class="eh kf kg kh ki b">CounterApp</code>:这是主要的应用组件</li><li id="7934" class="lf lg hu jj b jk lo jo lp js lq jw lr ka ls ke lk ll lm ln dt translated"><code class="eh kf kg kh ki b">Counter</code>:实际计数器组件</li></ul><p id="26a9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，这段代码是为这篇文章准备的，只是为了解释的目的。请忽略您可能看到的任何其他需要改进的地方。☺</p><p id="a13b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">因此，要将类组件转换为功能性/钩子组件，步骤如下:</p><h2 id="2d03" class="ky kz hu bd lt lu lv lw lx ly lz ma mb js mc md me jw mf mg mh ka mi mj mk ml dt translated">首先选择最小的类组件，即自下而上的方法会更好。</h2><ol class=""><li id="cc0b" class="lf lg hu jj b jk mm jo mn js mo jw mp ka mq ke mr ll lm ln dt translated">将类组件拥有的所有代码移动到render方法中并使其工作，例如事件处理函数或任何其他函数或代码。</li><li id="ea2f" class="lf lg hu jj b jk lo jo lp js lq jw lr ka ls ke mr ll lm ln dt translated">更新代码以使用<code class="eh kf kg kh ki b">props</code> &amp; <code class="eh kf kg kh ki b">states</code>的对象分解。</li><li id="e850" class="lf lg hu jj b jk lo jo lp js lq jw lr ka ls ke mr ll lm ln dt translated">在<code class="eh kf kg kh ki b">class</code>语法前添加一行，如下所示。</li></ol><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="47f5" class="ky kz hu ki b fv la lb l lc ld">const Counter = () =&gt; {}<br/>class Counter extends React.Component {<br/>  /*...code goes here */<br/>}</span></pre><p id="2438" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">4.将render方法中的所有内容移动到更新的函数组件代码块中。</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="4436" class="ky kz hu ki b fv la lb l lc ld">const Counter = () =&gt; {<br/>  //...code inside render methods of class component code goes here<br/>}<br/>class Counter extends React.Component {<br/>  //...Rest of the code<br/>  render() {<br/>    // This will be blank now<br/>  }<br/>}</span></pre><p id="dbfe" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">5.将props的析构代码移到功能组件的括号内。从代码块中移除代码。</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="ba85" class="ky kz hu ki b fv la lb l lc ld">const Counter = ({ maxLimit, count }) =&gt; {<br/>  /*...rest of the code */<br/>}</span></pre><p id="ce9d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">6.更新组件以使用像<code class="eh kf kg kh ki b">useState</code>这样的钩子或者任何其他可能需要的钩子。例如。</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="22bf" class="ky kz hu ki b fv la lb l lc ld">const Counter = ({ maxLimit, count }) =&gt; {<br/>  //...Rest of the code<br/>  const [count, setCount] = React.useState(count)<br/>  //...Rest of the code<br/>}</span></pre><blockquote class="kj kk kl"><p id="14c2" class="jh ji km jj b jk jl jm jn jo jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd ke hn dt translated"><em class="hu">如果您有多个state属性，请将其更改为对所有属性单独使用挂钩。我在这里不解释如何写钩子的语法。请阅读相同的官方文档。</em></p></blockquote><p id="6f70" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">7.最后，更新return语句代码块，使用新创建的props(析构的)或使用钩子的状态。所做的任何其他更改都应相应纳入。并完全删除类组件代码行。</p><p id="2a9d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，这可能看起来很多。让我们来研究一下现有的例子。</p><h1 id="28d1" class="ms kz hu bd lt mt mu mv lx mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni dt translated">计数器组件</h1><p id="2215" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js nj ju jv jw nk jy jz ka nl kc kd ke hn dt translated">在render方法内移动<code class="eh kf kg kh ki b">onIncrement</code>和<code class="eh kf kg kh ki b">onDecrement</code>代码块。定义为<code class="eh kf kg kh ki b">const</code>并将功能<code class="eh kf kg kh ki b">this.onIncrement</code>和<code class="eh kf kg kh ki b">this.onDecrement</code>分别更新为<code class="eh kf kg kh ki b">onIncrement</code>和<code class="eh kf kg kh ki b">onDecrement</code>。</p><p id="7b4a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在render方法中对<code class="eh kf kg kh ki b">props</code>和<code class="eh kf kg kh ki b">state</code>使用对象去结构化。在我们的例子中，您可以这样做:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="1f49" class="ky kz hu ki b fv la lb l lc ld">const { maxLimit, count } = this.props<br/>const { count } = this.state</span></pre><p id="0fed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，就在<code class="eh kf kg kh ki b">class Counter extends React.Component {</code>行之前，创建一个类似如下的行:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="07e0" class="ky kz hu ki b fv la lb l lc ld">const Counter = () =&gt; {}</span></pre><p id="dda4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从<code class="eh kf kg kh ki b">render</code>方法中剪切所有内容，并将其粘贴到<code class="eh kf kg kh ki b">const Counter = () =&gt; {}</code>的花括号中</p><p id="d18b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">将分解后的<code class="eh kf kg kh ki b">props</code>移入括号中。第2行被注释掉，第1行现在有了道具<code class="eh kf kg kh ki b">{maxLimit, initialCount}</code>。</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="f87d" class="ky kz hu ki b fv la lb l lc ld">const Counter = ({ maxLimit, count }) =&gt; {<br/>  // const { maxLimit, initialCount } = this.props;<br/>  const { count } = this.state<br/>  // ....Rest of the code<br/>}</span></pre><p id="f986" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，我们需要改变我们的<code class="eh kf kg kh ki b">this.state</code>。我们将在这里使用<code class="eh kf kg kh ki b">useState</code>钩子。更新第2行的代码，如下所示:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="9181" class="ky kz hu ki b fv la lb l lc ld">const Counter = ({ maxLimit, initialCount }) =&gt; {<br/>  const [count, setCount] = React.useState(initialCount);<br/>  // ....Rest of the code<br/>}</span></pre><p id="78f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们修改的代码是使用钩子的语法。</p><p id="861c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在是时候更新我们的函数，使用我们用钩子定义的<code class="eh kf kg kh ki b">setCount</code>。更改我们在<code class="eh kf kg kh ki b">onIncrement</code>和<code class="eh kf kg kh ki b">onDecrement</code>中的代码<code class="eh kf kg kh ki b">this.setState</code>。更新后的代码如下所示:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="c60b" class="ky kz hu ki b fv la lb l lc ld">const Counter = ({ maxLimit, initialCount }) =&gt; {<br/>  // ....Rest of the code<br/>  const onIncrement = () =&gt; {<br/>    setCount(count + 1);<br/>  };<br/>  const onIncrement = () =&gt; {<br/>    setCount(count - 1);<br/>  };<br/>  // ....Rest of the code<br/>}</span></pre><p id="ab4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，相应地更新return语句的代码，以使用新的<code class="eh kf kg kh ki b">count</code>状态(使用钩子创建)和去结构化的<code class="eh kf kg kh ki b">props</code>。并且，完全删除<code class="eh kf kg kh ki b">class Counter extends React.Component {}</code>代码。</p><p id="6010" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh kf kg kh ki b">Counter</code>组件的最终代码应该如下所示:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="514b" class="ky kz hu ki b fv la lb l lc ld">const Counter = ({ maxLimit, initialCount }) =&gt; {<br/>  const [count, setCount] = React.useState(initialCount);<br/>  const onIncrement = () =&gt; {<br/>    setCount(count + 1);<br/>  };<br/>  const onDecrement = () =&gt; {<br/>    setCount(count - 1);<br/>  };<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button<br/>        onClick={onDecrement}<br/>        disabled={count === initialCount}<br/>      &gt;<br/>        -<br/>      &lt;/button&gt;<br/>      &lt;div&gt;{count}&lt;/div&gt;<br/>      &lt;button<br/>        onClick={onIncrement}<br/>        disabled={count === maxLimit}<br/>      &gt;<br/>        +<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="42fa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以，你可能会注意到，最后没有使用<code class="eh kf kg kh ki b">this</code>，代码看起来也干净了很多。</p><h1 id="f4d2" class="ms kz hu bd lt mt mu mv lx mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni dt translated">CounterApp组件</h1><p id="043c" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js nj ju jv jw nk jy jz ka nl kc kd ke hn dt translated">主<code class="eh kf kg kh ki b">CounterApp</code>组件中没有太多东西，所以我们可以毫不费力地将其转换为功能组件。<code class="eh kf kg kh ki b">CounterApp</code>的最终代码将如下所示:</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="8d9e" class="ky kz hu ki b fv la lb l lc ld">const CounterApp = ({ initialData: {count, maxLimit} }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;h2&gt;Counter Example&lt;/h2&gt;<br/>      &lt;Counter initialCount={count} maxLimit={maxLimit} /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><blockquote class="kj kk kl"><p id="c0a9" class="jh ji km jj b jk jl jm jn jo jp jq jr kn jt ju jv ko jx jy jz kp kb kc kd ke hn dt translated"><em class="hu">疑惑</em><code class="eh kf kg kh ki b"><em class="hu">&lt;&gt;</em></code><em class="hu"/><code class="eh kf kg kh ki b"><em class="hu">&lt;/&gt;</em></code><em class="hu">是什么？这是一种避免我们以前创建的额外元素层的方法。所以，用这个或者用文章开头所示的</em> <code class="eh kf kg kh ki b"><em class="hu">React.Fragment</em></code> <em class="hu">。</em></p></blockquote><p id="cb65" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">完整的计数器应用程序代码如下所示。</p><pre class="kq kr ks kt fq ku ki kv kw aw kx dt"><span id="9066" class="ky kz hu ki b fv la lb l lc ld">const initialData = {<br/>  count: 0,<br/>  maxLimit: 10<br/>};<br/>// added style to make it look better, in case you want to see<br/>const counterStyles = {<br/>  h1: {<br/>    maxWidth: "185px",<br/>    boxShadow: "5px 5px 4px #888888"<br/>  },<br/>  container: {<br/>    display: "flex",<br/>    alignItems: "center"<br/>  },<br/>  button: {<br/>    width: "30px",<br/>    borderRadius: "50%",<br/>    borderStyle: "none",<br/>    fontSize: "22px",<br/>    backgroundColor: "khaki",<br/>    height: "30px",<br/>    paddingBottom: "5px",<br/>    cursor: "pointer"<br/>  },<br/>  countDiv: {<br/>    minWidth: "80px",<br/>    padding: "0 15px",<br/>    textAlign: "center",<br/>    height: "30px",<br/>    lineHeight: 2,<br/>    border: "1px solid",<br/>    borderRadius: "10px",<br/>    margin: "0 5px"<br/>  }<br/>}</span><span id="5633" class="ky kz hu ki b fv le lb l lc ld">const Counter = ({ maxLimit, initialCount }) =&gt; {<br/>  // styles...<br/>  const { container, button, countDiv } = counterStyles;<br/>  const [count, setCount] = React.useState(initialCount);<br/>  const onIncrement = () =&gt; {<br/>    setCount(count + 1);<br/>  };<br/>  const onDecrement = () =&gt; {<br/>    setCount(count - 1);<br/>  };<br/>  return (<br/>    &lt;div style={container}&gt;<br/>      &lt;button<br/>        style={button}<br/>        onClick={onDecrement}<br/>        disabled={count === initialCount}<br/>      &gt;<br/>        -<br/>      &lt;/button&gt;<br/>      &lt;div style={countDiv}&gt;{count}&lt;/div&gt;<br/>      &lt;button<br/>        style={button}<br/>        onClick={onIncrement}<br/>        disabled={count === maxLimit}<br/>      &gt;<br/>        +<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="3c5a" class="ky kz hu ki b fv le lb l lc ld">const CounterApp = ({ initialData: {count, maxLimit} }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;h2 style={counterStyles.h1}&gt;Counter App: Hooks&lt;/h2&gt;<br/>      &lt;Counter initialCount={count} maxLimit={maxLimit} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span><span id="a465" class="ky kz hu ki b fv le lb l lc ld">ReactDOM.render(<br/>  &lt;CounterApp initialData={initialData} /&gt;,<br/>  document.getElementById('root')<br/>)</span></pre><h1 id="f796" class="ms kz hu bd lt mt mu mv lx mw mx my mb mz na nb me nc nd ne mh nf ng nh mk ni dt translated">摘要</h1><p id="58e7" class="pw-post-body-paragraph jh ji hu jj b jk mm jm jn jo mn jq jr js nj ju jv jw nk jy jz ka nl kc kd ke hn dt translated">通过这篇文章，我们学到了一些关于如何将基于类的组件转换成功能性的基于钩子的组件的技巧。我希望这将有助于您迁移现有的代码库。</p><p id="e685" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果有任何问题/顾虑，请随时联系我们。</p><p id="fb29" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">快乐学习！</p></div><div class="ab cl nm nn hc no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="hn ho hp hq hr"><p id="bd39" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="km">最初发表于</em><a class="ae jg" href="https://www.elanandkumar.com/blog/react-hooks-class-to-hooks-migration/" rel="noopener ugc nofollow" target="_blank"><em class="km">【https://www.elanandkumar.com】</em></a><em class="km">。</em></p></div></div>    
</body>
</html>