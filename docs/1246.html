<html>
<head>
<title>12 Concepts That Will Level Up Your JavaScript Skills</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升JavaScript技能的12个概念</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/12-javascript-concepts-that-will-level-up-your-development-skills-b37d16ad7104?source=collection_archive---------0-----------------------#2019-02-21">https://medium.com/hackernoon/12-javascript-concepts-that-will-level-up-your-development-skills-b37d16ad7104?source=collection_archive---------0-----------------------#2019-02-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/a14cf26906f7e595623095533a6af04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zDY1styY9gAbl9DEeAS6DA.jpeg"/></div></div></figure><p id="0025" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JavaScript是一种复杂的语言。如果您是任何级别的JavaScript开发人员，理解它的基本概念是很重要的。本文讨论了12个概念，这些概念对于任何JS开发人员来说都是非常重要的，但绝不代表JS开发人员应该了解的全部内容。</p><p id="e31b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢这篇文章，请为它鼓掌👏(还是50！)来帮助传播消息！</p><p id="7950" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我会在一个名为<a class="ae ka" href="https://github.com/nas5w/javascript-tips-and-tidbits" rel="noopener ugc nofollow" target="_blank"> JS Tips &amp; Tidbits </a>的Github资源库中不断更新这个列表。请明星⭐和分享，如果你想跟进！</p><p id="42f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">***</p><h2 id="5b33" class="kb kc hu bd kd ke kf kg kh ki kj kk kl jn km kn ko jr kp kq kr jv ks kt ku kv dt translated">通过注册我的免费时事通讯，在您的收件箱中获得快速JavaScript技巧！</h2><figure class="kw kx ky kz fq iv"><div class="bz el l di"><div class="la lb l"/></div></figure><p id="8355" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt">***</p><h1 id="63c2" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">1.值与参考变量赋值</h1><p id="b8b8" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">理解JavaScript如何给变量赋值是编写无bug JavaScript的基础。如果您不理解这一点，您很容易编写无意中更改值的代码。</p><p id="7a8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JavaScript <em class="ly">总是</em>按值分配变量。但是这一部分<strong class="je hv">非常</strong>重要:当赋值是JavaScript的五个原语类型(即<code class="eh lz ma mb mc b">Boolean</code>、<code class="eh lz ma mb mc b">null</code>、<code class="eh lz ma mb mc b">undefined</code>、<code class="eh lz ma mb mc b">String</code>和<code class="eh lz ma mb mc b">Number</code>)之一时，实际值被赋值。然而，当赋值为<code class="eh lz ma mb mc b">Array</code>、<code class="eh lz ma mb mc b">Function</code>或<code class="eh lz ma mb mc b">Object</code>时，会分配一个对存储器中对象的<em class="ly">引用。</em></p><p id="57f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">示例时间！在下面的代码片段中，<code class="eh lz ma mb mc b">var2</code>被设置为等于<code class="eh lz ma mb mc b">var1</code>。因为<code class="eh lz ma mb mc b">var1</code>是一个原始类型(<code class="eh lz ma mb mc b">String</code>)，所以<code class="eh lz ma mb mc b">var2</code>被设置为等于<code class="eh lz ma mb mc b">var1</code>的<code class="eh lz ma mb mc b">String</code>值，并且可以认为在这一点上与<code class="eh lz ma mb mc b">var1</code>完全不同。因此，重新分配<code class="eh lz ma mb mc b">var2</code>对<code class="eh lz ma mb mc b">var1.</code>没有影响</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="801b" class="kb kc hu mc b fv mh mi l mj mk">let var1 = 'My string';<br/>let var2 = var1;</span><span id="97e6" class="kb kc hu mc b fv ml mi l mj mk">var2 = 'My new string';</span><span id="a25a" class="kb kc hu mc b fv ml mi l mj mk">console.log(var1);<br/>// 'My string'<br/>console.log(var2);<br/>// 'My new string'</span></pre><p id="5e41" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们把这个和对象赋值比较一下。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="48a0" class="kb kc hu mc b fv mh mi l mj mk">let var1 = { name: 'Jim' }<br/>let var2 = var1;</span><span id="3067" class="kb kc hu mc b fv ml mi l mj mk">var2.name = 'John';</span><span id="580d" class="kb kc hu mc b fv ml mi l mj mk">console.log(var1);<br/>// { name: 'John' }<br/>console.log(var2);<br/>// { name: 'John' }</span></pre><p id="bdfc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您期望像原语赋值这样的行为，您可能会看到这是如何引起问题的！如果您创建了一个无意中改变了对象的函数，这可能会变得特别糟糕。</p><h1 id="bea2" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">2.关闭</h1><p id="ce9d" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">闭包是一种重要的JavaScript模式，用于对变量进行私有访问。在本例中，<code class="eh lz ma mb mc b">createGreeter</code>返回一个匿名函数，该函数可以访问所提供的<code class="eh lz ma mb mc b">greeting</code>“Hello”对于所有未来的使用，<code class="eh lz ma mb mc b">sayHello</code>将获得此问候！</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="e018" class="kb kc hu mc b fv mh mi l mj mk">function createGreeter(greeting) {<br/>  return function(name) {<br/>    console.log(greeting + ', ' + name);<br/>  }<br/>}</span><span id="2811" class="kb kc hu mc b fv ml mi l mj mk">const sayHello = createGreeter('Hello');<br/>sayHello('Joe');<br/>// Hello, Joe</span></pre><p id="3f09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在更真实的场景中，您可以设想一个初始函数<code class="eh lz ma mb mc b">apiConnect(apiKey)</code>，它返回一些使用API键的方法。在这种情况下，<code class="eh lz ma mb mc b">apiKey</code>只需要提供一次，不再需要。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="3ef4" class="kb kc hu mc b fv mh mi l mj mk">function apiConnect(apiKey) {<br/>  function get(route) {<br/>    return fetch(`${route}?key=${apiKey}`);<br/>  }</span><span id="34cd" class="kb kc hu mc b fv ml mi l mj mk">  function post(route, params) {<br/>    return fetch(route, <!-- -->{<br/>      method: 'POST',<br/>      body: JSON.stringify(params),<br/>        headers: {<br/>          'Authorization': `Bearer ${apiKey}`<br/>        }<br/>      }<!-- -->)<br/>  }</span><span id="5d99" class="kb kc hu mc b fv ml mi l mj mk">  return { get, post }<br/>}</span><span id="f26f" class="kb kc hu mc b fv ml mi l mj mk">const api = apiConnect('my-secret-key');</span><span id="eb50" class="kb kc hu mc b fv ml mi l mj mk">// No need to include the apiKey anymore<br/>api.get('http://www.example.com/get-endpoint');<br/>api.post('http://www.example.com/post-endpoint', { name: 'Joe' });</span></pre><h1 id="8b84" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">3.解构</h1><p id="785b" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">不要被JavaScript参数析构所迷惑！这是从对象中干净地提取属性的一种常见方式。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="a631" class="kb kc hu mc b fv mh mi l mj mk">const obj = {<br/>  name: 'Joe',<br/>  food: 'cake'<br/>}</span><span id="cb7a" class="kb kc hu mc b fv ml mi l mj mk">const { name, food } = obj;</span><span id="a462" class="kb kc hu mc b fv ml mi l mj mk">console.log(name, food);<br/>// 'Joe' 'cake'</span></pre><p id="7ead" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果要以不同的名称提取属性，可以使用以下格式指定它们。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="d527" class="kb kc hu mc b fv mh mi l mj mk">const obj = {<br/>  name: 'Joe',<br/>  food: 'cake'<br/>}</span><span id="9664" class="kb kc hu mc b fv ml mi l mj mk">const { name: myName, food: myFood } = obj;</span><span id="050e" class="kb kc hu mc b fv ml mi l mj mk">console.log(myName, myFood);<br/>// 'Joe' 'cake'</span></pre><p id="b6ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在下面的例子中，析构用于将<code class="eh lz ma mb mc b">person</code>对象干净地传递给<code class="eh lz ma mb mc b">introduce</code>函数。换句话说，析构可以(并且经常)直接用于提取传递给函数的参数。如果你熟悉React，你可能以前见过这个！</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="a2ba" class="kb kc hu mc b fv mh mi l mj mk">const person = {<br/>  name: 'Eddie',<br/>  age: 24<br/>}</span><span id="255a" class="kb kc hu mc b fv ml mi l mj mk">function introduce({ name, age }) {<br/>  console.log(`I'm ${name} and I'm ${age} years old!`);<br/>}</span><span id="d04b" class="kb kc hu mc b fv ml mi l mj mk">console.log(introduce(person));<br/>// "I'm Eddie and I'm 24 years old!"</span></pre><h1 id="4859" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">4.扩展语法</h1><p id="9389" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">一个让人迷惑但相对简单的JavaScript概念是spread操作符！在下面的例子中，<code class="eh lz ma mb mc b">Math.max</code>不能应用于<code class="eh lz ma mb mc b">arr</code>数组，因为它不接受数组作为参数，而是接受单个元素作为参数。扩展操作符<code class="eh lz ma mb mc b">...</code>用于将单个元素从数组中取出。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="36f9" class="kb kc hu mc b fv mh mi l mj mk">const arr = [4, 6, -1, 3, 10, 4];<br/>const max = Math.max(...arr);<br/>console.log(max);<br/>// 10</span></pre><h1 id="1821" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">5.Rest语法</h1><p id="840b" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我们来谈谈JavaScript rest语法。您可以使用它将传递给函数的任意数量的参数放入一个数组中！</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="c733" class="kb kc hu mc b fv mh mi l mj mk">function myFunc(...args) {<br/>  console.log(args[0] + args[1]);<br/>}</span><span id="5d4a" class="kb kc hu mc b fv ml mi l mj mk">myFunc(1, 2, 3, 4);<br/>// 3</span></pre><h1 id="986f" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">6.数组方法</h1><p id="be0b" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">JavaScript数组方法通常可以为您提供难以置信的、优雅的方式来执行您需要的数据转换。作为StackOverflow的贡献者，我经常看到关于如何以某种方式操作对象数组的问题。这往往是数组方法的完美用例。</p><p id="3ed5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我将在这里介绍一些不同的数组方法，它们是由相似的方法组织起来的，这些方法有时会被混在一起。这个列表一点也不全面:我鼓励你回顾并练习MDN (我最喜欢的JavaScript参考资料)上讨论的所有内容<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="65a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> map、filter、reduce <br/> </strong>围绕JavaScript数组方法<code class="eh lz ma mb mc b">map</code>、<code class="eh lz ma mb mc b">filter</code>、<code class="eh lz ma mb mc b">reduce</code>有些混乱。这些是转换数组或返回聚合值的有用方法。</p><ul class=""><li id="72ff" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> map: </strong>返回数组，其中每个元素都按照函数的指定进行转换</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="aac7" class="kb kc hu mc b fv mh mi l mj mk">const arr = [1, 2, 3, 4, 5, 6];<br/>const mapped = arr.map(el =&gt; el + 20);</span><span id="9479" class="kb kc hu mc b fv ml mi l mj mk">console.log(mapped);<br/>// [21, 22, 23, 24, 25, 26]</span></pre><ul class=""><li id="6813" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> filter: </strong>返回函数返回true的元素数组</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="41ea" class="kb kc hu mc b fv mh mi l mj mk">const arr = [1, 2, 3, 4, 5, 6];<br/>const filtered = arr.filter(el =&gt; el === 2 || el === 4);</span><span id="89da" class="kb kc hu mc b fv ml mi l mj mk">console.log(filtered);<br/>// [2, 4]</span></pre><ul class=""><li id="ef9e" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv">减少:</strong>累加函数中指定的值</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="ba2e" class="kb kc hu mc b fv mh mi l mj mk">const arr = [1, 2, 3, 4, 5, 6];<br/>const reduced = arr.reduce((total, current) =&gt; total + current);</span><span id="9c42" class="kb kc hu mc b fv ml mi l mj mk">console.log(reduced);<br/>// 21</span></pre><p id="cafd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> find，findIndex，indexOf <br/> </strong>数组方法<code class="eh lz ma mb mc b">find</code>、<code class="eh lz ma mb mc b">findIndex</code>和<code class="eh lz ma mb mc b">indexOf</code>经常可以合并使用。如下使用它们。</p><ul class=""><li id="c6a0" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> find </strong>:返回第一个符合指定条件的实例。不会继续查找任何其他匹配的实例。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="f888" class="kb kc hu mc b fv mh mi l mj mk">const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br/>const found = arr.find(el =&gt; el &gt; 5);</span><span id="40e6" class="kb kc hu mc b fv ml mi l mj mk">console.log(found);<br/>// 6</span></pre><p id="74cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">再次注意，虽然<code class="eh lz ma mb mc b">5</code>之后的所有内容都符合标准，但只返回第一个匹配的元素。这实际上非常有帮助，当你找到一个匹配时，你通常会<code class="eh lz ma mb mc b">break</code>一个for循环！</p><ul class=""><li id="d0de" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> findIndex </strong>:这与<code class="eh lz ma mb mc b">find</code>的工作方式几乎相同，但是它返回的不是第一个匹配元素的<em class="ly">索引</em>。以下面的例子为例，为了清楚起见，它使用了名称而不是数字。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="d7e3" class="kb kc hu mc b fv mh mi l mj mk">const arr = ['Nick', 'Frank', 'Joe', 'Frank'];<br/>const foundIndex = arr.findIndex(el =&gt; el === 'Frank');</span><span id="27cd" class="kb kc hu mc b fv ml mi l mj mk">console.log(foundIndex);<br/>// 1</span></pre><ul class=""><li id="2d37" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> indexOf: </strong>的工作方式几乎与<code class="eh lz ma mb mc b">findIndex</code>相同，但它不是将函数作为参数，而是采用一个简单的值。当你有更简单的逻辑，不需要用函数来检查是否有匹配时，可以用这个。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="c36a" class="kb kc hu mc b fv mh mi l mj mk">const arr = ['Nick', 'Frank', 'Joe', 'Frank'];<br/>const foundIndex = arr.indexOf('Frank');</span><span id="fefa" class="kb kc hu mc b fv ml mi l mj mk">console.log(foundIndex);<br/>// 1</span></pre><p id="0890" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> push，pop，shift，unshift <br/> </strong>有很多很棒的数组方法来帮助以有针对性的方式从数组中添加或删除元素。</p><ul class=""><li id="5f29" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> push: </strong>这是一个相对简单的方法，将一个项添加到数组的末尾。它就地修改数组，函数本身返回添加到数组中的项。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="dc2b" class="kb kc hu mc b fv mh mi l mj mk">let arr = [1, 2, 3, 4];<br/>const pushed = arr.push(5);</span><span id="47e0" class="kb kc hu mc b fv ml mi l mj mk">console.log(arr);<br/>// [1, 2, 3, 4, 5]<br/>console.log(pushed);<br/>// 5</span></pre><ul class=""><li id="fe18" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated">从数组中移除最后一项。同样，它会就地修改数组。函数本身返回从数组中移除的项。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="43d7" class="kb kc hu mc b fv mh mi l mj mk">let arr = [1, 2, 3, 4];<br/>const popped = arr.pop();</span><span id="b773" class="kb kc hu mc b fv ml mi l mj mk">console.log(arr);<br/>// [1, 2, 3]<br/>console.log(popped);<br/>// 4</span></pre><ul class=""><li id="72fc" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> shift: </strong>从数组中移除第一个项目。同样，它会就地修改数组。函数本身返回从数组中移除的项。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="21ed" class="kb kc hu mc b fv mh mi l mj mk">let arr = [1, 2, 3, 4];<br/>const shifted = arr.shift();</span><span id="3f91" class="kb kc hu mc b fv ml mi l mj mk">console.log(arr);<br/>// [2, 3, 4]<br/>console.log(shifted);<br/>// 1</span></pre><ul class=""><li id="44af" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> unshift: </strong>将一个或多个元素添加到数组的开头。同样，它会就地修改数组。与许多其他方法不同，函数本身返回数组的新长度。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="567f" class="kb kc hu mc b fv mh mi l mj mk">let arr = [1, 2, 3, 4];<br/>const unshifted = arr.unshift(5, 6, 7);</span><span id="ff20" class="kb kc hu mc b fv ml mi l mj mk">console.log(arr);<br/>// [5, 6, 7, 1, 2, 3, 4]<br/>console.log(unshifted);<br/>// 7</span></pre><p id="4ada" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> splice，slice<br/>T37】这些方法或者修改或者返回数组的子集。</strong></p><ul class=""><li id="6ce9" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv">拼接:</strong>通过移除或替换现有元素和/或添加新元素来更改数组的内容。此方法就地修改数组。</li></ul><p id="d047" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面的代码示例可以读作:在数组的位置<code class="eh lz ma mb mc b">1</code>处，移除<code class="eh lz ma mb mc b">0</code>元素，插入<code class="eh lz ma mb mc b">b</code>。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="3ce9" class="kb kc hu mc b fv mh mi l mj mk">let arr = ['a', 'c', 'd', 'e'];<br/>arr.splice(1, 0, 'b')</span></pre><ul class=""><li id="4112" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv"> slice: </strong>从指定的开始位置和结束位置之前返回数组的浅表副本。如果没有指定结束位置，则返回数组的其余部分。重要的是，这个方法<strong class="je hv">并不</strong>就地修改数组，而是返回所需的子集。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="4f5f" class="kb kc hu mc b fv mh mi l mj mk">let arr = ['a', 'b', 'c', 'd', 'e'];<br/>const sliced = arr.slice(2, 4);</span><span id="688f" class="kb kc hu mc b fv ml mi l mj mk">console.log(sliced);<br/>// ['c', 'd']<br/>console.log(arr);<br/>// ['a', 'b', 'c', 'd', 'e']</span></pre><p id="79a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">排序</strong></p><ul class=""><li id="9cb0" class="mm mn hu je b jf jg jj jk jn mo jr mp jv mq jz mr ms mt mu dt translated"><strong class="je hv">排序:</strong>根据提供的函数对数组进行排序，该函数采用第一个元素和第二个元素参数。就地修改数组。如果函数返回负数或0，则顺序保持不变。如果为正值，则元素顺序会被交换。</li></ul><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="55ab" class="kb kc hu mc b fv mh mi l mj mk">let arr = [1, 7, 3, -1, 5, 7, 2];<br/>const sorter = (firstEl, secondEl) =&gt; firstEl - secondEl;<br/>arr.sort(sorter);</span><span id="292b" class="kb kc hu mc b fv ml mi l mj mk">console.log(arr);<br/>// [-1, 1, 2, 3, 5, 7, 7]</span></pre><p id="5dd5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">唷，你都看到了吗？我也没有。事实上，在写这篇文章的时候，我不得不大量参考MDN文档——这没关系！只要知道有什么样的方法可以让你达到95%的目标。</p><h1 id="9cc9" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">7.发电机</h1><p id="6060" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">不要害怕<code class="eh lz ma mb mc b">*</code>。生成器函数指定下次调用<code class="eh lz ma mb mc b">next()</code>时产生什么<code class="eh lz ma mb mc b">value</code>。可以有有限数量的产出，之后<code class="eh lz ma mb mc b">next()</code>返回一个未定义的<code class="eh lz ma mb mc b">value</code>，或者使用一个循环得到无限数量的值。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="241a" class="kb kc hu mc b fv mh mi l mj mk">function* greeter() {<br/>  yield 'Hi';<br/>  yield 'How are you?';<br/>  yield 'Bye';<br/>}</span><span id="eeed" class="kb kc hu mc b fv ml mi l mj mk">const greet = greeter();</span><span id="a143" class="kb kc hu mc b fv ml mi l mj mk">console.log(greet.next().value);<br/>// 'Hi'<br/>console.log(greet.next().value);<br/>// 'How are you?'<br/>console.log(greet.next().value);<br/>// 'Bye'<br/>console.log(greet.next().value);<br/>// undefined<br/></span></pre><p id="7575" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用一个无限值生成器:</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="bf9a" class="kb kc hu mc b fv mh mi l mj mk">function* idCreator() {<br/>  let i = 0;<br/>  while (true)<br/>    yield i++;<br/>}</span><span id="ede5" class="kb kc hu mc b fv ml mi l mj mk">const ids = idCreator();</span><span id="19e4" class="kb kc hu mc b fv ml mi l mj mk">console.log(ids.next().value);<br/>// 0<br/>console.log(ids.next().value);<br/>// 1<br/>console.log(ids.next().value);<br/>// 2<br/>// etc...</span></pre><h1 id="c7ac" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">8.相同运算符(<code class="eh lz ma mb mc b">===</code>)与相等运算符(<code class="eh lz ma mb mc b">==</code>)</h1><p id="5413" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">一定要知道JavaScript中标识操作符(<code class="eh lz ma mb mc b">===</code>)和相等操作符(<code class="eh lz ma mb mc b">==</code>)的区别！<code class="eh lz ma mb mc b">==</code>运算符将在比较值之前进行类型转换，而<code class="eh lz ma mb mc b">===</code>运算符在比较之前不会进行任何类型转换。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="d1fb" class="kb kc hu mc b fv mh mi l mj mk">console.log(0 == '0');<br/>// true<br/>console.log(0 === '0');<br/>// false</span></pre><h1 id="996b" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">9.对象比较</h1><p id="c062" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我看到JavaScript新手犯的一个错误是直接比较对象。变量指向内存中对象的引用，而不是对象本身！实际比较它们的一种方法是将对象转换成JSON字符串。但是这有一个缺点:对象属性顺序没有保证！比较对象的一个更安全的方法是引入一个专门进行深度对象比较的库(例如<a class="ae ka" href="https://lodash.com/docs#isEqual" rel="noopener ugc nofollow" target="_blank"> lodash的isEqual </a>)。</p><p id="3e11" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下对象看起来相等，但实际上它们指向不同的引用。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="408e" class="kb kc hu mc b fv mh mi l mj mk">const joe1 = { name: 'Joe' };<br/>const joe2 = { name: 'Joe' };</span><span id="7996" class="kb kc hu mc b fv ml mi l mj mk">console.log(joe1 === joe2);<br/>// false</span></pre><p id="f828" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相反，下面的计算结果为true，因为一个对象被设置为等于另一个对象，因此指向同一个引用(内存中只有一个对象)。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="1739" class="kb kc hu mc b fv mh mi l mj mk">const joe1 = { name: 'Joe' };<br/>const joe2 = joe1;</span><span id="777b" class="kb kc hu mc b fv ml mi l mj mk">console.log(joe1 === joe2);<br/>// true</span></pre><p id="043d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请务必回顾上面的值与引用部分，以充分理解将一个变量设置为另一个指向内存中对象引用的变量的后果！</p><h1 id="13fb" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">10.回调函数</h1><p id="10dc" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">太多人被JavaScript回调函数吓倒了！它们很简单，举个例子。<code class="eh lz ma mb mc b">console.log</code>函数被作为回调传递给<code class="eh lz ma mb mc b">myFunc</code>。当<code class="eh lz ma mb mc b">setTimeout</code>完成时，它被执行。这就是全部了！</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="83a4" class="kb kc hu mc b fv mh mi l mj mk">function myFunc(text, callback) {<br/>  setTimeout(function() {<br/>    callback(text);<br/>  }, 2000);<br/>}</span><span id="d7d0" class="kb kc hu mc b fv ml mi l mj mk">myFunc('Hello world!', console.log);<br/>// 'Hello world!'</span></pre><h1 id="3929" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">11.承诺</h1><p id="5d1c" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">一旦你理解了JavaScript回调，你很快就会发现自己陷入了嵌套的“回调地狱”这就是承诺帮助的地方！将异步逻辑包装在承诺中，成功时使用<code class="eh lz ma mb mc b">resolve</code>，失败时使用<code class="eh lz ma mb mc b">reject</code>。用“然后”处理成功，用<code class="eh lz ma mb mc b">catch</code>处理失败。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="5430" class="kb kc hu mc b fv mh mi l mj mk">const myPromise = new Promise(function(res, rej) {<br/>  setTimeout(function(){<br/>    if (Math.random() &lt; 0.9) {<br/>      return res('Hooray!');<br/>    }<br/>    return rej('Oh no!');<br/>  }, 1000);<br/>});</span><span id="e386" class="kb kc hu mc b fv ml mi l mj mk">myPromise<br/>  .then(function(data) {<br/>    console.log('Success: ' + data);<br/>   })<br/>   .catch(function(err) {<br/>    console.log('Error: ' + err);<br/>   });<br/>   <br/>// If Math.random() returns less than 0.9 the following is logged:<br/>// "Success: Hooray!"<br/>// If Math.random() returns 0.9 or greater the following is logged:<br/>// "Error: On no!"</span></pre><h1 id="3949" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">12.异步等待</h1><p id="1f35" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">一旦你掌握了JavaScript承诺的诀窍，你可能会喜欢上<code class="eh lz ma mb mc b">async await</code>，它只是承诺之上的“语法糖”。在下面的例子中，我们创建了一个<code class="eh lz ma mb mc b">async</code>函数，在这个函数中我们<code class="eh lz ma mb mc b">await</code>了<code class="eh lz ma mb mc b">greeter</code>承诺。</p><pre class="kw kx ky kz fq md mc me mf aw mg dt"><span id="745f" class="kb kc hu mc b fv mh mi l mj mk">const greeter = new Promise((res, rej) =&gt; {<br/>  setTimeout(() =&gt; res('Hello world!'), 2000);<br/>})</span><span id="2fc5" class="kb kc hu mc b fv ml mi l mj mk">async function myFunc() {<br/>  const greeting = await greeter;<br/>  console.log(greeting);<br/>}</span><span id="1ecd" class="kb kc hu mc b fv ml mi l mj mk">myFunc();<br/>// 'Hello world!'</span></pre><h1 id="b7ed" class="lc kc hu bd kd ld le lf kh lg lh li kl lj lk ll ko lm ln lo kr lp lq lr ku ls dt translated">结论</h1><p id="5d35" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">如果您不知道这12个概念中的任何一个，那么您很可能在JavaScript知识方面已经有了一点进步！如果你都知道，那么希望这是一个练习和增长知识的机会。你认为还有哪些概念很关键？请在评论中告诉我。</p></div></div>    
</body>
</html>