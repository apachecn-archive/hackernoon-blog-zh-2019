<html>
<head>
<title>Has the Python GIL been slain?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">蟒蛇GIL被杀了吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/has-the-python-gil-been-slain-9440d28fa93d?source=collection_archive---------0-----------------------#2019-05-15">https://medium.com/hackernoon/has-the-python-gil-been-slain-9440d28fa93d?source=collection_archive---------0-----------------------#2019-05-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/1a66469949918e5d975277025df1badf.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*Q4I1Iczn-0LcZhIl"/></div></figure><p id="419a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">2003年初，英特尔推出了全新的奔腾4“HT”处理器。这款处理器的主频为3 GHz，拥有“超线程”技术。</p><p id="8694" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在接下来的几年里，英特尔和AMD通过提高总线速度、L2高速缓存大小和减小芯片尺寸以最大限度地减少延迟，努力实现最佳的台式计算机性能。3Ghz HT在2004年被“Prescott”型号580取代，其时钟频率高达4 GHz。</p><figure class="jw jx jy jz fq iv"><div class="bz el l di"><div class="ka kb l"/></div></figure><p id="23f3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">看起来提高性能的途径是更高的时钟速度，但CPU受到高功耗和地球变暖热量输出的困扰。</p><p id="8dad" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你的台式机有4Ghz的CPU吗？不太可能，因为性能的发展方向是更高的总线速度和多核。英特尔酷睿2在2006年取代了奔腾4，其时钟速度要低得多。</p><p id="2f26" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">抛开消费级多核CPU的发布不谈，2006年还发生了一件事，Python 2.5发布了！Python 2.5捆绑了一个测试版的<code class="eh kc kd ke kf b">with</code>语句，您知道并且喜欢它。</p><p id="4382" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Python 2.5在利用英特尔的Core 2或AMD的Athlon X2时有一个主要限制。</p><blockquote class="kg"><p id="759d" class="kh ki hu bd kj kk kl km kn ko kp jv ek translated">GIL。</p></blockquote><h1 id="3d5a" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">什么是GIL？</h1><p id="ad38" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">GIL或全局解释器锁是Python解释器中的一个布尔值，受互斥体保护。CPython中的核心字节码评估循环使用锁来设置哪个线程当前正在执行语句。</p><p id="8680" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">CPython支持单个解释器中的多线程，但是线程必须请求访问GIL才能执行操作码(低级操作)。反过来，这意味着Python开发人员可以利用异步代码、多线程代码，而不必担心获取任何变量的锁或进程因死锁而崩溃。</p><p id="ae5a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">GIL使Python中的多线程编程变得简单。</p><figure class="jw jx jy jz fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/de1567f370ec1f2c554726b8576bd793.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*IwiGd5KgPdcm8Ui1"/></div></figure><p id="623e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">GIL还意味着，虽然CPython可以是多线程的，但在任何给定的时间只能执行一个线程。这意味着你的四核CPU正在这样做—(希望没有蓝屏)</p><p id="e98d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">GIL <a class="ae lu" href="https://github.com/python/cpython/commit/074e5ed974be65fbcfe75a4c0529dbc53f13446f" rel="noopener ugc nofollow" target="_blank">的当前版本是在2009年</a>编写的，支持异步功能，即使在多次尝试删除它或降低对它的要求后，它仍然相对完好。</p><p id="edd5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对任何移除GIL的提议的要求是，它不应该降低任何单线程代码的性能。任何在2003年启用超线程技术的人都会理解为什么<a class="ae lu" href="https://arstechnica.com/features/2002/10/hyperthreading/" rel="noopener ugc nofollow" target="_blank">它如此重要</a>。</p><h1 id="eaa4" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lv ld le lf lw lh li lj lx ll lm ln dt translated">避开CPython中的GIL</h1><p id="2681" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">如果你想在CPython中实现真正的并发代码，你必须使用多个进程。</p><p id="1dc1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在CPython 2.6中，<a class="ae lu" href="https://docs.python.org/2/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">多处理模块</a>被添加到标准库中。多重处理是CPython进程(每个进程都有自己的GIL)的包装器</p><pre class="jw jx jy jz fq ly kf lz ma aw mb dt"><span id="5347" class="mc kr hu kf b fv md me l mf mg"><strong class="kf hv">from</strong> <strong class="kf hv">multiprocessing</strong> <strong class="kf hv">import</strong> Process<br/><br/><strong class="kf hv">def</strong> f(name):<br/>    print 'hello', name<br/><br/><strong class="kf hv">if</strong> __name__ == '__main__':<br/>    p = Process(target=f, args=('bob',))<br/>    p.start()<br/>    p.join()</span></pre><p id="51bc" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">可以生成进程，通过编译的Python模块或函数发送命令，然后重新加入主进程。</p><p id="172c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">多重处理也支持通过队列或管道共享变量。它还有一个Lock对象，用于锁定主进程中的对象，以便从其他进程写入。</p><p id="025f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">多重处理有一个主要缺陷。它在时间和内存使用方面都有很大的开销。即使没有站点，CPython的启动时间也是100-200毫秒(参见<a class="ae lu" href="https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/哪个是最快的python-2ae7c61a6b2b版本</a>)。</p><p id="aa9c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">所以你可以在CPython中使用并发代码，但是你必须仔细规划它在<strong class="ja hv">长期运行的进程</strong>中的应用，这些进程之间很少共享对象。</p><p id="4e9b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一种选择是像Twisted这样的第三方包。</p><h1 id="b24a" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lv ld le lf lw lh li lj lx ll lm ln dt translated">PEP554和GIL之死？</h1><p id="6137" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">总而言之，CPython中的多线程很简单，但它不是真正的并发，而多处理是并发的，但有很大的开销。</p><blockquote class="kg"><p id="da58" class="kh ki hu bd kj kk kl km kn ko kp jv ek translated">如果有更好的方法呢？</p></blockquote><p id="28a3" class="pw-post-body-paragraph iy iz hu ja b jb mh jd je jf mi jh ji jj mj jl jm jn mk jp jq jr ml jt ju jv hn dt translated">绕过GIL的线索就在名字中，全局<strong class="ja hv">解释器</strong>锁是全局解释器状态的一部分。CPython进程可以有多个解释器，因此可以有多个锁，<em class="mm">然而</em>，这个特性很少被使用，因为它只通过C-API公开。</p><p id="8ba5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为CPython 3.8提议的特性之一是PEP554，它实现了子解释器和一个API，在标准库中有一个新的<code class="eh kc kd ke kf b">interpreters</code>模块。</p><p id="2499" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这使得在单个流程中从Python创建多个解释器成为可能。Python 3.8的另一个变化是解释器都有自己的Gil</p><figure class="jw jx jy jz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mn"><img src="../Images/e8da8260d7b9b945e12dbfbcdcc47ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-reIKC7OGp0Kxh5Y2jWPNQ.png"/></div></div></figure><p id="0c46" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因为解释器状态包含内存分配竞技场，所有指向Python对象(局部和全局)的指针的集合，PEP 554中的子解释器不能访问其他解释器的全局变量。</p><p id="bd3b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">类似于多重处理，在解释器之间共享对象的方法是将它们序列化，并使用某种形式的IPC(网络、磁盘或共享内存)。Python中有很多序列化对象的方法，有<code class="eh kc kd ke kf b">marshal</code>模块、<code class="eh kc kd ke kf b">pickle</code>模块和更标准化的方法，如<code class="eh kc kd ke kf b">json</code>和<code class="eh kc kd ke kf b">simplexml</code>。这些都有利弊，<strong class="ja hv">所有这些都有开销。</strong></p><p id="b628" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">第一个奖励是拥有一个共享的内存空间，它是可变的，并由拥有它的进程控制。这样，对象可以从主解释器发送，并由其他解释器接收。这将是一个由PyObject指针组成的查找管理内存空间，每个解释器都可以访问该空间，由主进程控制锁。</p><figure class="jw jx jy jz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="fe ff mn"><img src="../Images/43e4e04ebeb5f5f9ceb842458ba331e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuSl_WZkxRCQZUzAoSF2jg.png"/></div></div></figure><p id="f078" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这方面的API仍在开发中，但它可能看起来像这样:</p><figure class="jw jx jy jz fq iv"><div class="bz el l di"><div class="ms kb l"/></div></figure><p id="1be5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个例子使用了numpy，通过用<code class="eh kc kd ke kf b">marshal</code>模块序列化来发送一个numpy数组，然后子解释器处理数据(在一个单独的GIL上),所以这可能是一个CPU限制的并发问题，非常适合子解释器。</p><h2 id="3313" class="mc kr hu bd ks mt mu mv kw mw mx my la jj mz na le jn nb nc li jr nd ne lm nf dt translated">这看起来效率很低</h2><p id="93ed" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated"><code class="eh kc kd ke kf b">marshal</code>模块<em class="mm">相当快，</em>但是没有直接从内存中共享对象快。</p><p id="017e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae lu" href="https://www.python.org/dev/peps/pep-0574/" rel="noopener ugc nofollow" target="_blank"> PEP 574提出了一种新的pickle </a>协议(v5 ),该协议支持将内存缓冲区与pickle流的其余部分分开处理。对于大型数据对象，一次性序列化它们并从子解释器中反序列化会增加很多开销。</p><p id="3b39" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">新的API可以像这样接口(<em class="mm">假设</em>，两者都没有合并)</p><figure class="jw jx jy jz fq iv"><div class="bz el l di"><div class="ms kb l"/></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Pickle v5 and Sub-Interpreters PoC</figcaption></figure><h2 id="a755" class="mc kr hu bd ks mt mu mv kw mw mx my la jj mz na le jn nb nc li jr nd ne lm nf dt translated">这看起来像是一大堆样板文件</h2><p id="bbf2" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">好的，这个例子使用了低级的子解释器API。如果你用过多重处理库，你会发现一些问题。这不像<code class="eh kc kd ke kf b">threading</code>那么简单，你不能只是说在单独的解释器中用这个输入列表运行这个函数。</p><p id="c8fb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一旦这个PEP被合并，我希望我们会看到PyPi中的其他API采用它们。</p><h1 id="28fb" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lv ld le lf lw lh li lj lx ll lm ln dt translated">一个副解释器有多少开销？</h1><p id="d51c" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated"><strong class="ja hv">简答</strong>:多一个线程，少一个进程。</p><p id="5832" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">长回答</strong>:解释器有自己的状态，所以虽然PEP554可以很容易地创建子解释器，但它需要克隆和初始化以下内容:</p><ul class=""><li id="0738" class="nk nl hu ja b jb jc jf jg jj nm jn nn jr no jv np nq nr ns dt translated">__main__命名空间和importlib中的模块</li><li id="e796" class="nk nl hu ja b jb nt jf nu jj nv jn nw jr nx jv np nq nr ns dt translated">包含以下内容的sys字典</li><li id="517e" class="nk nl hu ja b jb nt jf nu jj nv jn nw jr nx jv np nq nr ns dt translated">内置功能(<code class="eh kc kd ke kf b">print()</code>、<code class="eh kc kd ke kf b">assert</code>等)</li><li id="1b24" class="nk nl hu ja b jb nt jf nu jj nv jn nw jr nx jv np nq nr ns dt translated">线</li><li id="8ee0" class="nk nl hu ja b jb nt jf nu jj nv jn nw jr nx jv np nq nr ns dt translated">核心配置</li></ul><p id="e149" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">核心配置可以很容易地从内存中克隆出来，但是导入的模块就没那么简单了。用Python导入模块很慢，所以如果创建一个子解释器意味着每次都要将模块导入另一个名称空间，那么好处就会减少。</p><h1 id="5c1e" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lv ld le lf lw lh li lj lx ll lm ln dt translated">阿辛西奥呢？</h1><p id="89e6" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">标准库中的<code class="eh kc kd ke kf b">asyncio</code>事件循环的现有实现创建了待评估的帧，但在主解释器中共享状态(因此共享GIL)。</p><p id="542b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在PEP554被合并之后，很可能在Python 3.9中，一个替代的事件循环实现<em class="mm">可以被实现(尽管还没有人这样做)，它在子解释器中运行异步方法，因此是并发的。</em></p><h1 id="b780" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lv ld le lf lw lh li lj lx ll lm ln dt translated">听起来不错，发货吧！</h1><p id="a409" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">不完全是。</p><p id="cdc9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">因为CPython已经用单个解释器实现了很长时间，代码库的许多部分使用“运行时状态”而不是“解释器状态”，所以如果PEP554以其当前形式合并，仍然会有许多问题。</p><p id="edc5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如，垃圾收集器(在3.7 </p><p id="5f7a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">During the PyCon sprints <a class="ae lu" href="https://github.com/python/cpython/pull/13219" rel="noopener ugc nofollow" target="_blank">中的变化已经开始</a>将垃圾收集器状态转移到解释器，这样每个子解释器将拥有自己的GC(正如它应该的)。</p><p id="8112" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一个问题是，在CPython代码库和许多C扩展中存在一些“全局”变量。因此，当人们突然开始编写适当的并发代码时，我们可能会开始看到一些问题。</p><p id="fcc8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另一个问题是，文件句柄属于进程，所以如果您在一个解释器中打开一个文件进行写入，子解释器将无法访问该文件(无需对CPython做进一步的更改)。</p><p id="d8b6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">简而言之，还有许多其他事情有待解决。</p><h1 id="912f" class="kq kr hu bd ks kt ku kv kw kx ky kz la lb lv ld le lf lw lh li lj lx ll lm ln dt translated">结论:GIL死了吗？</h1><p id="44ee" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">对于单线程应用程序，GIL仍然存在。所以即使PEP554合并了，如果你有单线程代码，也不会突然并发。</p><p id="e58b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您想要Python 3.8中的并发代码，您有CPU限制的并发问题，那么这可能是您的最佳选择！</p><h2 id="85b7" class="mc kr hu bd ks mt mu mv kw mw mx my la jj mz na le jn nb nc li jr nd ne lm nf dt translated">什么时候？</h2><p id="3eb2" class="pw-post-body-paragraph iy iz hu ja b jb lo jd je jf lp jh ji jj lq jl jm jn lr jp jq jr ls jt ju jv hn dt translated">Pickle v5和用于多处理的共享内存很可能是Python 3.8(2019年10月)，子解释器将在3.8到3.9之间。</p><p id="5785" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你现在想玩我的例子，我已经用所有需要的代码建立了一个自定义分支【https://github.com/tonybaloney/cpython/tree/subinterpreters<a class="ae lu" href="https://github.com/tonybaloney/cpython/tree/subinterpreters" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>