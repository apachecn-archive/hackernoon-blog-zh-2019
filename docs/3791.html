<html>
<head>
<title>Magic Trick Revealed: Breaking the Nil-Coalescing Operator in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">魔术揭秘:打破Swift中的零合并运算符</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/magic-trick-revealed-breaking-the-nil-coalescing-operator-in-swift-7f319e40e0bd?source=collection_archive---------0-----------------------#2019-06-23">https://medium.com/hackernoon/magic-trick-revealed-breaking-the-nil-coalescing-operator-in-swift-7f319e40e0bd?source=collection_archive---------0-----------------------#2019-06-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f14261443e6e05f234057c0741a368dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMxI-q0DAMtcF-VGs10G0Q.jpeg"/></div></div></figure><h1 id="828f" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">什么是可选的？</h1><p id="a7b5" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这几乎是每位swift开发人员在开始工作时阅读的第一件事。让我们用一种更有趣更简短的方式来理解optional，比如说你去购物，口袋里放着一个钱包。钱包里可以有点钱，也可以没有。如果你认为钱包是一个<strong class="kc hv"> <em class="ky">可选的</em> </strong>变量，那么要么它有一些价值，要么根本没有价值。</p><p id="b0e8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在商店买东西之前，你会检查钱包里是否有钱。如果有钱，你会购买，否则你会跳过。这与<strong class="kc hv"> <em class="ky">可选绑定</em> </strong>是同一个概念。但是如果你在买东西之前没有检查，那么如果钱包里没有现金，你可能会有麻烦。这个概念在Swift中被称为<strong class="kc hv"><em class="ky"/></strong>。</p><p id="a392" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">因此，如果可选值为零，强制展开可能会导致不必要的崩溃。为了安全起见，您可以使用可选绑定。但是Swift也提供了一个更安全的选项，叫做<strong class="kc hv"><em class="ky">nil-coalescing operator</em></strong>，它要求在应用于nil时返回一个额外的默认值。</p><h1 id="955c" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">打破僵局:</h1><p id="eef2" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><strong class="kc hv"> <em class="ky">零合并运算符(？？)</em> </strong>检查可选变量是否为零<strong class="kc hv"> <em class="ky"> (a？？b) </em> </strong>。如果为空，则返回默认值，否则返回可选的未包装值。让我们看看它在swift中是如何定义的</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="83f8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们可以使用如下的操作符-</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="3709" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">但是<strong class="kc hv"> <em class="ky">有个小问题？？</em> </strong>定义。每当我们使用nil-coalescing操作符时，无论可选操作符是否有值，我们都必须计算默认值。默认值的计算可能是一个复杂的操作，也可能是一个从磁盘存储器中大量读取的操作。因此，我们希望在不需要的时候避免计算，因为它有时是开销。所以为了避免read操作，我们可以重写<strong class="kc hv"> <em class="ky">？？</em> </strong>功能定义如下图-</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="804c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">因此，我们现在提供一个闭包类型<strong class="kc hv"> <em class="ky"> () - &gt; U </em> </strong>，而不是直接提供类型<strong class="kc hv"><em class="ky"/></strong>的默认值。所以现在<strong class="kc hv"> <em class="ky"> defaultValue </em> </strong>是一个<strong class="kc hv"> <em class="ky"> () - &gt; U </em> </strong>类型的函数。<strong class="kc hv"> <em class="ky"> defaultValue </em> </strong>函数内的代码只能从else块中执行。上面的实现也有一个缺点，因为<strong class="kc hv"> <em class="ky"> defaultValue </em> </strong>是一个匿名函数，所以我们必须在花括号<strong class="kc hv"> <em class="ky"> ({ }) </em> </strong>内编写计算默认值的代码。</p><p id="2eba" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我们可以通过使用<strong class="kc hv"><em class="ky">auto close</em></strong>类型属性从<strong class="kc hv"> <em class="ky"> defaultValue </em> </strong>闭包中去掉那些显式的花括号。该属性隐式地将任何参数转换为<strong class="kc hv"> <em class="ky">？？</em>中的</strong>操作符要求闭合。因此，我们可以提供与最初相同的接口，但不需要用户创建包装defaultValue参数的显式闭包。因此，Swift标准库中使用的定义如下</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="59c7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在看看上面使用的例子，我们已经从<strong class="kc hv"> <em class="ky"> defaultValue </em> </strong>函数中去掉了花括号，它的工作原理和我们每天为一个<strong class="kc hv"> <em class="ky">零合并</em> </strong>操作符编写的一样。</p><h1 id="0386" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">新的可选绑定:</h1><p id="a010" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">因此，如果我们有一个可选的，我们可以通过使用可选绑定，保护块或强制解包来解包值。但是我们可以再补充一点。假设我们有一个如下定义的函数</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="9c3f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在上面，如果<strong class="kc hv"> <em class="ky">可选</em> </strong>没有值，那么我们简单地返回nil，否则做一些计算。我们可以在optional上创建一个扩展来进行安全计算。</p><figure class="le lf lg lh fq iv"><div class="bz el l di"><div class="li lj l"/></div></figure><p id="3362" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv"> <em class="ky">稳妥地</em> </strong>函数取一个<strong class="kc hv"> <em class="ky">变换</em> </strong>的类型<strong class="kc hv"><em class="ky">(Wrapped)-&gt;U</em></strong>。如果<strong class="kc hv"> <em class="ky">可选</em> </strong>不为零，则应用<strong class="kc hv"> <em class="ky">变换</em> </strong>，否则<strong class="kc hv"> <em class="ky">安全</em> </strong>函数返回零。</p><p id="e452" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">利用这个扩展，我们可以更紧凑、更通用地重新编写<strong class="kc hv"> <em class="ky"> add </em> </strong>函数。</p><p id="93fb" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">因此，我们可以安全地将函数应用于任何可选的Struct或Class类型。</p><p id="2b2f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">🙏🙏🙏感谢您的阅读！！🙏🙏🙏</p></div></div>    
</body>
</html>