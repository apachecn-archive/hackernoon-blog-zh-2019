<html>
<head>
<title>Trace Your Requests Like A Boss with OpenTracing &amp; Jaeger</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenTracing &amp; Jaeger像老板一样跟踪您的请求</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/trace-your-requests-like-a-boss-with-opentracing-jaeger-cc8a07a0edc0?source=collection_archive---------0-----------------------#2019-01-27">https://medium.com/hackernoon/trace-your-requests-like-a-boss-with-opentracing-jaeger-cc8a07a0edc0?source=collection_archive---------0-----------------------#2019-01-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/66d0d50b4541d0cbd1be521ff7cc4afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o59-2_98TPsQQllPT2uzEw.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">credits: jaegertracing.io</figcaption></figure><div class=""/><p id="8ad4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">假设您的服务每秒钟收到数千个请求，您进行大量日志记录，并且不会错过日志记录系统中的任何异常。突然，运营团队向您发送了一条消息，指出id为<code class="eh ke kf kg kh b">X</code>的客户在生产过程中出现了一个错误，而您无法理解为什么您周围的所有人都过度紧张……然后事情就发生了变化。客户<code class="eh ke kf kg kh b">X</code>其实是老板的朋友！(<em class="ki">真实故事)</em></p><p id="ad4b" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">好吧…让我们看看你能做什么:</p><p id="da91" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你在你的日志系统上搜索了<code class="eh ke kf kg kh b">X</code>,然后一直等待，因为有数TB的日志。然后你用一个更详细的查询比如<code class="eh ke kf kg kh b">userId=X not in this and that but in this at time t</code>再试了一次，得到的结果……哦，又是一个问题！<code class="eh ke kf kg kh b">Error: wrong query syntax.</code>你的队友说你需要把<code class="eh ke kf kg kh b">not in this</code>换成<code class="eh ke kf kg kh b">in not this.</code>，你也修好了，等了大约10秒，屏幕上出现了24个结果！现在您已经准备好分析它们了。</p><p id="9990" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">… 10分钟后…</p><p id="ca84" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你发现<code class="eh ke kf kg kh b">ServiceA</code>调用了服务<code class="eh ke kf kg kh b">ServiceB</code>，而<code class="eh ke kf kg kh b">ServiceB</code>中的方法<code class="eh ke kf kg kh b">LongRunningProcess</code>用了3秒，服务<code class="eh ke kf kg kh b">A</code>返回500。</p><p id="2244" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">毕竟，你很高兴在大约20分钟内找到bug。</p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><p id="7ff2" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们假设你使用<em class="ki">开放式追踪</em>和<em class="ki">耶格</em>来回放这个过程。</p><ul class=""><li id="6480" class="kq kr ij ji b jj jk jn jo jr ks jv kt jz ku kd kv kw kx ky dt translated">您在浏览器上访问了Jaeger UI</li><li id="62e4" class="kq kr ij ji b jj kz jn la jr lb jv lc jz ld kd kv kw kx ky dt translated">您将<code class="eh ke kf kg kh b">userId=X</code>写入标签并设置日期</li><li id="8b36" class="kq kr ij ji b jj kz jn la jr lb jv lc jz ld kd kv kw kx ky dt translated">您点击了搜索，结果如下:</li></ul><figure class="lf lg lh li fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff le"><img src="../Images/a29714db5e32c9b84ce5c9c0d28412f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpxVGNIrjC4SGEGTYXRqwg.png"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Example request that Jaeger traced</figcaption></figure><p id="a54d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">几秒钟后，你会明白<code class="eh ke kf kg kh b">LongRunningProcess</code>实际上用了3秒钟，结果是<code class="eh ke kf kg kh b">ServiceA</code>返回了<code class="eh ke kf kg kh b">500.</code></p></div><div class="ab cl kj kk hc kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="hn ho hp hq hr"><p id="ff6c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">开放追踪是分布式追踪的开放标准，Jaeger是实现该标准的工具。请提前查看官方文档中的Jaeger架构。</p><p id="4161" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">今天，我们将使用为我们的演示环境创建2个API和1个控制台客户端。网芯。我还将使用我自己编写的简单包装器，因为在我看来它带来了简单性。</p><figure class="lf lg lh li fq hw fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/0107c9513ba825faa9d4c8819a8be315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*naE7TPLNJVNEpzWOw5Y0WA.png"/></div></figure><p id="cf1d" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">开始吧！</p><h2 id="ff54" class="ll lm ij bd ln lo lp lq lr ls lt lu lv jr lw lx ly jv lz ma mb jz mc md me mf dt translated">克隆存储库并准备您的环境</h2><p id="7d06" class="pw-post-body-paragraph jg jh ij ji b jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">如果您的工作空间中已经安装了<code class="eh ke kf kg kh b">.net core</code>和<code class="eh ke kf kg kh b">docker</code>，您就可以开始了。</p><p id="9c21" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">获取<code class="eh ke kf kg kh b">Jaeger</code>的docker图像并运行它:</p><pre class="lf lg lh li fq ml kh mm mn aw mo dt"><span id="1fa1" class="ll lm ij kh b fv mp mq l mr ms">docker run -d --name jaeger \<br/>  -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \<br/>  -p 5775:5775/udp \<br/>  -p 6831:6831/udp \<br/>  -p 6832:6832/udp \<br/>  -p 5778:5778 \<br/>  -p 16686:16686 \<br/>  -p 14268:14268 \<br/>  -p 9411:9411 \<br/>  jaegertracing/all-in-one:1.6</span></pre><p id="4ec4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">克隆我为这篇文章准备的回购:<a class="ae lj" href="https://github.com/skynyrd/opentracing-with-jaeger" rel="noopener ugc nofollow" target="_blank">https://github.com/skynyrd/opentracing-with-jaeger</a></p><p id="84cd" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们有一个。net核心解决方案包含4个项目:<code class="eh ke kf kg kh b">ConsoleClient</code>、<code class="eh ke kf kg kh b">ServiceA</code>、<code class="eh ke kf kg kh b">ServiceB</code>和<code class="eh ke kf kg kh b">JaegerWrapper.</code>，我们将逐一介绍。让我们从<code class="eh ke kf kg kh b">JaegerWrapper</code>开始了解耶格客户端的动态。</p><h2 id="e907" class="ll lm ij bd ln lo lp lq lr ls lt lu lv jr lw lx ly jv lz ma mb jz mc md me mf dt translated">JaegerWrapper:为了句法糖——因为为什么不呢？</h2><p id="cac7" class="pw-post-body-paragraph jg jh ij ji b jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">为了使用Jaeger客户端，我们首先需要了解跟踪在我们的代码中是如何工作的。</p><blockquote class="mt mu mv"><p id="9d25" class="jg jh ki ji b jj jk jl jm jn jo jp jq mw js jt ju mx jw jx jy my ka kb kc kd hn dt translated">一个<strong class="ji ik">轨迹</strong>是通过系统的数据/执行路径，并且可以被认为是一个<a class="ae lj" href="https://www.jaegertracing.io/docs/1.8/architecture#span" rel="noopener ugc nofollow" target="_blank">跨度</a>的有向非循环图。</p><p id="b42e" class="jg jh ki ji b jj jk jl jm jn jo jp jq mw js jt ju mx jw jx jy my ka kb kc kd hn dt translated">一个<strong class="ji ik"> span </strong>表示Jaeger中的一个逻辑工作单元，它有一个操作名、操作的开始时间和持续时间。跨度可以被嵌套和排序以模拟因果关系。</p><p id="85d5" class="jg jh ki ji b jj jk jl jm jn jo jp jq mw js jt ju mx jw jx jy my ka kb kc kd hn dt translated">Jaeger官方文件。</p></blockquote><p id="d88f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在应用程序中，我们需要一个跟踪器来管理我们的跨度。为了简单起见，我强烈建议在微服务中使用一个跟踪器。创建<code class="eh ke kf kg kh b">Tracer</code>并注册后，jaeger客户端库默认开始分析系统中的控制器，甚至我们不需要为此创建一个单独的<code class="eh ke kf kg kh b">Trace</code>和<code class="eh ke kf kg kh b">Span</code>，都是由<code class="eh ke kf kg kh b">OpenTracing.Contrib.NetCore</code>库创建的。然而，如果我们想要分析一个特定的方法，或者添加一些额外的标签/日志到我们的范围，我们需要创建一个<code class="eh ke kf kg kh b">Trace</code>并绑定一个<code class="eh ke kf kg kh b">Span</code>到它。</p><p id="f11e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="ki">重要提示:如果您在系统中有另一个活动span时创建并激活了一个span，它将成为子span。你可以在上图中看到。父跨度可扩展。</em></p><p id="a341" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我为此写了一个简单的构建器，<code class="eh ke kf kg kh b">JaegerWrapper</code>是一个包含它的类库，如果你喜欢，你可以使用/复制。</p><pre class="lf lg lh li fq ml kh mm mn aw mo dt"><span id="e32a" class="ll lm ij kh b fv mp mq l mr ms">_traceBuilder<br/>  .WithSpanName("LongRunningProcess")<br/>  .WithTag(new StringTag("exampleTag"), "exampleValue")<br/>  .TraceIt(() =&gt;<br/>  {<br/>    Thread.Sleep(3000);<br/>  });</span></pre><p id="75ec" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">举个例子，这个代码块用于上图中黄色横条表示的<code class="eh ke kf kg kh b">LongRunningProcess</code>跨度。我们给它添加了<code class="eh ke kf kg kh b">exampleTag: exampleValue</code>，我们甚至可以使用<code class="eh ke kf kg kh b">WithLog</code>方法添加更复杂的结构。<code class="eh ke kf kg kh b">TraceIt</code>消耗的时间在GUI中以跨度持续时间的形式发布。在这个例子中，我使用了一个简单的<code class="eh ke kf kg kh b">Thread.Sleep(3000)</code>，但是你也可以返回一些东西(<code class="eh ke kf kg kh b">Func</code>而不是<code class="eh ke kf kg kh b">Action</code>)，例如:</p><pre class="lf lg lh li fq ml kh mm mn aw mo dt"><span id="9f80" class="ll lm ij kh b fv mp mq l mr ms">var result = _traceBuilder<br/>              ...<br/>              .TraceIt(() =&gt; <br/>              {<br/>                 return "something"<br/>              }</span></pre><h2 id="bb58" class="ll lm ij bd ln lo lp lq lr ls lt lu lv jr lw lx ly jv lz ma mb jz mc md me mf dt translated">通过API传递</h2><p id="05a0" class="pw-post-body-paragraph jg jh ij ji b jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">如果你打算HTTP调用一个服务，并且你想保留你的span生命期，你需要以某种方式通知其他服务。</p><p id="f7a6" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在大多数情况下，您希望使用<code class="eh ke kf kg kh b">OpenTracing.Contrib.NetCore</code>包来自动化配置，但是如果您很好奇，下面是其背后的逻辑:</p><p id="6ea5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Jaeger用HTTP头来解决这个问题，HTTP头将附加到请求中。您还可以使用<code class="eh ke kf kg kh b">JaegerWrapper</code>进行更多的抽象:</p><figure class="lf lg lh li fq hw"><div class="bz el l di"><div class="mz na l"/></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Still using the OpenTracing.Contrib.NetCore is the clearest option for the APIs.</figcaption></figure><h2 id="8e3a" class="ll lm ij bd ln lo lp lq lr ls lt lu lv jr lw lx ly jv lz ma mb jz mc md me mf dt translated">WebAPIs的配置</h2><p id="f70c" class="pw-post-body-paragraph jg jh ij ji b jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">对于<code class="eh ke kf kg kh b">ServiceA</code>和<code class="eh ke kf kg kh b">ServiceB</code>，我们需要为Jaeger注册服务:</p><pre class="lf lg lh li fq ml kh mm mn aw mo dt"><span id="db9b" class="ll lm ij kh b fv mp mq l mr ms">// In ConfigureServices method of Startup class:</span><span id="7fe2" class="ll lm ij kh b fv nb mq l mr ms">GlobalTracer.Register(Tracer);<br/>services.AddOpenTracing();</span></pre><p id="622a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您还想使用包装器，您可以简单地添加这些:</p><pre class="lf lg lh li fq ml kh mm mn aw mo dt"><span id="2891" class="ll lm ij kh b fv mp mq l mr ms"><strong class="kh ik">var </strong>serviceProvider = services.BuildServiceProvider();</span><span id="cda7" class="ll lm ij kh b fv nb mq l mr ms">services.AddScoped&lt;ITraceBuilder&gt;(t =&gt; <br/>    <strong class="kh ik">new </strong>TraceBuilder(serviceProvider.GetService&lt;ITracer&gt;()));</span></pre><h2 id="91fb" class="ll lm ij bd ln lo lp lq lr ls lt lu lv jr lw lx ly jv lz ma mb jz mc md me mf dt translated">示例呼叫</h2><p id="2518" class="pw-post-body-paragraph jg jh ij ji b jj mg jl jm jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd hn dt translated">看看<code class="eh ke kf kg kh b">ServiceA</code>的<code class="eh ke kf kg kh b">AWorldController</code>，我们在那里调用<code class="eh ke kf kg kh b">ServiceB</code>但是没有使用任何JaegerClient或者JaegerWrapper方法。这是因为我们添加了<code class="eh ke kf kg kh b">OpenTracing.Contrib.NetCore</code>库，它神奇地在黑盒中跟踪我们的请求。</p><pre class="lf lg lh li fq ml kh mm mn aw mo dt"><span id="6363" class="ll lm ij kh b fv mp mq l mr ms"><strong class="kh ik">private static async </strong>Task&lt;<strong class="kh ik">dynamic</strong>&gt; GetBObject(<strong class="kh ik">string </strong>id)<br/><strong class="kh ik">{<br/>    var </strong>httpClient = <strong class="kh ik">new </strong>HttpClient<br/>    {<br/>        BaseAddress = <strong class="kh ik">new </strong>Uri("http://localhost:7334")<br/>    };<br/><br/>    <strong class="kh ik">var </strong>result = <strong class="kh ik">await </strong>httpClient.GetAsync($"/bworld/id/{id}");<br/><br/>    <strong class="kh ik">if </strong>(result.IsSuccessStatusCode)<br/>    {<br/>        <strong class="kh ik">return await </strong>result.Content.ReadAsAsync&lt;<strong class="kh ik">dynamic</strong>&gt;();<br/>    }<br/>    <br/>    <strong class="kh ik">throw new </strong>Exception("uncovered area.");<br/><strong class="kh ik">}</strong></span></pre><p id="6860" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">并检查ConsoleClient的主要方法。这一次，由于这不是一个WebAPI，我们使用JaegerWrapper手动跟踪我们的调用。</p><pre class="lf lg lh li fq ml kh mm mn aw mo dt"><span id="1cb0" class="ll lm ij kh b fv mp mq l mr ms">traceBuilder.WithSpanName("MainWork")<br/>    .WithHttpCall(client, url, HttpMethod.Get)<br/>    .TraceIt(() =&gt;<br/>    {<br/>        <strong class="kh ik">var </strong>response = client.GetAsync(url).Result;<br/><br/>        <strong class="kh ik">if </strong>(!response.IsSuccessStatusCode)<br/>            <strong class="kh ik">throw new </strong>Exception("uncovered area for the demo.");<br/><br/>        <strong class="kh ik">var </strong>responseBody = response.Content.ReadAsStringAsync().Result;<br/>        Console.WriteLine(responseBody);<br/>    });</span></pre><p id="592e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">几年前我在制作中使用了<code class="eh ke kf kg kh b">Zipkin</code>而不是<code class="eh ke kf kg kh b">Jaeger</code>，因此我不想写任何关于性能的东西。但是我可以说齐普金表现得很好。如果你有Jaeger的制作经验，请在下面评论，我很好奇！</p><p id="f330" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">感谢阅读。</p></div></div>    
</body>
</html>