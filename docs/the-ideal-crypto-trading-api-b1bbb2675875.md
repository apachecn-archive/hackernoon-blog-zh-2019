# 理想的加密交易 API

> 原文：<https://medium.com/hackernoon/the-ideal-crypto-trading-api-b1bbb2675875>

在过去的几年里，我们已经整合了几十家交易所(最近统计有 35 家)。一路走来，我们看到、经历和遭受了许多与加密交换 API 相关的不同事情。本着与更广泛的加密社区合作的精神，并带着使我们未来的集成更容易的(有点自私的)希望，我们认为我们应该分享一些关于理想的交易 API 应该是什么样子的想法。

之所以提出这个建议，是因为存在各种各样的 API 实现，而大多数 API 都在重复同样的错误。使它们在机构环境中的使用复杂化的错误。我们建议对现有的 API 模型进行一些简单的修改，以构建我们认为的用于加密交易的健壮的机构级 API。

![](img/9f3643bd9305631c74492db58ef298f8.png)

**原料药的味道**

在整个加密交易领域，有多种类型的 API 可用于自动交易。从技术角度来看，API 分为以下几类:

1.REST:所有市场数据和交易都在 REST 端点之上

2.Websocket:所有的市场数据和交易都是通过 Websockets 进行的

3.FIX:纯粹的 FIX 实现很少见，但是这些类型的交易 API 在加密领域的势头越来越大。(Deribit 有一个纯 FIX 实现，它也处理帐户更新)

4.组合

*   混合，REST 用于私有端点，Websocket 用于市场数据
*   Hybrid-2.0，REST 用于私有端点，Websocket 用于市场数据和私有数据(订单更新、填充等)。)
*   修复+以上组合

***纯休息***

使用这种风格的 API，通常所有的交互都是基于投票的。不用说，这是非常有限的，主要是由任意的速率限制(这是缩放所必需的。)这种风格的 API 不适合全面的机构级交易系统。对更新(无论是市场数据还是我们自己的执行)进行投票的要求简直令人疲惫不堪。

***纯 Websocket***

有几个纯 websocket apis 的好例子 coins.ph (pro)有一个定义非常好的纯 websocket 交易的 API，HitBTC 也是。Bitfinex 也有一个很好的(理论上的)v2，但是当前的 beta 实现不稳定。对于希望实现一个好的基于 websocket 的 API 的交易所来说，一个好的模型是 coins API。

***杂交***

有许多实施混合交易 API 的交易所的例子。通常只有市场数据或市场数据和一些私有数据可以通过 websocket 获得，而交易(创建订单或取消订单的过程)是通过 REST 端点进行的。Okex、Kucoin、币安等都是这种交易 API 的例子。

***修复***

这些类型的交易 API 正在密码领域获得发展势头。越来越多的新交易所提供这个(现有交易所也开始支持。)这种风格的 API 非常适合机构交易，但是也有一些限制。作为一个标准的主要修正不能解决我们在 crypto 中的所有需求(例如实例化交易以提取硬币)。)其他缺失的元素是账户余额等关键信息——在 FIX 中根本没有与之匹配的对等项。

有人可能会说，这些可以通过最新 FIX 协议标准中的新位置维护消息来实现，但这感觉像是一种黑客攻击。在协议扩展到支持为此所需的额外消息之前，我们会发现这些 API 是交易和市场数据的 FIX 和其他账户相关活动的 REST(或 Websocket)的混合体。正是这种需求实现了许多不同的协议来完成完整的交易功能，这导致我们说 FIX 只在有限的情况下有效(在一些特定的交易所交易，如 LMAX、LXDX 或 Blockfills。)

加密 API 缺少什么？

到目前为止，如果你花些时间分析一下这种情况，那么我们所讨论的就不会感到惊讶。当我们建立自己的交易系统时，第一阶段(也是最消耗我们资源的阶段之一)是连接大量的交易所。由于我们的模型可以跨任意数量的交易所交易，并且我们可以让多个模型跨给定的交易所交易，所以我们需要的关键功能是健壮的订单和执行处理。

健壮的订单处理意味着我们需要随时了解订单的状态，健壮的执行处理意味着我们需要知道所有的执行(并能够将这些执行分配给生成订单的模型。)这最后一步对于我们在模型层面管理风险至关重要。

***客户订单 ID***

我们在大多数 API(甚至是声称是机构级的交易所)中看到的第一个差距是，很少有人支持客户订单 id 的概念。客户订单 id 是我们在订单管理系统中分配给订单的内部 id。这个键允许我们识别生成特定订单的模型，然后这个键成为将该订单上的任何执行分配给该模型的键。

API 失败的地方在于我们不能设置这个客户订单 id。因此，我们调用 REST 来创建订单，响应为我们提供了交换订单 id，但是由于某种原因，如果 HTTP 请求失败(例如有 Cloudflare 这样的服务提供商挡路，可能会有几个故障点),如果订单通过某种方式到达匹配引擎，我们就无法识别我们检测到的在交换中活动的订单。更糟糕的是，有时这些订单然后交易，我们收到执行——我们不能分配(如果我们有多个模型交易，很难区分哪个模型交易！)

对于混合 API，这个问题更加严重，因为通过 websocket 推出的订单更新没有客户端订单 id，只有交换订单 id，因此，我们必须缓冲所有内容，直到 REST 请求返回，以了解我们在 websocket 上收到的内容。我们认为简单地添加一个客户端订单 id(用于创建、更改、取消操作，无论是 Websocket 还是 REST)以及随后在输出中包含该字段(订单更新和执行)极大地提高了 API 的健壮性——因为我们可以处理来自交换的所有消息，并且只处理我们设置的客户端订单 id。我们甚至可以区分特定于 exchange 的 UI 上的手动订单和自动订单，并适当地处理它们。

***每执行一个命令***

一些老一代 API 不提供填充端点，一个轮询订单状态以检测任何订单上的填充，并通过查看订单上的执行数量来计算部分填充(综合)。这实际上并不是很好，后来当我们需要将我们的交易与我们的交易的交换视图进行协调时，这个过程是复杂的，因为单个交易没有列出来，通常是订单级别的汇总。

最新一代的 API 提供了填充端点，但是引入了相当有限的约束，例如必须提供订单 id 才能获得填充(例如 Okex。)这是一个令人衰弱的要求，因为典型的机构级交易系统将跨许多模型生成许多订单，并且必须轮询每个单个订单以进行填充是浪费时间。返回我们的填充的端点可以通过一些标准进行过滤，例如符号和最后的交易 id，使用这些标准，它应该返回我们所有订单的所有部分填充。

***批量操作***

作为一个做市商，我们经常被要求发布一个关于买价和卖价的深度订单。因此，能够发送一批订单(通过 websocket，例如 Bitfinex)或通过 REST(例如 Okex)减少了我们的订单处理负载，可以想象在交易所的网关上。通常，我们希望看到一个批处理创建和批处理取消端点，这样我们可以在一个单一的操作中移动我们的订单，而不必为每个订单操作提出单独的请求。例如，如果我们被要求发布三个出价和三个报价，每次价格移动，我们将发送六个取消和六个创建。如果 API 支持批处理，那么这将是两个请求，如果 API 支持订单替换，那么一个请求包含六个变更。交易所的负荷将会大大减少。

***【取消断开】和*** 一个取消所有点播的选项

对于任何连接的 API (websocket 等。)，这是一个总的来说很有用的功能。启用后，如果我们从会话中断开，任何未结订单都将被取消。这为我们提供了一些保护，以防我们退出市场，并防止我们离开时任何订单被取消。理想情况下，如果有一个我们连接的专用频道，它应该支持此功能。

***那么理想的 API 是什么样子的呢？***

从我们的经验来看(除非是与修复相关的非常特殊的情况),最理想的 API 是混合 API。我们认为这对于交换来说具有最小的实现开销，并且是我们可以处理的最简单的模型。然而，要做到这一点，我们需要以下内容:

1.创建/更新/取消休息

2.用于更新和执行的 Websocket

3.create order 的 REST 端点必须接受一个客户订单 id(最好是批处理的)

4.如果*应该是用于订单修改的 REST 端点，这增加了匹配引擎的复杂性，并且*可以通过具有批处理端点来消除*。*

5.要取消的其余端点应进行批处理

6.所有订单更新和个人填写都应该通过私有的 websocket 渠道发送，并且这些更新应该包含客户订单 id。如果没有客户订单 id，我们所做的任何分配都将完全依赖于交换订单 id(它仅在对创建操作的响应中可用。)因此，这在我们这边引入了一种竞争，可以通过在更新中公开客户订单 id 来消除这种竞争。

7.最后但同样重要的是，良好的文档和测试网络

完整的 websocket 实现也很好，但是要实现一个完整的解决方案可能在技术上更具挑战性，因此，我们不会让这个模型成为最理想的 API 类型。

正如你所看到的，这些不是主要的要求或争议，只是一些简单的准则，如果满足了，应该会为像我们这样的机构交易者带来一个相当健壮的 API。令人惊讶和有争议的是 crypto 中很少 API 有这个。