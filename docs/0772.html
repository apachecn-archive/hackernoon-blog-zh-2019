<html>
<head>
<title>Forward Fax to Email with SendGrid and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SendGrid和Node.js将传真转发到电子邮件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/forward-fax-to-email-with-sendgrid-and-node-js-6cdfa6f403c8?source=collection_archive---------21-----------------------#2019-01-31">https://medium.com/hackernoon/forward-fax-to-email-with-sendgrid-and-node-js-6cdfa6f403c8?source=collection_archive---------21-----------------------#2019-01-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/d78a89fd0001c4c81a771241c22c1b6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*anE5JGrvgK6a9Sv382Yoew.png"/></div></div></figure><p id="5ee8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在是2019年，你需要接收一份传真。你是做什么的？你可以买一台传真机，把它接到电话线上，然后把你的号码发出去。但现在是2019年，而不是1979年，我们生活在未来，所以让我们抓住Node.js，选择几个API，将传真转换为电子邮件。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ka"><img src="../Images/4f932626e401f93580b6a0fc814a0957.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*HZhVX-QHwIiIFkL0"/></div></figure><p id="5d9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你将需要一个<a class="ae kf" href="https://www.twilio.com/try-twilio" rel="noopener ugc nofollow" target="_blank"> Twilio账户</a>、一个<a class="ae kf" href="https://signup.sendgrid.com/" rel="noopener ugc nofollow" target="_blank"> SendGrid账户</a>和<a class="ae kf" href="https://www.youtube.com/watch?v=XC3uDuRXJyA" rel="noopener ugc nofollow" target="_blank">这个noise </a>来提醒你在构建你自己的传真到电子邮件转换器时错过了什么。</p><h1 id="68ff" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">接收传真</h1><p id="69f3" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我们将使用Twilio号码接收传入的传真，而不是笨重的机器。你将需要一个支持传真的Twilio号码来构建这个应用程序，因此请登录你的<a class="ae kf" href="http://twilio.com/console" rel="noopener ugc nofollow" target="_blank"> Twilio帐户</a>。您可以<a class="ae kf" href="https://www.twilio.com/console/phone-numbers/search" rel="noopener ugc nofollow" target="_blank">购买一个新号码</a>或者您<a class="ae kf" href="https://www.twilio.com/console/phone-numbers/incoming" rel="noopener ugc nofollow" target="_blank">可能已经有一个</a>，只需寻找此图标，表明它可以接收传真:</p><p id="1cef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你有一个数字准备好了，我们将需要设置接收一些网络挂钩。你可能认为传真的工作原理和信息传递一样，但它更像是语音通话。我们需要回应两个进来的网络钩子。对于第一种情况，我们有两种选择:接收或拒绝传真。我们可以用<code class="eh lj lk ll lm b"><a class="ae kf" href="https://www.twilio.com/docs/fax/twiml/receive" rel="noopener ugc nofollow" target="_blank">&lt;Receive&gt;</a></code>或<code class="eh lj lk ll lm b"><a class="ae kf" href="https://www.twilio.com/docs/fax/twiml/reject" rel="noopener ugc nofollow" target="_blank">&lt;Reject&gt;</a></code>传真TwiML动词来做到这一点。</p><p id="2930" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">拒绝接收传真会挂断连接，我们就完成了。选择接收传入的传真意味着Twilio将代表您接听来电并接收传真。要做到这一点，我们需要设置第二个webhook URL作为<code class="eh lj lk ll lm b">&lt;Receive&gt;</code>元素的action属性，当传真被完全接收时将会请求这个属性。</p><p id="eb4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个webhook是我们将要做的所有工作，将传真下载为PDF格式，并作为电子邮件发送。我们将使用Node.js将它构建为一个<a class="ae kf" href="https://www.twilio.com/docs/api/runtime/functions" rel="noopener ugc nofollow" target="_blank"> Twilio函数</a>(尽管您可以用任何语言来实现这一点，并自己托管应用程序)。</p><h1 id="bca3" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">下载传真</h1><h2 id="81b6" class="ln kh hu bd ki lo lp lq km lr ls lt kq jn lu lv ku jr lw lx ky jv ly lz lc ma dt translated">配置</h2><p id="6b96" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">我们将使用<code class="eh lj lk ll lm b">request</code> npm模块下载传真PDF文件，就像<a class="ae kf" href="https://www.twilio.com/blog/2018/05/how-to-receive-and-download-picture-messages-in-node-js-with-twilio-mms.html" rel="noopener ugc nofollow" target="_blank">我的队友Sam对MMS消息中的媒体所做的那样</a>，并且还将它发送到<a class="ae kf" href="https://sendgrid.com/docs/API_Reference/api_v3.html" rel="noopener ugc nofollow" target="_blank"> SendGrid API </a>。打开Twilio控制台的<a class="ae kf" href="https://www.twilio.com/console/runtime/functions/configure" rel="noopener ugc nofollow" target="_blank">运行时依赖</a>部分，添加<code class="eh lj lk ll lm b">request</code>版本2.88.0。</p><p id="f5c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当您在config部分时，<a class="ae kf" href="https://app.sendgrid.com/settings/api_keys" rel="noopener ugc nofollow" target="_blank">在您的SendGrid帐户</a>中创建一个API键(确保它有发送电子邮件的权限)，并将其保存为一个名为<code class="eh lj lk ll lm b">SENDGRID_API_KEY</code>的环境变量。</p><p id="e36e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在构建函数之前，我们还需要两位配置。你需要一个接收传真的电子邮件地址，以及一个发送传真的电子邮件地址。将<code class="eh lj lk ll lm b">TO_EMAIL_ADDRESS</code>和<code class="eh lj lk ll lm b">FROM_EMAIL_ADDRESS</code>添加到环境变量中。</p><p id="2f74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在进入下一部分之前，请确保保存配置。</p><h1 id="5404" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">编写函数</h1><p id="c0f2" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">创建一个<a class="ae kf" href="https://www.twilio.com/console/runtime/functions/manage" rel="noopener ugc nofollow" target="_blank">新功能</a>并选择空白模板。我们将通过要求<code class="eh lj lk ll lm b">request</code>并创建处理函数来开始代码。</p><pre class="kb kc kd ke fq mb lm mc md aw me dt"><span id="02ec" class="ln kh hu lm b fv mf mg l mh mi">const request = require('request');<br/><br/>exports.handler = function(context, event, callback) {<br/><br/>}</span></pre><p id="af45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">webhook请求向我们发送一个URL，它描述了包含传真的PDF文件的位置。URL在参数<code class="eh lj lk ll lm b">MediaUrl</code>中。</p><p id="092c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们要用<code class="eh lj lk ll lm b">request</code>下载那个PDF。为了将它发送到SendGrid API，我们将需要它作为一个<code class="eh lj lk ll lm b">Buffer</code>，我们可以通过将编码设置为<code class="eh lj lk ll lm b">null</code>来使用<code class="eh lj lk ll lm b">request</code>来做到这一点。</p><p id="cb92" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将以下内容添加到您的函数中:</p><pre class="kb kc kd ke fq mb lm mc md aw me dt"><span id="47dd" class="ln kh hu lm b fv mf mg l mh mi">exports.handler = function(context, event, callback) {<br/>  const faxUrl = event.MediaUrl;<br/><br/>  request.get({ uri: faxUrl, encoding: null }, (error, response, body) =&gt; {<br/>    // body is the PDF file as a Buffer object<br/>  });<br/>}</span></pre><p id="9e32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们需要构建<a class="ae kf" href="https://sendgrid.com/docs/API_Reference/Web_API_v3/Mail/index.html" rel="noopener ugc nofollow" target="_blank">我们想要发送给SendGrid API </a>的请求。我以前探索过这个问题，当时我构建了一个函数来将短信作为电子邮件转发。在回调中添加以下代码:</p><pre class="kb kc kd ke fq mb lm mc md aw me dt"><span id="649c" class="ln kh hu lm b fv mf mg l mh mi">request.get({ uri: faxUrl, encoding: null }, (error, response, body) =&gt; {<br/>    const email = {<br/>      personalizations: [{ to: [{ email: context.TO_EMAIL_ADDRESS }] }],<br/>      from: { email: context.FROM_EMAIL_ADDRESS },<br/>      subject: `New fax from ${event.From}`,<br/>      content: [<br/>        {<br/>          type: 'text/plain',<br/>          value: 'Your fax is attached.'<br/>        }<br/>      ],<br/>      attachments: []<br/>    };<br/>    // more to come<br/>  }</span></pre><p id="a823" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们使用之前保存的环境变量添加<code class="eh lj lk ll lm b">to</code>和<code class="eh lj lk ll lm b">from</code>电子邮件地址。主题说有一个新传真，来自发送它的号码，内容是一个简单的消息，说有一个传真附件。最后，我们添加一组附件。</p><p id="0142" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果传真下载成功，我们会将其作为附件添加到电子邮件中。为此，我们将其作为具有三个键的对象提供:</p><ul class=""><li id="b0d8" class="mj mk hu je b jf jg jj jk jn ml jr mm jv mn jz mo mp mq mr dt translated"><code class="eh lj lk ll lm b">content</code>:一个base64编码的字符串，来自我们下载的PDF的<code class="eh lj lk ll lm b">Buffer</code></li><li id="6c5e" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh lj lk ll lm b">filename</code>:根据传真的Sid标识符创建</li><li id="71ca" class="mj mk hu je b jf ms jj mt jn mu jr mv jv mw jz mo mp mq mr dt translated"><code class="eh lj lk ll lm b">type</code>:文件的MIME类型，我们可以直接从下载传真的响应的头中得到</li></ul><pre class="kb kc kd ke fq mb lm mc md aw me dt"><span id="f185" class="ln kh hu lm b fv mf mg l mh mi">request.get({ uri: faxUrl, encoding: null }, (error, response, body) =&gt; {<br/>    const email = { ... };<br/>    if (!error &amp;&amp; response.statusCode === 200) {<br/>      email.attachments.push({<br/>        content: body.toString('base64'),<br/>        filename: `${event.FaxSid}.pdf`,<br/>        type: response.headers['content-type']<br/>      });<br/>    }<br/>    // more to come<br/>  }</span></pre><p id="b80f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果下载传真时出现错误，我们会跳过添加附件，但我们会继续发送电子邮件作为通知。</p><p id="c848" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经建立了电子邮件，我们需要将它发送到SendGrid API。我们将以JSON的形式发送，将我们在这里创建的<code class="eh lj lk ll lm b">email</code>对象打包为主体，并添加我们之前创建的API令牌作为授权。</p><p id="4d1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果<a class="ae kf" href="https://sendgrid.com/docs/API_Reference/Web_API_v3/Mail/index.html#apiv3example-post" rel="noopener ugc nofollow" target="_blank">响应成功，状态码为202</a>，那么我们可以发送一个空的TwiML <code class="eh lj lk ll lm b">&lt;Response&gt;</code>给Twilio，让它知道一切正常。如果有一个错误，那么我们把错误或者主体作为第一个参数传递给回调函数，这样我们的函数就把它记录为一个错误。</p><pre class="kb kc kd ke fq mb lm mc md aw me dt"><span id="fb4a" class="ln kh hu lm b fv mf mg l mh mi">request.get({ uri: faxUrl, encoding: null }, (error, response, body) =&gt; {<br/>    const email = { ... };<br/>    if (!error &amp;&amp; response.statusCode == 200) {<br/>      // add attachment<br/>    }<br/>    request.post(<br/>      {<br/>        uri: 'https://api.sendgrid.com/v3/mail/send',<br/>        body: email,<br/>        auth: {<br/>          bearer: context.SENDGRID_API_KEY<br/>        },<br/>        json: true<br/>      },<br/>      (error, response, body) =&gt; {<br/>        if (error) {<br/>          return callback(error);<br/>        } else {<br/>          if (response.statusCode === 202) {<br/>            return callback(null, new Twilio.twiml.VoiceResponse());<br/>          } else {<br/>            return callback(body);<br/>          }<br/>        }<br/>      }<br/>    );<br/>  }</span></pre><p id="f575" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我们转发传真所需要的。完整代码如下:</p><pre class="kb kc kd ke fq mb lm mc md aw me dt"><span id="c68f" class="ln kh hu lm b fv mf mg l mh mi">const request = require('request');<br/><br/>exports.handler = function(context, event, callback) {<br/>  const faxUrl = event.MediaUrl;<br/><br/>  request.get({ uri: faxUrl, encoding: null }, (error, response, body) =&gt; {<br/>    const email = {<br/>      personalizations: [{ to: [{ email: context.TO_EMAIL_ADDRESS }] }],<br/>      from: { email: context.FROM_EMAIL_ADDRESS },<br/>      subject: `New fax from ${event.From}`,<br/>      content: [<br/>        {<br/>          type: 'text/plain',<br/>          value: 'Your fax is attached.'<br/>        }<br/>      ],<br/>      attachments: []<br/>    };<br/>    if (!error &amp;&amp; response.statusCode === 200) {<br/>      email.attachments.push({<br/>        content: body.toString('base64'),<br/>        filename: `${event.FaxSid}.pdf`,<br/>        type: response.headers['content-type']<br/>      });<br/>    }<br/>    request.post(<br/>      {<br/>        uri: 'https://api.sendgrid.com/v3/mail/send',<br/>        body: email,<br/>        auth: {<br/>          bearer: context.SENDGRID_API_KEY<br/>        },<br/>        json: true<br/>      },<br/>      (error, response, body) =&gt; {<br/>        if (error) {<br/>          return callback(error);<br/>        } else {<br/>          if (response.statusCode === 202) {<br/>            return callback(null, new Twilio.twiml.VoiceResponse());<br/>          } else {<br/>            return callback(body);<br/>          }<br/>        }<br/>      }<br/>    );<br/>  });<br/>}</span></pre><p id="11fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">给函数一个路径并保存它。</p><h1 id="05d0" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">把所有的放在一起</h1><p id="1d60" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">返回编辑您的传真号码。在“语音和传真”部分，确保您已设置为接受传入的传真。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mx"><img src="../Images/6564bcdf97a94a11b4d18420a96e9af0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlkZ2S0BMZgidfQoyw9PmQ.png"/></div></div></figure><p id="2a12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于“有传真进来”,选择<em class="my"> TwiML </em>,然后点击红色按钮创建一个新的TwiML接收箱来接收传入的传真呼叫。输入以下TwiML，用函数URL替换操作URL:</p><pre class="kb kc kd ke fq mb lm mc md aw me dt"><span id="6144" class="ln kh hu lm b fv mf mg l mh mi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;Response&gt;<br/>  &lt;Receive action="FUNCTION_URL" /&gt;<br/>&lt;/Response&gt;</span></pre><p id="3471" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">保存号码配置，您就可以通过电子邮件接收传真了。</p><h1 id="2621" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">测试它</h1><p id="83c8" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">正如我们已经确定的，现在是2019年，我们没有传真机来测试这一点。现在，你可以去你当地的图书馆或打印店借他们的，或者打开<a class="ae kf" href="https://www.twilio.com/console/runtime/api-explorer/fax/fax/create" rel="noopener ugc nofollow" target="_blank"> Twilio API explorer并通过API </a>给自己发一份传真(你可以在这里使用你现有的传真号码作为<code class="eh lj lk ll lm b">To</code>和<code class="eh lj lk ll lm b">From</code>号码)。发送传真时，你需要把PDF文件放在Twilio能拿到的地方。如果你没有，可以在这里使用我们的测试PDF文件<a class="ae kf" href="https://www.twilio.com/docs/documents/25/justthefaxmaam.pdf" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="73dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当你将传真机发送到世界各地时，不要忘记播放传真机的真实声音。</p><p id="5f8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">等待几分钟(传真需要时间！)然后查看你的邮箱。</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ka"><img src="../Images/da148b08f8fb23366fbfb1c6040f1ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*ptGBTyvOlS4lD9oa"/></div></figure><p id="9253" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该已经收到你的新传真了。</p><p id="7475" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">庆祝的时间到了！</p><figure class="kb kc kd ke fq iv fe ff paragraph-image"><div class="fe ff ka"><img src="../Images/0aad1baaad294766ae7e20b09a1d7878.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*t1ZUdlRW-8wYTl4m"/></div></figure><h1 id="67e4" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">在写这篇文章的时候，没有传真机受到损害</h1><p id="a966" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">凭借Twilio number、JavaScript、Twilio函数、TwiML Bin和SendGrid API的强大功能，我们现在可以将传真直接发送到我们的电子邮件收件箱。</p><p id="fada" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经看到了如何使用<code class="eh lj lk ll lm b"><a class="ae kf" href="https://www.npmjs.com/package/request" rel="noopener ugc nofollow" target="_blank">request</a></code>下载文件，然后将它们直接发送到<a class="ae kf" href="https://sendgrid.com/docs/API_Reference/Web_API_v3/Mail/index.html#apiv3example-post" rel="noopener ugc nofollow" target="_blank"> SendGrid API </a>。您也可以使用同样的技术将<a class="ae kf" href="https://www.twilio.com/docs/sms/tutorials/how-to-send-sms-messages" rel="noopener ugc nofollow" target="_blank">收到的彩信</a>转发到您的电子邮件。</p><p id="d26f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你曾经想象过JavaScript和电子邮件会解决传真吗？对传统科技的未来有什么想法吗？请在下面的评论中给我留言，或者在Twitter<a class="ae kf" href="https://twitter.com/philnash" rel="noopener ugc nofollow" target="_blank">上</a>告诉我你的其他复古未来发明。2019传真万岁！</p></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="69c4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="my">标题中的传真图标由Emojione第2版提供。</em></p></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="8021" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="my">原载于</em><a class="ae kf" href="https://www.twilio.com/blog/fax-email-sendgrid-nodejs" rel="noopener ugc nofollow" target="_blank"><em class="my">www.twilio.com</em></a><em class="my">。</em></p></div></div>    
</body>
</html>