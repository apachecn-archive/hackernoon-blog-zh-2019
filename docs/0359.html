<html>
<head>
<title>Managing React modals with singleton component design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用单体组件设计管理反应模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/managing-react-modals-with-singleton-component-design-5efdd317295b#2019-01-15">https://medium.com/hackernoon/managing-react-modals-with-singleton-component-design-5efdd317295b#2019-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="7ba3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">(本帖原帖到我个人</em> <a class="ae jq" href="https://www.techynovice.com/manage-react-modal-with-singleton-component-design/" rel="noopener ugc nofollow" target="_blank"> <em class="jp">博客</em> </a> <em class="jp"> ) </em></p><p id="71ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开发应用程序时，控制应用程序中所有类型的模态(信息模态、定制警告、图像灯箱等等)是一个令人沮丧的问题。当应用程序很简单时，放置一个单独的<code class="eh jr js jt ju b">&lt;Modal /&gt;</code>组件并有一个状态来切换它的开/关就足够了。然而，当你在应用程序中有不同的地方呈现相同的模态或者不同种类的模态时，事情就变得复杂了。</p><p id="ae25" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对此已经有了一些设计解决方案，比如使用 React Context API ( <a class="ae jq" rel="noopener" href="/@BogdanSoare/how-to-use-reacts-new-context-api-to-easily-manage-modals-2ae45c7def81">这篇博客</a>就是一个例子)或者操纵<code class="eh jr js jt ju b">react-navigation</code>的<code class="eh jr js jt ju b">StackNavigator</code>(如<a class="ae jq" href="https://blog.brainsandbeards.com/better-modals-in-react-native-8ea6fb207146?gi=23e52db335d3" rel="noopener ugc nofollow" target="_blank">这篇博客文章</a>中所述)。在这篇文章中，我想分享我自己使用 singleton <code class="eh jr js jt ju b">&lt;Modal /&gt; </code>组件解决这个问题的设计。我们将从该解决方案中获得一个命令式 API，如:</p><pre class="jv jw jx jy fq jz ju ka kb aw kc dt"><span id="88c2" class="kd ke hu ju b fv kf kg l kh ki">SomeModal.show(title, content, { ...options })<br/>SomeModal.hide()</span></pre><p id="53fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">(请注意，这有点类似于没有导航道具的<code class="eh jr js jt ju b">react-navigation</code>向导<a class="ae jq" href="https://reactnavigation.org/docs/en/navigating-without-navigation-prop.html" rel="noopener ugc nofollow" target="_blank">导航)</a></p><p id="5a21" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jr js jt ju b">&lt;SomeModal /&gt;</code>是一个 react 组件，它在顶层呈现如下:</p><pre class="jv jw jx jy fq jz ju ka kb aw kc dt"><span id="c7e4" class="kd ke hu ju b fv kf kg l kh ki">class App extends Component {<br/>  render() {<br/>    // Container is your own wrapper component<br/>    return (<br/>      &lt;Container&gt;<br/>        {/* Your real app */}<br/>        &lt;SomeModal /&gt;<br/>      &lt;/Container /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="5010" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么当我们调用<code class="eh jr js jt ju b">show()</code>和<code class="eh jr js jt ju b">hide()</code>方法时<code class="eh jr js jt ju b">SomeModal</code>是如何知道该做什么的呢？首先，我们将定义组件方法<code class="eh jr js jt ju b">__show()</code>和<code class="eh jr js jt ju b">__hide()</code>，然后在它的构造函数中，我们通过使用<code class="eh jr js jt ju b">this</code>保存它对静态属性<code class="eh jr js jt ju b">SomeModal</code>的引用(因为构造函数中的<code class="eh jr js jt ju b">this</code>将是对呈现组件的引用)。该引用将可以访问<code class="eh jr js jt ju b">SomeModal</code>的所有组件方法。我们现在可以创建两个静态方法<code class="eh jr js jt ju b">show(), hide()</code>并使用它:</p><pre class="jv jw jx jy fq jz ju ka kb aw kc dt"><span id="e598" class="kd ke hu ju b fv kf kg l kh ki">class SomeModal extends Component {<br/>  static show() {<br/>    SomeModal.__singletonRef.__show();<br/>  }<br/><br/>  static hide() {<br/>    SomeModal.__singletonRef.__hide();<br/>  }<br/><br/>  constructor(props) {<br/>    super(props);<br/>    SomeModal.__singletonRef = this;<br/>  }<br/><br/>  __show() { ... }<br/>  __hide() { ... }<br/>}</span></pre><p id="56b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当做这个单例组件时，我们需要确保我们不会在应用程序中使用这个组件两次，因为引用将是不正确的。在我看来，当我们在应用程序中有一个定义好的模态风格，并且我们想在任何地方显示和隐藏它时，这是最好的选择。这也允许在 React 组件之外显示和隐藏模态。</p><p id="88b7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你有不同种类的情态动词呢？在我自己的项目中，对于每一种模态，我都制作一个单独的 React 组件，并将其渲染到顶层，如下所示:</p><pre class="jv jw jx jy fq jz ju ka kb aw kc dt"><span id="e8fc" class="kd ke hu ju b fv kf kg l kh ki">&lt;Container&gt;<br/>  {...}<br/>  &lt;FeedbackModal /&gt;<br/>  &lt;LinkPreviewModal /&gt;<br/>  &lt;AlertModal /&gt;<br/>&lt;/Container /&gt;</span></pre><p id="07c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望你发现这种处理情态动词的方式很有用。请让我知道你的想法！</p><p id="22cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">黑客快乐！</p></div></div>    
</body>
</html>