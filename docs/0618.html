<html>
<head>
<title>-PHP Operators (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">-PHP操作符(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/php-operators-part-2-85f39530994b?source=collection_archive---------18-----------------------#2019-01-25">https://medium.com/hackernoon/php-operators-part-2-85f39530994b?source=collection_archive---------18-----------------------#2019-01-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e174b79e139157c6a1392e0a9b07f0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_IUXHbVA8y0KqM-C.jpg"/></div></div></figure><h1 id="0a76" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="1a5d" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">PHP中的运算符是一个庞大的主题，并不总是能被完全理解。</p><p id="cd0a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">所有这些误解的原因之一是，有些操作符非常简单，在阅读它们之后，几秒钟之内就可以在代码中实现，</p><p id="aee5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">其他人则相反，</p><p id="476d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">几乎是未知的，一旦研究过，还是少用为妙。</p><p id="8171" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">虽然运算符属于“语言基础”范畴，但是误用它们或者在使用它们时出现拼写错误<strong class="kc hv">是很难识别的</strong>。</p><p id="27ca" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你可能会浪费半个多小时的时间去调试一些代码，然后发现插入了平等的符号，而不是不平等的符号。</p><p id="7171" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">亲身经历(感叹)。</p><p id="c6f7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在我之前的博客文章中，你已经发现了PHP操作符<a class="ae ky" href="http://anastasionico.uk/blog/php-operators" rel="noopener ugc nofollow" target="_blank">的主要类型。</a></p><p id="c5da" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">下面你会看到引用操作符、赋值操作符和一些好东西，你可以用它们来打动你的同事。</p><h1 id="72cf" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">面向专业开发人员的PHP基础知识</h1><p id="adfc" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这篇博客文章是名为“面向专家开发者的PHP基础知识”系列文章的一部分。</p><p id="3e78" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在这个系列中，你将学习PHP的基础知识，但是你也将会看到许多只有在书本和高级教程中才能找到的小技巧和特性。</p><p id="f59e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">根据你的水平，你可能只是想偶尔阅读或者干脆跳过它们。</p><p id="5175" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你不必记住这里写的所有东西！</p><p id="c9e7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">只需阅读，找出某些功能或技术的存在，并返回到这些网页时，你觉得已经准备好进入下一个层次。</p><p id="c53d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="http://anastasionico.uk/blog/php-basics-for-web-developer" rel="noopener ugc nofollow" target="_blank">面向web开发专家的PHP基础知识(1 '部分)</a><br/><a class="ae ky" href="http://anastasionico.uk/blog/php-construct-comments" rel="noopener ugc nofollow" target="_blank">PHP 7的构造和注释</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-variables" rel="noopener ugc nofollow" target="_blank">如何使用变量(PHP 7)</a><br/><a class="ae ky" href="http://anastasionico.uk/blog/composite-variable-in-php" rel="noopener ugc nofollow" target="_blank">PHP中的复合变量(数组、对象和更多)</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-operators" rel="noopener ugc nofollow" target="_blank"> PHP运算符(1部分)</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison" rel="noopener ugc nofollow" target="_blank"> PHP运算符(2) </a></p><p id="ac23" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">此外，这篇博客分为几个主要部分</p><p id="6301" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison#assign" rel="noopener ugc nofollow" target="_blank">赋值运算符</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison#reference" rel="noopener ugc nofollow" target="_blank">参考运算符</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison#comparison" rel="noopener ugc nofollow" target="_blank">比较运算符</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison#error" rel="noopener ugc nofollow" target="_blank">误差控制运算符</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison#backtick" rel="noopener ugc nofollow" target="_blank">反斜杠运算符</a> <br/> <a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison#conclusion" rel="noopener ugc nofollow" target="_blank">结论</a></p><h1 id="792e" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">分配运算符</h1><p id="437e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">正如你在上一章看到的，</p><p id="1f97" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">除非你需要空的或者null变量，<strong class="kc hv">每个变量都应该有一个值。</strong></p><p id="adaa" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">但是我们如何给变量赋值呢？</p><p id="48d0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">为了给一个变量赋值，PHP为web开发人员提供了许多称为赋值操作符的操作符。</p><p id="8f59" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">他们以等号<em class="le">“=”</em>为基础。</p><p id="faf0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">语法由三个因素组成:</p><p id="e007" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">第一个是由名字表示的变量，中间是赋值运算符，语句的第三个元素是值，可以是不同的类型。</strong></p><p id="a2da" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这里有一个例子:</p><p id="b95a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><em class="le"> $variable = "这是一个字符串"；</em></p><p id="3a75" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">赋值运算符可以与任何其他二进制和算术运算符结合使用，这为程序员提供了一种使代码更快编写和更易于阅读的方法。</p><p id="e7fe" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">以下是复合赋值运算符的一些示例:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="66d8" class="lo jd hu lk b fv lp lq l lr ls">$sum = 1 + 1; $sum += 100; <br/>// this is equal to $sum = $sum + 100; <br/>// $sum is equal to 102; <br/>$string = "My name is:"; <br/>$string .= "Nico"; <br/>// this is equal to $string = $string . "Nico"; <br/>// $string is equal to "My name is Nico</span></pre><p id="b0c2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一个常见的错误，也是即使是有经验的程序员也必须时刻注意的事情，就是当赋值操作符指的是等号操作符<em class="le"> "== "的时候，要写赋值操作符。</em></p><p id="2516" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">想象一下后者在共识中的不正确使用，比如if语句，</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="5847" class="lo jd hu lk b fv lp lq l lr ls">$var = "Hello"; <br/>if ($var = "Goodbye") {}</span></pre><p id="20f2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">虽然使用等式运算符时，该条件的结果会是false，但是在这种情况下，变量$var被正确地赋予了新值“Goodbye ”,因此PHP解析器将该条件评估为true。</p><p id="5ff0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一些专家使用的避免这种错误的技术是所谓的尤达条件，</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/1497519dc2ebe87d488cb8f57d05f33e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*pIpRDZC5UKp4vcx6.jpg"/></div></figure><p id="48e2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这种约定利用了PHP不允许更改常量值的事实，</p><p id="0e3f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果你把一个常量放在条件的左边，当你写代码时出错，PHP会抛出一个警告。</p><p id="84d2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">虽然这种技术已经被证明是可行的，但是它是否值得在可读性和个人风格的条件下使用，还是要由你来决定。</p><h1 id="2f27" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">参考运算符</h1><p id="f270" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这里有一个我在走向掌握语言的道路上遇到的最奇怪、最难理解的符号(离到达还很远)。</p><p id="c8cf" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">在PHP中，对变量赋值有两种不同的方式，</p><p id="b5ad" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">按值或按引用。</strong></p><p id="1fd1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">默认情况下，<strong class="kc hv">所有标量值都被赋值，</strong></p><p id="ef3b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果你想通过引用分配一个标量值，可以使用符号<em class="le"> = &amp; </em></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="ec82" class="lo jd hu lk b fv lp lq l lr ls">$firstPerson = "Nico"; <br/>$secondPerson =&amp; $firstPerson; <br/>$secondPerson = "John"; <br/>echo $firstPerson; <br/>// The value echoed out will be "John" instead of "Nico"</span></pre><p id="1b72" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">对于对象，</p><p id="6539" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">恰恰相反的情况发生了，</p><p id="0d67" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">所有对象总是通过引用分配，</strong></p><p id="5c3b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果你试图使用PHP对象的<em class="le"> = &amp; </em>符号，它将抛出一个错误。</p><p id="25e8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">迷茫？</p><p id="a0b7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">以下是解释，</p><p id="9cd5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">出现这种差异是因为经过多年的开发和改进，PHP已经优化了这个过程，使得变量的赋值越快越好。</p><p id="79b7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这可以通过使用名为<em class="le"> zval </em>的容器来实现，</p><p id="2aff" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv"> <em class="le"> Zval </em>由四部分组成:</strong></p><p id="71a2" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">值，类型，Is_ref和Refcout。</strong></p><p id="7054" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这个容器包含了变量的所有信息，比如长度，大小，在内存中的确切位置。</p><p id="a6e4" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">当我们通过引用调用一个值时，我们指出了包含它的值的确切元素。</p><p id="c459" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="http://www.phpinternalsbook.com/zvals.html" rel="noopener ugc nofollow" target="_blank">以下是这些容器的详细说明</a></p><h1 id="d987" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">比较运算符</h1><p id="6a5a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">该做作业了…</p><p id="47b5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">一等于一吗？</p><p id="e64f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">停下来，用PHP写下最后一句话，</p><p id="ef2a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">完成了吗？</p><p id="c68f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">让我们看看结果。</p><p id="3f42" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">为了完成前面的操作，您需要名为比较运算符的PHP特性。</p><p id="763d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">准确地说，这一类别有9个元素，它们都非常容易学习。</p><p id="7f69" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">事实上，</p><p id="f460" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你已经从小学学过很多了。</p><p id="e4c3" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">要进行比较，您需要一个符号和两个元素来比较符号旁边的每个元素:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/3ea87055aebca0539f77122f6e1b414a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*rAfjPApqCXbnZ6Ll.jpg"/></div></figure><p id="2497" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">以下是运算符:</p><p id="6fc1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">大于:符号&gt; </strong> <br/>对于为真的条件，左边的元素必须大于右边的元素，(这不仅适用于数字，也适用于考虑字母位置的字符串，大写字母比小写字母少)。</p><p id="2243" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">大于等于:符号&gt; = </strong> <br/>足够说明问题了吧？</p><p id="6e58" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">小于:符号&lt; </strong> <br/>正好与大于相反</p><p id="a3de" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">小于或等于:符号&lt; = </strong> <br/>大于或等于的反义词</p><p id="241f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">不相等:符号&lt; &gt; </strong> <br/>为真，两个值必须不同</p><p id="2427" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">等价:symbol == </strong> <br/>为真，两个值不能不同</p><p id="e2ce" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv"> Identity: symbol === </strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="657d" class="lo jd hu lk b fv lp lq l lr ls">$int = 123; <br/>$str = "123"; <br/>($int === $str) <br/>// the result of this condition is false because although the values ​​are equal the two types of variable are different</span></pre><p id="39d7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">不等价:符号！</strong>=<br/>见&lt; &gt;</p><p id="ffed" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">不相同:符号！== </strong> <br/>在某种意义上，这个可以等同于同一个运算符<em class="le"> === </em>，</p><p id="cb2c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果我们比较的两个元素不具有相同的值并且不属于同一类型，则该语句的结果为真。</p><p id="1ca1" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">请注意，如果两个元素具有相同的值，但它们属于两种不同的类型，则它们不相同。</p><p id="fa96" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">如果两个值属于同一类型，但没有两个相等的值，也会发生同样的情况。</p><h1 id="806a" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">额外运算符</h1><p id="9332" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这里有两个不常见的操作符，这也是为什么这个系列被称为“面向web开发专家的PHP基础知识”的原因。</p><h1 id="0640" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">误差控制算子</h1><p id="7b03" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">你见过@运算符吗？</p><p id="b283" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这被称为错误控制操作符，用于抑制PHP中的错误。</p><p id="de2e" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><a class="ae ky" href="http://php.net/manual/en/language.operators.errorcontrol.php" rel="noopener ugc nofollow" target="_blank">在这里你会找到更多关于错误控制操作符</a>的信息</p><p id="c8be" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">现在，</p><p id="f85f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">正如您可以想象的那样，<strong class="kc hv">隐藏错误并不被认为是一种好的实践，而且会使调试过程更加困难。</strong></p><p id="bc78" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">那为什么要用这个运算符呢？</p><p id="3485" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">举个例子吧，</p><p id="b1ad" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">不久前，我发表了几篇文章，描述了PHP 7.3 的<a class="ae ky" href="http://anastasionico.uk/blog/php-73" rel="noopener ugc nofollow" target="_blank">新特性和弃用之处。</a></p><p id="335c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这种<a class="ae ky" href="https://hackernoon.com/tagged/programming" rel="noopener ugc nofollow" target="_blank">编程</a>语言的上一个版本和前一个版本之间的区别之一涉及到<em class="le"> preg_match() </em>函数和该函数需要作为参数之一的正则表达式。</p><p id="eec8" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">如果你已经在应用程序中大量使用了这个函数，并且仍然想把代码更新到PHP7.3，而不是处理所有可能出现的错误，你可以简单地禁用这些错误，</strong></p><p id="d974" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">将服务器更新到PHP的新版本，并逐一修复错误。</p><p id="320d" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">注意，只有当函数使用的库使用PHP标准错误报告时，这个操作符才起作用。</p><p id="d60c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">当然，</p><p id="1174" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我不建议这样做，但我在这里让你知道这个选项是存在的。</p><p id="d670" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这是Xdebug的作者吴镇男·雷瑟斯写的一篇关于这个主题的文章，很老了，但仍然很热门。</p><p id="0d99" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">是否使用以及如何使用由你决定。</p><p id="dd8c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">下面是一个语法示例:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="c058" class="lo jd hu lk b fv lp lq l lr ls">$db = @mysqli_connect(); <br/>// Even if there will be an error with the connection no errors will be displayed</span></pre><h1 id="4a12" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">反斜杠运算符</h1><p id="f13c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">另一个很少使用的运算符是称为“反勾符”的运算符。</p><p id="5120" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">使用这个操作符相当于使用<em class="le"> shell_exec() </em>命令，</p><p id="cf82" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">它通过shell执行作为参数的字符串所需的命令，如果成功执行，则返回字符串本身。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="fd4c" class="lo jd hu lk b fv lp lq l lr ls">echo `touch index.php`; <br/>// this command is equal to shell_exec('touch index.php');</span></pre><p id="1d70" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我可以给你一个建议，谨慎使用这两个命令，</p><p id="1c12" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">既然我们在谈论文件系统上的操作，理解这些命令的破坏力并不需要天才。</p><p id="43db" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">小心使用它们，</p><p id="fff5" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">净化文本，最重要的是，不要使用外部输入，比如用户输入的字符串作为参数。</p><h1 id="f560" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">结论</strong></h1><p id="6a6a" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我打赌你感到不知所措？你不是吗？</p><p id="cfbe" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">这很正常。</p><p id="b39f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">太多的信息加在一起会有这种效果。</strong></p><p id="8646" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">正如我在本系列文章中多次提到的，不要认为有必要一次就学会你所阅读的所有内容。</p><p id="016c" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">实际上，</p><p id="9b10" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我认为一旦你读了这个话题，你应该花时间去消化它。</p><p id="3141" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">不要误解我，</p><p id="b2d6" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">其中一些操作符一点都不难，我认为在你读完这篇文章后尽快使用它们是很重要的。</p><p id="5871" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">替别人取而代之，哼。</p><p id="2b0b" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">您很少会使用它们，相反，根据最佳实践，最好根本不要使用它们。</p><p id="7986" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">我认为给你的一个重要建议是记下这篇文章(如果你愿意，可以把它标上书签)，然后再读一遍，并在几周后回顾文章中所写的内容。</p><p id="a6b7" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><strong class="kc hv">分析一下哪些运算符你用得最多，哪些根本不用。</strong></p><p id="e989" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">然后检查您最近几周使用的脚本是否可以使用这些页面中描述的一些操作符进行简化。</p><p id="5bca" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">给你！</p><p id="7d6a" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">你已经发现了学习和正确实现PHP的每一个新旧特性的秘密。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><a href="http://eepurl.com/dIZqjf"><div class="fe ff lu"><img src="../Images/81f240e8dd073aab6ad31da0e0d28d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8FKpkkhRhWP0iLk7FpzTbQ.jpeg"/></div></a></figure><p id="9bb0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt">…</p><p id="a2a9" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><em class="le">现在你知道了基础知识，是时候开始练习了，</em></p><p id="d45f" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">利用Blue Host的能力和速度，创建一个帐户，在那里你可以锻炼，并以每月不到一杯星巴克咖啡的价格在实时服务器上看到你的进步。 </p><p id="3445" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated">(这是一个附属链接，价格对你来说保持不变，它帮助我改进这个内容。)</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><p id="9fe0" class="pw-post-body-paragraph ka kb hu kc b kd kz kf kg kh la kj kk kl lb kn ko kp lc kr ks kt ld kv kw kx hn dt translated"><em class="le">最初发表于</em><a class="ae ky" href="http://anastasionico.uk/blog/php-assignment-reference-comparison" rel="noopener ugc nofollow" target="_blank"><em class="le">anastasionico . uk</em></a><em class="le">。</em></p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="mc md l"/></div></figure></div></div>    
</body>
</html>