<html>
<head>
<title>How to write a self-healing Kinesis function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何写一个自我修复的Kinesis函数</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-write-a-self-healing-kinesis-function-fe18c462b49?source=collection_archive---------15-----------------------#2019-05-20">https://medium.com/hackernoon/how-to-write-a-self-healing-kinesis-function-fe18c462b49?source=collection_archive---------15-----------------------#2019-05-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="fe84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本周，我与一位客户一起解决了一个有趣的问题——根据响应时间和错误率动态调整对下游服务的并发请求数量。当与第三方集成时，这是一个常见的挑战，所以我们决定分享我们的方法，以便其他人可以从中受益。</p><h1 id="113d" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">问题是</h1><p id="a93c" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">我的客户是金融服务行业的，他们与50多家服务提供商进行集成。他们可以通过API访问提供商的数据，并且每天都需要从每个提供商那里获取这些数据。</p><p id="10a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，许多提供商对其API设置了限制和速率限制，例如:</p><ul class=""><li id="8b88" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">您只能在非高峰时段访问API。</li><li id="e4c7" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">在每周维护窗口期间，您无法访问API。</li><li id="8a81" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">您只能向API发出X个并发请求。</li></ul><p id="e05e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的客户实现了一个<em class="lg">调度器</em>服务来管理时间约束。<em class="lg">调度器</em>知道<strong class="it hv">何时</strong>开始每个提供者的接收过程。但是还有一个次要的过程，他们的用户(财务顾问)可以自己安排临时摄入。</p><p id="4a0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还必须记住其他一些情况:</p><ul class=""><li id="fc97" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">API遵循既定的行业标准。不幸的是，他们一次只能返回一条记录。</li><li id="db91" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">API响应时间变化很大，从5毫秒到70秒不等。</li><li id="5bcf" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">客户端需要获取的数据量因提供商而异。有些只有几千条记录，有些则有几十万条记录。</li><li id="0a51" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">我们不应该每天从一个提供者获取相同的记录超过一次。这归因于使用限制。</li><li id="958e" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">这个摄取过程是他们系统中最关键的业务部分 <strong class="it hv">之一。需要谨慎管理向这一新系统的迁移，以最大限度地减少对客户的潜在影响。</strong></li></ul><h1 id="f94c" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">解决方案</h1><p id="70a1" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">为了解决上述挑战，我们需要一种机制来:</p><ul class=""><li id="5a25" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">缓慢而稳定地从提供商的API获取大量记录。该过程需要可靠，但如果需要，可能需要几个小时。</li><li id="c6f8" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">最多只能同时获取X条记录。</li><li id="8a2a" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">当提供者API的响应时间或错误率开始上升时，逐渐减少并发性。</li></ul><p id="97cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们没有从头开始实现这样的机制，而是选择利用Kinesis和Lambda的内置批处理支持。在我们建议的设置中:</p><ul class=""><li id="59af" class="ks kt hu it b iu iv iy iz jc ku jg kv jk kw jo kx ky kz la dt translated">每个供应商都有一个Kinesis流。</li><li id="4182" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">调度程序服务将我们需要提取到流中的记录排队。</li><li id="be39" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">一个<em class="lg"> ventilator </em> Lambda函数将批量接收记录并将它们扇出到一个<em class="lg"> worker </em>函数(通过直接函数调用)。</li><li id="0baa" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">有许多不同的工作函数，每个提供者都有一个。这是因为大多数提供者都有特定于提供者的业务逻辑。</li><li id="5fad" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">为了避免在同一天处理相同的记录两次，<em class="lg">呼吸机</em>在DynamoDB表中跟踪今天已经处理过的记录。</li><li id="ca31" class="ks kt hu it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la dt translated">为了支持重试失败的记录，<em class="lg">呼吸机</em>还跟踪在同一个DynamoDB表中处理每个记录的尝试次数。当遇到部分故障时，<em class="lg">呼吸机</em>会增加失败记录和例外的<em class="lg">尝试次数</em>。Kinesis会自动为我们重试同一批记录。在随后的尝试中，先前成功的记录将被忽略。</li></ul><p id="e2be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从高层次来看，该系统如下所示:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/e03c4de75feefbf34713cf54e768bb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K1uQ3L0fogu9boi5.png"/></div></div></figure><p id="eb8a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种设计不能提供最大的吞吐量，这是设计的<strong class="it hv">！如前所述，这是由于提供者API的日常使用限制和可伸缩性问题。</strong></p><p id="aea2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个提供者都有自己的CloudFormation堆栈，包含Kinesis流、呼吸机和worker Lambda函数，以及DynamoDB表。这种设置使得一次一个提供者地逐渐迁移到新系统变得容易。</p><h1 id="ba81" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">自愈功能</h1><p id="85fd" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">每个提供者一个流的配置让我们可以使用Kinesis事件源映射的批处理大小来控制并发性。因此，<em class="lg">呼吸机</em>功能可以通过<a class="ae lt" href="https://docs.aws.amazon.com/lambda/latest/dg/API_UpdateEventSourceMapping.html" rel="noopener ugc nofollow" target="_blank">更新Kinesis事件源映射</a>来<strong class="it hv">自调整其批量大小</strong>。</p><p id="b70d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着供应商API的响应时间增加，<em class="lg">呼吸机</em>可以通过减少其批量大小来做出响应。这给了API一个喘息和恢复的机会。当响应时间恢复到可接受的水平时，那么<em class="lg">呼吸机</em>可以逐渐将其批量增加回先前的水平。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/8452569155a05a8b704d74a48ea1b3b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cTQIWJf5dNs-O4p9.png"/></div></div></figure><p id="bb6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们甚至更进一步。</p><p id="10de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果提供者API仍然在批量大小为1的情况下挣扎，那么很明显有些事情不对劲。不能将批大小更改为0，但可以完全禁用Kinesis事件源映射。当您稍后重新启用它时，Kinesis会将事件从它之前停止的地方推送到<em class="lg">呼吸机</em>，就像什么都没发生一样。</p><p id="771e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，如果Kinesis事件源被禁用，那么稍后需要其他东西来触发唤醒<em class="lg">呼吸机</em>。为此，我们有一个CloudWatch计划，每10分钟触发一次<em class="lg">呼吸机</em>功能。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/f1c1d941c86627b7bb0e71ad88c7d413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ovq3b9htqzMi5Itj.png"/></div></div></figure><p id="ea1c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果Kinesis事件源已经启用，那么这些CloudWatch触发的调用就什么也不做。然而，当Kinesis被禁用时，<em class="lg">呼吸机</em>可以在批量为1时重新启用它。这允许Kinesis在下一次调用时向提供者API发出一个请求。如果反应时间仍然高于阈值，那么我们将再次禁用Kinesis，循环重复。直到提供者API能够及时响应请求。然后，Kinesis流保持启用状态，并且<em class="lg">呼吸机</em>功能将逐渐恢复其之前的批量。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/9d82e92d70bfb4f016ebea124c02986f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2N7Am_SF_w2xn8BV.png"/></div></div></figure><p id="4db3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是应用于流处理的经典<a class="ae lt" href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank">断路器模式</a>。</p><h1 id="ad95" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">给我看看它是怎么工作的！</h1><p id="44e0" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">如果你想看看这在实践中是如何工作的，我做了一个演示程序来说明。你可以在这里找到源代码<a class="ae lt" href="https://github.com/theburningmonk/self-adjusting-kinesis-function-demo" rel="noopener ugc nofollow" target="_blank">。按照自述文件中的说明部署演示应用程序，并使用提供的<em class="lg"> feed-stream </em>脚本输入数据。</a></p><p id="75c6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这个演示应用程序，我可以通过环境变量调整来自<em class="lg"> worker </em>函数的缓慢和错误响应的比率。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/18df515a7f4354703fdfb5288be35a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eJ1-pvEZ2FOFwHt7.png"/></div></div></figure><p id="2417" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我这样做时，你将很快看到<em class="lg">通风设备</em>采取措施减少其批量。它将调整批量大小，相应地增加和减少。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/516ab03a0e322e089c3ee12765250a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1oheNbovxL7UeFmn.png"/></div></div></figure><p id="b3c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以创建一个指标过滤器来从日志中提取批量大小，并在CloudWatch中将它转换成一个指标。这让您可以观察批次大小如何随时间变化。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/2096757a37b58747858a1181750a51db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dOd9saq0PKtGdenl.png"/></div></div></figure><p id="ea63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果提高的响应时间和错误率继续，那么最终<em class="lg">呼吸机</em>功能将禁用其Kinesis事件源。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/59df98f6d892bb01955750e87d3de8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tqKBzYVxiovkd06j.png"/></div></div></figure><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/a0ffeb7dd449f14c1a23632c27d91c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a6Uw8LG2T0NUDcTL.png"/></div></div></figure><p id="36f4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，cron作业将每10分钟重新启用该流。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/bbf43790de2747cd1aaf721fa900e855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oxWJQs64br6nwie8.png"/></div></div></figure><p id="660a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以及<em class="lg">工作者</em>功能是否已经恢复。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/1409bb116fd1944657e6e5113aad8506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M-2sa1OdqP_OhJDg.png"/></div></div></figure><p id="a5fd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后<em class="lg">呼吸机</em>功能将逐渐增加其批量。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/a273aeaf727f8a625c6fe734aade0af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XQUumJRsophXYlvj.png"/></div></div></figure><p id="22ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">直到它最终恢复到原来的批量10。如果您一直监视批量大小的变化，您可能会看到以下内容:</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/1cfedef7f8f2597511c8c9fbc4807e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0j8tbveBhofy2yzO.png"/></div></div></figure><h1 id="bcd4" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">摘要</h1><p id="4ff7" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">在这篇文章中，我们讨论了一个自我修复运动功能的设计，它可以根据性能调整吞吐量。通过这样做，我们能够仔细地调整我们的系统对第三方API发出的并发请求的数量，并保持在它们的操作限制之内。我们还讨论了这样的设计如何实现断路器模式，以及如何在第三方API陷入困境时完全摆脱困境。</p><p id="0ad7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望你喜欢这篇文章，如果你有任何建议或意见，别忘了告诉我们。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/3a3da7abd3092197e27e6091deb63f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/0*4oTayviygB5abYYl.png"/></div></figure><p id="977b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">嗨，我的名字是<strong class="it hv">崔琰</strong>。我是一个<a class="ae lt" href="https://aws.amazon.com/developer/community/heroes/yan-cui/" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> AWS无服务器英雄</strong> </a>和<a class="ae lt" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">量产无服务器</strong> </a>的作者。我已经在AWS中运行了近10年的大规模生产工作负载，我是一名架构师或首席工程师，涉足从银行、电子商务、体育流媒体到移动游戏等多个行业。我目前是一名专注于AWS和无服务器的独立顾问。</p><p id="c37e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以通过<a class="ae lt" href="mailto:theburningmonk.com" rel="noopener ugc nofollow" target="_blank">邮箱</a>、<a class="ae lt" href="https://twitter.com/theburningmonk" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae lt" href="https://www.linkedin.com/in/theburningmonk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="404d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看我的新课程，<a class="ae lt" href="https://theburningmonk.thinkific.com/courses/complete-guide-to-aws-step-functions" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">AWS步骤功能完整指南</strong> </a>。</p><p id="a329" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本课程中，我们将介绍有效使用AWS Step Functions服务所需了解的一切。包括基本概念、HTTP和事件触发器、活动、设计模式和最佳实践。</p><p id="cd40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里拿到你的副本。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/2faf40b47320300fed81b3e09483ffb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZYcHhOOzUf5VB-Ri.png"/></div></div></figure><p id="ee8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">来了解AWS Lambda: CI/CD的操作性<strong class="it hv">最佳实践</strong>，本地测试&amp;调试功能、日志记录、监控、分布式跟踪、canary部署、配置管理、认证&amp;授权、VPC、安全性、错误处理等等。</p><p id="8bb5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还可以用代码<strong class="it hv"> ytcui </strong>获得<strong class="it hv">票面价格6折</strong>。</p><p id="96be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">点击此处获取您的副本<a class="ae lt" href="https://bit.ly/production-ready-serverless" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="be87" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lg">原载于2019年5月20日https://theburningmonk.com</em><a class="ae lt" href="https://theburningmonk.com/2019/05/a-self-healing-kinesis-function-that-adapts-its-throughput-based-on-performance/" rel="noopener ugc nofollow" target="_blank"><em class="lg"/></a><em class="lg">。</em></p></div></div>    
</body>
</html>