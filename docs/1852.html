<html>
<head>
<title>Hoisting in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Javascript 中提升</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/hoisting-in-javascript-532203715c5c#2019-03-19">https://medium.com/hackernoon/hoisting-in-javascript-532203715c5c#2019-03-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ab33f2f5dcf14f60eb51e8af2e5efe1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N017fpumKIZQOr8b"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@hojipago?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">EJ Yao</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a0bc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最近，我一直致力于理解更多的 Javascript 基础知识，并且研究了提升。我认为这是一个非常酷的概念，所以我写了一篇博文来解释它。</p><h1 id="c877" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">什么是吊装？</h1><p id="3304" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">提升是 Javascript 引擎中的一个过程，它遍历您的代码，并根据某些内容的存在分配内存。提升是我们理解这是如何工作的一种方式。</p><p id="a0fc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<a class="ae jg" href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" rel="noopener ugc nofollow" target="_blank">全局执行上下文</a>中，有两个阶段，创建阶段和执行阶段。前者提供全局对象(如浏览器中的‘窗口’)、<code class="eh li lj lk ll b">this</code>关键字和提升。后者是我们运行代码的时候。</p><p id="b837" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当 Javascript 引擎遍历您的代码时，它会查找函数声明(但不是箭头函数或函数表达式)和变量(不包括 let 或 const)。这些然后被“提升”,这将在内存中为它们分配空间。</p><h1 id="46e0" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">部分提升</h1><p id="88fc" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">首先是局部提升。这仅适用于变量。函数的处理方式不同。因此，请考虑下面的代码:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="40a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以在第一行，我们尝试用<code class="eh li lj lk ll b">console.log</code>和<code class="eh li lj lk ll b">favouriteDrink</code>变量。这里有一个问题，我们还没有定义它。所以我们真的应该得到一个参考误差，对吗？<code class="eh li lj lk ll b">undefined</code>从哪里来？</p><p id="53f5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">嗯，当 Javascript 引擎遍历上面的代码时，它看到我们有一个<code class="eh li lj lk ll b">var</code>，并意识到一个变量将被定义。它不关心变量是什么，但是它知道需要一些内存，所以它在堆中分配一些内存，这样当我们需要它的时候它就准备好了。</p><p id="ba57" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是为什么你在上面的例子中得到“未定义”的原因。你可能在编码时见过这个，对吗？这只是 Javascript 的占位符。它不会破坏脚本，但是它知道有些东西会被分配给我们的<code class="eh li lj lk ll b">favouriteDrink</code>变量。</p><p id="2b08" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很好，那么来个更棘手的例子怎么样？看看下面的代码:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="3a5c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好，我们有两个同名的变量，但是值不同。Javascript 如何处理这个问题？它不在乎。出于提升的目的，引擎会看到第一个变量声明，并在内存堆中为它分配一些空间。然后它会看到同一个变量的第二个声明，但是这个变量的值并不重要。内存已经被分配，所以引擎简单地忽略它。</p><p id="86b5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当您运行上面的代码时，我们的第二个<code class="eh li lj lk ll b">console.log</code>语句不出所料地返回 beer，因为我们获取了该变量的最新声明。</p><p id="21d0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，请记住以下内容不适用:</p><pre class="lm ln lo lp fq ls ll lt lu aw lv dt"><span id="5df7" class="lw kg hu ll b fv lx ly l lz ma">const a = 'Foo'; <br/>let b = 'Bar';</span></pre><p id="2450" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">既不<code class="eh li lj lk ll b">const</code>也不<code class="eh li lj lk ll b">let</code>被提升。</p><h1 id="66aa" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">完全提升</h1><p id="19f9" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">函数声明(但不是表达式或箭头函数)是完全提升的。这意味着该函数在内存堆中被分配了空间，但不是像我们在上一节中看到的那样简单地创建一个占位符，而是将该函数的内容存储在内存中。举个例子:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="1a7c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如我们所看到的，我们在实际编写函数之前就调用了它。这是怎么回事？函数的内容已经存储在内存中，所以 Javascript 知道你在找什么。想象一下，这个函数实际上是从我们编写它的地方取出来的，而不是放在文件的顶部。这通常是一种简单(尽管过于简单化)的视觉提升方式。相反，内存被分配到内存堆中。</p><p id="0583" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以让我们来看一个更复杂的版本:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="62a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你知道为什么我们在第一个<code class="eh li lj lk ll b">console.log</code>和第二个<code class="eh li lj lk ll b">running</code>中没有定义吗？提升发生在每个执行上下文中。每当您在 Javascript 中运行一个函数时，都会创建一个新的执行上下文，我们必须再次经历全局执行上下文中的创建和执行阶段。</p><p id="0728" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以当我们调用<code class="eh li lj lk ll b">favouriteSport()</code>时，我们创建了一个新的执行上下文，提升就发生了。所以在我们的第一个<code class="eh li lj lk ll b">console.log</code>中，我们有<code class="eh li lj lk ll b">undefined</code>，因为 Javascript 引擎创建了我们的占位符。所以在执行阶段，我们调用我们的函数，一个新的执行上下文被创建。在执行上下文中，我们只能访问函数内部的变量。变量被提升，变成<code class="eh li lj lk ll b">undefined</code>，直到我们给它提供一个值，在这个例子中是“running”。</p><p id="f4c7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后当我们再次调用<code class="eh li lj lk ll b">console.log</code>时，我们有一个值赋给我们的变量，我们得到正确的输出。有道理吗？</p><p id="75f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，以下内容不起作用:</p><figure class="lm ln lo lp fq iv"><div class="bz el l di"><div class="lq lr l"/></div></figure><p id="e24e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是因为 Javascript 不提升函数表达式或箭头函数。</p><h1 id="d5e9" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="3c7f" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">这是对吊装的快速介绍。希望你觉得这很容易理解，现在更好地理解这个概念。这其实很简单。</p><p id="8085" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">提升是一件好事吗？嗯，那要看情况。这无疑是一个令人困惑的话题，尤其是对初学者来说，而且会降低代码的可读性。另一方面，这是 Javascript 的一个奇特特性，它允许灵活地编写代码。</p><p id="8224" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">就我个人而言，我会尽可能地避免提升，以支持可读性更好的代码。我倾向于使用<code class="eh li lj lk ll b">const</code>和<code class="eh li lj lk ll b">let</code>而不是<code class="eh li lj lk ll b">var</code>，这阻止了我默认使用提升。我发现，如果你触发了一个引用错误，那么你需要查看你的代码结构，而不是依赖 Javascript 的内部来帮你解决。</p><p id="a374" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你喜欢这个，那么我推荐你去看看安德烈·尼戈伊的<a class="ae jg" href="https://www.udemy.com/advanced-javascript-concepts/" rel="noopener ugc nofollow" target="_blank">高级 Javascript 课程</a>——我发现它非常有帮助！</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><p id="544f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="mi">原载于 2019 年 3 月 19 日</em><a class="ae jg" href="https://ruairidhwm.github.io/2019/03/19/javascript-hoisting.html" rel="noopener ugc nofollow" target="_blank"><em class="mi">ruairidhwm . github . io</em></a><em class="mi">。</em></p></div></div>    
</body>
</html>