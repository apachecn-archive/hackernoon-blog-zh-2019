<html>
<head>
<title>How to Use Flutter for Hybrid Development: Alibaba’s Open Source Code Instance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Flutter进行混合开发:阿里巴巴的开源代码实例</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-use-flutter-for-hybrid-development-alibabas-open-source-code-instance-302bf2273485?source=collection_archive---------2-----------------------#2019-06-13">https://medium.com/hackernoon/how-to-use-flutter-for-hybrid-development-alibabas-open-source-code-instance-302bf2273485?source=collection_archive---------2-----------------------#2019-06-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ef3e" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">阿里巴巴的先宇如何通过使用Flutter Boost的增量迁移将Flutter混合集成到现有的原生应用中</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/85059cf67c0ca83cdd725f13fa2ce798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dRSqNGEFlqvlPlkj.png"/></div></div></figure><p id="fcd2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kr">本文是阿里巴巴</em> <a class="ae ks" rel="noopener" href="/@alitech_2017/utilizing-flutter-best-practice-from-alibaba-236a53aa32c8"> <strong class="jx hv"> <em class="kr">利用旋舞</em> </strong> </a> <em class="kr">系列的一部分。</em></p><p id="c95e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一定规模的app通常都有一套成熟的、通用的基础库，尤其是阿里巴巴体系内的app，一般都依赖于体系内的很多基础库。使用Flutter从零开始重新开发一个app的成本和风险都很高。因此，原生应用中的增量迁移是Flutter技术应用于现有原生应用的一种健壮方式。</p><p id="b9e7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt">The tech team from Xianyu (闲鱼), Alibaba’s second-hand trading platform, has developed a unique hybrid technology solution in this practice.</p><h1 id="6b40" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">现状与思考</h1><p id="1eb0" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">仙宇目前采用的混动方案是共用同一个发动机。这个解决方案是基于在任何时候最多只能看到一个页面的事实。在一些特定的场景中可以看到几个ViewControllers，但是这里不讨论这些场景。</p><p id="03d4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们可以这样简单地理解这个解决方案:我们把共享的Flutter视图看作一个画布，然后用一个原生容器作为逻辑页面。我们每次打开一个容器，就用通讯机制通知Flutter视图渲染当前逻辑页面，然后把Flutter视图放到当前容器中。</p><p id="dfc0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种解决方案不能同时支持多个水平逻辑页面，因为页面切换时必须从栈顶执行操作，不能在保持状态的同时执行水平切换。例如，对于两个页面A和B，B当前位于堆栈的顶部。要切换到A，需要从栈顶弹出B。这时候B的地位就丧失了。如果要切换回B，只能重新打开B，页面状态无法维持。</p><p id="a0ed" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">并且，在pop过程中，官方的Flutter对话框可能会被误杀。此外，基于堆栈的操作依赖于对Flutter框架的属性修改，这使得该解决方案具有侵入性。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lq"><img src="../Images/43acf2922a9e46064e66fa241d839f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lcAVt-v9ccbMegix.png"/></div></div></figure><h1 id="404d" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">FlutterBoost:新一代混合动力技术解决方案</h1><p id="1b48" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">颤振推进项目已经在GitHub中开源。通过此链接查看:<a class="ae ks" href="https://github.com/alibaba/flutter_boost" rel="noopener ugc nofollow" target="_blank">https://github.com/alibaba/flutter_boost</a></p><h1 id="f97c" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">重构计划</h1><p id="37fe" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">在仙域推广Flutter的时候，更复杂的页面场景已经逐渐暴露了旧解决方案的局限性和问题。因此，我们推出了一个新的混合技术解决方案，代号为FlutterBoost(向C++ Boost库致敬)。新混合解决方案的主要目标如下:</p><ul class=""><li id="9c08" class="lr ls hu jx b jy jz kb kc ke lt ki lu km lv kq lw lx ly lz dt translated">可重用通用混合解决方案</li><li id="9e60" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">支持更复杂的混合模式，比如支持主页标签</li><li id="8067" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">非侵入性解决方案:不再依赖修改颤振的解决方案</li><li id="2123" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">支持通用页面生命周期</li><li id="0e5f" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">统一清晰的设计理念</li></ul><p id="f413" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">与旧方案类似，新方案依然采用共享引擎模式。主要思想是原生容器用消息驱动Flutter页面容器，从而实现原生容器和Flutter容器的同步。我们希望Flutter呈现的内容是由Naitve容器驱动的。</p><p id="de5e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">简单来说，我们想把Flutter容器做成浏览器。我们输入一个页面地址，然后容器管理页面呈现。在原生端，我们只需要考虑如何初始化容器，然后设置容器对应的页面标志。</p><h1 id="3419" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">主要概念</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mf"><img src="../Images/716ac6bca81a3942427bbf472669952b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u_W2baxPRxVp9YIV.png"/></div></div></figure><h1 id="3710" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">原生层</h1><ul class=""><li id="3bad" class="lr ls hu jx b jy ll kb lm ke mg ki mh km mi kq lw lx ly lz dt translated">容器:本机容器、平台控制器、活动和视图控制器</li><li id="95a9" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">集装箱经理:集装箱的经理</li><li id="8c9c" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">适配器:Flutter是适配层</li><li id="d994" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">消息传递:基于通道的消息通信</li></ul><h1 id="2a7c" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">省道层</h1><ul class=""><li id="ce68" class="lr ls hu jx b jy ll kb lm ke mg ki mh km mi kq lw lx ly lz dt translated">容器:Flutter用来存放小部件的容器，具体实现为Navigator的派生类。</li><li id="3b86" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">容器管理器:管理Flutter容器并提供API，比如Show和Remove。</li><li id="aa77" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">协调器:接收消息传递消息并负责调用容器管理器的状态管理的协调器。</li><li id="b564" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">消息传递:基于通道的消息通信</li></ul><h1 id="8d7c" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">对页面的理解</h1><p id="a6cb" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Native和Flutter表达的页面的对象和概念是不一致的。在Native中，页面通常表示为ViewController和Activity。然而，在Flutter中，页面被表示为一个小部件。我们希望统一页面的概念，或者弱化和抽象掉与Flutter中的小部件相对应的页面的概念。换句话说，当本地页面容器存在时，FlutterBoost确保将小部件用作容器内容。因此，当我们理解和执行路由操作时，应该以原生容器为准。Flutter小部件取决于本地页面容器的状态。</p><p id="6801" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然后，当谈到FlutterBoost中的页面时，我们指的是原生容器及其附属的小部件。所有的页面路由操作，以及打开或关闭页面，实际上都是对原生页面容器的直接操作。无论路由请求来自哪里，最终都会转发给Native来实现路由操作。这也是FlutterBoost接入时需要实现平台协议的原因。</p><p id="be15" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另一方面，我们无法控制服务代码通过Flutter本身的导航器推送新的小部件。如果服务直接使用Navigator操作小部件而不使用FlutterBoost，包括非全屏小部件，比如Dialog，我们建议服务自己管理其状态。这种类型的小部件不属于FlutterBoost定义的页面。</p><p id="dc88" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">理解这里的页面概念对于理解和使用FlutterBoost至关重要。</p><h1 id="0c0d" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">与旧解决方案的主要区别</h1><p id="9ad5" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">我们前面提到过，旧的解决方案在Dart层为小部件切换维护一个单一的导航器堆栈结构。新的解决方案在Dart端引入了容器概念。不是使用栈结构来维护现有页面，而是以平面键-值映射的形式维护所有当前页面，并且每个页面都有一个唯一的ID。这种结构自然支持页面的搜索和切换，不再受制于栈顶操作。所以可以解决一些之前pop带来的问题。此外，页面堆栈操作不需要通过修改Flutter源代码来执行，消除了实现的侵入性。</p><p id="ade7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">其实我们介绍的容器就是导航器，也就是一个原生容器对应一个导航器。这是如何工作的？</p><h1 id="4370" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">多导航器的实现</h1><p id="9bd7" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Flutter提供了在底层定制导航器的接口，我们实现了一个管理多个导航器的对象。目前，最多只有一个可见的颤振导航仪可用。此导航器中包含的页面是对应于当前可见容器的页面。</p><p id="5907" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">原生容器和Flutter容器(导航器)一一对应，它们的生命周期也是同步的。当一个本地容器被创建时，一个Flutter容器也被创建，并且它们通过相同的ID链接。当本机容器被销毁时，Flutter容器也被销毁。Flutter容器的状态依赖于原生容器，也就是我们所说的原生驱动。管理器集中管理和切换当前显示在屏幕上的容器。</p><p id="79a0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们用一个简单的例子来描述创建新页面的过程:</p><ol class=""><li id="47ac" class="lr ls hu jx b jy jz kb kc ke lt ki lu km lv kq mj lx ly lz dt translated">创建一个原生容器(iOS ViewController、Android Activity或Fragment)。</li><li id="0095" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq mj lx ly lz dt translated">本地容器通过消息机制通知Flutter协调器新的容器被创建。</li><li id="9aad" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq mj lx ly lz dt translated">然后通知Flutter容器管理器创建相应的Flutter容器，并在其中加载相应的小部件页面。</li><li id="6cea" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq mj lx ly lz dt translated">当本地容器显示在屏幕上时，容器向Flutter Coordinator发送一条消息，通知要显示的页面的ID。</li><li id="c5bc" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq mj lx ly lz dt translated">Flutter容器管理器找到相应ID的Flutter容器，并将其设置为前台可见容器。</li></ol><p id="3a3f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这是创建新页面的主要逻辑。销毁和进入后台等操作也是由原生容器事件驱动的。</p><h1 id="1f22" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">官方提出的混合解决方案</h1><h1 id="cfd5" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">它是如何工作的</h1><p id="0d3b" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">颤振技术链主要由C++实现的颤振引擎和Dart实现的框架组成(这里不讨论编译和构造工具)。Flutter引擎负责线程管理、Dart VM状态管理和Dart代码加载。Dart代码实现的框架是服务暴露的主要API。概念，比如小部件，是Dart级别的框架内容。</p><p id="3999" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一个进程中最多只能初始化一个Dart虚拟机。然而，一个流程可以有多个Flutter引擎，并且多个引擎实例共享同一个Dart VM。</p><p id="cb83" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们来看看具体的实现。每次在iOS上初始化FlutterViewController时，都会初始化一个引擎，这意味着会有一个新的线程(理论上线程可以重用)运行Dart代码。对于像Android这样的活动也可以达到类似的效果。如果启动了多个引擎实例，请注意，Dart虚拟机仍然是共享的，但是由不同引擎实例加载的代码在其独立的隔离区中运行。</p><h1 id="3734" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">官方建议</h1><h2 id="dde4" class="mk ku hu bd kv ml mm mn kz mo mp mq ld ke mr ms lf ki mt mu lh km mv mw lj mx dt translated">深度引擎共享</h2><p id="e8f4" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">在混合解决方案方面，我们已经与谷歌进行了讨论，并提出了一些可能的解决方案。官方对Flutter的建议是，从长远来看，应该支持在同一个引擎中支持多窗口渲染的能力。至少在逻辑上，FlutterViewController共享同一个引擎的资源。换句话说，我们希望所有的渲染窗口共享同一个主隔离。</p><p id="110d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，官方的长期建议目前没有得到很好的支持。</p><h2 id="ae6f" class="mk ku hu bd kv ml mm mn kz mo mp mq ld ke mr ms lf ki mt mu lh km mv mw lj mx dt translated">多引擎模式</h2><p id="27f0" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">混合解决方案中要解决的主要问题是如何处理交替的Flutter和Native页面。Google工程师提供了一个Keep It Simple的解决方案:对于连续的FlutterViewController(小部件)，只需要打开当前的FlutterViewController。对于备用颤振页面，初始化一个新的发动机。</p><p id="182c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如，让我们执行以下导航操作:</p><p id="5a52" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">颤动第1页-&gt;颤动第2页-&gt;原生第1页-&gt;颤动第3页</p><p id="1da9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们只需要在颤振页面1和颤振页面3中创建不同的颤振实例。</p><p id="c755" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种解决方案的优点是容易理解，逻辑上合理，但也存在潜在的问题。如果一个原生页面和一个颤振页面一直交替，颤振引擎的数量是线性增加的，颤振引擎本身就是一个重物。</p><h2 id="30ae" class="mk ku hu bd kv ml mm mn kz mo mp mq ld ke mr ms lf ki mt mu lh km mv mw lj mx dt translated">多引擎模式的问题</h2><ul class=""><li id="73a3" class="lr ls hu jx b jy ll kb lm ke mg ki mh km mi kq lw lx ly lz dt translated">冗余资源:在多引擎模式下，每个引擎之间的隔离是相互独立的。从逻辑上讲，这不会造成任何伤害，但是引擎的底层实际上维护了图像缓存和其他消耗内存的对象。想象一下，每个引擎都维护自己的图像缓存，这可能非常占用内存。</li><li id="1c35" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">插件注册:插件依靠Messenger传递消息，而Messenger目前是由FlutterViewController (Activity)实现的。如果你有多个FlutterViewControllers，那么插件的注册和通信就会变得混乱和难以维护，消息传输的来源和目标也会变得不可控。</li><li id="4b56" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">Flutter Widget和Native的页面区别:Flutter页面是Widget，Native页面是VC。从逻辑上讲，我们希望消除抖动页面和本机页面之间的差异。否则，当我们执行页面跟踪和其他统一操作时，就会出现不必要的复杂性。</li><li id="56a7" class="lr ls hu jx b jy ma kb mb ke mc ki md km me kq lw lx ly lz dt translated">页面间通信的复杂性增加:如果所有的Dart代码运行在同一个引擎实例中，并且它们共享一个隔离区，那么就可以使用一个统一的编程框架来进行小部件间的通信。并且，多引擎实例也使得这种情况更加复杂。</li></ul><p id="bdd8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">因此，综合考虑，我们没有采用多发动机混合动力方案。</p><h1 id="2f34" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">摘要</h1><p id="92d5" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">目前，FlutterBoost已经在生产环境中支持仙游客户端上所有基于Flutter的开发服务，为更复杂的混合场景提供支持，稳定为数亿用户提供服务。</p><p id="cc21" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从项目一开始，我们就希望FlutterBoost能够解决Native App混合模式访问Flutter的一般性问题。所以我们把它做成一个可复用的Flutter插件，希望能吸引更多感兴趣的人参与到Flutter社区的建设中来。在这有限的篇幅里，我们分享了先宇在颤振混合技术解决方案上积累的经验和代码。欢迎有兴趣的人积极与我们交流。</p><h1 id="73f9" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">扩展和补充</h1><h2 id="3ffc" class="mk ku hu bd kv ml mm mn kz mo mp mq ld ke mr ms lf ki mt mu lh km mv mw lj mx dt translated">表演</h2><p id="cc8d" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">在两个Flutter页面之间切换时，我们只有一个Flutter视图，所以需要保存上一个页面的截图。如果颤振页面包含多张截图，会占用大量内存。这里，我们采用文件内存L2缓存策略，其中最多只保存2–3个截图，其余的写入文件按需加载。这样就可以在保证用户体验的同时，在内存上保持一个稳定的水平。</p><p id="2c05" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在页面渲染性能方面，AOT的优势是显而易见的。在快速页面切换时，Flutter可以灵敏地切换对应的页面，逻辑上营造出多页飘动感。</p><h2 id="9f56" class="mk ku hu bd kv ml mm mn kz mo mp mq ld ke mr ms lf ki mt mu lh km mv mw lj mx dt translated">支持1.0版</h2><p id="6870" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">项目之初，我们基于仙宇目前使用的Flutter版本进行开发，然后进行了1.0版本的兼容性升级测试。目前为止没有发现问题。</p><h2 id="b982" class="mk ku hu bd kv ml mm mn kz mo mp mq ld ke mr ms lf ki mt mu lh km mv mw lj mx dt translated">接近</h2><p id="0791" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">任何集成了Flutter的项目都可以很容易地以官方依赖的方式引入FlutterBoost作为插件，项目只需要少量的代码访问就可以完成访问。有关详细的访问文档，请参见GitHub主页上的官方项目文档。</p><p id="7824" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">颤振推进项目已经在GitHub中开源。通过此链接查看:<a class="ae ks" href="https://github.com/alibaba/flutter_boost" rel="noopener ugc nofollow" target="_blank">https://github.com/alibaba/flutter_boost</a></p><p id="2071" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt"><strong class="jx hv">(Original article by Chen Jidong陈纪栋)</strong></p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><h1 id="d3d9" class="kt ku hu bd kv kw nf ky kz la ng lc ld ja nh jb lf jd ni je lh jg nj jh lj lk dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">关于阿里巴巴最新技术的第一手深入资料→脸书:<a class="ae ks" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">【阿里巴巴科技】</strong> </a>。Twitter:<a class="ae ks" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">“AlibabaTech”</strong></a>。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="nk nl l"/></div></figure></div></div>    
</body>
</html>