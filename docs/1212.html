<html>
<head>
<title>Build a Progressive Web App In VueJs, from Zero to Hero! Part II — The Service Worker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在VueJs中构建一个进步的Web App，从零到英雄！第二部分——服务人员</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-progressive-web-app-in-vuejs-from-zero-to-hero-part-2-the-service-worker-d9babc3d756f?source=collection_archive---------2-----------------------#2019-02-20">https://medium.com/hackernoon/build-a-progressive-web-app-in-vuejs-from-zero-to-hero-part-2-the-service-worker-d9babc3d756f?source=collection_archive---------2-----------------------#2019-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/de36642bd786c3c9ef5731f7184a05cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-LFUe3N6UTDgWp1vMmd_w.png"/></div></div></figure><p id="594a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本教程中，我们将实现并讨论<strong class="je hv">服务工人</strong>，这是一项核心技术，它将原生应用程序令人惊叹的离线优先体验添加到常规web应用程序中。</p><p id="2d0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，这篇文章是教你如何用VueJS开发所谓的渐进式web应用的系列文章的第二部分！</p><p id="08b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://hackernoon.com/a-progressive-web-app-in-vue-tutorial-part-1-the-vue-app-f9231b032a0b" rel="noopener ugc nofollow" target="_blank">第一部分</a> —在<a class="ae ka" href="https://hackernoon.com/tagged/vuejs" rel="noopener ugc nofollow" target="_blank"> VueJS </a>中构建税收计算器应用。</p><p id="e236" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二部分——让应用程序离线工作。</p><p id="e0b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您还没有完成第一部分，请不要担心，您也可以直接开始构建PWA特性。我们走吧！</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="8cd1" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">离线优先范式</h2><p id="496e" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">在今天的网络上，当没有网络连接时，大多数网站和网络应用程序都会失败。这是如此普遍，以至于今天的用户甚至不会抱怨这种糟糕的体验。</p><p id="1845" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于渐进式web应用程序来说，情况就不同了，因为这些应用程序在本地应用程序和Web应用程序之间架起了一座桥梁。与网络相比，本地应用用户不会简单地接受由于糟糕的<a class="ae ka" href="https://hackernoon.com/tagged/network" rel="noopener ugc nofollow" target="_blank">网络</a>连接导致的完全崩溃。</p><p id="1a70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是为什么构建PWAs不仅需要新的技术，还需要新的范例来满足这些用户的期望。这个范例叫做<strong class="je hv">离线优先</strong>！归结为一句话:</p><blockquote class="li lj lk"><p id="13e7" class="jc jd ll je b jf jg jh ji jj jk jl jm lm jo jp jq ln js jt ju lo jw jx jy jz hn dt translated">离线优先意味着总是根据用户当前的网络条件提供最佳的体验。</p></blockquote><p id="f7f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过查看税务计算器应用程序作为我们的起点，我们可以直接了解离线优先对于应用程序开发意味着什么。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="e56c" class="lp kj hu bd kk lq lr ls ko lt lu lv ks lw lx ly kv lz ma mb ky mc md me lb mf dt translated">税收计算器应用程序</h1><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/993343a81ed5af477f36e50b0bb89fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/1*VSLBsxOk4S2dNTzS5wxnrA.gif"/></div></figure><p id="d2c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我们在本教程的第<a class="ae ka" href="https://hackernoon.com/a-progressive-web-app-in-vue-tutorial-part-1-the-vue-app-f9231b032a0b" rel="noopener ugc nofollow" target="_blank">部分</a> I中构建的VueJS应用程序。它帮助用户根据一些个人细节计算德国所得税(真的很棘手)。</p><p id="c921" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要开始使用已经完成的应用程序，请查看这个<a class="ae ka" href="https://github.com/fh48/vue-calculator-pwa" rel="noopener ugc nofollow" target="_blank"> repo </a>的<code class="eh ml mm mn mo b">07_complete</code>分支。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="ceba" class="lp kj hu bd kk lq lr ls ko lt lu lv ks lw lx ly kv lz ma mb ky mc md me lb mf dt translated">让我们让应用程序离线工作！</h1><p id="00c7" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">让我们从离线使用所得税计算器开始。通常，所有静态文件(HTML、JS、CSS、图像等。)被一次又一次地请求。由于tax calculator应用程序在前端进行计算，因此实际上并不需要服务器连接，只是为了获取这些静态文件。这意味着，要让我们的应用程序离线可用，我们只需要使用服务人员来缓存它们就可以了！</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mp"><img src="../Images/22b9109ff27f8b3a5bad9aa771f44411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZolsOWU4CKNUp0lL93scUw.png"/></div></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Chrome’s offline-dinosaur easter egg won’t be part of our app experience anymore.</figcaption></figure><p id="5dea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">听起来没那么容易，对吧？</p><p id="da29" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">事实上，大部分工作已经完成。我们的应用程序基于VueJS PWA模板，支持开箱即用的静态资产预缓存。然而，如果你不熟悉<strong class="je hv">服务工作者</strong>和<strong class="je hv">缓存API </strong>的概念，就不容易理解发生了什么。</p><p id="0cc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我们在本节开始探索这两个主题的原因！</p><h2 id="d3f1" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated"><strong class="ak">什么是服务人员？</strong></h2><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/572ab401ffdc181368c6cf60794fa9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9K--obHOXwIrsnVhFJgkw.png"/></div></div></figure><p id="7254" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">服务人员是您的浏览器在后台运行的脚本，独立于网页。它既不能直接与网页交互，也不能直接访问DOM，因为服务工作器运行在不同的线程上。服务工作者的这种性质为不需要网页或用户交互的功能打开了大门，例如网络请求的拦截和管理以及包括数据缓存。</p><p id="82d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你自己检查一下吧！转到<code class="eh ml mm mn mo b">webpack.prod.conf</code>文件，在那里我们配置<code class="eh ml mm mn mo b">sw-precache</code>来构建一个服务工人。寻找<code class="eh ml mm mn mo b">SWPrecacheWebpackPlugin</code>构造器，将<code class="eh ml mm mn mo b">minified</code>选项改为<code class="eh ml mm mn mo b">false</code>。</p><p id="c111" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，运行<code class="eh ml mm mn mo b">yarn build</code>。当我们现在检查我们的<code class="eh ml mm mn mo b">/build</code>文件夹时，我们在那里找到了<code class="eh ml mm mn mo b">service-worker.js</code>文件。服务人员是生产的唯一特征。想象一下，你的应用程序会在开发模式下缓存所有静态文件…这不是一个非常愉快的开发体验。这就是为什么我们需要<a class="ae ka" href="https://github.com/zeit/serve" rel="noopener ugc nofollow" target="_blank">服务于</a>我们的生产建设，以确保一切正常运行。</p><pre class="mh mi mj mk fq mv mo mw mx aw my dt"><span id="2fb6" class="ki kj hu mo b fv mz na l nb nc">yarn global add serve</span></pre><p id="2d1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后运行下面的命令并浏览<a class="ae ka" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a></p><pre class="mh mi mj mk fq mv mo mw mx aw my dt"><span id="ee31" class="ki kj hu mo b fv mz na l nb nc">serve dist/</span></pre><p id="0dd1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该看看你所知道的税收计算器。现在转到开发工具，网络标签。设置<code class="eh ml mm mn mo b">offline</code>勾号并刷新页面。该应用程序仍在那里，功能齐全！</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/bdb043cb9c273600002ba697df70c124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SaTFhvlHTu1hmSIeztqFMQ.png"/></div></div></figure><p id="59e5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太好了，现在我们知道什么是服务人员，以及<code class="eh ml mm mn mo b"><a class="ae ka" href="https://github.com/GoogleChromeLabs/sw-precache" rel="noopener ugc nofollow" target="_blank">sw-precache</a></code>如何让我们非常方便地设置它。然而，我们还没有探究服务人员实际上是如何缓存静态文件的。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="102a" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">缓存存储API</h2><p id="e8e6" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">首先，理解缓存的一般工作原理很重要。因此，我们来看看<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" rel="noopener ugc nofollow" target="_blank">缓存存储</a>浏览器API。这是一种相当新型的缓存层，它允许我们显式地管理资产的缓存。您可能还记得，CacheStorage与AppCache完全不同。CacheStorage不那么固执己见，更先进，这给了我们更多的自由。</p><p id="41ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">CacheStorage非常适合我们的目的，因为它允许我们在非常精细的级别上管理我们的缓存需求。基本上，我们可以为每一个单独的单个决定如何以及何时从缓存或网络提供服务。尽管我们基本上可以想出非常个性化的缓存策略，但有几个是通用的，值得了解一下。</p><p id="fa5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最常见的有<em class="ll">仅缓存</em>、<em class="ll">缓存回退到网络</em>、<em class="ll">仅网络</em>、<em class="ll">网络、回退到缓存和通用回退。</em></p><h2 id="7de3" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated"><strong class="ak">缓存优先策略</strong></h2><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/60bac2b8a819c46fddc0489df487eee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DIZpI0989VYxTabJZdxo-g.png"/></div></div></figure><p id="1ed1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的<code class="eh ml mm mn mo b">sw-precache</code>库有一个<code class="eh ml mm mn mo b">cache-first</code>策略。</p><p id="5fe8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着，当应用程序开始加载其静态文件(1)时，服务工作人员会拦截请求。接下来，服务工作者尝试从本地缓存存储提供静态文件(2)。只有当文件不可用时，它才连接到网络获取文件(3)并完成应用程序的请求(4)。</p><p id="63bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一般来说，<code class="eh ml mm mn mo b">cache-first</code>对于基本的离线优先实现来说是一个很好的策略。然而，这种策略也有一些缺点。例如，它防止用户总是看到最新版本的应用程序，因为服务人员最好提供缓存的、可能过时的应用程序版本。在<code class="eh ml mm mn mo b">sw-precache</code>的<a class="ae ka" href="https://github.com/GoogleChromeLabs/sw-precache#considerations" rel="noopener ugc nofollow" target="_blank">文档</a>中，他们建议通过以下方式进行补偿</p><blockquote class="li lj lk"><p id="0e41" class="jc jd ll je b jf jg jh ji jj jk jl jm lm jo jp jq ln js jt ju lo jw jx jy jz hn dt translated">当有新内容时，向用户显示提示/警告，让他们有机会重新加载页面以获取新内容。</p></blockquote><p id="4cb5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于我们的税收计算器来说，这不是一个大问题，否则其他缓存策略可能是更好的选择。</p><p id="adc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">您想了解更多关于缓存策略的信息吗？就把这个教程往你最感兴趣的方向开吧！参与投票，了解你真正关心的是什么！</strong></p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h2 id="25ec" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">服务人员生命周期</h2><p id="79c4" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">要成功实施上述任何一种缓存策略，熟悉服务人员的生命周期非常重要。因此，现在让我们来看看实际生命周期的简化版本。我们来看以下几个阶段:i <em class="ll">安装，激活</em>和<em class="ll">激活。</em>这些阶段<em class="ll"> </em>中的每一个都必须在工人的一生中完成。</p><figure class="mh mi mj mk fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/f1309e4019e707af49eac84ad3355070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Co7fMsWGNzGsZb5iWS6WNA.png"/></div></div></figure><p id="3cdd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当工人进入其中一个阶段时，它发出一个事件，我们可以监听。现在我们可以检查我们的服务人员实际上是如何缓存我们的静态文件的。不要让助手函数迷惑了你，我为你强调了什么是最重要的。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ni ng l"/></div></figure><p id="4d37" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">安装事件，</strong>通常用于在服务人员激活之前缓存需要可用的文件。例如，服务人员正常工作所依赖的请求。如果出现任何问题，我们只需取消安装。下次用户访问该页面时，服务人员将再次尝试安装。</p><p id="1239" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果有新的静态资产，它们会被<code class="eh ml mm mn mo b">cache.put(cacheKey, resonseToCache)</code>添加到缓存中，否则工作者会转移到下一个阶段。<code class="eh ml mm mn mo b">event.waitUntil()</code>在服务工作者中被大量使用来扩展当前状态，直到传递的回调链被解决。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ni ng l"/></div></figure><p id="2c21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">激活事件，</strong>当服务人员被激活时，它将控制我们的应用程序。需要激活一个工作线程，它才能拦截获取请求。当一个工作者被初始注册时，pages在下次加载之前不会使用它。<code class="eh ml mm mn mo b">claim()</code>方法迫使服务人员立即控制一个页面。我们还可以在这里做更多的缓存管理，从缓存中删除不再属于我们期望的URL的请求。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="fa51" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Fetch事件，</strong>Fetch事件是我们唯一没有看到的是服务工作者实际上是如何获取缓存的静态文件的。这是通过监听<code class="eh ml mm mn mo b">fetch</code>事件实现的。</p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="ni ng l"/></div></figure><p id="0f3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我跳过了如何计算<code class="eh ml mm mn mo b">shouldRespond</code>，更重要的是理解我们如何从缓存返回内容给所有的<code class="eh ml mm mn mo b">GET</code>请求。如果我们不能从缓存中提供服务，因为我们可能没有缓存请求的资源，我们只需让请求通过，从网络获取内容。</p><p id="89d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要忘记回到你的<code class="eh ml mm mn mo b">webpack.prod.conf</code>文件，将<code class="eh ml mm mn mo b">minified</code>选项重置为<code class="eh ml mm mn mo b">true.</code></p><h2 id="4542" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">服务人员得到很好的支持吗？</h2><p id="17ce" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">您可能已经对服务人员的浏览器和平台支持感到疑惑。长话短说，所有主要的浏览器厂商和平台都明确承诺扩展它们的PWA支持。</p><p id="9c9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，苹果远远落在后面，他们可能需要很长时间才能赶上。就在去年的iOS 11.3更新中，苹果开始支持服务人员的基本功能。</p><p id="b6d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" href="https://hackernoon.com/a-progressive-web-app-in-vue-tutorial-part-1-the-vue-app-f9231b032a0b" rel="noopener ugc nofollow" target="_blank">第一部分</a>的介绍中，您可以找到更多关于哪些厂商和平台承诺支持PWAs的信息。</p><p id="8dc0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是我们现在需要了解的关于服务工作者和缓存的全部内容。我们已经涵盖了使我们的应用程序成为真正的离线优先体验的基本细节！</p><p id="b5a9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">你下一步想学什么？就把这个教程往你最感兴趣的方向开吧！参与投票，了解你真正关心的是什么！</strong></p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure><p id="ba84" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读！<em class="ll">如果你喜欢这篇博文，在Twitter上关注我</em><a class="ae ka" href="https://twitter.com/Fa_Hinse" rel="noopener ugc nofollow" target="_blank"><em class="ll">@ Fa _ Hinse</em></a><em class="ll"/><em class="ll">请鼓掌👏</em></p><figure class="mh mi mj mk fq iv"><div class="bz el l di"><div class="nj ng l"/></div></figure></div></div>    
</body>
</html>