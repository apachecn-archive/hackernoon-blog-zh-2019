<html>
<head>
<title>All your containers are belong to us — deploying to Microsoft Azure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你所有的容器都属于我们——部署到微软Azure</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/all-your-containers-are-belong-to-us-deploying-to-microsoft-azure-2e9aa464a113?source=collection_archive---------4-----------------------#2019-03-07">https://medium.com/hackernoon/all-your-containers-are-belong-to-us-deploying-to-microsoft-azure-2e9aa464a113?source=collection_archive---------4-----------------------#2019-03-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir"><p id="4631" class="is it hu bd iu iv iw ix iy iz ja jb ek translated">Azure Container实例支持将Docker容器部署到Azure基础设施上，而无需配置任何虚拟机或采用更高级别的服务。</p></blockquote><figure class="je jf jg jh ji jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff jd"><img src="../Images/3c311aa7ba263366cd03300c83c78d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RRWgFQlhDNahNRnl.jpg"/></div></div></figure><p id="4611" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">在<a class="ae kn" href="https://twitter.com/chris_noring" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我，很乐意接受您对主题或改进的建议/Chris</p><p id="c090" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">那是1989年。游戏Zero Ving刚刚在日本发行。游戏的创造者Toaplan一点也不知道他们的游戏会在2019年成为传奇，因为你作为一个用户在输掉游戏时面临的屏幕。<em class="ko">你所有的基地都是属于我们的</em>——也就是说，你已经输了。容器当然不是这样，使用容器你会大获全胜，当你把它们带到云上时更是如此。</p><blockquote class="kp kq kr"><p id="c46c" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated">今天，在一个或多个容器中开发和交付应用程序变得越来越普遍。Docker是最常见的容器化软件之一。这是一个很棒的工具，可以很容易地创建图像和容器，还可以监控它们。如果我们能继续使用Docker，并把我们的应用程序带到云端，那不是很好吗</p></blockquote><p id="9939" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">在本文中，我们将执行以下操作:</p><ul class=""><li id="0686" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated"><strong class="js hv">解释</strong>，为什么我们可能需要云</li><li id="b51a" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">从GitHub克隆</strong>应用程序源代码，让我们更专注于将应用程序发布到云上，而不是从头开始编写，所以让我们使用一个现有的应用程序</li><li id="74b5" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">从应用程序源创建</strong>一个容器映像，这是我们需要做的一个预备步骤</li><li id="30ca" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">在本地Docker环境中测试映像，在我们将您的软件推向云之前，在本地测试它总是一个好的做法</strong></li><li id="567f" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated">创建一个容器注册表，这是Azure上存储Docker图片的东西</li><li id="65c8" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">部署</strong>我们的应用程序，我们可以从容器注册表中的一个映像创建一个容器实例</li></ul><h1 id="3ac4" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">资源</h1><p id="12e2" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">如果你错过了我们在这篇文章中提到的链接。他们在这里:</p><ul class=""><li id="7ef5" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated">安装Azure CLI </li><li id="280c" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><a class="ae kn" href="https://docs.microsoft.com/en-us/azure/container-instances/container-instances-tutorial-deploy-app?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank">本文基于</a>的教程</li><li id="aa11" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><a class="ae kn" href="https://docs.microsoft.com/en-us/cli/azure/container?view=azure-cli-latest#az-container-create?wt.mc_id=medium-blog-chnoring" rel="noopener ugc nofollow" target="_blank"> az容器命令</a></li><li id="7e88" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><a class="ae kn" href="https://aka.ms/learn-container-registry" rel="noopener ugc nofollow" target="_blank">学习集装箱登记模块</a></li><li id="5fd0" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><a class="ae kn" href="https://itnext.io/docker-from-the-beginning-part-i-ae809b84f89f" rel="noopener ugc nofollow" target="_blank"> Docker教程系列</a></li></ul><h1 id="6a08" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">云的承诺</h1><p id="a131" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">使用容器技术允许我们将应用程序分成许多服务。最重要的是，它提供了一个安全可靠的应用交付选项。现在，下一个问题来了，我们将它交付到哪里，本地还是云？</p><p id="ae46" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">这篇文章是关于将你的应用程序交付到云中的，所以当然，我们有点偏颇。让我简短地解释一下为什么我们认为云是应用程序的绝佳选择:</p><ul class=""><li id="81b9" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated">性价比，从你只需为你实际使用的东西付费的意义上来说，它是性价比高的。在本地场景中，您可能需要为您认为会增加的用户和使用量支付服务器、CPU、内存等费用。这是一笔很大的现金支出，你需要问自己，我是否愿意花时间去寻找我需要的东西，同时也愿意花时间和金钱去升级它？</li><li id="b366" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">可扩展</strong>，云可以轻松实现横向和纵向扩展，增加一名新员工不成问题，增加更多服务器和数据库也不成问题，我们可以在几分钟内完成</li><li id="f0c2" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">弹性</strong>，想象你是一家电子商务公司，在节假日或者黑色星期五之类的时候用户突然激增。云可以动态地添加您需要的额外资源来应对这种情况，当然，当用户数量下降到更正常的水平时，它可以动态地缩减规模</li></ul><h1 id="9f45" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">先决条件</h1><p id="d38a" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">您需要安装以下软件</p><ul class=""><li id="65e1" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated">Docker，这里有针对Linux、Mac和Windows的不同指南，查看<a class="ae kn" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">官方文档</a>以了解如何为您的操作系统安装Docker</li><li id="5cc4" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated">Azure CLI <a class="ae kn" href="https://docs.microsoft.com/cli/azure/install-azure-cli" rel="noopener ugc nofollow" target="_blank">安装</a></li></ul><h1 id="3359" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">克隆应用程序</h1><p id="1eb8" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">我们最初说过，我们将更多地关注如何部署而不是编写应用程序，因此，我们将使用一个预制的应用程序，您可以从这里下载:</p><blockquote class="kp kq kr"><p id="6bf5" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> git克隆</em><a class="ae kn" href="https://github.com/Azure-Samples/aci-helloworld.git" rel="noopener ugc nofollow" target="_blank"><em class="hu">https://github.com/Azure-Samples/aci-helloworld.git</em></a></p></blockquote><p id="3213" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">看着它，你会发现它是一个非常简单的运行Express的<code class="eh mm mn mo mp b">Node.js</code>应用程序。为了便于演示，存储库中有两个感兴趣的文件:</p><ul class=""><li id="881a" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated"><code class="eh mm mn mo mp b">app/index.js</code>，这是应用程序的入口点</li><li id="c0d9" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><code class="eh mm mn mo mp b">Dockerfile</code>，这是docker文件，它将帮助我们将应用程序构建成一个图像，并最终成为一个包含应用程序的容器。</li></ul><p id="6664" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">让我们来看看<code class="eh mm mn mo mp b">app/index.js</code>文件:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="110f" class="my lk hu mp b fv mz na l nb nc">const express = require('express'); <br/>const morgan = require('morgan'); <br/>const app = express(); </span><span id="722c" class="my lk hu mp b fv nd na l nb nc">app.use(morgan('combined')); </span><span id="5c2e" class="my lk hu mp b fv nd na l nb nc">app.get('/', (req, res) =&gt; { res.sendFile(__dirname + '/index.html') }); </span><span id="25e7" class="my lk hu mp b fv nd na l nb nc">var listener = app.listen(process.env.PORT || 80, function() {<br/>  console.log('listening on port ' + listener.address().port); <br/>});</span></pre><p id="c25d" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">从上面我们可以看到，这是一个非常标准的<code class="eh mm mn mo mp b">Node.js + Express</code>应用程序，这里没有魔法。</p><p id="0362" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">现在让我们来看看<code class="eh mm mn mo mp b">Dockerfile</code>:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="191d" class="my lk hu mp b fv mz na l nb nc">FROM node:8.9.3-alpine </span><span id="c37b" class="my lk hu mp b fv nd na l nb nc">RUN mkdir -p /usr/src/app </span><span id="1009" class="my lk hu mp b fv nd na l nb nc">COPY ./app/ /usr/src/app/ </span><span id="5256" class="my lk hu mp b fv nd na l nb nc">WORKDIR /usr/src/app </span><span id="aafb" class="my lk hu mp b fv nd na l nb nc">RUN npm install </span><span id="fcc1" class="my lk hu mp b fv nd na l nb nc">CMD node /usr/src/app/index.js</span></pre><p id="bda7" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">它执行以下操作:</p><ul class=""><li id="22ca" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated"><strong class="js hv">选择一个操作系统镜像</strong>，简而言之，我们基于Ubuntu和一个名为alpine的发行版，它预装了Node.js。</li><li id="c8bb" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">创建一个目录</strong>，命令如下<code class="eh mm mn mo mp b">mkdir -p /usr/src/app</code></li><li id="6a15" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">复制从<code class="eh mm mn mo mp b">./app/</code>到<code class="eh mm mn mo mp b">/usr/src/app/</code>的所有文件</strong></li><li id="00be" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">将工作目录</strong>设置为<code class="eh mm mn mo mp b">/usr/src/app</code></li><li id="d24a" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">使用<code class="eh mm mn mo mp b">npm install</code>安装我们的节点依赖关系</strong></li><li id="b961" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv">使用<code class="eh mm mn mo mp b">node /usr/src/app/index.js</code>启动我们的应用</strong></li></ul><p id="835a" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">总而言之，这是一个非常标准的外观<code class="eh mm mn mo mp b">Dockerfile</code>。</p><h1 id="196e" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">建立形象</h1><p id="94b1" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">构建图像是我们在实际启动应用程序之前需要做的预备步骤。构建步骤将获取我们需要的操作系统映像，下载相关库，复制我们的应用程序代码，等等。</p><p id="a70a" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">我们可以使用<code class="eh mm mn mo mp b">docker build</code>命令来构建一个图像。我们需要使用的确切命令是:</p><blockquote class="kp kq kr"><p id="ff25" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu">码头工人建造。/ACI-hello world-t ACI-tutorial-app</em></p></blockquote><p id="f008" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">上面的命令在目录<code class="eh mm mn mo mp b">/aci-helloworld</code>中查找Dockerfile并创建一个名为<code class="eh mm mn mo mp b">aci-tutorial-app</code>的映像。运行该命令应该会产生如下所示的输出:</p><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff ne"><img src="../Images/bc512c41f1f5805bd78b29ddf30f4a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9bN6bBzkApBIIMWa.png"/></div></div></figure><p id="1dd8" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">上面显示了我们在<code class="eh mm mn mo mp b">Dockerfile</code>中设置的所有步骤，例如:</p><ul class=""><li id="9000" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated">关闭操作系统映像，复制我们的应用程序</li><li id="bdbc" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated">设置一个<code class="eh mm mn mo mp b">WORKDIR</code>，</li><li id="efaf" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated">通过运行<code class="eh mm mn mo mp b">NPM INSTALL</code>安装依赖项，</li><li id="b023" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated">用<code class="eh mm mn mo mp b">CMD node /user/scr/app/index.js</code>启动应用程序</li></ul><p id="acc2" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">如果运行以下命令，我们可以看到创建的映像:</p><blockquote class="kp kq kr"><p id="5445" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> docker图像</em></p></blockquote><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff nf"><img src="../Images/65bc1159d755f17e69481d59eb82f15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JQWuBSdMkxHdS9fl.png"/></div></div></figure><p id="21a5" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">好，那么，我们有一个图像，这意味着我们准备好了我们的下一步；在本地测试。</p><h1 id="9b21" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">通过实例化一个容器来测试图像</h1><p id="34dd" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">现在我们有了一个图像，我们可以使用<code class="eh mm mn mo mp b">docker run</code>从它创建一个容器。完整的命令如下所示:</p><blockquote class="kp kq kr"><p id="bb92" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu">docker run-d-p 8080:80 ACI-tutorial-app</em></p></blockquote><p id="12fd" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">让我们来看看论点:</p><ul class=""><li id="a6f8" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated"><code class="eh mm mn mo mp b">-d</code>，这告诉容器在后台运行</li><li id="b12d" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><code class="eh mm mn mo mp b">-p</code>，这允许我们映射端口，参数值应该这样解释[外部端口]:[容器内部端口]</li></ul><p id="86fe" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">我们可以看到外部端口是<code class="eh mm mn mo mp b">8080</code>，这意味着我们可以导航到</p><blockquote class="kp kq kr"><p id="bb9e" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><a class="ae kn" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"><em class="hu">http://localhost:8080</em></a><em class="hu">确保我们的应用程序正常工作。</em></p></blockquote><p id="4a7a" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">这是我们得到的图像，所以我会说我们的容器正在工作:</p><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff ng"><img src="../Images/baab76ee46848564fad5ec0837cd401e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gC-W5TBle9rjKc2B.png"/></div></div></figure><p id="6da4" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">使用以下命令，我们可以列出所有正在运行的容器:</p><blockquote class="kp kq kr"><p id="211f" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> docker ps它应该呈现以下结果:</em></p></blockquote><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff nh"><img src="../Images/ccff3f613a49cb3464b7595649bf7286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FeVciiE1XIrIFkDy.png"/></div></div></figure><p id="92ad" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">我们不希望容器运行并耗尽资源，所以让我们关闭它。我们想运行命令<code class="eh mm mn mo mp b">docker kill</code>来关闭容器，但是，这个命令需要一个参数，它需要<code class="eh mm mn mo mp b">container id</code>。还记得我们跑<code class="eh mm mn mo mp b">docker ps</code>的时候吗？第一栏是我们的<code class="eh mm mn mo mp b">container id</code>。虽然我们不需要完整的id，但是前4个字符就足够了。所以让我们开始指挥吧</p><blockquote class="kp kq kr"><p id="5e67" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> docker kill【容器id，4个前字符】docker ps //应该是空单就是这样。下面是我们刚刚运行的命令的屏幕截图:</em></p></blockquote><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff nh"><img src="../Images/cb7959a765d308d0a2bbd0abd1b01cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fR4v--hD-wqE3qyL.png"/></div></div></figure><h1 id="9769" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">创建容器注册表</h1><blockquote class="ir"><p id="cc23" class="is it hu bd iu iv ni nj nk nl nm jb ek translated">Azure容器注册中心是你在Azure中的私有Docker注册中心。</p></blockquote><p id="df6d" class="pw-post-body-paragraph jq jr hu js b jt nn jv jw jx no jz ka kb np kd ke kf nq kh ki kj nr kl km jb hn dt translated">我们需要<code class="eh mm mn mo mp b">Docker</code>、<code class="eh mm mn mo mp b">Docker Engine</code>和<code class="eh mm mn mo mp b">Azure CLI</code>来完成这项工作。此时我们已经安装了<code class="eh mm mn mo mp b">Docker</code>，让我们看看如何安装<code class="eh mm mn mo mp b">Azure CLI</code>:</p><blockquote class="kp kq kr"><p id="81f3" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><a class="ae kn" href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest" rel="noopener ugc nofollow" target="_blank"><em class="hu">https://docs . Microsoft . com/en-us/CLI/azure/install-azure-CLI？view = azure-CLI-最新</em> </a></p></blockquote><p id="160a" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">在我们创建这个注册表之前，我们需要一个<code class="eh mm mn mo mp b">Resource Group</code>。一个<code class="eh mm mn mo mp b">Resource Group</code>是一个逻辑容器，我们需要在其中放置所有的资源，如应用程序、数据库和现在的<code class="eh mm mn mo mp b">Resource Group</code>。同一组中的所有内容都可以轻松安全地进行通信。</p><p id="aa7c" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">所以让我们先创建它:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="6033" class="my lk hu mp b fv mz na l nb nc">az group create --name [your name for a resource group] --location westeurope</span></pre><p id="bf07" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">一旦创建了这个<code class="eh mm mn mo mp b">Resource Group</code>，我们就可以继续创建我们的<code class="eh mm mn mo mp b">Container Registry</code>。</p><p id="0c3e" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">该命令如下所示:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="3be4" class="my lk hu mp b fv mz na l nb nc">az acr create --resource-group [your name for your resource group] --name [your name for a registry] --sku Basic --admin-enabled true</span></pre><p id="4d6b" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">让我们把它分解一下。</p><blockquote class="kp kq kr"><p id="8727" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> az acr创建</em></p></blockquote><p id="d709" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">是创建我们的<code class="eh mm mn mo mp b">Container Registry</code>的实际命令。那么我们需要一些论据:</p><ul class=""><li id="043b" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated"><code class="eh mm mn mo mp b"><strong class="js hv">--resource-group</strong></code>，这个参数应该是我们新创建的<code class="eh mm mn mo mp b">Resource Group</code></li><li id="2c94" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><code class="eh mm mn mo mp b"><strong class="js hv">--name</strong></code>，这是我们给注册中心起的名字，例如<code class="eh mm mn mo mp b">containerregistry</code></li><li id="dbc1" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><code class="eh mm mn mo mp b"><strong class="js hv">--sku</strong></code>，这是价格方案，我们选择最便宜的一款叫做<code class="eh mm mn mo mp b">Basic</code></li></ul><p id="d9d6" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">您应该得到如下所示的输出:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="5f6e" class="my lk hu mp b fv mz na l nb nc">{ <br/>  "adminUserEnabled": true, <br/>  "creationDate": "2018-03-16T21:54:47.297875+00:00", <br/>  "id": "/subscriptions/&lt;Subscription ID&gt;/resourceGroups/myResourceGroup/providers/Microsoft.ContainerRegistry/registries/mycontainerregistry082", <br/>  "location": "eastus", <br/>  <strong class="mp hv">"loginServer": "[your container registry name].azurecr.io"</strong>, <br/>  <strong class="mp hv">"name": "containerregistry"</strong>, <br/>  "provisioningState": "Succeeded", <br/>  "resourceGroup": "myResourceGroup", <br/>  "sku": { "name": "Basic", "tier": "Basic" }, <br/>  "status": null, <br/>  "storageAccount": null, <br/>  "tags": {}, <br/>  "type": "Microsoft.ContainerRegistry/registries" <br/>}</span></pre><p id="b92f" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">重要的部分是用值<code class="eh mm mn mo mp b">Succeeded</code>返回一个<code class="eh mm mn mo mp b">provisionState</code>。</p><h1 id="0389" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">登录我们的注册表</h1><p id="7a0e" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">我们需要登录我们的注册表，然后才能将docker图像推送到它。让我们登录:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="6774" class="my lk hu mp b fv mz na l nb nc">az acr login --name [name of container registry]</span></pre><p id="15ed" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">那会告诉你是否一切正常</p><p id="98c5" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">您的输出应该如下所示:</p><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff ns"><img src="../Images/40a0f9a2ef58767a876284b67b6d88b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KiDvmXjHaLBykxF0.png"/></div></div></figure><p id="b977" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">上面你可以看到我选择调用注册表<code class="eh mm mn mo mp b">chriscontainerregistry</code> put，你必须用你选择的名字替换它。</p><h1 id="e950" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">标签容器图像</h1><p id="70e5" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">要将容器映像推送到像Azure Container Registry这样的私有注册中心，必须首先用<code class="eh mm mn mo mp b">registry's login server</code>的全名标记该映像。</p><p id="6842" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">这一点可以在创建注册表时通过查看JSON输出来找到。您正在寻找一个名为<code class="eh mm mn mo mp b">"loginServer"</code>的物业。其格式为<code class="eh mm mn mo mp b">[your registry name].azurecr.io</code>。在我的情况下，那将是<code class="eh mm mn mo mp b">chriscontainerregistry.azurecr.io</code>。</p><p id="784e" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">因此，要么您记住我们创建容器注册表时的名称<code class="eh mm mn mo mp b">loginServer</code>，要么您可以随时通过调用以下命令来检索<code class="eh mm mn mo mp b">loginServer</code>:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="fdef" class="my lk hu mp b fv mz na l nb nc">az acr show --name [container registry name] --query loginService --output table</span></pre><p id="54a3" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">这将为我们提供打印在终端中的<code class="eh mm mn mo mp b">loginServer</code>名称。当然，在我们的例子中,<code class="eh mm mn mo mp b">[container registry name]</code>是值<code class="eh mm mn mo mp b">chriscontainerregistry</code>,因此根据您选择的名称进行相应的调整。</p><p id="d125" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">让我们现在回到码头。我们需要用容器注册表的<code class="eh mm mn mo mp b">loginServer</code>标记<code class="eh mm mn mo mp b">aci-tutorial-app</code>图像的<em class="ko">标签</em>。</p><p id="d703" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">我们用以下命令标记它:</p><blockquote class="kp kq kr"><p id="fbc1" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> docker标签ACI-tutorial-app/ACI-tutorial-app:v1</em></p></blockquote><p id="a9da" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">我们来分解一下。</p><ul class=""><li id="482c" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated">这是我们图像的名字，如果你想验证的话，运行<code class="eh mm mn mo mp b">docker image</code></li><li id="c752" class="kv kw hu js b jt le jx lf kb lg kf lh kj li jb la lb lc ld dt translated"><strong class="js hv"> /aci-tutorial-app:v1 </strong>，这将对图像进行标记，这样就有可能将其推送到我们的容器注册表中。需要注意的是，<code class="eh mm mn mo mp b">:v1</code>这是一个版本号，但是我们可以很容易地称之为<code class="eh mm mn mo mp b">LATEST</code>或者今天的日期，关键是要有一个系统，这样你就知道你是否想要使用一个特定的图像</li></ul><p id="443b" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">因此，在我们的例子中，使用正确值的正确命令应该是:</p><blockquote class="kp kq kr"><p id="45ca" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> docker标签aci-tutorial-app【容器注册表名称】. azure Cr . io/ACI-tutorial-app:v1</em></p></blockquote><p id="95ae" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">此时运行<code class="eh mm mn mo mp b">docker images</code>命令，验证它是否被正确创建。它应该是这样的:</p><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff nt"><img src="../Images/037b853f22bb0c5cbbf30996cc8d94b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JeCzs4DqyMQxP7HI.png"/></div></div></figure><h1 id="1c17" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">将映像推送到存储库</h1><p id="2359" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">现在，我们实际上可以将图像推送到存储库。我们通过执行以下命令来实现这一点:</p><blockquote class="kp kq kr"><p id="1f8d" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu">docker push/ACI-tutorial-app:v1</em></p></blockquote><p id="87af" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">有了所有正确的值，它将是:</p><blockquote class="kp kq kr"><p id="da56" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu">码头工人推chriscontainerregistry.azurecr.io/aci-tutorial-app:v1</em></p></blockquote><p id="ca17" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">您可能需要先登录，在这种情况下，您可以运行以下命令:</p><blockquote class="kp kq kr"><p id="1e07" class="jq jr ko js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km jb hn dt translated"><em class="hu"> az acr登录名称【集装箱注册名称】</em></p></blockquote><p id="ec05" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">执行<code class="eh mm mn mo mp b">docker push</code>应产生以下结果:</p><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff nu"><img src="../Images/0053d294b0133fc4a54fb6af2f0c6dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*djK7j8oHgGEAs8Qe.png"/></div></div></figure><h1 id="771a" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">列出存储库中的图像</h1><p id="6872" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">好了，现在我们实际上想看看我们有什么图片，剧透一下，应该是我们刚刚上传的那张；)</p><p id="1ce0" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">我们可以运行以下命令:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="16ad" class="my lk hu mp b fv mz na l nb nc">az acr repository list --name --output table</span></pre><p id="31fa" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">使用<code class="eh mm mn mo mp b">acrName</code>的正确值，它看起来像这样:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="0d23" class="my lk hu mp b fv mz na l nb nc">az acr repository list --name [name of container registry] --output table</span></pre><p id="3b0a" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">这就是我们唯一推送的图片:)</p><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff nv"><img src="../Images/55ed22d729f30d3fd3bffb9775490813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s9Qsw841eAU1qgUh.png"/></div></div></figure><h1 id="0ca6" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">部署应用程序</h1><p id="0283" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">既然我们在存储库中有了我们的映像，我们可以告诉存储库从我们的映像创建一个容器，从而部署我们的应用程序。</p><p id="00b5" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">要运行我们的部署命令，我们首先需要一些信息，即:</p><ul class=""><li id="f6d7" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated">登录服务器，我们可以对其运行以下命令</li></ul><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="cde1" class="my lk hu mp b fv mz na l nb nc">az acr show --name --query loginServer</span></pre><ul class=""><li id="4e36" class="kv kw hu js b jt ju jx jy kb kx kf ky kj kz jb la lb lc ld dt translated">用户名和密码，为此我们运行以下命令:</li></ul><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="a073" class="my lk hu mp b fv mz na l nb nc">az acr credential show --name --query "passwords[0].value"</span></pre><p id="c9b2" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">这将返回密码</p><p id="b98e" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">好了，现在我们来看看deploy命令，它看起来可能有点吓人:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="f239" class="my lk hu mp b fv mz na l nb nc">az container create --resource-group myResourceGroup --name aci-tutorial-app --image &lt;acrLoginServer&gt;/aci-tutorial-app:v1 --cpu 1 --memory 1 --registry-login-server &lt;acrLoginServer&gt; --registry-username &lt;acrName&gt; --registry-password &lt;acrPassword&gt; --dns-name-label &lt;aciDnsLabel&gt; --ports 80</span></pre><p id="693a" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">创建容器的方法有很多，如果你对其他方法感兴趣，看看这个链接<a class="ae kn" href="https://docs.microsoft.com/en-us/cli/azure/container?view=azure-cli-latest#az-container-create" rel="noopener ugc nofollow" target="_blank"> az容器创建</a></p><h1 id="20ea" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">检查进度和日志</h1><p id="56ac" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">如果部署需要一段时间，您可以使用以下命令同时检查状态:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="04bc" class="my lk hu mp b fv mz na l nb nc">az container show --resource-group [name or resource group] --name aci-tutorial-app --query instanceView.state</span></pre><p id="4f0d" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">在一个很长的JSON回复后，寻找<code class="eh mm mn mo mp b">provisioningState: Succeded</code>，如果你有，你是好的。</p><p id="5833" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">让我们用下面的命令来看看我们的容器:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="40f2" class="my lk hu mp b fv mz na l nb nc">az container show --resource-group [name of resource group] --name aci-tutorial-app --query ipAddress.fqdn</span></pre><p id="2cff" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">我们可以通过运行以下命令来查看应用程序的日志:</p><pre class="mq mr ms mt fq mu mp mv mw aw mx dt"><span id="4d9b" class="my lk hu mp b fv mz na l nb nc">az container logs --resource-group [name of resource group] --name aci-tutorial-app</span></pre><p id="6271" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated"><em class="ko">这将告诉我们在端口80上运行</em></p><h1 id="345e" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">访问部署的应用程序</h1><p id="835c" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">一旦部署完毕，我们就可以通过<code class="eh mm mn mo mp b">--dns-name-label</code>值访问应用程序，就像这样:</p><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="fe ff nw"><img src="../Images/776929bb1a7dd7d9ded4bf6c5e897a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5gyujKk-20U1ncVe.png"/></div></div></figure><figure class="mq mr ms mt fq jj fe ff paragraph-image"><div class="fe ff nx"><img src="../Images/c3af8d0413a17fa901319583fe645ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*0HSGTTEYve-fRbPd.gif"/></div></figure><h1 id="3b90" class="lj lk hu bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">摘要</h1><p id="ea93" class="pw-post-body-paragraph jq jr hu js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km jb hn dt translated">我们开始部署一个应用程序。这次我们想要部署一个docker容器。为此，我们首先需要创建一个docker图像。所以我们用<code class="eh mm mn mo mp b">docker build</code>创建了一个。</p><p id="c923" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">然后我们意识到我们需要一个<code class="eh mm mn mo mp b">Container Registry</code>，因为我们将从那里部署我们的映像，即实例化一个docker容器并部署它。</p><p id="e027" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">为了让它出现在<code class="eh mm mn mo mp b">Container Registry</code>中，我们首先需要用<code class="eh mm mn mo mp b">loginServer</code>名称标记它，之后我们推送标记的图像。</p><p id="690a" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">最后，我们告诉<code class="eh mm mn mo mp b">Container Registry</code>从我们的映像创建一个容器并部署它。部署完成后，我们可以进入浏览器，验证应用程序是否存在，成功:)</p><p id="cf5b" class="pw-post-body-paragraph jq jr hu js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km jb hn dt translated">其实没那么多步。我的意思是，假设我们的应用程序由3个其他服务组成。我们只需要为每一个构建一个图像，标记它，推送，并创建一个容器。</p></div></div>    
</body>
</html>