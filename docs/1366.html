<html>
<head>
<title>Limiting your API requests: the right way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">限制您的API请求:正确的方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/limiting-your-api-requests-the-right-way-9608b661a0ce?source=collection_archive---------3-----------------------#2019-02-26">https://medium.com/hackernoon/limiting-your-api-requests-the-right-way-9608b661a0ce?source=collection_archive---------3-----------------------#2019-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/dd4a4f5c2607cb07d8b5efa3a0a7f60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JW_FfCiv7_6M_Na5iI7_lQ.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Image from @STR/AFP/GettyImages</figcaption></figure><div class=""/><p id="2dce" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">大家好。我叫亚历山大，是Javascript开发人员。今天，我想告诉你一个故事，关于我试图在构建服务器应用程序中找到禅，以满足世界上每一个API。</p><h1 id="3133" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">序言</h1><p id="7c4d" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">这开始于2015年6月，当时Telegram在API中宣布了他们的新<a class="ae lh" href="https://core.telegram.org/bots" rel="noopener ugc nofollow" target="_blank">机器人平台</a>。我是一个在小型网络工作室工作的全栈Javascript和PHP开发人员，我所有的工作就是基于这个栈快速开发登陆页面。让你的工作机器人就在你的信使中的想法令人兴奋，类似的东西我在2010年为ICQ开发的。唯一剩下的问题是未来机器人的想法。它会做什么？我将如何开发它？所以我决定写<a class="ae lh" href="https://t.me/baneksbot" rel="noopener ugc nofollow" target="_blank"> baneksbot </a>。</p><p id="a71a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我开始每天阅读bot API，试图理解我应该如何使用它。我决定用MySQL数据库写一个小的PHP机器人，它应该只要求VK集团的新职位，广播给所有订阅用户，并可以显示每天/每周/每月/以往最喜欢的职位。2015年7月发布。</p><p id="3b40" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">2016年，我决定将这个机器人完全重写为Node.JS，而不是MySQL，我选择MongoDB进行帖子存储，选择ElsaticSearch进行快速搜索。代替长轮询，我开始使用webhooks。所以baneksbot v2.0已经发布了。我有大约20 000名用户订阅新帖子，所以我很快遇到了Bot API限制，并开始得到<code class="eh li lj lk ll b">HTTP 429</code>错误，而不是电报响应。那是2016年10月，然后我意识到我需要以某种方式限制我的机器人请求，让它变慢。</p><h1 id="1948" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">简单地说，费率/限额</h1><p id="d04a" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">你可能知道，很多REST API兼容服务都有所谓的<a class="ae lh" href="https://en.wikipedia.org/wiki/Rate_limiting" rel="noopener ugc nofollow" target="_blank">速率限制</a>来防止DoS攻击和服务器过载。有些人有软规则，你可以在短时间内越过他们的限制，而有些人有严格的规则，你会立即得到回应和超时，然后你可以再试一次。</p><p id="8dab" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我的情况下，Telegram有软的，但硬的速率限制规则，我一再忽略这些规则，我的许多信息从未发送给用户。所以我决定寻找解决方案，并尝试寻找如何遵循这些规则的方法。</p><p id="b1aa" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最简单的方法是设置超时，然后发送消息:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="a167" class="lu kf ij ll b fv lv lw l lx ly">const delay = interval =&gt; new Promise(resolve =&gt; setTimeout(resolve, interval));</span><span id="8b32" class="lu kf ij ll b fv lz lw l lx ly">const sendMessage = async params =&gt; {<br/>  await delay(1000);<br/>  <br/>  return axios(params);<br/>};</span></pre><h2 id="a809" class="lu kf ij bd kg ma mb mc kk md me mf ko jr mg mh ks jv mi mj kw jz mk ml la mm dt translated">优点:</h2><ul class=""><li id="21b3" class="mn mo ij ji b jj lc jn ld jr mp jv mq jz mr kd ms mt mu mv dt translated">非常简单</li><li id="016e" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">非常管用</li></ul><h2 id="a58a" class="lu kf ij bd kg ma mb mc kk md me mf ko jr mg mh ks jv mi mj kw jz mk ml la mm dt translated">缺点:</h2><ul class=""><li id="7ccc" class="mn mo ij ji b jj lc jn ld jr mp jv mq jz mr kd ms mt mu mv dt translated">难以管理</li><li id="72b8" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">无法单独配置</li></ul><p id="a2d0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以这基本上是刚从PHP转移到Node的人的主要方法。JS，并试图写一些不会工作得那么快的东西<em class="nb">。</em>但是，很明显，节点。在异步的情况下，JS更强大，所以我们需要一些优雅的东西。为了让它工作，我们需要一个<strong class="ji ik">队列</strong>。</p><h1 id="c97a" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">请求队列</h1><p id="8c8a" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">实际上，在<a class="ae lh" href="https://npmjs.com" rel="noopener ugc nofollow" target="_blank">npmjs.com</a>中有很多请求队列。有些相当不错，有些不怎么样。我开始尝试它们，看看它们能否在我的用例中正常工作。我使用了一个名为<code class="eh li lj lk ll b">request</code>的库来轻松地发出HTTP请求。在<code class="eh li lj lk ll b">require('http').request</code>之后，就像呼吸了一口新鲜空气:你有承诺，你可以使用流，你可以给它用户友好的网址等等。所以我的第一选择是<a class="ae lh" href="https://www.npmjs.com/package/request-rate-limiter" rel="noopener ugc nofollow" target="_blank">请求速率限制器</a>。它可以很容易地配置和使用在任何地方。实际上，对于95%的用例来说，它是一个完美的库。</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="08a7" class="lu kf ij ll b fv lv lw l lx ly">const RateLimiter = require('request-rate-limiter');</span><span id="cbee" class="lu kf ij ll b fv lz lw l lx ly">const limiter = new RateLimiter(120); // 120 requests per minute</span><span id="19f4" class="lu kf ij ll b fv lz lw l lx ly">const sendMessage = params =&gt; limiter.request(params);</span><span id="5bc4" class="lu kf ij ll b fv lz lw l lx ly">sendMessage('/sendMessage?text=hi')<br/>  .then(response =&gt; {<br/>    console.log('hello!', response);<br/>  }).catch(err =&gt; {<br/>    console.log('oh my', err);<br/>  });</span></pre><h2 id="52e3" class="lu kf ij bd kg ma mb mc kk md me mf ko jr mg mh ks jv mi mj kw jz mk ml la mm dt translated">优点:</h2><ul class=""><li id="ef75" class="mn mo ij ji b jj lc jn ld jr mp jv mq jz mr kd ms mt mu mv dt translated">它不会发送比API允许的更多的请求</li><li id="66e0" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">它有内置队列，所以您可以轻松地将请求放在那里，等待响应</li></ul><h2 id="11f6" class="lu kf ij bd kg ma mb mc kk md me mf ko jr mg mh ks jv mi mj kw jz mk ml la mm dt translated">缺点:</h2><ul class=""><li id="4bad" class="mn mo ij ji b jj lc jn ld jr mp jv mq jz mr kd ms mt mu mv dt translated">每个实例只能配置一个规则</li><li id="4d1a" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">所以你不能用<em class="nb">整体</em>队列来让你的应用程序全局遵循这些规则</li></ul><p id="28a8" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如您所见，这是一个几乎完美的请求队列库。但是让我们更仔细地阅读Telegram Bot API。有几条规则:</p><ul class=""><li id="1b4b" class="mn mo ij ji b jj jk jn jo jr nc jv nd jz ne kd ms mt mu mv dt translated">你<strong class="ji ik">可以</strong>每秒发送<strong class="ji ik"> 1条消息</strong>给个人聊天</li><li id="78cf" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">您<strong class="ji ik">可以每分钟</strong>向群组/频道发送<strong class="ji ik"> 20条消息</strong></li><li id="0793" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">但是那时你<strong class="ji ik">不能</strong>每秒发送超过<strong class="ji ik"> 30条信息</strong>总计<strong class="ji ik">。</strong></li></ul><p id="0047" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可能会想，如果我将速率/限制设置为1/3(每60秒20条消息)，每个人都会很高兴。但是让我们再一次考虑这些数字。</p><h1 id="245c" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">在下一个请求前等待3秒钟</h1><p id="9876" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">听起来很可怕，是吧？但那是真的。如果你想容易地遵循这些规则，你不能发送它，而不是这个时期。我很失望。我想尽可能快地从VK发送这些帖子，以便在这些帖子出现在VK后立即为我的用户提供顶级内容。我在我的机器人里也承诺过，在这篇文章发表后的一分钟内，我会给你发新的文章。所以我决定发展我自己的队列:用二十一点和…规则。</p><h1 id="2c59" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">智能队列</h1><p id="3a7f" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">我从2017年1月开始开发这个队列。创建基本概念，一周后写出第一个原型。这个队列的主要概念是:</p><ul class=""><li id="3448" class="mn mo ij ji b jj jk jn jo jr nc jv nd jz ne kd ms mt mu mv dt translated">应该有一个队列来存储请求并以正确的顺序执行它们</li><li id="3a4f" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">应该有能力为不同的请求设置多个规则</li><li id="5cf6" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">规则应该有一个优先级，这样优先级较低的请求可以保留一点，为更重要的请求让路</li><li id="de0f" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated">即使我完美地编写了这些规则，也应该有一个B计划来重新尝试这个请求，没有额外的痛苦，并在相同的承诺中得到响应</li></ul><p id="e37a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是我如何创建我的第一个名为<a class="ae lh" href="https://www.npmjs.com/package/smart-request-balancer" rel="noopener ugc nofollow" target="_blank">智能请求平衡器</a>的公共npm库。它可以很容易地遵循这些规则，并使我的bot API在近两年内保持安全。让我解释一下它是如何工作的:</p><p id="2a86" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，您需要创建一个队列，</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="72d9" class="lu kf ij ll b fv lv lw l lx ly">const SmartQueue = require('smart-request-balancer');</span></pre><p id="98f5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">然后你初始化它</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="dc31" class="lu kf ij ll b fv lv lw l lx ly">const queue = new SmartQueue(config);</span></pre><p id="9c5f" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">并利用它。没什么特别的！</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="cbfe" class="lu kf ij ll b fv lv lw l lx ly">const sendMessage = params =&gt; queue.request(retry =&gt; axios(params)<br/>  .then(response =&gt; response.data)<br/>  .catch(error =&gt; {<br/>    if (error.response.status === 429) {<br/>      return retry(error.response.data.parameters.retry_after);<br/>    }<br/>    throw error;<br/>  }), user_id, rule);</span><span id="92fc" class="lu kf ij ll b fv lz lw l lx ly">sendMessage('/sendMessage?text=hi')<br/>  .then(response =&gt; {<br/>    console.log('hello!', response);<br/>  }).catch(err =&gt; {<br/>    console.log('oh my', err);<br/>  });</span></pre><p id="535e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可能会问，<code class="eh li lj lk ll b">error.response.data.parameters.rerty_after</code>是什么？<code class="eh li lj lk ll b">user_id</code>？<code class="eh li lj lk ll b">rule</code>？？？让我解释一下。</p><p id="9953" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于这个特殊的例子，我们创建了一个<code class="eh li lj lk ll b">sendMessage</code>函数，它基本上发出<code class="eh li lj lk ll b">axios</code>请求，但也有另外两个参数:<code class="eh li lj lk ll b">user_id</code>和<code class="eh li lj lk ll b">rule</code>。这里的<code class="eh li lj lk ll b">user_id</code>只是用户的唯一键，基于它我们可以将这些请求存储在一个队列中。例如，如果您想为用户1发送30条消息，为用户2发送50条消息，那么将会有两个队列，它们不应该相互等待并独立工作。用户每秒1条消息，记得吗？但与此同时，它不应该达到电报的总体规则，全球每秒不超过30条消息！</p><p id="d5e7" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">还不明白？让我向您展示如何配置这个队列:</p><pre class="lm ln lo lp fq lq ll lr ls aw lt dt"><span id="1e61" class="lu kf ij ll b fv lv lw l lx ly">const config = {<br/>  rules: {<br/>    individual: {<br/>      rate: 1,<br/>      limit: 1,<br/>      priority: 1<br/>    },<br/>    group: {<br/>      rate: 20,<br/>      limit: 60,<br/>      priority: 1<br/>    },<br/>    broadcast: {<br/>      rate: 30,<br/>      limit: 1,<br/>      priority: 2<br/>    }<br/>  },<br/>  overall: {<br/>    rate: 30,<br/>    limit: 1<br/>  }<br/>}</span></pre><p id="8755" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如你所见，我们有3条规则:针对个人、针对团体/频道和针对广播。我们还有总体规则。此外，个人和群体规则具有比广播更高的优先级，这意味着当我的机器人空闲并想要广播消息时，它会很容易地广播它们，但只要有人发送命令，它就会立即响应，然后继续广播。此外，机器人永远不会达到每秒30条消息的总限制，不会被API忽略。</p><p id="f3f3" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们回到我们的例子。什么是<code class="eh li lj lk ll b">retry</code>？<code class="eh li lj lk ll b">retry</code>是一个特殊的函数，如果您不小心达到了极限(在我们的例子中是429)或者出于某种原因想要重复您的请求，您应该调用它。当你在这个区间内调用这个函数时，这个请求将在这个区间后被添加到队列中，并在这个区间后解析这个承诺。很整洁，是吧？</p><p id="a8ee" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但是等等，什么是<code class="eh li lj lk ll b">rule</code>？这正是我们在配置中提供的<code class="eh li lj lk ll b">rule</code>。</p><h1 id="e56f" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">它是如何工作的</h1><p id="c535" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">让我们总结一下这个算法:</p><ol class=""><li id="ca6a" class="mn mo ij ji b jj jk jn jo jr nc jv nd jz ne kd nf mt mu mv dt translated">你用<code class="eh li lj lk ll b">queue.request</code>发出请求</li><li id="866f" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd nf mt mu mv dt translated"><code class="eh li lj lk ll b">SmartQueue</code>将此请求添加到队列<code class="eh li lj lk ll b">&lt;key, rule&gt;</code></li><li id="56ea" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd nf mt mu mv dt translated">如果整个队列中有第一个元素，则执行请求，否则等待轮到它</li><li id="a2ac" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd nf mt mu mv dt translated">解决请求，加热它的队列和整个队列</li><li id="c4a1" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd nf mt mu mv dt translated">移除空队列</li><li id="bb34" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd nf mt mu mv dt translated">返回步骤3，直到队列中没有请求</li></ol><p id="e924" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">简单而强大。仅此而已。</p><h1 id="9581" class="ke kf ij bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">收场白</h1><p id="6959" class="pw-post-body-paragraph jg jh ij ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">这些天以来，这个队列在我的多个机器人中成功地工作，我几乎忘记了广播的事情，开始享受我的生活。这两年来，我一直在润色这个图书馆，准备出版。现在它准备好为人们带来和平的队列。</p><p id="f29a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">总之，以下是我写这篇文章时使用的有用链接:</p><ul class=""><li id="0ae3" class="mn mo ij ji b jj jk jn jo jr nc jv nd jz ne kd ms mt mu mv dt translated"><a class="ae lh" href="https://en.wikipedia.org/wiki/Rate_limiting" rel="noopener ugc nofollow" target="_blank">维基百科中的限速</a></li><li id="bbe7" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lh" href="https://www.npmjs.com/package/smart-request-balancer" rel="noopener ugc nofollow" target="_blank">链接到npm上的智能请求平衡器库</a></li><li id="0771" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lh" href="https://github.com/energizer91/smart-request-balancer" rel="noopener ugc nofollow" target="_blank">链接到github上的智能请求平衡器库</a></li><li id="8c3f" class="mn mo ij ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated"><a class="ae lh" href="https://github.com/energizer91/baneksbot" rel="noopener ugc nofollow" target="_blank">链接到github上的baneksbot电报机器人</a></li></ul><p id="354e" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">欢迎你方的所有贡献。感谢您的耐心和关注。愿原力与你同在！再见。</p></div></div>    
</body>
</html>