<html>
<head>
<title>Standardizing HTTP API testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">标准化HTTP API测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/standardizing-http-api-testing-cc7e513d4823?source=collection_archive---------22-----------------------#2019-02-19">https://medium.com/hackernoon/standardizing-http-api-testing-cc7e513d4823?source=collection_archive---------22-----------------------#2019-02-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="828e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇博文实际上是我的软件开发和咨询业务的标准操作程序草案。在过去的几个月里，我遇到过三四次为HTTP APIs编写测试的任务。我已经尝试了多种编写自动化测试的方法，这是我最喜欢的方法。TypeScript、Jest和supertest似乎配合得很好，足以实现简洁的测试。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/548b80884936af682a6d516729c316f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3HWqx0wUjJalpfEk.jpg"/></div></div></figure><h1 id="9c99" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">背景和标准化的需要</h1><p id="74e7" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">几年前，我的大部分网络编程仅限于PHP。使用PHPUnit和Guzzle对这些项目进行了测试。后来，我们还使用<a class="ae le" href="http://behat.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Behat </a>进行更具可读性的测试。Docker流行起来后，PHP monolith演变成了一个用多种编程语言构建的应用程序。现在一些小服务是用Node.js写的，新的数据分析代码大多是用Python写的。</p><p id="19e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">起初，用与服务器相同的语言编写API级测试似乎是显而易见的。但是在比较了Node.js、PHP和Python的解决方案之后，很明显不同语言之间的质量和方法是不同的。</p><p id="112b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了质量上的差异，问题还在于学习每个测试框架所浪费的时间。投入时间学习Python是值得的，因为我们现在可以使用Pandas和Scipy进行分析。Jupyter在原型制作方面很棒。相比之下，学习用每种语言测试HTTP APIs没有任何价值。使用同一种语言来编写web服务和伴随的测试也没有技术上的理由。</p><p id="722e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于像HTTP API测试这样的任务，拥有一个标准的过程有很多好处:你可以用同一个框架编写很多测试。在你学习了基础知识之后，你可以专注于更高层次的问题，比如组织测试，确定测试内容以及测试更复杂的API。每当你创建一个新的web服务时，你不会浪费时间在谷歌上搜索诸如“测试REST API的最好方法是什么？”。因为决定标准化我工作流程的这一部分，我正在为其他决定节省大脑带宽。</p><h1 id="0785" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">我的标准测试堆栈</h1><p id="d5e9" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">在过去的几个月里，我对TypeScript的体验非常积极。大部分时间我都是在前端用Angular。但它在后端的表现同样出色。可用的工具和类型定义使Express的开发变得轻而易举。与普通JavaScript相比，像VS代码这样的ide中的自动完成功能是非常出色的。类型检查非常有用，尤其是在重构的时候。它支持ES2017的现代功能，如<a class="ae le" href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9" rel="noopener ugc nofollow" target="_blank">异步/等待</a>。我曾经使用Karma作为测试框架，但是找到插件和编写配置的良好组合是一场噩梦。Jest是一个令人愉快的改进。它开箱即用，并具有您可能已经熟悉的常见API:<a class="ae le" href="https://jestjs.io/docs/en/api" rel="noopener ugc nofollow" target="_blank">describe，It，expect </a>。测试HTTP APIs的另一个重要因素是发出请求的方式。Superagent有非常好的<a class="ae le" href="https://visionmedia.github.io/superagent/" rel="noopener ugc nofollow" target="_blank">文档</a>，它与TypeScript配合得很好。我喜欢它的可链接语法。</p><h1 id="b66e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">测试简单GET请求的示例</h1><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="0801" class="lk kc hu lg b fv ll lm l ln lo">import request = require('supertest');</span><span id="350d" class="lk kc hu lg b fv lp lm l ln lo">const BASE_URL = 'http://my-service:3000';</span><span id="ad63" class="lk kc hu lg b fv lp lm l ln lo">describe('Hello world', () =&gt; {<br/>    it('Should say "hello world"', async() =&gt; {<br/>        const response = await request(BASE_URL)<br/>            .get('/')<br/>            .expect(200);<br/>        expect(response.text).toBe("hello world");<br/>    });<br/>});</span></pre><p id="a088" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">函数<code class="eh lq lr ls lg b">describe</code>将特定特性的测试组合在一起。函数<code class="eh lq lr ls lg b">it</code>定义了一个测试。在这种特殊情况下，测试是一个异步函数。它也可以是一个普通函数或返回承诺的函数。在接下来的四行中，我们看到了<code class="eh lq lr ls lg b">async/await</code>语法的优雅。执行仍然是异步的，但是语法看起来非常线性。这使语法与我们连续步骤的心理模型一致。行<code class="eh lq lr ls lg b">.expect(200)</code>断言响应代码确实是<code class="eh lq lr ls lg b">200</code>。最后，我们还要检查响应的内容。</p><h1 id="5df2" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">发布请求</h1><p id="3271" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">使用POST和PUT请求发送数据如下所示:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="378b" class="lk kc hu lg b fv ll lm l ln lo">import request = require('supertest');</span><span id="d890" class="lk kc hu lg b fv lp lm l ln lo">const BASE_URL = 'http://my-service:3000';</span><span id="c11c" class="lk kc hu lg b fv lp lm l ln lo">describe('POST /news', () =&gt; {<br/>    it('Should save and return back the news', async() =&gt; {<br/>        const response = await request(BASE_URL)<br/>            .post('/news')<br/>            .send({'title': 'Breaking news!'})<br/>            .expect(201);</span><span id="0e8f" class="lk kc hu lg b fv lp lm l ln lo">        expect(response.body).toEqual({'id': 1, 'title': 'Breaking news!'});<br/>    });<br/>});</span></pre><p id="59c5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们使用了<code class="eh lq lr ls lg b">post(url)</code>而不是<code class="eh lq lr ls lg b">get(url)</code>，并添加了对<code class="eh lq lr ls lg b">send(data)</code>的调用来发送我们的JSON。</p><h1 id="ff49" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">授权和其他标题</h1><p id="d15c" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">可以使用<code class="eh lq lr ls lg b">set('header-name', 'value')</code>设置标题，如下例所示:</p><pre class="jq jr js jt fq lf lg lh li aw lj dt"><span id="7e98" class="lk kc hu lg b fv ll lm l ln lo">import request = require('supertest');</span><span id="f0ff" class="lk kc hu lg b fv lp lm l ln lo">const BASE_URL = 'http://my-service:3000';</span><span id="267c" class="lk kc hu lg b fv lp lm l ln lo">describe('Authorization test', () =&gt; {<br/>    it('Should respond with 401 if token invalid', async () =&gt; {<br/>        await request(BASE_URL)<br/>            .post('/admin/news')<br/>            .set('Authorization', 'Bearer invalid')<br/>            .send({})<br/>            .expect(401)<br/>            .expect('WWW-Authenticate', /^Bearer/);<br/>    });<br/>});</span></pre><p id="e983" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我希望这篇文章能帮助你更快地设置测试。完整的代码可在<a class="ae le" href="https://gitlab.com/mdrolc/testing-http-apis" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/mdrolc/testing-http-apis</a>那里你会发现一个简单的服务和相应的测试。</p><p id="f10d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lt">原载于2019年2月19日</em><a class="ae le" href="https://drola.si/post/2019-02-19-testing-http-apis" rel="noopener ugc nofollow" target="_blank"><em class="lt">【https://drola.si/post/2019-02-19-testing-http-apis</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>