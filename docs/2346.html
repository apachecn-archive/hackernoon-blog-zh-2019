<html>
<head>
<title>In Detail about Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于 Docker Swarm 的详细信息</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/in-detail-of-docker-swarm-bbf623597c54#2019-04-12">https://medium.com/hackernoon/in-detail-of-docker-swarm-bbf623597c54#2019-04-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="eb5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jp"> Docker Swarm </em> </strong>是一个流行的编排解决方案。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/9dccfa2066804a8a2e9e578f2d6dfce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*4p2q9pGNiULh0c4wzWLcWw.png"/></div></figure><p id="8259" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jy translated">container Orchestration 就是管理容器的生命周期，尤其是在大型的动态环境中。容器编排的主要职责是:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="0a29" class="km kn hu ki b fv ko kp l kq kr">1. Provisioning and deployment of containers</span><span id="866d" class="km kn hu ki b fv ks kp l kq kr">2. Redundancy and availability of containers</span><span id="db1f" class="km kn hu ki b fv ks kp l kq kr">3. Cluster management</span><span id="3dd8" class="km kn hu ki b fv ks kp l kq kr">4. Scaling up or removing containers to spread application <br/>   load evenly across host infrastructure</span><span id="90fa" class="km kn hu ki b fv ks kp l kq kr">5. Movement of containers from one host to another if there is <br/>   a shortage of resources in a host, or if a host dies</span><span id="c37d" class="km kn hu ki b fv ks kp l kq kr">6. Allocation of resources between containers</span><span id="6905" class="km kn hu ki b fv ks kp l kq kr">7. External exposure of services running in a container with <br/>   the outside world</span><span id="ca5c" class="km kn hu ki b fv ks kp l kq kr">8. Load balancing of service discovery between containers</span><span id="b1da" class="km kn hu ki b fv ks kp l kq kr">9. Health monitoring of containers and hosts</span><span id="28be" class="km kn hu ki b fv ks kp l kq kr">10. Configuration of an application in relation to the <br/>    containers running it</span></pre><p id="44aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些开源编排解决方案有:Docker Swarm、Kubernetes、Apache Mesos、OPENSHIFT、Nomad 等。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/06954420625665a74792f18a2f2506a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*ulz_Lvz_1JqDpNhY-EJliA.png"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Container Ecosystem Layers</figcaption></figure><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/7d145578603fe3cdd4097e300a71b22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*_8RlsZNVIf6p-pVhZinV1A.jpeg"/></div></figure></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="be36" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jy translated"><span class="l jz ka kb bm kc kd ke kf kg di">一个</span> <strong class="it hv">集群的架构</strong></p><h2 id="928d" class="km kn hu bd lg lh li lj lk ll lm ln lo jc lp lq lr jg ls lt lu jk lv lw lx ly dt translated">Swarm 的主要架构组件包括:</h2><blockquote class="lz"><p id="72d3" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">群集:</p></blockquote><ol class=""><li id="99e5" class="mj mk hu it b iu ml iy mm jc mn jg mo jk mp jo mq mr ms mt dt translated"><strong class="it hv">一组节点，至少有一个主节点和几个工作节点，可以是虚拟机或物理机。</strong></li></ol><blockquote class="lz"><p id="8b64" class="ma mb hu bd mc md mu mv mw mx my jo ek translated">服务:</p></blockquote><ol class=""><li id="5d64" class="mj mk hu it b iu ml iy mm jc mn jg mo jk mp jo mq mr ms mt dt translated">由群管理员定义的管理器或代理节点必须执行的任务。</li><li id="712e" class="mj mk hu it b iu mz iy na jc nb jg nc jk nd jo mq mr ms mt dt translated">它定义了集群应该使用哪些容器图像，以及集群将在每个容器中运行哪些命令。</li></ol><blockquote class="ne nf ng"><p id="ef7d" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">这个上下文中的服务类似于微服务；例如，您可以在这里为运行在 swarm 中的 nginx web 服务器定义配置参数。副本的参数也在服务定义中定义。</p></blockquote><blockquote class="lz"><p id="57a8" class="ma mb hu bd mc md mu mv mw mx my jo ek translated">管理器节点:</p></blockquote><p id="e3b1" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">部署应用程序后，管理器节点提供了多种功能，例如:</p><ol class=""><li id="2dc9" class="mj mk hu it b iu iv iy iz jc nn jg no jk np jo mq mr ms mt dt translated">它将工作(以任务的形式)交付给工作节点，</li><li id="3b1c" class="mj mk hu it b iu mz iy na jc nb jg nc jk nd jo mq mr ms mt dt translated">管理它所属的群体的状态。</li></ol><blockquote class="lz"><p id="8245" class="ma mb hu bd mc md mu mv mw mx my jo ek translated">工作节点:</p></blockquote><ol class=""><li id="7b00" class="mj mk hu it b iu ml iy mm jc mn jg mo jk mp jo mq mr ms mt dt translated">工作者节点运行由群中的管理者节点分发的任务。</li><li id="d006" class="mj mk hu it b iu mz iy na jc nb jg nc jk nd jo mq mr ms mt dt translated">每个工作节点运行一个代理，向主节点报告分配给它的任务的状态，因此管理节点可以跟踪群中运行的服务和任务。</li></ol><blockquote class="lz"><p id="6c8f" class="ma mb hu bd mc md mu mv mw mx my jo ek translated">任务:</p></blockquote><ol class=""><li id="ea2c" class="mj mk hu it b iu ml iy mm jc mn jg mo jk mp jo mq mr ms mt dt translated"><strong class="it hv">任务</strong>是 Docker 容器，它执行您在服务中定义的命令。</li><li id="de26" class="mj mk hu it b iu mz iy na jc nb jg nc jk nd jo mq mr ms mt dt translated">管理者节点将<em class="jp">任务</em>分配给工作者节点，并且在该分配之后，该任务不能被移动到另一个工作者。如果任务在副本集中失败，管理器会将该任务的新版本分配给群中的另一个可用节点。</li></ol><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="fe ff nq"><img src="../Images/2e14ae01bca971336a3c25af0f83ead8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx35t3UKDaUmC-V2dkWD4g.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek"><strong class="bd nv">Docker Swarm Architecture</strong></figcaption></figure></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="f9b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt jy translated">创造一个码头工人群体</p><blockquote class="lz"><p id="cfbd" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 1||安装 Docker 机器</p></blockquote><p id="f04f" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated"><strong class="it hv"> Docker Machine </strong>是一个工具，让你在虚拟主机上安装<strong class="it hv"> Docker </strong>引擎，用<strong class="it hv">Docker</strong>-<strong class="it hv">Machine</strong>命令管理主机。</p><p id="6be8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用以下命令在<code class="eh nw nx ny ki b">ubuntu</code>上安装对接机:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="4540" class="km kn hu ki b fv ko kp l kq kr">$ base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp; curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp; sudo install /tmp/docker-machine /usr/local/bin/docker-machine</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="611d" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 2||创建 docker 机器作为 Docker 群的节点</p></blockquote><p id="09fa" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">创建一台<code class="eh nw nx ny ki b">manager</code>机器和其他<code class="eh nw nx ny ki b">worker</code>机器</p><p id="96d3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建<code class="eh nw nx ny ki b">manager</code>节点:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="a4c8" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker-machine create --driver virtualbox manager1</span></pre><p id="5265" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">创建两个<code class="eh nw nx ny ki b">worker</code>节点:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="51e8" class="km kn hu ki b fv ko kp l kq kr">1. $ sudo docker-machine create --driver virtualbox worker1<br/>2. $ sudo docker-machine create --driver virtualbox worker2</span></pre><blockquote class="ne nf ng"><p id="6ccd" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">注意:如果您遇到 docker-machine:预创建检查错误:“退出状态 126”，您必须在您的机器上安装<code class="eh nw nx ny ki b"><em class="hu">virtualbox</em></code>。</p></blockquote><p id="c3d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查创建的机器列表:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="15c1" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker-machine ls</span><span id="08e8" class="km kn hu ki b fv ks kp l kq kr">#  we have one 'manager'machine ----&gt; manager1 <br/>   and two 'worker' machine ------&gt; worker1 and worker2</span></pre><p id="d91f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">检查特定机器运行的<code class="eh nw nx ny ki b">ip address</code>:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="5e04" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker-machine ip manager1</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="6fa3" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 3||通过 ssh 从终端连接管理器和工作机</p></blockquote><p id="69ea" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">打开 3 个终端窗口，运行以下命令连接<code class="eh nw nx ny ki b">manager1</code> <code class="eh nw nx ny ki b">worker1</code>和<code class="eh nw nx ny ki b">worker2</code>节点:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="4172" class="km kn hu ki b fv ko kp l kq kr"># connect to manager1 node<br/>1. $ sudo docker-machine ssh manager1</span><span id="29e8" class="km kn hu ki b fv ks kp l kq kr"># connect to worker1 node<br/>2. $ sudo docker-machine ssh worker1</span><span id="4b72" class="km kn hu ki b fv ks kp l kq kr"># connect to manager1 node<br/>3. $ sudo docker-machine ssh worker2</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="2fac" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 4||初始化 Docker 群</p></blockquote><p id="5c38" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">通过<code class="eh nw nx ny ki b">manager1</code> <strong class="it hv"> IP 地址</strong>运行以下命令，初始化<code class="eh nw nx ny ki b">manager</code>节点上的<code class="eh nw nx ny ki b">docker swarm</code>:</p><blockquote class="ne nf ng"><p id="4657" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated"><strong class="it hv">注意:这只适用于蜂群管理器，不适用于工人机器</strong></p></blockquote><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="5464" class="km kn hu ki b fv ko kp l kq kr"># chek manager1 IP_address<br/>1. $ sudo docker-machine ip manager1</span><span id="3a23" class="km kn hu ki b fv ks kp l kq kr"># initialize docker swarm on manager1<br/>2. $ docker swarm init --advertise-addr manager1_ip_address</span><span id="7d68" class="km kn hu ki b fv ks kp l kq kr">output will be something like this:</span><span id="ca2d" class="km kn hu ki b fv ks kp l kq kr">Swarm initialized: current node (vq7xx5j4dpe04rgwwm5ur63ce) is now a manager.</span><span id="ba6f" class="km kn hu ki b fv ks kp l kq kr">To add a worker to this swarm, run the following command:</span><span id="2ec9" class="km kn hu ki b fv ks kp l kq kr">    docker swarm join --token SWMTKN-1-50qba7hmo5exuapkmrj6jki8knfvinceo68xjmh322y7c8f0pj-87mjqjho30uue43oqbhhthjui 10.0.120.3:2377</span><span id="8f6c" class="km kn hu ki b fv ks kp l kq kr">To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</span></pre><p id="dfcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行<code class="eh nw nx ny ki b">docker node ls</code>以验证<code class="eh nw nx ny ki b">manager</code>。这只在<code class="eh nw nx ny ki b">swarm manager</code>中有效，在<code class="eh nw nx ny ki b">worker</code>中无效。如果你愿意，你可以通过在你的终端的<code class="eh nw nx ny ki b">worker</code>机器上运行这个命令来检查。</p><blockquote class="ne nf ng"><p id="fb00" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>该<code class="eh nw nx ny ki b"><em class="hu">docker swarm init</em></code>命令生成一个加入令牌。令牌确保没有恶意节点加入群集。您需要使用这个令牌将其他节点加入到群中。</p></blockquote></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="e214" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">第五步||加入工人群体</p></blockquote><p id="97b0" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">在<code class="eh nw nx ny ki b">worker1</code>和<code class="eh nw nx ny ki b">worker2</code>上，复制并运行最后一个命令输出到控制台的<code class="eh nw nx ny ki b">docker swarm join</code>命令:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="c164" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker swarm join --token SWMTKN-1-50qba7hmo5exuapkmrj6jki8knfvinceo68xjmh322y7c8f0pj-87mjqjho30uue43oqbhhthjui 10.0.120.3:2377</span><span id="00fd" class="km kn hu ki b fv ks kp l kq kr"># after running the command you will be prompted "This node has joined a swarm</span></pre><p id="f9c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">万岁！你现在有一个三节点群！！通过从您的<code class="eh nw nx ny ki b">manager</code>机器运行以下命令进行验证:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="9e94" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker node ls</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="fe ff nz"><img src="../Images/dd8b61dd462d108138bbb080403bb89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iTaPHgpJofCXXUh6t7jEbw.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">3-node swarm</figcaption></figure></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="8d9b" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">第 6 步||查看更多信息</p></blockquote><p id="3d7c" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">在管理器上运行标准 docker 命令</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="79df" class="km kn hu ki b fv ko kp l kq kr"># check the swarm section no of manager, nodes etc<br/>1. $ sudo docker info</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="6faf" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 7 ||在 docker swarm 上运行或部署容器(服务)</p></blockquote><p id="517c" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">既然我们已经初始化了三节点 Swarm 集群，我们将部署一些容器。为了在 Docker 集群上运行容器，我们需要创建一个服务。</p><blockquote class="ne nf ng"><p id="3927" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>服务是一种抽象，它表示部署在分布式集群中的同一映像的多个容器。</p></blockquote><p id="2231" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们用 NGINX 做一个简单的例子。目前，我们将创建一个具有一个运行容器的服务，但是我们将在以后扩展。</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="aae0" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker service create --detach=true --name nginx1 --publish 80:80  --mount source=/etc/hostname,target=/usr/share/nginx/html/index.html,type=bind,ro nginx:1.12<br/>pgqdxr41dpy8qwkn6qm7vke0q</span><span id="33d7" class="km kn hu ki b fv ks kp l kq kr"># description of flag</span><span id="edb8" class="km kn hu ki b fv ks kp l kq kr">1. --detach=true: Run this container in the background<br/>2. --name: Gives a name to the container in our case it's 'nginx1'.<br/>3. <!-- -->--mount: <!-- -->NGINX print out the hostname of the node it's running on.<br/>2. <!-- -->--publish:<!-- --> Uses the swarm's built-in routing mesh. In this case, port 80 is exposed on every node in the swarm. The routing mesh will route a request coming in on port 80 to one of the nodes running the container.</span></pre><blockquote class="ne nf ng"><p id="58c0" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">这个命令语句是声明性的，Docker Swarm 会试图维持这个命令中声明的状态，除非被另一个<code class="eh nw nx ny ki b"><em class="hu">docker service</em></code>命令显式改变。</p></blockquote><ol class=""><li id="0480" class="mj mk hu it b iu iv iy iz jc nn jg no jk np jo mq mr ms mt dt translated"><strong class="it hv">检查服务:(仅来自管理器节点)</strong></li></ol><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="a8ab" class="km kn hu ki b fv ko kp l kq kr">$ <!-- -->sudo docker service ls</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="fe ff oa"><img src="../Images/dec3da2f543dd6906c58150eac3beb1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-t5nYZnm_efv_1RBVpcVw.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek"><strong class="bd nv">Inspect the service</strong></figcaption></figure><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="dc78" class="km kn hu ki b fv ko kp l kq kr">1. $ docker node inspect worker1<br/>2. $ docker node inspect self <br/>3. $ docker node inspect worker2</span></pre><p id="eeb1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv">检查服务的运行容器</strong></p><p id="3415" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通过命令检查正在运行的服务</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="4e66" class="km kn hu ki b fv ko kp l kq kr">$ <!-- -->docker service ps.</span></pre><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="fe ff ob"><img src="../Images/376d0f523ad235fc129f1273586305c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*Js8X7mpIrtQ4wMsB6vEtWQ.png"/></div></div></figure><blockquote class="ne nf ng"><p id="f1e3" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">在我们的例子中，它将是<code class="eh nw nx ny ki b"><em class="hu">manager1</em></code>而不是<code class="eh nw nx ny ki b"><em class="hu">node1</em></code></p><p id="4bf2" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated">任务是 Docker Swarm 中的另一个抽象，代表服务的运行实例。在这种情况下，任务和容器之间存在一对一的映射。</p></blockquote><p id="c45c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<strong class="it hv">测试服务</strong></p><p id="f119" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">由于路由网格，可以在端口 80 上向群的任何节点发送请求。这个请求将被自动路由到运行 NGINX 容器的节点。</p><p id="155d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在每个节点上尝试以下命令:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="0930" class="km kn hu ki b fv ko kp l kq kr">$ curl localhost:80<br/># manager1</span><span id="4aed" class="km kn hu ki b fv ks kp l kq kr">Note: Curling will output the hostname where the container is running. In our case, it is running on manager1</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="80f3" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 8 ||扩展服务</p></blockquote><p id="9075" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">在生产中，我们可能需要处理应用程序的大量流量，因此我们将学习如何伸缩。我们将按照以下步骤扩展我们的应用程序:</p><ol class=""><li id="a97a" class="mj mk hu it b iu iv iy iz jc nn jg no jk np jo mq mr ms mt dt translated"><strong class="it hv">用更新的副本数量更新我们的服务:</strong></li></ol><p id="a435" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh nw nx ny ki b">docker service</code>命令更新我们之前创建的<code class="eh nw nx ny ki b">NGINX </code>服务，以包含 5 个副本。这为服务定义了一个新的状态。</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="aafa" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker service update --replicas=5 --detach=true nginx1</span></pre><p id="0caa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行此命令会发生以下事件:</p><ul class=""><li id="3575" class="mj mk hu it b iu iv iy iz jc nn jg no jk np jo oc mr ms mt dt translated">服务的状态被更新为 5 个副本，这些副本存储在 swarm 的内部存储器中。</li><li id="a2ab" class="mj mk hu it b iu mz iy na jc nb jg nc jk nd jo oc mr ms mt dt translated">Docker Swarm 发现现在计划的副本数量与声明的状态 5 不匹配。</li><li id="2e5f" class="mj mk hu it b iu mz iy na jc nb jg nc jk nd jo oc mr ms mt dt translated">Docker Swarm 调度 5 个以上的任务(容器),试图满足服务的声明状态。</li></ul><p id="58b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jp">该群主动检查期望状态是否等于实际状态，并在需要时尝试协调。</em></p><p id="a0d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv">检查正在运行的实例:</strong></p><p id="62b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">几秒钟之内，蜂群就会成功完成任务。运行以下命令检查正在运行的实例:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="ec2c" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker service ps nginx1</span></pre><p id="6b6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.<strong class="it hv">向</strong> <a class="ae od" href="http://localhost:80." rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">发送大量请求 http://localhost:80。</strong> </a></p><p id="e736" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当您在<code class="eh nw nx ny ki b">port 80</code>上发送请求时，路由网格有多个容器来路由请求。路由网格充当这些容器的负载平衡器，交替将请求路由到哪里。</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="1065" class="km kn hu ki b fv ko kp l kq kr">$ curl localhost:80<br/>worker2<br/>$ curl localhost:80<br/>worker2<br/>$ curl localhost:80<br/>worker1<br/>$ curl localhost:80<br/>manager1<br/>$ curl localhost:80<br/>manager1</span></pre><blockquote class="ne nf ng"><p id="8d9e" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>您向哪个节点发送请求并不重要。接收请求的节点和该请求被路由到的节点之间没有连接。</p></blockquote><p id="97fe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.<strong class="it hv">检查服务的汇总日志:</strong></p><p id="bf53" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">查看这些请求被路由到哪些节点的另一个简单方法是检查聚合日志。您可以通过使用命令<code class="eh nw nx ny ki b">docker service logs [service name]</code>获得服务的聚合日志。</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="c984" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker service logs nginx1</span><span id="4974" class="km kn hu ki b fv ks kp l kq kr"># you can see that each request was served by a different container.</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="9c25" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 9||更新服务</p></blockquote><p id="3fb6" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">现在您已经部署了您的服务，您将看到您的应用程序的发布。你要把 NGINX 的版本更新到 1.13 版。</p><ol class=""><li id="eeba" class="mj mk hu it b iu iv iy iz jc nn jg no jk np jo mq mr ms mt dt translated"><strong class="it hv">运行</strong> <code class="eh nw nx ny ki b"><strong class="it hv">update</strong></code> <strong class="it hv">命令:</strong></li></ol><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="d5d7" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker service update --image nginx:1.13 --detach=true nginx1</span><span id="a37c" class="km kn hu ki b fv ks kp l kq kr"># This triggers a rolling update of the swarm.</span></pre><p id="f124" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.<strong class="it hv">查看更新:</strong></p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="717d" class="km kn hu ki b fv ko kp l kq kr">$ <!-- -->sudo docker service ps nginx1</span></pre><p id="63c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您已经成功更新了您的应用程序！</p></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="625a" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 9:关闭节点</p></blockquote><p id="c3dc" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">如果您想关闭一个节点，可以通过运行以下命令来完成:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="8db9" class="km kn hu ki b fv ko kp l kq kr">1. $ sudo docker node update --availability drain worker1<br/># worker1 node will shut-down</span><span id="e151" class="km kn hu ki b fv ks kp l kq kr">2. $ sudo docker node ls<br/># verify the running node</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="7c8f" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 9:删除服务</p></blockquote><p id="097c" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">您可以通过运行以下命令从所有计算机上删除服务:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="556e" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker rm nginx1</span><span id="d117" class="km kn hu ki b fv ks kp l kq kr"># In our case 'nginx1' is our service name</span></pre><p id="58a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">验证删除的服务:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="16a9" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker service ps nginx1<br/># no such service: nginx1</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="4e61" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">第十步:离开蜂群</p></blockquote><p id="e76a" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">如果你想让一个<code class="eh nw nx ny ki b">worker</code>节点离开集群，从期望的<code class="eh nw nx ny ki b">worker node</code>运行以下命令:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="f764" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker swarm leave<br/># Node left the swarm</span><span id="e7cd" class="km kn hu ki b fv ks kp l kq kr"># verify it from manager node running:<br/>$ sudo docker node ls</span></pre></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><blockquote class="lz"><p id="fef2" class="ma mb hu bd mc md me mf mg mh mi jo ek translated">步骤 10:停止并移除机器</p></blockquote><p id="1994" class="pw-post-body-paragraph ir is hu it b iu ml iw ix iy mm ja jb jc nk je jf jg nl ji jj jk nm jm jn jo hn dt translated">如果要停止机器运行:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="4ab2" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker-machine stop machineName</span></pre><p id="5447" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果要删除机器运行:</p><pre class="jr js jt ju fq kh ki kj kk aw kl dt"><span id="80e1" class="km kn hu ki b fv ko kp l kq kr">$ sudo docker-machine rm machineName</span></pre><blockquote class="ne nf ng"><p id="31e9" class="ir is jp it b iu iv iw ix iy iz ja jb nh jd je jf ni jh ji jj nj jl jm jn jo hn dt translated"><strong class="it hv">注意:</strong>您必须从外部运行<code class="eh nw nx ny ki b"><em class="hu">stop</em></code>和<code class="eh nw nx ny ki b"><em class="hu">rm</em></code>命令。既不来自<code class="eh nw nx ny ki b"><em class="hu">manager</em></code>也不来自<code class="eh nw nx ny ki b"><em class="hu">worker</em></code>机器。</p></blockquote></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="3059" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以查看我之前的文章看看如何 dockerize 一个 flask 应用点击这里<a class="ae od" rel="noopener" href="/@tasnuva2606/dockerize-flask-app-4998a378a6aa?source=friends_link&amp;sk=93569352f150bf5e6141abc152654734">https://medium . com/@ tasnuva 2606/dockerize-flask-app-4998 a 378 a6aa？source = friends _ link&amp;sk = 93569352 f 150 BF 5 e 6141 ABC 152654734</a>。</p><p id="8f4b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">恭喜你！！现在你已经很了解 docker swarm 了，不是吗？？</p></div></div>    
</body>
</html>