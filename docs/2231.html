<html>
<head>
<title>How to Add a Cache Layer to Serverless GraphQL AppSync API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何向无服务器GraphQL AppSync API添加缓存层</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-add-a-cache-layer-to-appsync-dynamodb-resolver-be924842916b?source=collection_archive---------0-----------------------#2019-04-07">https://medium.com/hackernoon/how-to-add-a-cache-layer-to-appsync-dynamodb-resolver-be924842916b?source=collection_archive---------0-----------------------#2019-04-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0c66f99850e4dca1a29672303ccd344d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gb5wltZBIWO5oHekkKfxzg.jpeg"/></div></div></figure><p id="b580" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇文章中，我展示了一个基于<strong class="je hv">无服务器</strong>框架的简单应用程序的例子。应用使用亚马逊Appsync，Lambda，DynamoDB，<strong class="je hv">亚马逊DynamoDB加速器(DAX) </strong>，演示如何在AWS Appsync解析器前使用亚马逊DAX作为缓存层。</p><blockquote class="ka kb kc"><p id="6cae" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">Amazon DynamoDB Accelerator (DAX)是一个完全受管的、高度可用的、用于<a class="ae kh" href="https://aws.amazon.com/dynamodb/" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>的内存中<a class="ae kh" href="https://aws.amazon.com/caching/" rel="noopener ugc nofollow" target="_blank">缓存</a>，它提供了高达10倍的性能提升——从毫秒到微秒——甚至每秒数百万个请求。</p></blockquote><h2 id="5300" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">一个简单的无服务器CMS</h2><p id="33a1" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">本文中的示例应用程序是一个简单的CMS。我使用无服务器框架模板来简化Appsync的设置。模板中创建Appsync、Dynamodb、Cognito身份池和用户池、DAX集群、角色、安全组和子网组的部分，您可以使用它们进行自动和可重复的部署。</p><p id="44ae" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下图说明了应用程序解决方案:</p><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div class="fe ff li"><img src="../Images/f611e6ff910c9a36ac5aff81a5a916be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*svdIbWDLu3ngOUMqpimy1g.jpeg"/></div></figure><h2 id="cdf0" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">无服务器框架入门</h2><p id="25e3" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">首先，您需要安装无服务器框架:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="66a3" class="ki kj hu lo b fv ls lt l lu lv"><strong class="lo hv">$</strong> npm install -g serverless</span></pre><p id="5fce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，让我们创建一个新的无服务器项目:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="6b60" class="ki kj hu lo b fv ls lt l lu lv"><strong class="lo hv">$</strong> sls create --template aws-nodejs --path simpleCMS<br/><strong class="lo hv">$</strong> cd simpleCMS<br/><strong class="lo hv">$</strong> npm init</span></pre><p id="a319" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建的目录包括两个文件——handler . js是Lambda函数。serverless.yml文件包含后端的配置。</p><h2 id="9132" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">添加插件</h2><p id="89ed" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">你需要添加两个无服务器框架的插件:<a class="ae kh" href="https://github.com/sid88in/serverless-appsync-plugin" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">无服务器-appsync-plugin </strong> </a>和<a class="ae kh" href="https://github.com/svdgraaf/serverless-pseudo-parameters" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">无服务器-伪参数</strong> </a>:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="5f25" class="ki kj hu lo b fv ls lt l lu lv"><strong class="lo hv">$ </strong>npm install serverless-pseudo-parameters<br/><strong class="lo hv">$ </strong>npm install serverless-appsync-plugin</span></pre><p id="0655" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编辑serverless.yml文件并将插件添加到<strong class="je hv">插件</strong>部分:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="04d0" class="ki kj hu lo b fv ls lt l lu lv"><strong class="lo hv">plugins</strong>:<br/>  - serverless-appsync-plugin<br/>  - serverless-pseudo-parameters</span></pre><h2 id="cc8b" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">定义AWS AppSync模式</h2><p id="9cf7" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">让我们来看看模式。模式文件是文本文件，通常命名为<code class="eh lw lx ly lo b">schema.graphql</code>，示例模式应该如下所示:</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><h2 id="b638" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">创建映射模板</h2><p id="bc69" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">现在我们已经定义了模式，我们需要为它添加解析器，映射模板文件应该位于与serverless.yml文件相关的名为mapping-templates的目录中。</p><h2 id="f572" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated"><strong class="ak">管道</strong>解析器<strong class="ak">解析器</strong></h2><figure class="lj lk ll lm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/ef84eb5ef951cab8d9fb273dcc82019f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eT-EUC6s8uoxlJN_2WdaYw.png"/></div></div></figure><p id="2270" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AppSync团队去年发布了<strong class="je hv">管道</strong>解析器，管道解析器提供了对数据源串行执行操作的能力。</p><p id="14bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个例子中，有两个函数附加了查询和突变API，管道解析器运行以下逻辑:</p><ul class=""><li id="e27c" class="mc md hu je b jf jg jj jk jn me jr mf jv mg jz mh mi mj mk dt translated">连接到Lambda数据源，从DAX获取项目或将项目放入DAX。</li><li id="0e92" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">如果Lambda函数引发错误，则连接到DynamoDb数据源，直接从DynamoDb获取项目或将项目放入dynamo db。</li></ul><p id="cbdb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们在一个名为<code class="eh lw lx ly lo b">mapping-templates/Mutation-addPost-request.vtl</code>的文件中创建添加后突变的请求模板，注意它是一个<strong class="je hv">管道</strong>解析器。它会将参数保存到上下文stash并调用附加的管道函数。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="69c5" class="ki kj hu lo b fv ls lt l lu lv">$util.qr($context.stash.put("id", $util.autoId()))<br/>$util.qr($context.stash.put("title", $ctx.args.post.title))<br/>$util.qr($context.stash.put("createdAt", $util.time.nowISO8601()))<br/>$util.qr($context.stash.put("content", $ctx.args.post.content))<br/>{}</span></pre><p id="0ac1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后为第一个管道函数<code class="eh lw lx ly lo b">mapping-templates/Function-addPostViaDax-request.vtl</code>创建模板，该函数将调用lambda函数将post插入到<strong class="je hv"> DAX </strong>。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="67db" class="ki kj hu lo b fv ls lt l lu lv">{<br/>    "version": "2017-02-28",<br/>    "operation": "Invoke",<br/>    "payload": {<br/>        "field": "addPostViaDax",<br/>        "arguments": $utils.toJson($context.stash)<br/>    }<br/>}</span></pre><p id="19f2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来让我们创建第二个管道函数模板<code class="eh lw lx ly lo b">mapping-templates/Function-addPostToDB-request.vtl</code>，如果前面的lambda函数执行失败，它将直接向DynamoDB插入post。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="187e" class="ki kj hu lo b fv ls lt l lu lv">#<strong class="lo hv">if</strong>($ctx.prev.result.errorMessage)<br/>{<br/>    "version" : "2017-02-28",<br/>    "operation" : "PutItem",<br/>    "key": {<br/>       "id" : $util.dynamodb.toDynamoDBJson($context.stash.id)<br/>    },<br/>    "attributeValues" : {<br/>        "title" : $util.dynamodb.toDynamoDBJson($context.stash.title) ,<br/>        "content" : $util.dynamodb.toDynamoDBJson($context.stash.content),<br/>       "createdAt":  $util.dynamodb.toDynamoDBJson($context.stash.createdAt)<br/>    },<br/>}<br/>#<strong class="lo hv">else</strong><br/>  #return($ctx.prev.result)<br/>#<strong class="lo hv">end</strong></span></pre><h2 id="e775" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">定义依赖服务</h2><p id="56d7" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">现在，我需要一个DynamoDB表、Appsync、Amazon Cognito用户池和身份池、Vpc中的DAX、安全组和一些IAM角色来将它们连接在一起。这些被放在serverless.yml的<strong class="je hv">资源</strong>部分。</p><h2 id="9a3e" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">定义AppSync GrpahQL API</h2><p id="cdfd" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">让我们定义AWS AppSync资源，将以下示例配置添加到<code class="eh lw lx ly lo b">serverless.yml</code>的<strong class="je hv">自定义</strong>部分</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="1082" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，每个查询和变异在映射模板中都有一个条目。</p><h2 id="e760" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">定义DynamoDB表</h2><p id="47b4" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">该代码示例的下一部分创建一个DynamoDB表。</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="3be7" class="ki kj hu lo b fv ls lt l lu lv"><br/>  <strong class="lo hv">PostsTable</strong>:<br/>    <strong class="lo hv">Type</strong>: AWS::DynamoDB::Table<br/>    <strong class="lo hv">Properties</strong>:<br/>      <strong class="lo hv">TableName</strong>: ${self:custom.postsTable}<br/>      <strong class="lo hv">AttributeDefinitions</strong>:<br/>        - AttributeName: id<br/>          AttributeType: S<br/>      <strong class="lo hv">KeySchema</strong>:<br/>        - AttributeName: id<br/>          KeyType: HASH<br/>      <strong class="lo hv">ProvisionedThroughput</strong>:<br/>        ReadCapacityUnits: 5<br/>        WriteCapacityUnits: 1<br/>      <strong class="lo hv">StreamSpecification</strong>:<br/>        StreamViewType: NEW_IMAGE</span></pre><p id="0d7c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该表只有一个哈希键。<strong class="je hv">ProvisionedThroughput</strong><strong class="je hv">ReadCapacityUnits</strong>保持低电平，因为DAX服务于大部分读取流量。仅当DAX没有缓存该项时，才调用DynamoDB。</p><h2 id="264f" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">定义DAX集群</h2><p id="a60d" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">现在让我们创建DAX群集，该模板设置了以下服务:</p><ul class=""><li id="060e" class="mc md hu je b jf jg jj jk jn me jr mf jv mg jz mh mi mj mk dt translated">具有一个t2.small节点的DAX群集。</li><li id="c272" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">具有允许Lambda在TCP端口8111上向DAX发送流量的规则的安全组。</li><li id="827b" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">IAM角色允许DAX访问DynamoDB。</li><li id="f425" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">VPC指的是这个安全组。</li><li id="3241" class="mc md hu je b jf ml jj mm jn mn jr mo jv mp jz mh mi mj mk dt translated">安全组控制允许网络流量在VPC中流动的方式。</li></ul><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><h2 id="b1f3" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated"><strong class="ak">定义VPC为λ</strong></h2><p id="460c" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">为了正确地将AWS Lambda连接到DAX，我需要将您的Lambda函数部署到DAX的同一个VPC中，在<code class="eh lw lx ly lo b">serverless.yml</code>文件中配置<strong class="je hv"> provider </strong>部分:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="451e" class="ki kj hu lo b fv ls lt l lu lv"><strong class="lo hv">provider</strong>:<br/>  <strong class="lo hv">vpc</strong>:<br/>    <strong class="lo hv">securityGroupIds</strong>:<br/>      - Fn::GetAtt: [DaxVpcSecurityGroup, GroupId]<br/>    <strong class="lo hv">subnetIds</strong>:<br/>      - Ref: daxSubnet1<br/>      - Ref: daxSubnet2</span></pre><p id="eb5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AWS配置的其他部分，如身份验证、模式和数据源等。你可以在我的<a class="ae kh" href="https://github.com/yai333/AppsyncDax" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> GitHub回购</strong> </a>中找到它们。</p><h2 id="f0ff" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">代码</h2><p id="b2a6" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">lambda函数代码在<strong class="je hv"> handler.js </strong>中。Lambda处理程序使用环境变量进行配置:<strong class="je hv"> POSTS_TABLE_NAME </strong>是包含post数据的表的名称，<strong class="je hv"> DAX_ENDPOINT </strong>是DAX集群端点。这些变量在<code class="eh lw lx ly lo b">serverless.yml</code>中自动配置。</p><p id="196b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当有突变或查询请求时，Appsync将调用lambda函数数据源来插入或获取DAX中的数据，如果Lambda函数引发错误，管道解析器将转到下一个管道函数并连接到DynamoDb数据源，从/向DynamoDb获取/放置项目。</p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="lz ma l"/></div></figure><h2 id="527b" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">部署您的API</h2><p id="65b8" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">要部署您的API，请运行以下命令:</p><pre class="lj lk ll lm fq ln lo lp lq aw lr dt"><span id="a77e" class="ki kj hu lo b fv ls lt l lu lv">$ serverless deploy -v</span></pre><h2 id="237a" class="ki kj hu bd kk kl km kn ko kp kq kr ks jn kt ku kv jr kw kx ky jv kz la lb lc dt translated">结论</h2><p id="5a1a" class="pw-post-body-paragraph jc jd hu je b jf ld jh ji jj le jl jm jn lf jp jq jr lg jt ju jv lh jx jy jz hn dt translated">在这篇文章中，我展示了如何使用无服务器框架来创建Appsync lambda数据源，该数据源使用DAX和DynamoDB来实现简单的查询和变异。我希望这篇文章对你有用，完整的代码示例可以在我的<a class="ae kh" href="https://github.com/yai333/AppsyncDax" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> GitHub repo </strong> </a> <strong class="je hv">上找到。</strong></p><figure class="lj lk ll lm fq iv"><div class="bz el l di"><div class="mq ma l"/></div></figure></div></div>    
</body>
</html>