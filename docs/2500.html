<html>
<head>
<title>How to Turn React Components into Native Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将 React 组件转换成本地 Web 组件</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-turn-react-component-into-native-web-component-84834315cb24#2019-04-19">https://medium.com/hackernoon/how-to-turn-react-component-into-native-web-component-84834315cb24#2019-04-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/36e107d481c258ac5460bd04055eb6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*PRUJTTCZVlxp43LacdtrGg.jpeg"/></div></figure><p id="b104" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如何将 React 组件包装在框架无关的 HTML 定制元素中的分步说明；如何公开它的属性和事件，并支持子进程。</p><p id="5bcb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我有一个副业项目，创建和维护<a class="ae jx" href="https://www.dotnetify.net/elements" rel="noopener ugc nofollow" target="_blank">一个名为 dotNetify-Elements </a>的 React 组件库；一组非常专业的 UI 组件，能够通过<a class="ae jx" href="https://hackernoon.com/tagged/web" rel="noopener ugc nofollow" target="_blank"> web </a> socket/SignalR 与. NET 核心后端实时对话。</p><p id="cf19" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有几次我想在静态网页或者用其他 UI 框架构建的网站上使用它们。这是可能的，但它需要经历一些困难才能让<a class="ae jx" href="https://hackernoon.com/tagged/react" rel="noopener ugc nofollow" target="_blank"> React </a> build 系统运行起来，有时这可能并不理想。</p><p id="85e6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Web 组件标准<a class="ae jx" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank">虽然不像 React 那样通用，但至少提供了一种构建可以在大多数浏览器上本地操作的专门 UI 元素的方法。但是从头开始重新构建我的库听起来对我来说并不太有吸引力，所以我进行了一次反复试验，看看我是否可以将我现有的 React 组件封装到这项技术中。</a></p><p id="9c5c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在某种程度上，这是一个成功的结果。我还没有解决每个问题；有一些黑客攻击，我怀疑有性能打击，但你可以在这里看到结果:</p><ul class=""><li id="b96c" class="jy jz hu ja b jb jc jf jg jj ka jn kb jr kc jv kd ke kf kg dt translated">实时仪表板演示:<a class="ae jx" href="https://jsfiddle.net/dsuryd/ygosxk8m" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/dsuryd/ygosxk8m</a></li><li id="8287" class="jy jz hu ja b jb kh jf ki jj kj jn kk jr kl jv kd ke kf kg dt translated">反应式表单演示:<a class="ae jx" href="https://jsfiddle.net/dsuryd/hmvwpjx0/1/" rel="noopener ugc nofollow" target="_blank">https://jsfiddle.net/dsuryd/hmvwpjx0</a></li></ul><p id="b7c7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw">(你会看到的是 HTML 视图部分；如果你也有兴趣看后端代码，</em> <a class="ae jx" href="https://www.dotnetify.net/elements/examples/customerform" rel="noopener ugc nofollow" target="_blank"> <em class="jw">从这里开始</em> </a> <em class="jw">。)</em></p><p id="c784" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你想了解我是如何做到的，以及你自己是如何做到的，下面是一套指导说明。</p><h2 id="efc5" class="km kn hu bd ko kp kq kr ks kt ku kv kw jj kx ky kz jn la lb lc jr ld le lf lg dt translated">创建元素外壳</h2><p id="14eb" class="pw-post-body-paragraph iy iz hu ja b jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv hn dt translated">创建 HTML 自定义元素有两个步骤:</p><ol class=""><li id="99af" class="jy jz hu ja b jb jc jf jg jj ka jn kb jr kc jv lm ke kf kg dt translated">编写一个扩展 HTMLElement(或其任何派生类型，如 HTMLParagraphElement)的类。</li><li id="d194" class="jy jz hu ja b jb kh jf ki jj kj jn kk jr kl jv lm ke kf kg dt translated">向 window.customElements 对象注册该类。</li></ol><p id="295a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如，让我们创建一个名为“我的按钮”的按钮:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="d9f0" class="km kn hu ls b fv lw lx l ly lz">class MyButton extends HTMLElement {<br/>   constructor() {<br/>      super(); <br/>  }<br/>}</span><span id="11c8" class="km kn hu ls b fv ma lx l ly lz">customElements.define('my-button', MyButton);</span></pre><p id="c8a0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="jw">(注意:您必须将</em><a class="ae jx" href="http://&quot;https://unpkg.com/@webcomponents/webcomponentsjs@2/custom-elements-es5-adapter.js" rel="noopener ugc nofollow" target="_blank"><em class="jw">custom-elements-es5-adapter . js</em></a><em class="jw">添加到 index.html 才能工作；不要编了！).</em></p><p id="f954" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在我们有了 shell，让我们创建一个组件，当它应用到页面时，它将呈现一个 React 按钮组件。</p><h2 id="9a46" class="km kn hu bd ko kp kq kr ks kt ku kv kw jj kx ky kz jn la lb lc jr ld le lf lg dt translated">包装反应</h2><p id="d9c8" class="pw-post-body-paragraph iy iz hu ja b jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv hn dt translated">就像 React 一样，定制元素也有一些生命周期挂钩，您可以通过回调方法来访问它们。当元素被添加到文档中时，<code class="eh mb mc md ls b">connectedCallback</code>被调用，而<code class="eh mb mc md ls b">disconnectedCallback</code>则相反。这些是安装和卸载 React 组件的好地方:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="fbd4" class="km kn hu ls b fv lw lx l ly lz">class MyButton extends HTMLElement {<br/>   constructor() {<br/>      super(); <br/>   }</span><span id="5e74" class="km kn hu ls b fv ma lx l ly lz">   connectedCallback() {<br/>      ReactDOM.render(&lt;MyReactComponent /&gt;, this);<br/>   }</span><span id="9dbc" class="km kn hu ls b fv ma lx l ly lz">   disconnectedCallback(){<br/>      ReactDOM.unmountComponentAtNode(this);<br/>   }</span></pre><p id="4327" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">通过使用<code class="eh mb mc md ls b">this</code>，我们告诉 ReactDOM 在元素上安装组件，因此任何呈现的标记都将成为主文档 DOM 的一部分。这是我有意为之的，因为我希望组件受到 css 全局主题的影响。但是如果您希望它更加独立，那么我们可以将它安装在影子 DOM 上，这基本上是一个对其他代码隐藏的 DOM 子树:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="7f82" class="km kn hu ls b fv lw lx l ly lz">this.root = this.attachShadow({mode: 'open'});<br/>ReactDOM.render(&lt;MyReactComponent /&gt;, this.root);</span></pre><p id="6ec0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">模式<code class="eh mb mc md ls b">open</code>仅仅意味着您仍然希望允许 Javascript 代码访问影子 DOM。当然，如果你想完全隔离它，使用模式<code class="eh mb mc md ls b">closed</code>代替。</p><h2 id="7af0" class="km kn hu bd ko kp kq kr ks kt ku kv kw jj kx ky kz jn la lb lc jr ld le lf lg dt translated">传递属性</h2><p id="ca27" class="pw-post-body-paragraph iy iz hu ja b jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv hn dt translated">自然，我们希望允许人们通过自定义元素的属性将属性值传递给 React 组件。事实是，自定义元素属性将被视为字符串，而 React 属性接受所有类型。</p><p id="5fac" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">显然，我们需要将值转换成适当的类型。您可以很容易地为每个元素编写自定义代码，但是让我们选择一个以通用方式实现这一点的函数:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="a36c" class="km kn hu ls b fv lw lx l ly lz">connectedCallback() {<br/>   const props = {<br/>      ...this.getProps(this.attributes, MyReactComponent.propTypes)<br/>   };<br/>   ReactDOM.render(&lt;MyReactComponent {...props} /&gt;, this);<br/>}</span><span id="b602" class="km kn hu ls b fv ma lx l ly lz">getProps(attributes, propTypes) {<br/>   propTypes = propTypes|| {};<br/>   return [ ...attributes ]         <br/>      .filter(attr =&gt; attr.name !== 'style')         <br/>      .map(attr =&gt; this.convert(propTypes, attr.name, attr.value))<br/>      .reduce((props, prop) =&gt; <br/>         ({ ...props, [prop.name]: prop.value }), {});<br/>}</span><span id="60ca" class="km kn hu ls b fv ma lx l ly lz">convert(propTypes, attrName, attrValue) {<br/>   const propName = Object.keys(propTypes)<br/>      .find(key =&gt; key.toLowerCase() == attrName);</span><span id="695e" class="km kn hu ls b fv ma lx l ly lz">   let value = attrValue;<br/>   if (attrValue === 'true' || attrValue === 'false') <br/>      value = attrValue == 'true';      <br/>   else if (!isNaN(attrValue) &amp;&amp; attrValue !== '') <br/>      value = +attrValue;      <br/>   else if (/^{.*}/.exec(attrValue)) <br/>      value = JSON.parse(attrValue);</span><span id="b92e" class="km kn hu ls b fv ma lx l ly lz">   return {         <br/>      name: propName ? propName : attrName,         <br/>      value: value      <br/>   };<br/>}</span></pre><p id="e927" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">自定义元素的属性可从<code class="eh mb mc md ls b">this.attributes</code>访问。该函数所做的是遍历属性，通过查看其值来猜测类型，从组件的<code class="eh mb mc md ls b">propTypes</code>中找到匹配的 React 属性名称(因为属性名称都是小写的)，通过查看其值来猜测类型，将它们转换并聚合为要传递给 React 组件的对象文字。</p><h2 id="0087" class="km kn hu bd ko kp kq kr ks kt ku kv kw jj kx ky kz jn la lb lc jr ld le lf lg dt translated">处理属性更新</h2><p id="ae99" class="pw-post-body-paragraph iy iz hu ja b jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv hn dt translated">我们现在能够通过自定义元素属性设置 React 属性值，但是如果我们想在元素呈现后通过 Javascript 更改任何值呢？</p><p id="6b81" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们需要一种机制来通知我们的元素它的任何属性已经改变，这样它就可以强制 React 组件进行更新。定制元素有另一个处理这种类型事件的回调方法，恰当地命名为<code class="eh mb mc md ls b">attributeChangedCallback</code>。但是遗憾的是，只有当我们添加了返回属性名称的静态函数<code class="eh mb mc md ls b">getObservedAttributes</code>时，这个回调才会起作用，我们必须静态地声明这个函数。</p><p id="0fee" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我正在寻找一种解决方案，它不会强迫我列出我想要观察的所有属性，幸运的是有一种东西叫做<code class="eh mb mc md ls b">MutationObserver</code>。这是 DOM 事件规范的一部分，它允许我们观察对 DOM 树所做的更改。</p><p id="84f4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们更新元素的构造函数，使用这个 API 来监听任何属性更改，并在发生这种情况时强制 React 组件重新装载。在这个过程中，我们将 React 挂载和卸载代码重构为独立的方法，以实现可重用性:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="6f79" class="km kn hu ls b fv lw lx l ly lz">constructor() {<br/>   super();<br/>   this.observer = new MutationObserver(() =&gt; this.update());<br/>   this.observer.observe(this, { attributes: true });<br/>}</span><span id="1f89" class="km kn hu ls b fv ma lx l ly lz">connectedCallback() {<br/>   this.mount();<br/>}</span><span id="2141" class="km kn hu ls b fv ma lx l ly lz">disconnectedCallback() {<br/>   this.unmount();<br/>   this.observer.disconnect();<br/>}</span><span id="fee8" class="km kn hu ls b fv ma lx l ly lz">update() {<br/>   this.unmount();<br/>   this.mount();<br/>}</span><span id="ad16" class="km kn hu ls b fv ma lx l ly lz">mount() {<br/>   const props = {<br/>      ...this.getProps(this.attributes, MyReactComponent.propTypes)<br/>   };<br/>   ReactDOM.render(&lt;MyReactComponent {...props} /&gt;, this);<br/>}</span><span id="64ef" class="km kn hu ls b fv ma lx l ly lz">unmount() {<br/>   ReactDOM.unmountComponentAtNode(this);<br/>}</span></pre><h2 id="cc3a" class="km kn hu bd ko kp kq kr ks kt ku kv kw jj kx ky kz jn la lb lc jr ld le lf lg dt translated">引发事件</h2><p id="8aea" class="pw-post-body-paragraph iy iz hu ja b jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv hn dt translated">如果没有引发事件的能力，我们的按钮元素将毫无用处。所以接下来要解决的是如何将 React 组件引发的任何事件转换成可以用<code class="eh mb mc md ls b">addEventListener</code>监听的 DOM 事件。</p><p id="4adb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">假设组件遵循 React 事件命名约定(camel-case <em class="jw"> on </em> *)，我们将再次使用<code class="eh mb mc md ls b">propTypes</code>寻找匹配模式的属性名，并传递给它一个调用 DOM <code class="eh mb mc md ls b">dispatchEvent</code>的函数:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="d947" class="km kn hu ls b fv lw lx l ly lz">mount() {<br/>   const props = {<br/>      ...this.getProps(this.attributes, MyReactComponent.propTypes)<br/>      ...this.getEvents(MyReactComponent.propTypes)<br/>   };<br/>   ReactDOM.render(&lt;MyReactComponent {...props} /&gt;, this);<br/>}</span><span id="f2e7" class="km kn hu ls b fv ma lx l ly lz">getEvents(propTypes) {<br/>   return Object.keys(propTypes)<br/>      .filter(key =&gt; /on([A-Z].*)/.exec(key))<br/>      .reduce((events, ev) =&gt; ({<br/>         ...events,<br/>         [ev]: args =&gt; <br/>            this.dispatchEvent(new CustomEvent(ev, { ...args }))<br/>      }), {});<br/>}</span></pre><p id="c74c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我们目前所拥有的一个屏幕截图，一个按钮元素响应一个点击事件和属性的改变:</p><figure class="ln lo lp lq fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="fe ff me"><img src="../Images/2c72ee60a7d4b842a7689ef28e98a50b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/1*_Ug6I472IoTFcbcd0PhAAA.gif"/></div></div></figure><h2 id="7bac" class="km kn hu bd ko kp kq kr ks kt ku kv kw jj kx ky kz jn la lb lc jr ld le lf lg dt translated">跨群体儿童</h2><p id="663e" class="pw-post-body-paragraph iy iz hu ja b jb lh jd je jf li jh ji jj lj jl jm jn lk jp jq jr ll jt ju jv hn dt translated">虽然这种实现对于叶组件来说很好，但是我的 React 组件是其他元素的容器，无论是简单的标量值、DOM 元素，还是其他 React 组件。这被证明是一个相当大的挑战，因为 ReactDOM <code class="eh mb mc md ls b">render</code>似乎只想接受 React 组件作为子组件，而我需要它来接受自定义元素的内部 HTML 标记。</p><p id="fd72" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我最终决定使用库<code class="eh mb mc md ls b">html-to-react</code>，它接受 HTML 标记并生成一个 React 组件。让我们将代码更新为:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="c355" class="km kn hu ls b fv lw lx l ly lz">import htmlToReact from 'html-to-react';<br/>...</span><span id="41dd" class="km kn hu ls b fv ma lx l ly lz">mount() {<br/>   const props = {<br/>      ...this.getProps(this.attributes, MyReactComponent.propTypes)<br/>      ...this.getEvents(MyReactComponent.propTypes),<br/>      children: this.parseHtmlToReact(this.innerHTML)</span><span id="6650" class="km kn hu ls b fv ma lx l ly lz">   };<br/>   ReactDOM.render(&lt;MyReactComponent {...props} /&gt;, this);<br/>}</span><span id="d064" class="km kn hu ls b fv ma lx l ly lz">parseHtmlToReact(html) {<br/>   return html &amp;&amp; new htmlToReact.Parser().parse(html);<br/>}</span></pre><p id="7fb1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">自定义元素现在能够呈现嵌套元素。但是，一旦元素得到更新，它们就会消失。为什么？是因为<code class="eh mb mc md ls b">this.innerHTML</code>的内容在元素挂载后就没有了。为了克服这个问题，让我们在<code class="eh mb mc md ls b">connectedCallback</code>期间缓存初始内容，并使用<code class="eh mb mc md ls b">mount</code>中的变量:</p><pre class="ln lo lp lq fq lr ls lt lu aw lv dt"><span id="194b" class="km kn hu ls b fv lw lx l ly lz">connectedCallback() {<br/>   this._innerHTML = this.innerHTML;<br/>   this.mount();<br/>}</span></pre><p id="e8d3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">就是这样！这就是它的要点。你可以超越这个，就像我一样。对于我的组件，我实现了更多来处理我的非常具体的用例，比如上下文注入和你看到的演示中的反应式表单的管理。</p><p id="51e5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">感谢您的阅读！</p><figure class="ln lo lp lq fq iv"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>