<html>
<head>
<title>Everything You Need to Know About Blocks in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Ruby中的块，你需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/everything-you-need-to-know-about-blocks-in-ruby-2ad99352f855?source=collection_archive---------1-----------------------#2019-05-11">https://medium.com/hackernoon/everything-you-need-to-know-about-blocks-in-ruby-2ad99352f855?source=collection_archive---------1-----------------------#2019-05-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="df0c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Ruby最强大的特性之一的完整指南</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/2865b2da8493becd55f91c82b86167c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F-6wKvSf26C2mRR6"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Photo by <a class="ae kf" href="https://unsplash.com/@shs521?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Susan Holt Simpson</a> on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="96ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">块是Ruby中最常用的特性之一，大多数Ruby开发人员都没有意识到它们的存在——包括它们有多强大。积木一点也不复杂，但也不是小孩子的游戏。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="c930" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们从一个经典的例子开始，为主人公揭露这个阻碍的真实面目:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kn ko l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Here we call the method ‘<code class="eh kp kq kr ks b">times'</code> on the Integer <code class="eh kp kq kr ks b">5</code>, and print <code class="eh kp kq kr ks b">“Hello Medium”</code> with each iteration.</figcaption></figure><p id="2b09" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于任何花时间用Ruby编写代码的人来说，这应该非常熟悉。几乎在我写过的所有Ruby脚本中都有一个家。虽然从技术上来说Ruby风格是使用<code class="eh kp kq kr ks b">{}</code>如果这个块可以压缩成一行:</p><pre class="jq jr js jt fq kt ks ku kv aw kw dt"><span id="a2d0" class="kx ky hu ks b fv kz la l lb lc">5.times { puts “Hello Medium" }</span></pre><p id="cf48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在后台，<code class="eh kp kq kr ks b">puts “Hello World”</code>是一个<strong class="it hv">块</strong>，作为匿名参数输入到函数<code class="eh kp kq kr ks b">times</code>。如果我们在API <a class="ae kf" href="https://ruby-doc.org/core-2.2.0/Integer.html#method-i-times" rel="noopener ugc nofollow" target="_blank">文档中查找times </a>，它会告诉我们！这些文件还告诉我们，如果我们愿意，我们的团队可以接受一个论点:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kn ko l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">5.times {|value| puts “Hello Medium #{value}” } would be the one-liner</figcaption></figure><p id="8e3b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这会将以下内容打印到控制台:</p><pre class="jq jr js jt fq kt ks ku kv aw kw dt"><span id="9303" class="kx ky hu ks b fv kz la l lb lc">Hello Medium 0<br/>Hello Medium 1<br/>Hello Medium 2<br/>Hello Medium 3<br/>Hello Medium 4</span></pre></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="97f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">块的另一个常见用例是在文件I/O期间。不管你是否意识到，任何时候你用<code class="eh kp kq kr ks b">IO.foreach</code>打开一个文件，你实际上都传递了一个块，该块为文件的每一行执行！</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kn ko l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Blockception!</figcaption></figure><p id="b59a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们一直在使用积木，却几乎没有意识到它们的巨大潜力——让我们改变这一点。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ld"><img src="../Images/29a0e99ffc09b4985134cf4bae0406f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xscEK3DdPSXQ9ueYwhHS9w.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek"><a class="ae kf" href="https://www.pexels.com/photo/sign-yield-1467970/." rel="noopener ugc nofollow" target="_blank">In Ruby, we ‘yield’ to blocks</a></figcaption></figure><p id="6171" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">块经常被称为“匿名方法”，因为它们可以隐式地传递给Ruby中的任何方法。执行(或调用)一个块所要做的就是对它进行<code class="eh kp kq kr ks b">yield</code>:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kn ko l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">“Hello Medium : 2019–04–28 08:23:45 -0400"</figcaption></figure><p id="eb1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里，我们将一个包含单个字符串的块:“Hello Medium”传递给我们的方法<code class="eh kp kq kr ks b">say_with_time</code>。然后这个方法<code class="eh kp kq kr ks b">yields</code>到它的块中，并打印当前时间。</p><p id="ce6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管这种方法有一些奇怪的行为…如果我们用pry检查它:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff le"><img src="../Images/c48445e40b92f97c198b9287da20eced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JV_L_-qMnr9V6fUT4MN2jw.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Our dear block is nowhere to be found…</figcaption></figure><p id="2b5c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们注意到的第一件事是，我们的块没有作为参数列在作用域中。我们可以屈服于它，并用<code class="eh kp kq kr ks b">block_given?</code>检查它的布尔状态，但是我们不能作为参数调用它。</p><p id="cd68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以将块显式定义为方法的输入参数，而不是依赖于隐式传递块。以这种方式展示该块让我们对其起源有了有价值的了解:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kn ko l"/></div></figure><p id="d3c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kp kq kr ks b">block</code>现在是一个局部变量，在检查它之后，我们终于揭开了我们亲爱的块Object: Proc的起源。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="82d1" class="lf ky hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">激活、触发</h1><p id="3e36" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">Procs是Procedures的缩写，本质上是封装在Ruby对象中的块。Procs为我们的块提供了额外的功能，并允许它们像普通对象一样被传递。</p><p id="862e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">天真地说，我们可以像以前利用块一样使用进程:</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kn ko l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Hello Medium : 2019–04–28 09:30:03 -0400</figcaption></figure><p id="5241" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们显式地定义了一个块，并将其传递给我们的<code class="eh kp kq kr ks b">say_with_time</code>方法，相比之下，在我们的第一个例子中，块是隐式传递的。这里的好处和在变量中保存原语是一样的:重用。你不会在任何需要的地方硬编码“Hello Medium ”,你会将它保存为一个变量并使用它，同样的逻辑也可以应用于进程/块！</p><p id="f1b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Procs比这个简单的例子有更大的潜力。一个触发程序所能完成的极限仅仅受到你的想象力和创造力的限制。正如我提到的，你通过“调用”一个程序块来屈服于它。从这个意义上来说，我们实际上已经揭示了Ruby中的回调函数！</p><p id="ad5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最多可以将一个块直接或间接地传递给一个方法，但是如果需要，可以将多个过程传递给一个方法:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mh"><img src="../Images/ae0a064d17155a0c007e155b9a671834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtr-dxViIOGRts2ut3y8xw.png"/></div></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="6597" class="lf ky hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">兰姆达斯</h1><p id="a34a" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">术语“Lambda表达式”与编程中的“匿名函数”同义，是从微积分模型中派生出来的同名函数。它的技术定义是“<a class="ae kf" href="https://en.wikipedia.org/wiki/Lambda_expression" rel="noopener ugc nofollow" target="_blank">一个被定义的、可能被调用的、不受标识符</a>约束的函数”。虽然格挡和触发也符合这个定义，但兰姆达斯有几个关键的区别，让他们在人群中脱颖而出。</p><p id="d72b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">首先，让我们探索lambda语法，与块和进程的语法形成对比:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mi"><img src="../Images/a4c0da0fbea2870ae1bc4c0729c40077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQNh5dRtSMPXOVFCj5APaA.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">How to use each type of Ruby closure</figcaption></figure><p id="25cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Lambdas和procs有一些关键的区别，这取决于你如何看待它们。</p><ul class=""><li id="79d1" class="mj mk hu it b iu iv iy iz jc ml jg mm jk mn jo mo mp mq mr dt translated">Lambdas强制执行传递给它们的参数数量</li><li id="a83f" class="mj mk hu it b iu ms iy mt jc mu jg mv jk mw jo mo mp mq mr dt translated">Lambdas处理<code class="eh kp kq kr ks b">return</code>关键字的方式不同于Procs</li></ul><p id="f466" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您传入的参数数量不正确，Lambda函数将抛出一个<code class="eh kp kq kr ks b">ArgumentError</code>，而Procs将简单地用<code class="eh kp kq kr ks b">nil</code>来填补空白。</p><p id="db43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于procs，<code class="eh kp kq kr ks b">return</code>意味着“从周围方法返回”，而对于lambdas <code class="eh kp kq kr ks b">return</code>意味着“从lambda返回”。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mx"><img src="../Images/ceba23f03dc0be6367ce451158343a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-jjQo5y6u5pAi14hvMGE8Q.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Here we see that Lambdas correctly govern their expected arguments, whereas Procs do not</figcaption></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff my"><img src="../Images/cf1ab0c34598ef7ce0d0c7979afbb260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*bU3u91Ch92bUHLb06pdlLA.png"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Examples of how Procs and Lambdas handle the ‘return’ keyword</figcaption></figure><p id="0a68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是上述脚本的输出:</p><pre class="jq jr js jt fq kt ks ku kv aw kw dt"><span id="6860" class="kx ky hu ks b fv kz la l lb lc">» ruby test_proc_lambda_returns.rb<br/>About to call Proc<br/>in the proc!<br/>Running Lambda<br/>in the lambda<br/>Done Running Lambda</span></pre><p id="b1d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">注意这里“完成运行过程！”第8行上的永远不会运行，因为我们的<code class="eh kp kq kr ks b">proc_return</code>中的<code class="eh kp kq kr ks b">return</code>跳出了整个<code class="eh kp kq kr ks b">test_proc_returns</code>方法。</p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><h1 id="7fa5" class="lf ky hu bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb dt translated">传递和执行块</h1><p id="d82a" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">既然我们几乎是街区专家，是时候把我们新学到的技能派上用场了。我们已经探索了将块隐式传递给Ruby方法，现在是时候让这篇文章变得显式了。在方法头中的变量前使用强大的<code class="eh kp kq kr ks b">&amp;</code>符号，我们可以将任何Proc/Lambda转换成一个块！</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mz"><img src="../Images/b93e0a3dee10097d2aa0556d5aa5d023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSgFUVeAmxpIA6FwwKcLFg.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">‘&amp;’ converts a Proc/Lambda to an explicit Block</figcaption></figure><p id="b99b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个例子中，我们已经开始探索作为回调函数的块的用例。<code class="eh kp kq kr ks b">print_each_value</code>本质上是一个封装在lambda中的方法，我选择它而不是Proc，因为我们想确保它有一个要打印的参数。在不改变<code class="eh kp kq kr ks b">print_blocks</code>方法的情况下，我们可以创建新的Lambdas来改变它的功能。上面的代码片段输出了以下内容:</p><pre class="jq jr js jt fq kt ks ku kv aw kw dt"><span id="a576" class="kx ky hu ks b fv kz la l lb lc">» ruby print_blocks.rb<br/>lets print each value verbatim<br/>0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>Now let's double down<br/>0<br/>2<br/>4<br/>6<br/>8<br/>10<br/>12<br/>14<br/>16</span></pre><p id="65d1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个例子仍然很幼稚，但是现在我们理解了<code class="eh kp kq kr ks b">&amp;</code>，我们可以完全沉浸在基于块的回调中。</p><p id="3cf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我之前说过，这里的可能性只是自限性的。鲁比的口头禅是永远不要问“为什么？”，功能是提供给你的，由你来决定用它创建什么。这里有几个有趣的例子让你动脑筋:</p><h2 id="4f56" class="kx ky hu bd lg na nb nc lk nd ne nf lo jc ng nh ls jg ni nj lw jk nk nl ma nm dt translated">尝试</h2><p id="5317" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">一种接受布尔值、可变参数数组和块的方法。<strong class="it hv"> Try </strong>然后执行该块，传入参数[0]，如果出现错误，则传入prys。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff nn"><img src="../Images/1442c7cb437dbf5611ab1771bc81ad1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-080OOomk3DP_BBlIC_qQ.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">A clear example of how powerful blocks can be</figcaption></figure><p id="ddc6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的第一次尝试中，尝试已经证明了它的价值:</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff no"><img src="../Images/d58d6eec091463185df228211db1fbc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*koyl9vSNsiDti7jVQ-erYw.png"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">I forgot to create the needed file…</figcaption></figure><p id="b93c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在修复了这个错误之后，我们可以重新运行我们的脚本:</p><pre class="jq jr js jt fq kt ks ku kv aw kw dt"><span id="680d" class="kx ky hu ks b fv kz la l lb lc">» ruby try.rb<br/>Hello World<br/>HELLO WORLD<br/>hello world</span></pre><p id="592a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我喜欢这个例子，因为我的屎坏了很多，能够立即确定为什么失败，并看到所说的失败的范围，让我更快地解决我的问题。这个例子很容易扩展，因为<code class="eh kp kq kr ks b">*params</code>可以包含任意数量的参数——只要记住我们的块必须在参数列表的末尾。</p><h2 id="54ff" class="kx ky hu bd lg na nb nc lk nd ne nf lo jc ng nh ls jg ni nj lw jk nk nl ma nm dt translated">四处执行</h2><p id="1b5b" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">将块传递给方法在Ruby中很常见，它有自己的名字:Execute Around(块)。在这个编程模型中，我们定义了一个方法，该方法接受一个块并围绕它执行一系列任务<strong class="it hv">，比如打印、记录、访问数据库，或者任何你的小编码者想要的。</strong></p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kn ko l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Our Block has finally reached its potential</figcaption></figure><pre class="jq jr js jt fq kt ks ku kv aw kw dt"><span id="d75c" class="kx ky hu ks b fv kz la l lb lc">» ruby execute_around.rb<br/>86400<br/>1<br/>-1</span></pre><p id="1db7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以及log_1556468836.txt的日志输出:</p><pre class="jq jr js jt fq kt ks ku kv aw kw dt"><span id="1729" class="kx ky hu ks b fv kz la l lb lc">Starting 'Calculate seconds in a day'<br/>Completed 'Calculate seconds in a day'<br/>Starting 'Open a file I know doesn't exist'<br/>'Open a file I know doesn't exist' FAILED!</span></pre><h1 id="a106" class="lf ky hu bd lg lh np lj lk ll nq ln lo lp nr lr ls lt ns lv lw lx nt lz ma mb dt translated">快速回顾</h1><ul class=""><li id="5438" class="mj mk hu it b iu mc iy md jc nu jg nv jk nw jo mo mp mq mr dt translated">块是隐式传递给函数的匿名函数。它们是Proc类的实例，当它们被传递到一个方法中时，带着它们的作用域</li><li id="8bc2" class="mj mk hu it b iu ms iy mt jc mu jg mv jk mw jo mo mp mq mr dt translated">Proc有两种形式:Proc和Lambda，它们的区别仅在于参数执行和对<code class="eh kp kq kr ks b">return</code>关键字的处理</li><li id="1835" class="mj mk hu it b iu ms iy mt jc mu jg mv jk mw jo mo mp mq mr dt translated">Procs、Lambdas和blocks都是Ruby中<code class="eh kp kq kr ks b">closures</code>的例子</li><li id="db3d" class="mj mk hu it b iu ms iy mt jc mu jg mv jk mw jo mo mp mq mr dt translated">Procs/Lambdas可以转换成带有<code class="eh kp kq kr ks b">&amp;</code>符号的块</li><li id="7599" class="mj mk hu it b iu ms iy mt jc mu jg mv jk mw jo mo mp mq mr dt translated">当作为回调函数实现时，块的功能就实现了</li></ul></div></div>    
</body>
</html>