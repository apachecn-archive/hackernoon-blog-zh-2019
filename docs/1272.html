<html>
<head>
<title>React’s New Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的新上下文API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reacts-new-context-api-b29d442d5abc?source=collection_archive---------2-----------------------#2019-02-22">https://medium.com/hackernoon/reacts-new-context-api-b29d442d5abc?source=collection_archive---------2-----------------------#2019-02-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/98a124a84a5854e5cfb1b80faa5ed7ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iq_xUySrcOf8k4ZwSeMzDw.jpeg"/></div></div></figure></div><div class="ab cl jc jd hc je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h2 id="7333" class="jj jk hu bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">介绍</h2><p id="da60" class="pw-post-body-paragraph kh ki hu kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la lb hn dt translated">最近React引入了一些新的很酷的特性，其中一个有趣且备受期待的特性是<strong class="kj hv">新的</strong> <strong class="kj hv">上下文API </strong>。16.3版引入了新的上下文API。上下文API在没有道具训练的状态管理中非常有用。让我们深入研究一下。</p><h2 id="a7f5" class="jj jk hu bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">问题</h2><p id="1666" class="pw-post-body-paragraph kh ki hu kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la lb hn dt translated">在许多情况下，在我们的应用程序中，我们需要将组件的状态传递到两到三个级别。因此，当并非所有的组件都需要道具时，我们将道具传递到组件树的一层又一层。假设组件层次结构很复杂，那么状态管理对开发人员来说是一种开销。</p><h2 id="59e8" class="jj jk hu bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">解决办法</h2><p id="a7c8" class="pw-post-body-paragraph kh ki hu kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la lb hn dt translated">对于状态管理，有几个可用的库，如Redux(最常用的和趋势)。但是React引入了上下文API来解决道具钻取的问题，让开发者的状态管理工作变得简单。</p><h2 id="b31e" class="jj jk hu bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">何时使用上下文</h2><p id="2675" class="pw-post-body-paragraph kh ki hu kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la lb hn dt translated">正如React建议的“如果你只想避免通过许多关卡传递一些道具。Context旨在共享可被视为React组件树的“全局”数据，如当前已验证的用户、主题或首选语言。</p><h2 id="a71c" class="jj jk hu bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">如何使用上下文</h2><p id="e7be" class="pw-post-body-paragraph kh ki hu kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la lb hn dt translated">所以现在如果你想在你的应用程序中使用上下文，首先创建上下文对象。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="0598" class="jj jk hu lh b fv ll lm l ln lo">import { createContext } from 'react';</span><span id="fc80" class="jj jk hu lh b fv lp lm l ln lo">const {Provider, Consumer } = React.createContext();</span></pre><p id="a0d3" class="pw-post-body-paragraph kh ki hu kj b kk lq km kn ko lr kq kr ju ls kt ku jy lt kw kx kc lu kz la lb hn dt translated">然后创建一个包装器组件，它将返回Provider组件，并且还将您想要从中访问上下文的所有组件添加为子组件。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d373" class="jj jk hu lh b fv ll lm l ln lo">class ProviderComponent extends Component {<br/>    state = {<br/>        title : “Vishal”,<br/>    }</span><span id="58da" class="jj jk hu lh b fv lp lm l ln lo">render() {<br/>        return ( <br/>        &lt;Provider value={this.state}&gt;<br/>          &lt;Website /&gt;<br/>        &lt;/Provider&gt;<br/>        )<br/>    }<br/>}</span></pre><p id="3ba7" class="pw-post-body-paragraph kh ki hu kj b kk lq km kn ko lr kq kr ju ls kt ku jy lt kw kx kc lu kz la lb hn dt translated">我们的网站组件看起来像</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="92fa" class="jj jk hu lh b fv ll lm l ln lo">const Website = () =&gt; (<br/>  &lt;div&gt;<br/>    &lt;Header /&gt;<br/>    &lt;Footer /&gt;<br/>  &lt;/div&gt;<br/>)</span></pre><p id="b3b7" class="pw-post-body-paragraph kh ki hu kj b kk lq km kn ko lr kq kr ju ls kt ku jy lt kw kx kc lu kz la lb hn dt translated">现在，如果我们想从提供者组件到标题组件访问标题，我们可以简单地使用上下文来消费提供者组件的状态，而无需适当的钻取。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="8cc0" class="jj jk hu lh b fv ll lm l ln lo">const Header = () =&gt; (<br/>  &lt;div&gt;<br/>     &lt;Consumer&gt;<br/>        {(context) =&gt; context.title}<br/>      &lt;/Consumer&gt;<br/>  &lt;/div&gt;<br/>)</span></pre></div><div class="ab cl jc jd hc je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h2 id="6e4f" class="jj jk hu bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">结论</h2><p id="eacb" class="pw-post-body-paragraph kh ki hu kj b kk kl km kn ko kp kq kr ju ks kt ku jy kv kw kx kc ky kz la lb hn dt translated">ReactJS的这个很酷的新特性可以帮助开发人员简化他们的工作。对于一个简单的prop drilling解决方案，context可以很好地工作，但是对于具有复杂状态和缩减器的大型应用程序，Redux可能是一个更好的解决方案。</p><p id="274a" class="pw-post-body-paragraph kh ki hu kj b kk lq km kn ko lr kq kr ju ls kt ku jy lt kw kx kc lu kz la lb hn dt translated">感谢阅读。我希望你喜欢这篇文章🙏</p></div></div>    
</body>
</html>