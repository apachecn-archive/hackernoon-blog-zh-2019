<html>
<head>
<title>Building a Serverless Microservice CRUD RESTful API with MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MongoDB构建无服务器微服务CRUD RESTful API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-serverless-microservice-crud-restful-api-with-mongodb-6e0316efe280?source=collection_archive---------0-----------------------#2019-01-29">https://medium.com/hackernoon/building-a-serverless-microservice-crud-restful-api-with-mongodb-6e0316efe280?source=collection_archive---------0-----------------------#2019-01-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="f9ed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本帖中，我们将构建一个无服务器的微服务，在一个完全托管的MongoDB NoSQL数据库上公开创建、读取、更新、删除(CRUD)操作。我们将使用新发布的<strong class="it hv"> Lambda层</strong>来封装与MongoDB集成所需的第三方库。我们将使用亚马逊API网关来创建、管理和保护我们的REST API，以及它与AWS Lambda的集成。Lambda将用于解析请求并执行CRUD操作。我使用自己的开源代码和脚本，以及AWS <a class="ae jp" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank">无服务器应用模型</a>来测试、打包和部署堆栈。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff jq"><img src="../Images/a557ca101cf3e30249c2c306fc6e2ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvU57Iufi8lFf2WDOo4frA.png"/></div></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Serverless Microservice CRUD REST API with MongoDB</figcaption></figure><p id="28e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">无服务器正在获得越来越多的牵引力，可以完成或补充集装箱。在无服务器中，仍然有服务器，只是你不管理它们，你按使用付费，它会自动为你扩展。它也是事件驱动的，因为你可以更多地关注业务逻辑代码，而不是入站集成，这要归功于越来越多的Lambda事件源触发器，如Alexa、S3、DynamoDB和由AWS构建和维护的API Gateway。</p><p id="d68c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更有趣的是，在这篇文章中，我使用了我在<a class="ae jp" href="https://www.youtube.com/watch?v=YGNu6SLCk50" rel="noopener ugc nofollow" target="_blank"> AWS re:Invent 2016 </a>和<a class="ae jp" href="https://aws.amazon.com/blogs/big-data/analyze-a-time-series-in-real-time-with-aws-lambda-amazon-kinesis-and-amazon-dynamodb-streams/" rel="noopener ugc nofollow" target="_blank">AWS大数据博客文章</a>中介绍的模式的简化版本和子集，您可以使用DynamoDB从我们内部的<a class="ae jp" href="https://aws.amazon.com/solutions/case-studies/justgiving/" rel="noopener ugc nofollow" target="_blank"> RAVEN数据科学平台</a>中使用的Kinesis流中的数十亿网络分析事件中实现大规模实时计数器。这里的重点将是创建前端，而不是后端，即使用API Gateway，Lambda和MongoDB的无服务器CRUD REST API。</p><h1 id="65f4" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">MongoDB和我的历史</h1><p id="37a6" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">有许多NoSQL数据库，如Amazon DynamoDB，这是一个键值和文档存储，可以轻松地与AWS中的其他无服务器堆栈集成，其中有许多博客帖子、书籍、文档和视频课程，包括<a class="ae jp" href="https://www.packtpub.com/application-development/implementing-serverless-microservices-architecture-patterns-video" rel="noopener ugc nofollow" target="_blank"> my own </a>。正如我们之前介绍过DynamoDB一样，让我们来谈谈如何使用MongoDB。如果我们看看一些<a class="ae jp" href="https://db-engines.com/en/system/MongoDB" rel="noopener ugc nofollow" target="_blank">数据库排名</a>，它在总体排名第五，在文档存储数据库排名第一，并且有一些大公司在使用它。</p><p id="c043" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我和MongoDB有些渊源。当我们于2013年在<a class="ae jp" href="https://www.justgiving.com/" rel="noopener ugc nofollow" target="_blank"> JustGiving </a>开始在生产中部署<em class="lj">机器学习的旅程时，这是一个以技术换公益的众筹和筹款平台，从2600万用户那里筹集了超过50亿美元用于公益事业，并于2017年被<a class="ae jp" href="https://www.blackbaud.com/" rel="noopener ugc nofollow" target="_blank"> Blackbaud </a>以1 . 21亿美元收购。我选择将产品命名为PANDA，我们构建的第二个系统是一个离线批量训练和推理引擎(当时在产品中嵌入数据科学非常罕见，更多的是在笔记本电脑上进行本地数据科学，没有Apache Spark，也没有无服务器或稳定的docker)。这些批量分数、推断或预测将定期插入MongoDB，我们将通过我们的PANDA REST API提供预测、推荐和建议，我们的前端服务和移动应用程序将调用这些API。我认为这种架构的美妙之处在于，我们将数据科学服务从前端产品中分离出来，允许我们以不同的速度移动，并在他们不注意的情况下更新后端。</em></p><p id="7c70" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当时，我选择MongoDB作为后端数据存储，因为它是一个NoSQL数据库，使我们能够灵活地在JSON中存储数据，以非常低的延迟检索数据，并可以通过分片轻松地向外扩展。在JustGiving，这是一个伟大的人工智能成功故事，也是许多后续案例研究、主题演讲、<a class="ae jp" href="https://www.amazon.co.uk/Cracking-Data-Code-Unlock-organisation/dp/1781333335" rel="noopener ugc nofollow" target="_blank">书籍</a>和<a class="ae jp" href="https://www.techuk.org/insights/news/item/9603-meet-october-s-big-data-hero" rel="noopener ugc nofollow" target="_blank">认可</a>的开始。我们不再使用MongoDB，但PANDA仍在使用，新的令人兴奋的功能和实验正在定期添加。我写这篇文章的灵感来自于阅读Adnan Rahi的<a class="ae jp" href="https://hackernoon.com/building-a-serverless-rest-api-with-node-js-and-mongodb-2e0ed0638f47" rel="noopener ugc nofollow" target="_blank">关于使用node.js和MongoDB </a>构建无服务器API的帖子，但是在这里我使用了Re:Invent(我目前最喜欢的语言Python)的最新无服务器特性和开源AWS无服务器应用模型(<a class="ae jp" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html" rel="noopener ugc nofollow" target="_blank"> SAM </a>)。</p><h1 id="bba7" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">MongoDB设置</h1><p id="81bc" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">MongoDB Atlas是我们将使用的，因为它有一个没有信用卡的免费层，并且是一个完全托管的服务。</p><h2 id="a218" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">设置新的集群</h2><p id="3552" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">1.在你的浏览器中，进入<a class="ae jp" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB web界面</a>T3】2。选择<strong class="it hv">开始免费</strong>3<br/>。输入你的<strong class="it hv">邮箱</strong>，<strong class="it hv">名</strong>，<strong class="it hv">姓</strong>，<strong class="it hv">密码</strong> <br/> 4。检查<strong class="it hv">我同意服务条款。</strong> <br/> 5。选择<strong class="it hv">免费入门</strong> <br/> 7。选择<strong class="it hv">关闭</strong>进行<strong class="it hv">全局集群配置</strong>6。选择<strong class="it hv"> AWS </strong>为<strong class="it hv">云提供商&amp;区域</strong>T31】7。选择有<strong class="it hv">自由层可用的地区</strong> <br/> *美国地区选择<strong class="it hv"> us-east-1 </strong> <br/> *欧洲地区选择<strong class="it hv"> eu-central-1 </strong> <br/> *亚洲地区选择<strong class="it hv"> ap-southeast-1 </strong>或<strong class="it hv"> ap-south-1 </strong> <br/> 8。对于<strong class="it hv">集群层</strong>将其留在<strong class="it hv"> M0(共享RAM，512 MB存储)</strong> <br/> 9。对于<strong class="it hv">附加设置</strong>，保留默认值<br/> 10。对于<strong class="it hv">簇名</strong>键入<code class="eh ly lz ma mb b">user-visits</code>T56】11。选择<strong class="it hv">创建集群</strong> <br/> *您也将获得验证码<br/> *这将开始创建集群</p><h2 id="a517" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">配置并连接到您的集群</h2><p id="0244" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在让我们创建一个Lambda函数可以使用的数据库用户，通过将IP范围列入白名单来允许Lambda访问数据库并连接到集群。</p><p id="88b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.选择<strong class="it hv">安全</strong>选项卡和<strong class="it hv"> MongoDB用户</strong> <br/> 2。选择<strong class="it hv">添加新用户</strong>子选项卡<br/> 3。在急停认证中<br/> *为<strong class="it hv">用户名</strong>输入<code class="eh ly lz ma mb b">lambdaReadWriteUser</code> <br/> *为<strong class="it hv">密码</strong>输入安全密码<br/> *为<strong class="it hv">用户权限</strong>选择<strong class="it hv">读写任意数据库</strong> <br/> 4。选择<strong class="it hv"> IP白名单</strong>子选项卡<br/> 5。选择<strong class="it hv">添加IP地址</strong>6<br/>。选择<strong class="it hv">允许从任何地方访问</strong> <br/> *安全风险—您将看到添加了CIDR <code class="eh ly lz ma mb b">0.0.0.0/0</code>，允许任何系统访问数据库，这通常是一种非常糟糕的安全做法，但对于这里的演示数据的概念证明来说是不错的。<br/> 7。选择<strong class="it hv">确认</strong>8<br/>。选择<strong class="it hv">概述</strong>标签<br/> 9。在沙盒窗口<br/> 10中选择<strong class="it hv">连接</strong>。选择<strong class="it hv">下的<strong class="it hv">短SRV连接串</strong>复制与你的驱动</strong>11兼容的连接串。安装Python依赖包<code class="eh ly lz ma mb b">pymongo</code>、<code class="eh ly lz ma mb b">dnspython</code>、<code class="eh ly lz ma mb b">bson</code>、<code class="eh ly lz ma mb b">$ sudo pip install pymongo dnspython bson</code>、<br/>或<code class="eh ly lz ma mb b">sudo pip install -r requirements.txt</code></p><h2 id="08c7" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">使用Python本地连接到MongoDB</h2><p id="d099" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">创建一个名为<code class="eh ly lz ma mb b">mongo_config.py</code>的Python脚本，并键入或粘贴以下内容</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="5a6b" class="lk kh hu mb b fv mg mh l mi mj">db_username = "lambdaReadWriteUser"<br/>db_password = "&lt;my-super-panda-password&gt;"<br/>db_endpoint = "user-visits-abcde.mongodb.net/test?retryWrites=true"<br/>db_port = "27017"</span></pre><p id="936b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ly lz ma mb b">db_endpoint</code>是短SRV中的主机，即<code class="eh ly lz ma mb b">@</code>符号后的部分。这里的<code class="eh ly lz ma mb b">test</code>将是数据库的名称，用所需的名称替换它。</p><h2 id="3448" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">安全建议</h2><p id="0313" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">上述内容存在一些安全风险，因此对于生产部署，我建议:<br/> *使用MongoDB AWS VPC对等连接(您将需要使用payed M10+实例)<br/> *不要在IP白名单中使用<code class="eh ly lz ma mb b">0.0.0.0/0</code>，而是在VPC中启动Lambda并将其限制在那个无类域间路由(CIDR)或IP范围内<br/> *不要使用<code class="eh ly lz ma mb b">mongo_config.py </code>来存储密码，而是使用KMS来加密密码并将其存储在Lambda环境变量中。</p><p id="ba4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在让我们创建四个CRUD方法。</p><h2 id="c87a" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建PUT方法</h2><p id="1bbf" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">创建并运行名为<code class="eh ly lz ma mb b">mongo_modify_items.py</code>的Python脚本，键入或粘贴以下内容</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="4424" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我使用了存储库设计模式并创建了一个<code class="eh ly lz ma mb b">class MongoRepository</code>，它抽象并集中了与MongoDB的所有交互，包括JSON记录的连接和插入。当<code class="eh ly lz ma mb b">MongoRepository</code>被实例化时，我们使用<code class="eh ly lz ma mb b">mongo_config.py</code>中的变量和参数<code class="eh ly lz ma mb b">mongo_db</code>、<code class="eh ly lz ma mb b">table_name</code>创建我们之前看到的短SRV连接字符串。</p><p id="bfad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh ly lz ma mb b">insert_mongo_event_counter_json()</code>方法中，我首先对数据有一个<code class="eh ly lz ma mb b">EventId</code>的检查进行整形，然后用<code class="eh ly lz ma mb b">EventId</code>和<code class="eh ly lz ma mb b">EventDay</code>创建一个<code class="eh ly lz ma mb b">entity_id</code> entity_id，作为类似于主键的更新过滤器。<code class="eh ly lz ma mb b">{“$set”:{‘EventCount’: event_data.get(‘EventCount’, 1)}}</code>是更新动作，这里我们覆盖了更新过滤器的现有<code class="eh ly lz ma mb b">EventCount</code>值，因为它是一个PUT，所以应该是幂等的——多次调用它具有相同的效果。这里我使用<code class="eh ly lz ma mb b">update_one()</code>向您展示<code class="eh ly lz ma mb b">$set</code>操作符，但是您同样可以使用更简单的<code class="eh ly lz ma mb b">insert_one()</code>将JSON文档添加到MongoDB集合中，参见<a class="ae jp" href="https://docs.mongodb.com/manual/crud/" rel="noopener ugc nofollow" target="_blank"> Mongo文档</a>。</p><p id="8d4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当您运行此命令时，您应该会在控制台中看到以下内容</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="e628" class="lk kh hu mb b fv mg mh l mi mj">{'n': 1, 'nModified': 0, 'opTime': {'ts': Timestamp(946684800, 2), 't': 1}, 'electionId': ObjectId('7fffffff0000000000000001'), 'ok': 1.0, 'operationTime': Timestamp(1546799181, 2), '$clusterTime': {'clusterTime': Timestamp(946684800, 2), 'signature': {'hash': b'~\n\xa5\xd9Ar\xa5 \x06f\xbd\x8e\x9d\xc39;\x14\x85\xb6(', 'keyId': 6642569842735972353}}, 'updatedExisting': True}</span><span id="0911" class="lk kh hu mb b fv mm mh l mi mj">Process finished with exit code 0</span></pre><p id="c6ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，<code class="eh ly lz ma mb b">’ok’: 1.0</code>表示更新成功，而<code class="eh ly lz ma mb b">’n’: 1, ‘nModified’: 0</code>表示添加了一条记录，没有修改其他记录。</p><p id="9174" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">13.在你的浏览器中，回到<a class="ae jp" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank"> MongoDB web界面</a> <br/> 14。在左侧导航栏<br/> 15的<strong class="it hv">集群</strong>下选择<strong class="it hv">用户访问</strong>。选择<strong class="it hv">收藏</strong>标签<br/>你应该会看到这样的东西</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="fe ff mn"><img src="../Images/354760caaa84c76f8250fdc4c71d6c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HRUnKfH9qX-zytO6sbdxyg.png"/></div></div></figure><p id="d29a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">再次运行它，您将看到<code class="eh ly lz ma mb b">EventCount : 1</code>，这是预期的行为。</p><h2 id="6e00" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建GET方法</h2><p id="53e6" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在让我们给<code class="eh ly lz ma mb b">class MongoRepository</code>添加另外两个叫做<code class="eh ly lz ma mb b">query_mongo_by_entityid()</code>和<code class="eh ly lz ma mb b">query_mongo_by_entityid_date()</code>的方法</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="81ad" class="lk kh hu mb b fv mg mh l mi mj">def query_mongo_by_entityid(self, entity_id):<br/>    results = self.event_collection.find({'EventId': entity_id})<br/>    print("Query: %s found: %d document(s)" % (entity_id, results.count()))<br/>    return dumps(results.sort("EventDay", pymongo.ASCENDING))</span><span id="10b6" class="lk kh hu mb b fv mm mh l mi mj">def query_mongo_by_entityid_date(self, entity_id, entity_date):<br/>    entity_id = {'EventId': entity_id, 'EventDay': {"$gt": int(entity_date)}}<br/>    results = self.event_collection.find(entity_id)<br/>    print("Query: %s found: %d document(s)" % (entity_id, results.count()))<br/>    return dumps(results.sort("EventDay", pymongo.ASCENDING))</span></pre><ul class=""><li id="50f8" class="mo mp hu it b iu iv iy iz jc mq jg mr jk ms jo mt mu mv mw dt translated"><code class="eh ly lz ma mb b">query_mongo_by_entityid()</code>通过<code class="eh ly lz ma mb b">EventId</code>查询MongoDB，并通过<code class="eh ly lz ma mb b">EventDay</code>对结果进行升序排序。</li><li id="dd83" class="mo mp hu it b iu mx iy my jc mz jg na jk nb jo mt mu mv mw dt translated"><code class="eh ly lz ma mb b">query_mongo_by_entityid_date()</code>按<code class="eh ly lz ma mb b">EventId</code>和大于指定参数的<code class="eh ly lz ma mb b">EventDate</code>查询MongoDB，并按<code class="eh ly lz ma mb b">EventDay</code>将结果按升序排序。</li></ul><h2 id="4097" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建POST方法</h2><p id="5a52" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在让我们给<code class="eh ly lz ma mb b">class MongoRepository</code>添加另一个叫做<code class="eh ly lz ma mb b">upsert_mongo_event_counter_json()</code>的方法</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="f860" class="lk kh hu mb b fv mg mh l mi mj">def upsert_mongo_event_counter_json(self, event_data):<br/>    entity_id = {'EventId': event_data.get('EventId', ''),<br/>                     'EventDay': int(event_data.get('EventDay', 0))}<br/>    if event_data.get('EventId', '') != '':<br/>        self.event_collection.update_one(entity_id,<br/>                                     {"$inc":{"EventCount":     <br/>                                     event_data.get('EventCount',1)}},<br/>                                     upsert=True).raw_result<br/>    else:<br/>        print("No EventId, skipping record")</span></pre><p id="557a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">称之为主要的</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="4ca8" class="lk kh hu mb b fv mg mh l mi mj">def main():<br/>    print(mongo_repo.upsert_mongo_event_counter_json(event_sample))</span></pre><p id="0c1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您现在将看到<code class="eh ly lz ma mb b">EventCount : 2</code>再次运行它，并且您将看到<code class="eh ly lz ma mb b">EventCount</code>将增加<code class="eh ly lz ma mb b">1</code>。这是因为如果指定了<code class="eh ly lz ma mb b">event_sample</code>字典中的<code class="eh ly lz ma mb b">EventCount</code>值，则<code class="eh ly lz ma mb b">$inc</code>会将<code class="eh ly lz ma mb b">EventCount</code>递增，否则默认为<code class="eh ly lz ma mb b">1</code>。</p><h2 id="ba4c" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建删除方法</h2><p id="f935" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">最后，我们也需要一个删除数据的方法。</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="97cb" class="lk kh hu mb b fv mg mh l mi mj">def delete_mongo_event_counter_json(self, entity_id):<br/>    return dumps(self.event_collection<br/>                 .delete_many({'EventId': entity_id})<br/>                 .deleted_count)</span></pre><p id="f9d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们选择删除与给定的<code class="eh ly lz ma mb b">entity_id</code>参数匹配的记录。</p><p id="00c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在知道了如何本地连接和更新MongoDB中的记录，现在让我们使用相同的Mongo CRUD代码以及解析请求、形成响应和基于HTTP方法控制执行流所需的附加代码来创建Lambda函数。在此之前，让我们创建Lambda所需的角色和策略。</p><h1 id="31e6" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">创建无服务器配置</h1><p id="1e44" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">我假设您已经安装了AWS CLI并带有密钥，如果您必须在Windows上运行，那么您正在运行一个<a class="ae jp" href="https://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/" rel="noopener ugc nofollow" target="_blank"> Linux Bash shell </a>。您还拥有Python 3.6+安装程序。</p><h2 id="7b90" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建环境变量</h2><p id="53da" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">首先，我创建名为<code class="eh ly lz ma mb b">common-variables.sh</code>的配置文件来存储所有的环境变量。我喜欢这样做，稍后我可以在CI/CD工具中配置这些，这样可以更容易地移植到不同的AWS帐户。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="4d29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我使用CLI确定AWS帐户ID，但是您也可以像注释中所示的那样对它进行硬编码，您可以对region进行同样的操作。你还会看到我有一些Layers变量，我们将使用shorty来创建带有MongoDB包的层，Lambda将需要这些包来对MongoDB进行CRUD访问。</p><h2 id="f903" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建Lambda执行角色</h2><p id="b131" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">首先，让我们创建一个Lambda IAM角色，它将允许Lambda写入CloudWatch。</p><p id="fdaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用以下JSON内容创建一个名为<code class="eh ly lz ma mb b">assume-role-lambda.json</code>的文件</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="ea44" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们用下面的代码创建一个名为<code class="eh ly lz ma mb b">create-role.sh</code>的shell脚本</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="ce6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里我们创建了一个名为<code class="eh ly lz ma mb b">lambda-mongo-data-api</code>的新角色，并附加了AWS托管策略<code class="eh ly lz ma mb b">AWSLambdaBasicExecutionRole</code>。这将允许我们将日志存储在CloudWatch中，以便进行任何调试和监控。</p><p id="aa48" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用<code class="eh ly lz ma mb b">./create-role.sh</code>运行shell脚本来创建Lambda执行角色并附加策略。</p><h2 id="ffb8" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建SAM模板</h2><p id="f60f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">AWS <a class="ae jp" href="https://docs.aws.amazon.com/lambda/latest/dg/serverless_app.html" rel="noopener ugc nofollow" target="_blank">无服务器应用程序模型(SAM) </a>是一个框架，允许您在AWS上构建无服务器应用程序，包括创建IAM角色、API网关和Lambda资源。比起其他流行的框架，我更喜欢SAM，比如领先的<a class="ae jp" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank"> Serverless </a>，因为SAM受AWS支持，不是基于node.js，而是基于Python。它使用SAM模板来定义无服务器应用程序，并使用AWS CLI来构建和部署它，这是基于CloudFormation的。</p><p id="9ed4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用下面的代码创建一个名为<code class="eh ly lz ma mb b">lambda-mongo-data-api.yaml</code>的文件</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="5028" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从上到下，我首先用一个描述定义SAM模板的类型，然后我们定义一组在部署时从<code class="eh ly lz ma mb b">common-variables.sh</code>传入的参数。如果没有传入这些值，那么它们将返回到默认值:<br/> * <code class="eh ly lz ma mb b">PythonVersion</code>默认值为python3.6 <br/> * <code class="eh ly lz ma mb b">AccountId</code>默认值指定为<code class="eh ly lz ma mb b">000000000000</code>*<br/>*<code class="eh ly lz ma mb b">AWSRegion</code>区域<br/> * <code class="eh ly lz ma mb b">LayerName</code>我们将为图层<br/> * <code class="eh ly lz ma mb b">LayerVersion</code>命名，因为每次发布新版本时每个图层都有一个版本<br/>这些参数中的每一个都是占位符，在YAML中用<code class="eh ly lz ma mb b"><a class="ae jp" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-sub.html" rel="noopener ugc nofollow" target="_blank">!Sub</a></code> CloudFormation函数替换。</p><p id="19aa" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们有CORS设置、Lambda配置处理程序、代码、名称和其他设置。</p><p id="bd8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后使用我们刚刚创建的IAM角色。我更喜欢创建独立于SAM的角色，因为它们可以更容易地被重用，因为它们不会被无服务器堆栈删除。我还有一个名为<code class="eh ly lz ma mb b">demo</code>的环境变量。出于安全原因，我将列出完整的<code class="eh ly lz ma mb b">GET POST PUT DELETE</code>方法，但是您可以将其缩短为<code class="eh ly lz ma mb b">Method: ANY</code>。</p><h2 id="e06b" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建Lambda函数</h2><p id="65ec" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">接下来让我们用下面的代码创建一个名为<code class="eh ly lz ma mb b">lambda_crud_mongo_records.py</code>的Lambda函数:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="34b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里从上到下分三个档次。</p><p id="38af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">*<code class="eh ly lz ma mb b">class HttpUtils</code>是一组用于解析查询字符串、正文并返回响应的实用方法。<br/> *我们之前谈到的<code class="eh ly lz ma mb b">class MongoRepository</code>，它抽象并集中了所有的MongoDB交互。<br/>*<code class="eh ly lz ma mb b">class Controller</code>控制主流程，根据方法、请求参数和请求体调用不同的Mongo方法。这里的方法有<code class="eh ly lz ma mb b">GET</code>、<code class="eh ly lz ma mb b">DELETE</code>、<code class="eh ly lz ma mb b">POST</code>和<code class="eh ly lz ma mb b">PUT</code>。对于<code class="eh ly lz ma mb b">GET</code>方法，根据是否提供了<code class="eh ly lz ma mb b">startDate</code>，我们可以在Mongo上进行两种类型的查询。</p><p id="66af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经编写了大部分防御性代码，所以像处理无效JSON和请求中的非数字这样的事情，不会降低Lambda。</p><h2 id="ace5" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">创建包</h2><p id="3539" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">一旦部署到AWS，Lambda将需要Python依赖包<code class="eh ly lz ma mb b">pymongo</code>、<code class="eh ly lz ma mb b">dnspython</code>和<code class="eh ly lz ma mb b">bson</code>。<br/>这些需要打包和部署才能工作。有两种方法可以做到这一点。第一个是使用一个<code class="eh ly lz ma mb b">virtualenv</code>来创建依赖包并添加Lambda代码，并将它们压缩成一个Zip包。第二种也是较新的方法，是使用Lambda层，将一个包含依赖包的包作为Zip文件，另一个用于Lambda源代码本身。</p><h2 id="c6bb" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">用MongoDB依赖包创建一个层</h2><p id="3cd8" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">什么是层？它们是在RE:Invent 2018上推出的，是Lambda包和依赖管理最有用的功能之一。过去，任何非标准的Python库或boto3包都必须与Lambda代码打包在一起。这使得包比它需要的要大，也阻止了Lambdas之间的重用。有了层，任何代码都可以与Lambda函数代码本身分开打包和部署。这允许一个层被不同的Lambda和一个更小的Lambda包重用。每个Lambda函数支持多达5层，允许您抽象第三方依赖包，也可以抽象您自己组织的代码。</p><p id="da29" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这里让我们创建一个包含三个依赖Python包的包，Lambda需要这些包来连接MongoDB并在其上执行CRUD操作。</p><p id="9d31" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用下面的代码创建一个名为<code class="eh ly lz ma mb b">lambda-requirements.txt</code>的文件</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="f531" class="lk kh hu mb b fv mg mh l mi mj">bson&gt;=0.5.6<br/>dnspython&gt;=1.15.0<br/>pymongo&gt;=3.6.1</span></pre><p id="85b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这包含将在层中打包的依赖包。我添加这个是因为我不想包含其他不需要的测试包，它们在<code class="eh ly lz ma mb b">requirements.txt</code>中。</p><p id="3f1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">用下面的代码创建一个名为<code class="eh ly lz ma mb b">create-dependent-layer.sh</code>的脚本</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="e14d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有的环境变量都是从我们上面运行的“common-variables . sh”shell脚本中创建的。</p><p id="d784" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个脚本首先创建一个virtualenv，并使用<code class="eh ly lz ma mb b">pip3</code>几个<a class="ae jp" href="https://pip.pypa.io/en/stable/reference/pip_install/" rel="noopener ugc nofollow" target="_blank">选项</a>安装我们在<code class="eh ly lz ma mb b">lambda-requirements.txt</code>中指定的包，以最大限度地减少安装我们需要的依赖包所需的代码量和时间。</p><p id="a196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，该脚本将安装了virtualenv的依赖包复制到目录<code class="eh ly lz ma mb b">${packages_path}/${python_version}/site-packages/</code>中，这里是<code class="eh ly lz ma mb b">../../build/python3.6/site-packages/</code>文件夹。这里我明确列出了包文件夹，因为我发现有时你pip安装的包有不同的文件夹名，所以被遗漏了。例如，包<code class="eh ly lz ma mb b">dnspython</code>实际上存储在<code class="eh ly lz ma mb b">dns</code>文件夹下，而不是像您所期望的<code class="eh ly lz ma mb b">dnspython</code>文件夹下。我遍历了一个包列表<code class="eh ly lz ma mb b">${packages_array[@]}</code>，并使用<code class="eh ly lz ma mb b">rsync</code>来复制文件和目录。请注意，要使该层正常工作，需要遵循如下所示的目录约定:</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/9e650d69ec8dc43439763f6dae5acf88.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*Z2GEMZJIK2RVq-Kv6boTfA.png"/></div><figcaption class="kc kd fg fe ff ke kf bd b be z ek">Lambda Layers Folder Structure and Build</figcaption></figure><p id="49b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ly lz ma mb b">Python3.6</code>文件夹结构的惯例是<code class="eh ly lz ma mb b">python/lib/python3.6/site-packages/</code>。</p><p id="77f9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我们用包创建Zip存档。这里的<code class="eh ly lz ma mb b">${target_package_folder#../}</code>用于去掉前面的<code class="eh ly lz ma mb b">../</code>前缀，因为我们只想向上一层，并在<code class="eh ly lz ma mb b">package</code>文件夹下创建Zip存档。这将在正确的文件夹结构<code class="eh ly lz ma mb b">python/lib/python3.6/site-packages/</code>中创建一个包含第三方包的<code class="eh ly lz ma mb b">mongodb-layer.zip</code>档案。</p><p id="159d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，我们使用<code class="eh ly lz ma mb b">aws s3 cp</code>将Zip存档复制到S3，这样它就可以作为一个层使用。</p><p id="52a2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们运行<code class="eh ly lz ma mb b">aws lambda publish-layer-version</code>将它发布为一个层，再次使用我们在<code class="eh ly lz ma mb b">common-variables.sh</code>中创建的环境变量。</p><p id="f8bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行脚本<code class="eh ly lz ma mb b">./create-dependent-layer.sh</code>来创建<code class="eh ly lz ma mb b">mongodb-layer.zip</code></p><p id="a344" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您会注意到，每次运行该脚本时，它都会创建一个新的图层版本。Lambda将使用的当前版本在<code class="eh ly lz ma mb b">common-variables.sh</code>中指定。</p><p id="962a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">还有其他方法来创建一个层中使用的包，比如使用docker容器或EC2，但是本质上这个过程也是类似的，使用<code class="eh ly lz ma mb b">virtualenv</code>和<code class="eh ly lz ma mb b">pip</code>。在撰写本文时，AWS只有一个<code class="eh ly lz ma mb b">SciPy</code>可用，但我希望将来会添加更多。</p><p id="c2a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了构建Lambda档案所需的层。</p><h2 id="2554" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">用Lambda创建一个包</h2><p id="59a9" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">然后我们使用<code class="eh ly lz ma mb b">create-lambda-package.sh</code>压缩Lambda和包</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="47c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，我们创建了两个python脚本的Zip存档文件<code class="eh ly lz ma mb b">lambda_crud_mongo_records.py</code>，其中包含Lambda代码和<code class="eh ly lz ma mb b">mongo_config.py</code>，其中包含MongoDB凭证。</p><p id="0a3e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行脚本<code class="eh ly lz ma mb b">./create-lambda-package.sh</code>检查Zip存档文件是否已创建。</p><p id="b2ad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们现在有一个Zip文件，其中Lambda作为<code class="eh ly lz ma mb b">lambda-mongo-data-api.zip</code>和它的第三方依赖包作为已经部署的可重用层<code class="eh ly lz ma mb b">mongodb-layer.zip</code>。这一层可以被账户中的任何其他Lambda使用！现在让我们看看如何使用SAM部署API Gateway和Lambda函数。</p><p id="88c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">或者，您可以让SAM创建Zip文件，但是我更喜欢控制这个过程，因为例如CI/CD步骤可以将Zip创建为可以回滚的工件，并且您还可以引入进一步的优化来减小大小或使用字节代码。</p><h2 id="9468" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">构建和部署无服务器微服务</h2><p id="2699" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在我们已经有了Zip包，或者作为Lambda及其第三方包的一个胖Zip包(在AWS RE:Invent之前的2018年就已经完成了)，或者一个Lambda Zip存档和一个用于我们已经部署的层的Zip包，让我们部署整个堆栈。</p><h2 id="0d09" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">将Lambda和包作为一个Zip文件进行构建和部署</h2><p id="04af" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">以下是shell脚本<code class="eh ly lz ma mb b">build-package-deploy-lambda-mongo-data-api.sh</code>的内容</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="b0c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">* <code class="eh ly lz ma mb b">aws cloudformation package</code>打包AWS SAM模板引用的工件，创建一个“lambda-mongo-data-API-output . YAML”模板，并将它们上传到S3。<br/> * <code class="eh ly lz ma mb b">aws cloudformation deploy</code>通过创建并执行变更集来部署指定的AWS SAM / CloudFormation模板。这里是API网关和Lambda函数。你可以看到，我可以传入一些我们之前在萨姆·YAML模板中看到的参数:<code class="eh ly lz ma mb b">AccountId</code>、<code class="eh ly lz ma mb b">LayerName</code>、<code class="eh ly lz ma mb b">LayerVersion</code>、<code class="eh ly lz ma mb b">PythonVersion</code>，这些参数是我们在<code class="eh ly lz ma mb b">common-variables.sh</code>中指定的。</p><p id="50bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们只需要运行脚本来创建Lambda Zip、包，并将其与API网关一起部署。</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="e9eb" class="lk kh hu mb b fv mg mh l mi mj">$ ./build-package-deploy-lambda-mongo-data-api.sh</span></pre><h2 id="3feb" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">测试部署的API</h2><p id="8001" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在，您已经了解了如何部署无服务器堆栈，并且可以在AWS管理控制台中测试API网关和Lambda，或者对API或Lambda进行自动化测试，但这里让我们重点关注使用名为Postman的API测试工具来手动测试它是否按预期运行。对于GET或DELETE方法，我们可以使用浏览器，但是我们需要一个类似于<a class="ae jp" href="https://www.getpostman.com" rel="noopener ugc nofollow" target="_blank"> Postman </a>或<a class="ae jp" href="https://insomnia.rest" rel="noopener ugc nofollow" target="_blank">失眠症</a>的工具，因为为了测试PUT和POST方法，我们需要在请求中提供一个JSON主体。</p><p id="b1c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.登录AWS管理控制台，打开<a class="ae jp" href="https://console.aws.amazon.com/apigateway" rel="noopener ugc nofollow" target="_blank"> API网关控制台</a> <br/> 2。在Amazon API Gateway导航窗格<br/> 3中选择<strong class="it hv">API/API Gateway-dynamo</strong>下的<strong class="it hv"> Stages </strong>。选择<strong class="it hv">将</strong>放在<strong class="it hv"> Prod/visits/PUT </strong>下以获取调用URL <br/> *调用URL应该类似于`<a class="ae jp" href="https://{restapi_id}.execute-api.{region}.amazonaws.com/Prod/visits`" rel="noopener ugc nofollow" target="_blank"> https://{restapi_id}。执行-api。{ region } . Amazon AWS . com/Prod/visits `</a><br/>*接下来我们将使用调用URL<br/>4。下载并安装<a class="ae jp" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank">邮差</a> <br/> 5。发射邮递员<br/> 6。从积木中选择<strong class="it hv">请求</strong>或从菜单<br/> 7中选择<strong class="it hv">新建&gt;请求</strong>。在新建保存请求窗口<br/> *中<strong class="it hv">请求名称</strong>键入<code class="eh ly lz ma mb b">put-api-test</code> <br/> *中<strong class="it hv">选择要保存到的集合或文件夹:</strong>键入<code class="eh ly lz ma mb b">api-test</code> <br/> *选择<strong class="it hv">创建集合“API-test”</strong>并在列表中选择<br/> *选择<strong class="it hv">保存到api-test </strong></p><h2 id="f554" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">测试部署的API PUT方法</h2><p id="913c" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">1.打开一个新的邮递员标签<br/> 2。从方法下拉菜单<br/> 3中选择上传。在<strong class="it hv">输入请求URL </strong>中，键入您部署的PUT URL，例如`<a class="ae jp" href="https://vjp3e7nvnh.execute-api.eu-west-1.amazonaws.com/Prod/visits`" rel="noopener ugc nofollow" target="_blank">https://vjp 3 e 7 nvnh . execute-API . eu-west-1 . amazonaws . com/Prod/visits `</a><br/>*选择<strong class="it hv"> PUT </strong>下的<strong class="it hv">API&gt;用户评论&gt; Stages </strong> <br/> 4。选择<strong class="it hv">主体</strong>拉环<br/> 5。在body下的行中，从单选按钮中选择<strong class="it hv"> raw </strong>和其右侧的<strong class="it hv"> JSON(应用程序/JSON)</strong>6。键入以下内容</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="7aa2" class="lk kh hu mb b fv mg mh l mi mj">{<br/> "EventId": "2011",<br/> "EventDay": "20171013",<br/> "EventCount": 2<br/>}</span></pre><p id="4e05" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">7.选择<strong class="it hv">发送</strong>8<br/>。检查响应体，如果是<code class="eh ly lz ma mb b">{“n”: 1, […]</code>，那么它已经被添加，否则你会得到一个异常消息，检查URL，JSON体和方法是正确的。<br/> 9。再次选择<strong class="it hv">发送</strong>两次，这应该没有影响，现在让我们看看GET响应。</p><h2 id="daa1" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">测试部署的API GET方法</h2><p id="c565" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">1.在Postman <br/> 2中打开相同的选项卡。把方法改成<strong class="it hv">得到</strong>T71】3。将<code class="eh ly lz ma mb b">/2011</code>追加到URL <br/> 4。选择<strong class="it hv">发送</strong></p><p id="c516" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您应该得到以下响应正文:</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="59b6" class="lk kh hu mb b fv mg mh l mi mj">[<br/>    {<br/>        "_id": {<br/>            "$oid": "5c3281a1b816a500d6a85afc"<br/>        },<br/>        "EventDay": "20171013",<br/>        "EventId": "2011",<br/>        "EventCount": 2<br/>    }<br/>]</span></pre><p id="98df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用PUT方法，无论调用多少次,<code class="eh ly lz ma mb b">EventCount</code>值都保持不变，这就是所谓的幂等运算。</p><h2 id="dee8" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">测试部署的API POST方法</h2><p id="9407" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">现在让我们测试POST方法，它在每次被调用时都将计数器递增指定的值，即非幂等运算。这对于实现计数器(如实时页面浏览量或分数)可能很有用。</p><p id="1f06" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.在Postman <br/> 2中打开相同的选项卡。将方法改为<strong class="it hv">贴</strong>贴<br/> 3。像原来的PUT URL <br/> 4一样从URL <br/>中移除<code class="eh ly lz ma mb b">/2011</code>。选择<strong class="it hv">主体</strong>标签<br/> 5。在body下的行中，从单选按钮中选择<strong class="it hv"> raw </strong>并选择其右侧的<strong class="it hv"> JSON(应用程序/JSON)</strong>6。键入以下内容:</p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="42c3" class="lk kh hu mb b fv mg mh l mi mj">{<br/> "EventId": "2011",<br/> "EventDay": "20171013",<br/> "EventCount": 2<br/>}</span></pre><p id="8c1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">7.选择<strong class="it hv">发送</strong>8<br/>。选择左边的<strong class="it hv">获取</strong>和<strong class="it hv">发送</strong></p><pre class="jr js jt ju fq mc mb md me aw mf dt"><span id="5149" class="lk kh hu mb b fv mg mh l mi mj">[<br/>    {<br/>        "_id": {<br/>            "$oid": "5c3282c6b816a500d6a88210"<br/>        },<br/>        "EventDay": 20171013,<br/>        "EventId": "2011",<br/>        "EventCount": 4<br/>    }<br/>]</span></pre><p id="fccd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">运行几次，你会看到<code class="eh ly lz ma mb b">EventCount</code>增加，如果你修改请求JSON主体<code class="eh ly lz ma mb b">EventCount</code>的值，你也可以增加少于或多于<code class="eh ly lz ma mb b">2</code>的值。</p><h2 id="337c" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">测试已部署的API删除方法</h2><p id="b98f" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">1.在Postman <br/> 2中打开相同的选项卡。将方法改为<strong class="it hv">删除</strong> <br/> 3。将<code class="eh ly lz ma mb b">/2011</code>附加到URL(像GET一样)<br/> 4。选择<strong class="it hv">发送</strong></p><p id="398a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您还可以检查MongoDB控制台，您将看到没有记录</p><p id="910d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.打开<a class="ae jp" href="https://cloud.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB控制台</a>和<br/> 2。在导航中选择<strong class="it hv">星团</strong> <br/> 3。在<strong class="it hv">概述</strong>选项卡中选择<strong class="it hv">用户访问</strong>和<br/> 4。在<strong class="it hv">用户访问</strong>中选择<strong class="it hv">收藏</strong>和<br/> 5。在名称空间下选择<strong class="it hv">Dev&gt;user-vists</strong>T56】* Mongo将运行一个查询<br/> 6。您应该得到查询结果0</p><h2 id="bcd9" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">清理</h2><p id="1ca9" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">由于我们已经使用SAM部署了无服务器API，要删除它，只需运行<code class="eh ly lz ma mb b">./delete-stack.sh</code>以下是shell脚本的内容:</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="c2cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ly lz ma mb b">aws cloudformation delete-stack</code>删除API网关和Lambda。使用for循环一次删除一个层。这里的<code class="eh ly lz ma mb b">${layer_version}</code>是从<code class="eh ly lz ma mb b">common-variables.sh</code>中声明的环境变量中固定下来的，但是通过查找当前层版本，可以很容易地使其成为动态的。</p><p id="8e47" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.打开<a class="ae jp" href="https://cloud.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB控制台</a> <br/> 2。在导航中选择<strong class="it hv">集群</strong>3<br/>。在<strong class="it hv">概览</strong>选项卡中选择<strong class="it hv">用户访问</strong>T10】4。在<strong class="it hv">用户访问</strong>中选择<strong class="it hv">收藏</strong>和<br/> 5。在<strong class="it hv">开发&gt;用户访客</strong>旁边，选择<strong class="it hv">删除</strong>图标<br/> 6。在<strong class="it hv">下拉列表</strong>窗口中输入“用户访问”</p><h2 id="a2b4" class="lk kh hu bd ki ll lm ln km lo lp lq kq jc lr ls ku jg lt lu ky jk lv lw lc lx dt translated">结束语</h2><p id="e964" class="pw-post-body-paragraph ir is hu it b iu le iw ix iy lf ja jb jc lg je jf jg lh ji jj jk li jm jn jo hn dt translated">做得好，你已经部署了一个无服务器的微服务，它有一个完整的CRUD RESTful API和一个MongoDB NoSQL后端。我们已经使用新发布的层来打包MongoDB依赖项，并使用Postman对其进行了测试。我将很快在GitHub上添加完整的源代码。</p><p id="78d5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想了解更多关于无服务器微服务和更复杂的用例，请看看我的视频课程，并支持我写更多免费的技术博客帖子。</p><p id="2e51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的视频课程还提供了其他实现的无服务器模式架构、源代码、shell脚本、配置和演练。对于初学者和中间用户，<a class="ae jp" href="https://www.packtpub.com/application-development/building-scalable-serverless-microservice-rest-data-api-video?utm_source=github" rel="noopener ugc nofollow" target="_blank">完整的无服务器数据API </a>代码、配置和详细的演示</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://www.packtpub.com/application-development/building-scalable-serverless-microservice-rest-data-api-video"><div class="fe ff nd"><img src="../Images/21e74a57929149f8e9e16bf5b2504447.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*uC2n0WrX7Efo7qRlU4y3HA.png"/></div></a><figcaption class="kc kd fg fe ff ke kf bd b be z ek"><a class="ae jp" href="https://www.packtpub.com/application-development/building-scalable-serverless-microservice-rest-data-api-video" rel="noopener ugc nofollow" target="_blank">Building a Scalable Serverless Microservice REST Data API Video Course</a></figcaption></figure><p id="08c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于中级或高级用户，我用原始内容、代码、配置和详细的演示介绍了<a class="ae jp" href="https://www.packtpub.com/application-development/implementing-serverless-microservices-architecture-patterns-video?utm_source=github" rel="noopener ugc nofollow" target="_blank"> 15+无服务器微服务模式</a>的实现。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><a href="https://www.packtpub.com/application-development/implementing-serverless-microservices-architecture-patterns-video"><div class="fe ff nd"><img src="../Images/be4fb5feaba8c334dc85a22ccf6f4aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*XBbcZmMS3kOyhzB9ftvsMA.png"/></div></a><figcaption class="kc kd fg fe ff ke kf bd b be z ek"><a class="ae jp" href="https://www.packtpub.com/application-development/implementing-serverless-microservices-architecture-patterns-video" rel="noopener ugc nofollow" target="_blank">Implementing Serverless Microservices Architecture Patterns Video Course</a></figcaption></figure><p id="705e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请随时在<a class="ae jp" href="https://www.linkedin.com/in/drfreeman/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>T31】Medium或<a class="ae jp" href="https://twitter.com/richardtfreeman" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上与我联系并留言。</p></div></div>    
</body>
</html>