<html>
<head>
<title>Introducing UI2CODE: An Automatic Flutter UI Code Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UI2CODE介绍:一个自动的颤振UI代码生成器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/introducing-ui2code-an-automatic-flutter-ui-code-generator-7e0a575c193?source=collection_archive---------6-----------------------#2019-03-15">https://medium.com/hackernoon/introducing-ui2code-an-automatic-flutter-ui-code-generator-7e0a575c193?source=collection_archive---------6-----------------------#2019-03-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="3130" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在人工智能的帮助下，阿里巴巴的先宇科技团队正在开发一种智能工具，以100%的准确率将视觉UI设计呈现为抖动代码</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/6abb33c7a294e6944ea389863696ce1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w46LzSKaxtyZOmy7COlU3w.jpeg"/></div></div></figure><p id="5a75" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">正如我们在最近一篇关于基于人工智能的算法开发的文章中所探讨的，自动化正在迅速地从开发人员可以处理的东西变成可以做开发人员工作的东西。虽然这种转变的程度在未来几年仍有待观察，但今天的一个主要焦点是人工智能如何处理应用程序开发的重复和乏味方面，以便人类开发人员可以将精力集中在其他地方。</p><p id="ca24" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt">Now, developers at Alibaba’s Xianyu(闲鱼) second-hand trading platform have launched the UI2CODE project to apply deep learning technology in converting visual user interface images to client-side code. With clear component, position, and layout features that suit the scope of machine learning, UI vision research presents an especially promising area for exploring these technologies’ uses in automatic code generation.</p><p id="f674" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这篇介绍Xianyu正在进行的工作的文章中，我们将探讨UI2CODE如何分析GUI元素和UI布局结构，从而为应用程序的整体设计生成Flutter代码。</p><blockquote class="ks kt ku"><p id="1ca0" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated"><em class="hu">延伸阅读:</em></p><p id="d13f" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated"><a class="ae kr" rel="noopener" href="/@alitech_2017/ui2code-how-to-fine-tune-background-and-foreground-analysis-fb269edcd12c"> <em class="hu"> UI2code:如何微调背景和前景分析</em> </a></p></blockquote><h1 id="6f94" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">项目的基础</h1><p id="bf58" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">UI2CODE的早期工作始于2018年3月，当时先宇技术团队对其技术可行性进行了初步研究。从那时起，该项目经历了三轮重构，通过各种机器学习代码生成程序来满足商业设置的标准。</p><p id="7dff" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">UI2CODE的核心原则是划分和控制UI开发特性，以避免过多鸡蛋放在一个篮子里的情况。为此，我们根据三个核心需求评估了它所包含的解决方案。首先，为了视觉复原的精度，它们的输出不能有哪怕一个像素的偏差。其次，尽管机器学习受制于概率，但它们的结果必须达到100%的准确性标准。最后，解决方案必须易于维护；对于工程师来说，可理解和可修改只是一个起点，合理的布局结构对于确保流畅的界面操作至关重要。</p><h1 id="3f9b" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">运行结果</h1><p id="c131" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">经过几轮重构，Xianyu团队确定UI2CODE的关键功能是解决提要流卡片的自动生成，提要流卡片也可以在页面级自动生成。下面的视频展示了UI2CODE插件的运行结果:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="ffbe" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面的部分探索了使UI2CODE能够生成这些结果的设计和过程原则。</p><h1 id="3086" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">架构设计和流程分解</h1><p id="0344" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">下图概述了UI2CODE的架构设计。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/03bf53e2244bd4b4f60c71085ea52689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*DT4vkDasGun_z9ny-xVt9g.png"/></div></figure><p id="c1e8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有了它，系统的过程可以简单地概括为如下所示的步骤:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/e2916480aaaee2126f56a4d5648b5f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*-kqeiu1QSUR6VtbTaW3RUw.png"/></div></figure><p id="bdcc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这个过程大致对应四个步骤。首先，使用深度学习技术从视觉草稿中提取GUI元素。接下来，使用深度学习技术来识别存在的GUI元素的类型。第三，使用递归神经网络技术生成DSL。最后，使用语法树模板匹配生成相应的颤振代码。</p><p id="5337" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">以下部分详细讨论了UI2CODE系统中的关键步骤。</p><h1 id="b123" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">背景/前景分析</h1><p id="f09b" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">UI2CODE中背景/前景分析的唯一目的是切片，它可以直接确定UI2CODE输出的准确性。</p><p id="94e2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面的白色背景用户界面提供了一个简单的例子:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/900ceba28c9ae07037a882eaf2b0b33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*UQqU09Cvj-yULiy8JyrdOg.png"/></div></figure><p id="850b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将该UI读入内存后，将对其执行二进制化，如下所示:</p><pre class="jk jl jm jn fq mb mc md me aw mf dt"><span id="f2ce" class="mg la hu mc b fv mh mi l mj mk">def image_to_matrix(filename):<br/>    im = Image.open(filename)<br/>    width, height = im.size<br/>    im = im.convert("L")<br/>    matrix = np.asarray(im)<br/>    return matrix, width, height</span></pre><p id="f738" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">结果是一个二维矩阵，它将该UI中白色背景的值转换为零:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ml"><img src="../Images/d9888804d9489f29a0efd97eae094e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CTJdUG4ZYEUS_S7x5czEQ.png"/></div></div></figure><p id="a2f1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">只需要五个切割来分离所有的GUI元素。有各种方法将它们分开；下面显示了一个横切代码片段，比实际的切割逻辑稍微简单一些，实际的切割逻辑本质上是一个递归过程:</p><pre class="jk jl jm jn fq mb mc md me aw mf dt"><span id="9f5a" class="mg la hu mc b fv mh mi l mj mk">def cut_by_col(cut_num, _im_mask):<br/>    zero_start = None<br/>    zero_end = None<br/>    end_range = len(_im_mask)<br/>    for x in range(0, end_range):<br/>        im = _im_mask[x]<br/>        if len(np.where(im==0)[0]) == len(im):<br/>            if zero_start == None:<br/>                zero_start = x<br/>        elif zero_start != None and zero_end == None:<br/>            zero_end = x<br/>        if zero_start != None and zero_end != None:<br/>            start = zero_start<br/>            if start &gt; 0:<br/>                cut_num.append(start)<br/>            zero_start = None<br/>            zero_end = None<br/>        if x == end_range-1 and zero_start != None and zero_end == None and zero_start &gt; 0:<br/>            zero_end = x<br/>            start = zero_start<br/>            if start &gt; 0:<br/>                cut_num.append(start)<br/>            zero_start = None<br/>            zero_end = None</span></pre><p id="4f3d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">客户端UI基本上是一个垂直流布局，可以先横切再垂直切割:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/aa6e8f4e06c52195534ab951de8915c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*7qjf6F1j-78k3txuDcaFNg.png"/></div></figure><p id="e57d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">此时，切割点的X和Y坐标被记录，并将形成组件位置关系的核心。切片之后，这产生了两组数据:六个GUI元素图片和它们对应的坐标系记录。在随后的步骤中，使用分类神经网络进行成分识别。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/95af4b4c68c821254e3bf13d5839e7a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*ZCgfIUHBLop9Zb1RSkFgpQ.png"/></div></figure><p id="c125" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在实际生产过程中，背景/前景分析变得更加复杂，主要是在处理复杂背景方面。</p><h1 id="747c" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">元件识别名</h1><p id="e21a" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">在识别成分之前，必须收集样本成分用于训练。进一步的，TensorFlow中提供的CNN模型和SSD模型用于这个阶段的增量训练。</p><p id="ed39" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">UI2CODE根据各种类型对GUI元素进行分类，包括图像、文本、形状/按钮、图标、价格等，然后将这些元素分类为UI组件、CI组件和BI组件。UI组件主要是针对颤振原生组件的分类；CI组件主要是对先宇的自定义UIKIT进行分类；BI组件主要用于具有特定业务相关性的提要流卡片的分类。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/27cda7371c4a4246e1dbb4b0c881084c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*zhcUkmtDh7TK3OA_WytgcA.png"/></div></figure><p id="4f20" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">元件识别的反复校正需要全局特征反馈，通常采用卷积神经网络。以下面的屏幕截图为例，深红色文本的两个字符(翻译为“全新”)构成了图像的richtext部分。同时，相同的形状样式可以出现在按钮或图标中。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mp"><img src="../Images/ae1ca2910c1a95ff93549f6e52358f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gEl93N9LQdte6hIweLwtA.png"/></div></div></figure><h1 id="cb0d" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">属性提取</h1><p id="5b52" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">在各种各样的技术点中，UI2CODE的属性提取步骤可以总结为处理组件的三个方面:形状和轮廓、字体属性和尺寸。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/036828855bb4c5c8d7efa7ff63dc68b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*Vl4x7xp10OjiCjYeawrSvw.png"/></div></figure><p id="722b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在属性提取之后，所有GUI信息的提取被有效地完成。GUI DSL按如下方式生成:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/9bd26edcc0fef2a9e16eec94d5c29998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bm3sZjZASoHS8QINfmgghw.png"/></div></div></figure><p id="40a3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">该数据使得能够执行布局分析。这里，文本属性的提取是最复杂的因素。</p><h1 id="ed37" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">布局分析</h1><p id="db7a" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">在UI2CODE的早期阶段，由于样本量小，在转移到规则实现之前，Xianyu团队使用四层LSTM网络进行训练和学习。规则实现还具有相对简单的优点；第一步切片中五个切的顺序是行和列，规则实现的缺点是布局比较死板，需要结合RNN进行提前反馈。</p><p id="7461" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">下面的视频展示了通过四层LSTM机制预测布局结构的结果；这里，UI布局结构类似于建筑物的框架，而UI层代码恢复类似于使用GUI属性的室内设计。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lw lx l"/></div></figure><h1 id="6be7" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">代码生成和插件</h1><p id="983c" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">人工智能本质上是一个概率问题，而自动生成的代码要求非常高的恢复度和100%的准确性。由于概率动力学很难达到这种程度的准确性，因此需要一个可编辑的工具来使开发人员能够快速理解和修改UI布局结构。</p><p id="99d6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为此，鲜宇团队为UI2CODE生成的DSL树实现了基于模板的匹配方法，其中代码模板的内容由经验丰富的Flutter技术专家定义。到目前为止，这已被证明是代码实现的最佳方法。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ms"><img src="../Images/3b7a68794f4724f6b6638ce9ccc237c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-PQCInA9KgIQYmMuId0k4g.png"/></div></div></figure><p id="16a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在代码模板中引入了一些标签，并使用Intellij插件来检索和替换Flutter项目中相应的UIKIT，以提高代码重用性。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/35d52855e87ff9d2810d90f7790a30bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*XN8AVRHniOKEap3EfCDVaw.jpeg"/></div></figure><p id="91f6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">整个插件项目需要提供定制的UIKIT功能，包括检索、替换、验证、创建、修改和DSL树的图形识别。总之，这类似于ERP系统，需要时间来改进。</p><h1 id="6d38" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">关键要点</h1><p id="f195" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">在本文介绍的五个关键组件中，有四个与机器视觉问题有关，并通过人工智能联系在一起。将代码发布到在线环境中提出了极其严格的要求，而人工智能的概率性质在这方面提出了一个重大挑战。为了继续解决这些问题并实施解决方案，先宇技术团队选择专注于机器视觉能力，同时使用人工智能技术作为构建完整UI2CODE系统的补充，并继续专注于人工智能技术，以使UI2CODE成为代码生成的理想自动化工具。</p><p id="f9c4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt"><strong class="jx hv">(Original article by Chen Yongxin陈永新 )</strong></p><blockquote class="ks kt ku"><p id="22f9" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated"><em class="hu">延伸阅读:</em></p><p id="be56" class="jv jw kv jx b jy jz iv ka kb kc iy kd kw kf kg kh kx kj kk kl ky kn ko kp kq hn dt translated"><a class="ae kr" rel="noopener" href="/@alitech_2017/ui2code-how-to-fine-tune-background-and-foreground-analysis-fb269edcd12c"> <em class="hu"> UI2code:如何微调背景和前景分析</em> </a></p></blockquote></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><h1 id="9200" class="kz la hu bd lb lc nb le lf lg nc li lj ja nd jb ll jd ne je ln jg nf jh lp lq dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph jv jw hu jx b jy lr iv ka kb ls iy kd ke lt kg kh ki lu kk kl km lv ko kp kq hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae kr" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">“阿里巴巴科技”</strong> </a>。推特:<a class="ae kr" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">【阿里巴巴技术】</strong> </a>。</p></div></div>    
</body>
</html>