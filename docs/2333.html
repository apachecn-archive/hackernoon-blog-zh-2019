<html>
<head>
<title>Graphs at Work. At school. And in other places, too.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作中的图表。在学校。在其他地方也是如此。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphs-at-work-at-school-and-in-other-places-too-9936493dec51?source=collection_archive---------23-----------------------#2019-04-11">https://medium.com/hackernoon/graphs-at-work-at-school-and-in-other-places-too-9936493dec51?source=collection_archive---------23-----------------------#2019-04-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="133b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我的另一半在附近的一所学校为<a class="ae jp" href="https://en.wikipedia.org/wiki/International_Baccalaureate" rel="noopener ugc nofollow" target="_blank">国际学士学位</a> (IB)项目教授<a class="ae jp" href="https://en.wikipedia.org/wiki/Further_Mathematics" rel="noopener ugc nofollow" target="_blank">进一步的数学</a>。我之前和他们的数学俱乐部有过一次接触，主题是“工作中的数学”。当时，<em class="jq">的工作</em>集中在Scrum的大规模推广上，所以我触及了斐波那契数(用于<a class="ae jp" href="https://www.scrum-institute.org/Effort_Estimations_Planning_Poker.php" rel="noopener ugc nofollow" target="_blank">工作量估算</a>)并触及了排队论的表面，特别是<a class="ae jp" href="https://en.wikipedia.org/wiki/M/M/1_queue" rel="noopener ugc nofollow" target="_blank"> M/M/1队列，以建模工作队列中的服务时间。</a></p><p id="7616" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">快进到一个月前，进一步的数学课完成了一个健康的图论入门，包括Dijkstra的算法和旅行推销员问题。学生们记得“工作中的数学”课程，并要求续写“工作中的图表”。根据家里的谈话，我完全预料到聪明的坏孩子会在那个班里游荡，所以这一定会很有趣——除了令人耳目一新的风景变化。我将类似代码的内容发布到了Gitlab，包括一个有意义的CD管道。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="2ff6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了暖场和评估观众，我首先介绍了树的一般用法，特别是文件系统树的用法。从增加IaaS数据量到访问Kubernetes中的秘密，这是IT和软件人员整天爬上爬下的那种树。你必须把它交给数学界的人:他们喜欢清晰的概念和明确的定义——你可以看出他们已经做了一段时间了。正如维基百科所说，</p><blockquote class="jy jz ka"><p id="d5f7" class="ir is jq it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">树是一个无向图，它满足以下任一等价条件:</p><p id="5985" class="ir is jq it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated"><em class="hu"> - G </em>是<a class="ae jp" href="https://en.wikipedia.org/wiki/Connected_graph" rel="noopener ugc nofollow" target="_blank">连接的</a>和<a class="ae jp" href="https://en.wikipedia.org/wiki/Cycle_(graph_theory)" rel="noopener ugc nofollow" target="_blank">非循环的</a>(不含循环)。</p><p id="07c9" class="ir is jq it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated"><em class="hu"> - G </em>是非循环的，如果<a class="ae jp" href="https://en.wikipedia.org/wiki/Edge_(graph_theory)" rel="noopener ugc nofollow" target="_blank">边</a>加到<em class="hu"> G </em>上，就形成一个简单的循环。</p><p id="d6a9" class="ir is jq it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated"><em class="hu"> - G </em>连接，但是如果从<em class="hu"> G </em>移除任何一个单边，就会变成<a class="ae jp" href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph" rel="noopener ugc nofollow" target="_blank">断开</a>。</p><p id="125e" class="ir is jq it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated"><em class="hu"> - G </em>连通且3顶点<a class="ae jp" href="https://en.wikipedia.org/wiki/Complete_graph" rel="noopener ugc nofollow" target="_blank">完全图</a> <em class="hu"> K </em> 3不是<em class="hu"> G </em>的<a class="ae jp" href="https://en.wikipedia.org/wiki/Minor_(graph_theory)" rel="noopener ugc nofollow" target="_blank">次图</a>。</p><p id="21db" class="ir is jq it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">-<em class="hu">G</em>中的任意两个顶点可以通过唯一的<a class="ae jp" href="https://en.wikipedia.org/wiki/Path_(graph_theory)" rel="noopener ugc nofollow" target="_blank">简单路径</a>连接。</p></blockquote><p id="fc79" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Unix文件系统是树的一个非常学术的例子，一个更完整的系统(比如整个云)可以被看作是一个<a class="ae jp" href="https://en.wikipedia.org/wiki/Tree_(graph_theory)#Forest" rel="noopener ugc nofollow" target="_blank">森林</a>，其中挂载操作允许用户将树缝合在一起。绑定挂载操作让树的一部分在方便的地方被透明地镜像。</p><p id="3f41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们设想一个数据卷作为服务在云提供商上提供，包含<code class="eh ke kf kg kh b">home</code>、<code class="eh ke kf kg kh b">www</code>和<code class="eh ke kf kg kh b">log</code>目录。连接到卷的虚拟机的操作系统会将其识别为<code class="eh ke kf kg kh b">/dev</code>下的设备，例如AWS EC2上的<code class="eh ke kf kg kh b">/dev/xvdh </code>。根据<a class="ae jp" href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" rel="noopener ugc nofollow" target="_blank"> FHS </a>，数据卷将安装在<code class="eh ke kf kg kh b">/media/vol</code>下。通过绑定挂载子树<code class="eh ke kf kg kh b">home</code>、<code class="eh ke kf kg kh b">www</code>、<code class="eh ke kf kg kh b">log</code>，可以将它们放回文件系统树中我们期望的位置，如下图所示。</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff ki"><img src="../Images/1fbe3167cd5699e47bab012bdcaa7f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QKDrOF7ETqzjOjx1rZiBw.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Filesystem mounting and bind-mounting</figcaption></figure><p id="0196" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">得到的图仍然是一棵树，因为<code class="eh ke kf kg kh b">home</code>可以在<code class="eh ke kf kg kh b">/</code>和<code class="eh ke kf kg kh b">/media/vol</code>下分别访问<em class="jq">。然而，在<code class="eh ke kf kg kh b">/home</code>下与文件和子目录交互的效果与在<code class="eh ke kf kg kh b">/media/vol/home</code>下与它们交互的效果完全相同。这种模型的价值在于，运行在这棵树上的软件不需要(也不想)知道树的所有部分来自哪里。只是它所依赖的文件和目录会在那里，总是在右边的位置。</em></p><p id="00f3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样的论点也适用于集装箱化的世界。一个容器把它的(通常是<a class="ae jp" href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="noopener ugc nofollow" target="_blank">命名空间</a>)文件系统看作一棵树，它总是有正确的结构，不管容器实际运行在哪里。Kubernetes等容器编排服务负责在树中挂载数据<a class="ae jp" href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener ugc nofollow" target="_blank">卷</a>。当前的最佳实践是使用相同的机制在容器中注入<a class="ae jp" href="https://kubernetes.io/docs/concepts/configuration/secret/" rel="noopener ugc nofollow" target="_blank">秘密</a>，使用文件系统——知道Kubernetes处理这些“秘密”对象本身，而不是常规的数据卷。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="58f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后<a class="ae jp" href="https://gitlab.com/graphs4IB/web-search" rel="noopener ugc nofollow" target="_blank">我继续</a>谷歌20岁的网页排名算法，和<a class="ae jp" href="http://ilpubs.stanford.edu/422/1/1999-66.pdf" rel="noopener ugc nofollow" target="_blank">他们现在著名的</a></p><blockquote class="jy jz ka"><p id="3b90" class="ir is jq it b iu iv iw ix iy iz ja jb kb jd je jf kc jh ji jj kd jl jm jn jo hn dt translated">为了测量网页的相对重要性，我们提出了PageRank，这是一种基于网页的图来计算每个网页的排名的方法。</p></blockquote><p id="eb84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">不可否认，根据链接到网页的页面排名来对网页进行排名的概念非常优雅。而且相当强大，因为这个简单的等式解释了我们所知道的网络。</p><p id="aa7d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">论文首先将<em class="jq"> N_u </em>定义为一个网页的链接数<em class="jq"> u </em>。网络的图被捕获在一个方阵<em class="jq"> A </em>中，其中<em class="jq"> A </em>距离各种邻接矩阵不远(如果从<em class="jq"> u </em>到<em class="jq"> v </em>有一条边，则<em class="jq"> A_{u，v}=1/N_u </em>)。PageRank保存在<em class="jq"> R </em>中，这是网页排名的向量。<em class="jq"> c </em>是归一化因子，所以所有网页的总排名是不变的。PageRank发明人证明了<em class="jq"> R </em>是<em class="jq"> A </em>的一个特征向量，特征值c: <em class="jq"> R=cAR </em>。如果我们想在这里注入一点物理学:我们可以将PageRank视为描述网页振动模式的向量，将<em class="jq"> 1/c </em>视为其<em class="jq">能量</em>水平。</p><p id="88f5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管可能有一些额外的算法来调整谷歌搜索中的这些等式，但我们还是花了一些时间来思考这种算法会青睐哪种页面。如何最好地描述这些首页？它们是最重要的页面吗？还是最… <em class="jq">真实</em>的页面？或者这只是某种选美比赛，获胜者是最受欢迎的页面，只要能引起人们的共鸣，不管这些页面是因为准确而受欢迎，还是因为更有问题，因为它们是关注的中心，出于我们可以想象的最好或最坏的原因？</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="a457" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">换个方式，在IP堆栈中变得更低，我<a class="ae jp" href="https://gitlab.com/graphs4IB/ospf" rel="noopener ugc nofollow" target="_blank">介绍了</a>通常用于IP网络的图，特别是在OSPF。随着Linux内核中<a class="ae jp" href="https://en.wikipedia.org/wiki/Linux_namespaces#Network_(net)" rel="noopener ugc nofollow" target="_blank">命名空间</a>的出现，有可能在单个主机中运行大量独立的路由表，从而使模拟相对复杂的网络行为变得容易。我从Edwin Cordeiro那里借来了<a class="ae jp" href="https://github.com/edwinsc/mininet_ospf_bgp" rel="noopener ugc nofollow" target="_blank">非常好的作品</a>，并为Ubuntu (18.04 LTS)和Mininet的最新版本修复了它。</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/820bc1ecc2ea5e9448254417f2ab1280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*zfMcadUGQ_H7y5R6gybNwg.png"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">OSPF Network</figcaption></figure><p id="7d0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">单个VM可以模拟一个像样的网络，有几个主机<em class="jq"> (h010_*) </em>和路由器<em class="jq"> (r010_*) </em>，内存和CPU占用非常有限。对于有限的投资，我们可以先进入链接状态广告和最短路径(即众所周知的Dijkstra)的勇敢世界。</p><p id="461d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在随机路由器中连接到Zebra守护进程，并从研究直连主机的路由工作方式开始。</p><pre class="kj kk kl km fq kz kh la lb aw lc dt"><span id="3adc" class="ld le hu kh b fv lf lg l lh li">$ <strong class="kh hv">sudo nsenter -n -t $(cat /tmp/zebra-r010_1.pid) telnet localhost zebra</strong><br/>Trying 127.0.0.1...<br/>Connected to localhost.<br/>Escape character is '^]'.</span><span id="bf28" class="ld le hu kh b fv lj lg l lh li">Hello, this is Quagga (version 1.2.4).<br/>Copyright 1996-2005 Kunihiro Ishiguro, et al.</span><span id="447b" class="ld le hu kh b fv lj lg l lh li">User Access Verification</span><span id="7f36" class="ld le hu kh b fv lj lg l lh li">Password:<br/>r010_1&gt; <strong class="kh hv">enable</strong><br/>Password:<br/>r010_1# <strong class="kh hv">show ip route connected</strong><br/>Codes: K - kernel route, C - connected, S - static, R - RIP,<br/>       O - OSPF, I - IS-IS, B - BGP, P - PIM, A - Babel, N - NHRP,<br/>       &gt; - selected route, * - FIB route</span><span id="60f6" class="ld le hu kh b fv lj lg l lh li">C&gt;* 10.0.0.0/30 is directly connected, r010_1-eth4<br/>C&gt;* 10.0.0.4/30 is directly connected, r010_1-eth5<br/>C&gt;* 10.1.0.0/24 is directly connected, r010_1-eth3<br/>C&gt;* 10.10.0.1/32 is directly connected, lo<br/>C&gt;* 10.255.0.0/30 is directly connected, r010_1-eth1<br/>C&gt;* 10.255.0.16/30 is directly connected, r010_1-eth2<br/>C&gt;* 127.0.0.0/8 is directly connected, lo<br/>r010_1#</span></pre><p id="328a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">OSPF允许每台路由器知道如何到达每个通告的网络，即计算到达远程网络应该使用的下一台路由器。在下面的例子中，<code class="eh ke kf kg kh b">r010_1</code>从OSPF得知，它应该通过其<code class="eh ke kf kg kh b">eth1</code>接口经由其邻居<code class="eh ke kf kg kh b">10.255.0.2</code>向<code class="eh ke kf kg kh b">10.2.0.0/24</code>(<code class="eh ke kf kg kh b">r010_2</code>之后的网络)发送数据包。</p><pre class="kj kk kl km fq kz kh la lb aw lc dt"><span id="d6f2" class="ld le hu kh b fv lf lg l lh li">r010_1# <strong class="kh hv">show ip route ospf</strong><br/>Codes: K - kernel route, C - connected, S - static, R - RIP,<br/>       O - OSPF, I - IS-IS, B - BGP, P - PIM, A - Babel, N - NHRP,<br/>       &gt; - selected route, * - FIB route</span><span id="9740" class="ld le hu kh b fv lj lg l lh li">O&gt;* 10.2.0.0/24 [110/20] via 10.255.0.2, r010_1-eth1, 00:44:36<br/>O&gt;* 10.3.0.0/24 [110/20] via 10.255.0.2, r010_1-eth1, 00:44:36<br/>O&gt;* 10.4.0.0/24 [110/20] via 10.255.0.17, r010_1-eth2, 00:44:36<br/>O&gt;* 10.5.0.0/24 [110/20] via 10.255.0.17, r010_1-eth2, 00:44:41<br/>O   10.10.0.1/32 [110/0] is directly connected, lo, 00:45:27<br/>O&gt;* 10.10.0.2/32 [110/10] via 10.255.0.2, r010_1-eth1, 00:44:37<br/>O&gt;* 10.10.0.3/32 [110/20] via 10.255.0.2, r010_1-eth1, 00:44:37<br/>O&gt;* 10.10.0.4/32 [110/20] via 10.255.0.17, r010_1-eth2, 00:44:37<br/>O&gt;* 10.10.0.5/32 [110/10] via 10.255.0.17, r010_1-eth2, 00:44:42<br/>O   10.255.0.0/30 [110/10] is directly connected, r010_1-eth1, 00:44:47<br/>O&gt;* 10.255.0.4/30 [110/20] via 10.255.0.2, r010_1-eth1, 00:44:37<br/>O&gt;* 10.255.0.8/30 [110/30] via 10.255.0.2, r010_1-eth1, 00:44:37<br/>  *                        via 10.255.0.17, r010_1-eth2, 00:44:37<br/>O&gt;* 10.255.0.12/30 [110/20] via 10.255.0.17, r010_1-eth2, 00:44:42<br/>O   10.255.0.16/30 [110/10] is directly connected, r010_1-eth2, 00:44:42</span></pre><p id="66e0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们最终获得了端到端的连接，这是IP网络的一个永远不会被高估的关键属性。是的，IPv4 NAT，我针对你。然后，我们可以检查网络中的端到端路径:</p><pre class="kj kk kl km fq kz kh la lb aw lc dt"><span id="603b" class="ld le hu kh b fv lf lg l lh li">mininet&gt; <strong class="kh hv">h010_51 traceroute h010_31</strong><br/>traceroute to 10.3.0.2 (10.3.0.2), 30 hops max, 60 byte packets<br/> 1  10.5.0.1 (10.5.0.1)  0.060 ms  0.005 ms  0.004 ms<br/> 2  10.255.0.13 (10.255.0.13)  0.015 ms  0.005 ms  0.005 ms<br/> 3  10.255.0.9 (10.255.0.9)  0.017 ms  0.007 ms  0.006 ms<br/> 4  10.3.0.2 (10.3.0.2)  0.024 ms  0.008 ms  0.007 ms</span></pre><p id="3073" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">欢迎来到神奇的分布式系统，在分布式系统中，节点最终会就它们应该如何单独行动达成共识，以便整个系统执行所需的端到端路由功能。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="d80e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然Dijkstra的算法允许在有限的搜索空间中找到最短的路径，但我还是忍不住引入了AI规划中的<a class="ae jp" href="https://gitlab.com/graphs4IB/ai-planning" rel="noopener ugc nofollow" target="_blank">搜索计划</a>的问题。<a class="ae jp" href="http://planning.domains/" rel="noopener ugc nofollow" target="_blank">。域名</a> <a class="ae jp" href="https://en.wikipedia.org/wiki/Top-level_domain" rel="noopener ugc nofollow" target="_blank">互联网TLD </a>(嘿，另一种极其重要的树)包含了一组用于规划域名的工具。它非常好的在线编辑器让我们可以导入汉诺塔域，其中包含一个单独的动作:</p><pre class="kj kk kl km fq kz kh la lb aw lc dt"><span id="07f9" class="ld le hu kh b fv lf lg l lh li">(define (domain hanoi)<br/> (:requirements :strips)<br/> (:predicates (clear ?x)<br/>              (on ?x ?y)<br/>              (smaller ?x ?y))</span><span id="1c27" class="ld le hu kh b fv lj lg l lh li"> (:action move<br/>  :parameters (?disc ?from ?to)<br/>  :precondition (and<br/>        (smaller ?to ?disc) <br/>        (on ?disc ?from) <br/>        (clear ?disc) <br/>        (clear ?to))<br/>  :effect (and<br/>        (clear ?from) <br/>        (on ?disc ?to) <br/>        (not (on ?disc ?from)) <br/>        (not (clear ?to)))<br/> )<br/>)</span></pre><p id="300b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个领域是用一种基于LISP的语言来表达的，这种语言叫做PDDL(规划领域定义语言)。</p><p id="5616" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">领域告诉我们，我们操作的对象可以是<code class="eh ke kf kg kh b">clear</code>(它们上面没有对象)，它们可以被放置在另一个的上面<code class="eh ke kf kg kh b">on</code>，并且它们通过<code class="eh ke kf kg kh b">smaller</code>关系排序。</p><p id="dafc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个领域允许我们的世界通过移动圆盘而被改变，从一个位置到另一个位置。有四种情况允许<code class="eh ke kf kg kh b">move</code>一个<code class="eh ke kf kg kh b">disc</code>在一个对象上面<code class="eh ke kf kg kh b">from</code>在另一个对象上面<code class="eh ke kf kg kh b">to</code>:</p><ul class=""><li id="c994" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated"><code class="eh ke kf kg kh b">disc </code>需要比被移动的对象<code class="eh ke kf kg kh b">to</code>大<code class="eh ke kf kg kh b">smaller</code></li><li id="e9a7" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><code class="eh ke kf kg kh b">disc </code>需要是当前<code class="eh ke kf kg kh b">on</code>它正在移动的对象<code class="eh ke kf kg kh b">from</code></li><li id="65f3" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><code class="eh ke kf kg kh b">disc</code>需要是任意对象的当前<code class="eh ke kf kg kh b">clear</code></li><li id="89c0" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">它正在移动的对象<code class="eh ke kf kg kh b">to</code>当前也需要是<code class="eh ke kf kg kh b">clear </code></li></ul><figure class="kj kk kl km fq kn fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/6646de106a06a2de139e65125985b6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*anS5oUl4JpTmQKbNGv175g.gif"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Solution to the tower of Hanoi problem with 4 discs (animation from <a class="ae jp" href="http://mathworld.wolfram.com/TowerofHanoi.html" rel="noopener ugc nofollow" target="_blank">Wolfram MathWorld)</a></figcaption></figure><p id="529e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">移动那个<code class="eh ke kf kg kh b">disc</code>有四种效果:</p><ul class=""><li id="883b" class="lk ll hu it b iu iv iy iz jc lm jg ln jk lo jo lp lq lr ls dt translated">我们正在移动的光盘<code class="eh ke kf kg kh b">from</code>现在是<code class="eh ke kf kg kh b">clear</code></li><li id="25c5" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><code class="eh ke kf kg kh b">disc</code>现在位于我们正在移动的<code class="eh ke kf kg kh b">to</code>圆盘的<code class="eh ke kf kg kh b">on</code>顶部</li><li id="301c" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated"><code class="eh ke kf kg kh b">disc</code>不再位于我们正在移动的<code class="eh ke kf kg kh b">from</code>盘的<code class="eh ke kf kg kh b">on</code>顶部</li><li id="0ec1" class="lk ll hu it b iu lt iy lu jc lv jg lw jk lx jo lp lq lr ls dt translated">我们正在移动的光盘<code class="eh ke kf kg kh b">to</code>不再是<code class="eh ke kf kg kh b">clear</code></li></ul><p id="f31c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">问题定义列出了我们世界中的所有物体，以及它们各自的大小和位置。例如，对于四张光盘:</p><pre class="kj kk kl km fq kz kh la lb aw lc dt"><span id="fec4" class="ld le hu kh b fv lf lg l lh li">(define (problem hanoi-4)<br/> (:domain hanoi)<br/> (:objects peg1 peg2 peg3 d1 d2 d3 d4 )<br/> (:init<br/>  (smaller peg1 d1)<br/>  (smaller peg1 d2)<br/>  (smaller peg1 d3)<br/>  (smaller peg1 d4)<br/>  (smaller peg2 d1)<br/>  (smaller peg2 d2)<br/>  (smaller peg2 d3)<br/>  (smaller peg2 d4)<br/>  (smaller peg3 d1)<br/>  (smaller peg3 d2)<br/>  (smaller peg3 d3)<br/>  (smaller peg3 d4)<br/>  (smaller d1 d1)<br/>  (smaller d2 d1)<br/>  (smaller d3 d1)<br/>  (smaller d4 d1)<br/>  (smaller d2 d2)<br/>  (smaller d3 d2)<br/>  (smaller d4 d2)<br/>  (smaller d3 d3)<br/>  (smaller d4 d3)<br/>  (clear peg2)<br/>  (clear peg3)<br/>  (clear d1)<br/>  (on d4 peg1)<br/>  (on d3 d4)<br/>  (on d2 d3)<br/>  (on d1 d2)<br/> )<br/> (:goal<br/>  (and <br/>   (on d4 peg3)<br/>   (on d3 d4)<br/>   (on d2 d3)<br/>   (on d1 d2)<br/>  )<br/> )<br/>)</span></pre><p id="eab6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们的四圆盘问题从定义三个钉子和四个圆盘开始，它们都是对象。</p><p id="dde5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，它继续定义世界的初始状态。栓钉进入的顺序与圆盘相同:每个圆盘都比所有栓钉小。那么<code class="eh ke kf kg kh b">d1</code>比它本身包含的所有圆盘都小；<code class="eh ke kf kg kh b">d2</code>比自身小，<code class="eh ke kf kg kh b">d3</code>和<code class="eh ke kf kg kh b">d4</code>，<code class="eh ke kf kg kh b">d3</code>。<code class="eh ke kf kg kh b">peg2</code>和<code class="eh ke kf kg kh b">peg3</code>清零，同时<code class="eh ke kf kg kh b">d4</code>在<code class="eh ke kf kg kh b">peg1</code>上，<code class="eh ke kf kg kh b">d3</code>在<code class="eh ke kf kg kh b">d4</code>上，<code class="eh ke kf kg kh b">d2</code>在<code class="eh ke kf kg kh b">d3</code>上，<code class="eh ke kf kg kh b">d1</code>在<code class="eh ke kf kg kh b">d2</code>上。</p><p id="3991" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">目标状态是<code class="eh ke kf kg kh b">peg3</code>上有<code class="eh ke kf kg kh b">d4</code>，在<code class="eh ke kf kg kh b">d4</code>上有<code class="eh ke kf kg kh b">d3</code>，在<code class="eh ke kf kg kh b">d3</code>上有<code class="eh ke kf kg kh b">d2</code>，在<code class="eh ke kf kg kh b">d2</code>上有<code class="eh ke kf kg kh b">d1</code>。我们可以让计划者计算计划，也就是将我们从初始状态带到目标状态的一系列行动。</p><pre class="kj kk kl km fq kz kh la lb aw lc dt"><span id="36c3" class="ld le hu kh b fv lf lg l lh li">(move d1 d2 peg2)<br/>(move d2 d3 peg3)<br/>(move d1 peg2 d2)<br/>(move d3 d4 peg2)<br/>(move d1 d2 d4)<br/>(move d2 peg3 d3)<br/>(move d1 d4 d2)<br/>(move d4 peg1 peg3)<br/>(move d1 d2 d4)<br/>(move d2 d3 peg1)<br/>(move d1 d4 d2)<br/>(move d3 peg2 d4)<br/>(move d1 d2 peg2)<br/>(move d2 peg1 d3)<br/>(move d1 peg2 d2)</span></pre><p id="e489" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">计划员邀请我们将圆盘<code class="eh ke kf kg kh b">d1</code>从<code class="eh ke kf kg kh b">d2</code>的顶部移动到<code class="eh ke kf kg kh b">peg2</code>的顶部。然后，我们应该将圆盘<code class="eh ke kf kg kh b">d2</code>从<code class="eh ke kf kg kh b">d3</code>移动到<code class="eh ke kf kg kh b">peg3</code>，等等。</p><p id="6f9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这项技术的强大之处在于，如果在计划执行过程中的某个时候出现了问题，并且我们处于初始状态和目标状态之间，它能够重新计划。计划者可以根据新的世界初始状态进行推理，保持之前的目标，并设计一个新的计划让我们达到目标。</p><p id="b1ce" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://gitlab.com/graphs4IB/ai-planning#development-environment" rel="noopener ugc nofollow" target="_blank">通过使用自定义规划器</a>，我们可以让规划器向我们显示它在寻找解决方案时考虑的搜索空间的图形。所考虑的行动之间的联系称为因果联系。这个计划，也就是将我们从世界的初始状态带到目标状态的一系列行动，可以毫不含糊地从一系列因果联系中推导出来。</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff lz"><img src="../Images/3f64ec952ed71a5e7d354660efd9de65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFZJIRGKGEVlo4jI10rgLg.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Search space</figcaption></figure><p id="b981" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们特别注意到，这个规划器从目标状态开始，回溯到初始状态。</p><p id="719d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了这个玩具例子之外，人工智能规划还被用来解决更困难的现实世界规划问题，这些问题的领域表示可以包括函数(浮点数)，要求规划者理解时间，甚至是函数连续变化的原因。当搜索状态变大时，将其可视化为图表有助于找到规划者在搜索中努力前进的潜在平台。这些平台可以通过调整规划者使用的试探法或领域定义来消除。</p></div><div class="ab cl jr js hc jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hn ho hp hq hr"><p id="244f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了冷静一下，我们<a class="ae jp" href="https://gitlab.com/graphs4IB/airflow-examples" rel="noopener ugc nofollow" target="_blank">用分析工作流中使用的有向无环图(DAG)完成了</a>。Apache Airflow，或其谷歌管理版本Cloud Composer，允许<a class="ae jp" href="https://cwiki.apache.org/confluence/display/AIRFLOW/Airflow+Home" rel="noopener ugc nofollow" target="_blank">以编程方式创作、安排和监控工作流</a>。Google的<a class="ae jp" href="https://cloud.google.com/composer/docs/quickstart" rel="noopener ugc nofollow" target="_blank"> quickstart </a>示例显示了一个非常线性的图(创建一个Dataproc集群，运行一个Hadoop作业，删除Dataproc集群)，所以我们稍微扩展了一下:</p><pre class="kj kk kl km fq kz kh la lb aw lc dt"><span id="2510" class="ld le hu kh b fv lf lg l lh li">create_dataproc_cluster &gt;&gt; run_dataproc_hadoop &gt;&gt; delete_dataproc_cluster &gt;&gt; victory_bash<br/>create_dataproc_cluster &gt;&gt; keep_busy &gt;&gt; victory_bash</span></pre><p id="7dad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在相当大的程度上，我们在这里手动指定为气流输入的图表可以与我们之前看到的人工智能规划器的输出进行比较。在我们的气流用例中，开发人员阐明计划，气流执行计划。在机器人术语中，气流充当<em class="jq">控制器</em>，即执行一些智能创建的解决问题的计划。在我们之前看到的AI规划用例中，(人类)领域建模师定义了个体行动(通过它们的先决条件和效果)、世界的初始状态及其目标状态，AI <em class="jq">规划者</em>搜索计划。参见加州大学埃迪堡分校Gerhard Wickler的<a class="ae jp" href="https://courses.csail.mit.edu/6.034s/handouts/spring12/Planning.pdf" rel="noopener ugc nofollow" target="_blank">自动规划</a>的幻灯片12，了解这两个部分在机器人架构中的位置。</p><p id="3d08" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">回到我们的(机器人)<em class="jq">控制器</em> : Airflow将绘制图形并遍历执行，指定每个节点的执行状态。</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff ma"><img src="../Images/fe3fa2e1da085e43c48d335971eeb9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Grht4NPH9mKMXoc6WvMP5w.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">DAG for our simple workflow</figcaption></figure><p id="7233" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了能够显示执行状态，一次又一次地运行，Airflow将DAG分解成一棵树，从最后一个操作符开始向后移动:</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff mb"><img src="../Images/4be13dce70db9bccf6a8ea767337f71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmJmWHiRKh_1ieAsCrRwEQ.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Tree representation</figcaption></figure><p id="6701" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">气流也可以用甘特图来表示单次运行的执行情况。甘特图表示提供了识别关键路径的能力，即，如果任务更短，将减少运行的总持续时间。</p><figure class="kj kk kl km fq kn fe ff paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="fe ff mc"><img src="../Images/80e55eafcaccaae522e679f4015c5b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BxhgQB-rZ-Q9kM1MHmjKsQ.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Gantt Chart Representation</figcaption></figure><p id="b6fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">成熟的甘特图通常也会指定任务之间的限制。在气流的情况下，它们相对简单，具有执行时间和前面操作符的成功方面的约束。在机器人中，它们可以包括不变量、故障条件，一直到操作约束，如超时、任务开始或结束之间的最小或最大时间。</p><p id="25de" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们到达了快速浏览图表的终点。数学非常简单，但是希望学生们能够相信图形是不可或缺的工具，无论是在计算机科学领域还是在软件工程或信息技术领域。</p><figure class="kj kk kl km fq kn"><div class="bz el l di"><div class="md me l"/></div></figure></div></div>    
</body>
</html>