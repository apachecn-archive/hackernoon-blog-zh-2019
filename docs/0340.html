<html>
<head>
<title>How to Create a File Storage Mobile App with NativeScript 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 NativeScript 5 创建文件存储移动应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/create-a-file-storage-mobile-app-with-nativescript-5-f14ee3be5bd0#2019-01-14">https://medium.com/hackernoon/create-a-file-storage-mobile-app-with-nativescript-5-f14ee3be5bd0#2019-01-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><a href="https://blog.jscrambler.com/create-a-file-storage-mobile-app-with-nativescript-5/?utm_source=medium.com&amp;utm_medium=referral"><div class="fe ff ir"><img src="../Images/62293c56691320ef31373f9e5460b49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NGchfttmWEvv03Mh.jpg"/></div></a></figure><p id="17ca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们之前的【NativeScript 文章中，我们预览了这个框架。对于本文，让我们创建一个小的演示项目。首先，让我们为演示设置一个场景。</p><p id="536b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">SimpleFileTransfer 是一个虚拟文件锁。用户可以注册该服务，并获得 100 MB 的免费虚拟存储空间。然后用户可以在服务器上下载和上传文件。用户可以通过填写表格来增加存储空间。</p><p id="0d8e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在继续之前，让我们记下应用程序的功能:</p><ul class=""><li id="cbda" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">注册:用户可以注册应用程序。</li><li id="c6f6" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">登录:验证用户。</li><li id="5b2f" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">详细信息页面:提供用户详细信息，如当前配额和总空间。此外，我们可以显示文件列表。</li><li id="a51c" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">下载文件:将文件从服务器下载到设备。</li><li id="868b" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">上传文件:将文件从设备上传到服务器。</li><li id="1f5e" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">增加配额:将用户的存储配额增加指定的量。</li></ul><p id="1c23" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可以在<a class="ae jw" href="https://github.com/JscramblerBlog/SimpleFileTransfer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到完整的代码。</p><h1 id="d8ce" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">构建后端</h1><p id="c4c2" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">后端必须提供管理路由、提供基本身份验证和存储以及促进文件传输的功能。</p><p id="a2f0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">基于上述要求，我们将使用以下堆栈:</p><ul class=""><li id="e8e4" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">节点:服务器</li><li id="b00a" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated"><a class="ae jw" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">快递</a>:中间件</li><li id="511c" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">顺序化 : ORM 中间件</li><li id="ee5a" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">SQLite:数据库</li></ul><p id="17d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还将使用像<a class="ae jw" href="https://github.com/expressjs/multer" rel="noopener ugc nofollow" target="_blank"> multer </a>和<a class="ae jw" href="https://github.com/kelektiv/node.bcrypt.js/" rel="noopener ugc nofollow" target="_blank"> bcrypt </a>这样的库来实现特定的功能，这些将在后面解释。</p><h1 id="ba75" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">正在初始化后端项目</h1><p id="d8e9" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">我们将使用 express-generator 来设置项目。使用以下命令全局安装<code class="eh lo lp lq lr b">express-generator</code>:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="0d5b" class="ma km hu lr b fv mb mc l md me">npm install express-generator -g</span></pre><p id="f488" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用以下命令启动一个新项目:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="8e1c" class="ma km hu lr b fv mb mc l md me">express file-server</span></pre><p id="8c94" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">导航到<code class="eh lo lp lq lr b">file-server</code>目录并使用<code class="eh lo lp lq lr b">npm install</code>安装依赖项。此外，安装以下依赖项:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="f1a0" class="ma km hu lr b fv mb mc l md me">npm install multer async sequelize sqlite3 body-parser bcrypt --save</span></pre><p id="7ce1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，我们将为以下内容创建一些额外的文件夹:</p><ul class=""><li id="012e" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">数据库:存储 SQLite 数据库和数据库脚本。</li><li id="e0c6" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">模型:存储模型。</li><li id="8a88" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">上传:临时存储上传的文件。</li><li id="a3d7" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">存储:为特定用户存储文件。</li></ul><h1 id="4437" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">从序列开始</h1><p id="4753" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated"><a class="ae jw" href="http://docs.sequelizejs.com/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>是一个用于 SQLite、MySQL、PostgreSQL 和 MSSQL 的 ORM 中间件。对于小型项目，使用 Sequelize + SQLite 组合很方便。</p><p id="e0b4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在我们当前的场景中，我们只需要一个模型。我们将模型用户定义如下:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="304c" class="ma km hu lr b fv mb mc l md me">const User = sequelize.define('user', {<br/>   uid: { type: Sequelize.INTEGER, primaryKey: true, autoIncrement: true },<br/>       username:  { type: Sequelize.STRING, unique: true },<br/>       password: Sequelize.STRING,<br/>       quota: {type: Sequelize.INTEGER, defaultValue: 104857600},<br/>       createdAt: Sequelize.DATE,<br/>       updatedAt: Sequelize.DATE,<br/>})</span></pre><p id="0a2c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以使用 Sequelize 的<code class="eh lo lp lq lr b">Model.sync</code>来初始化数据库中的模型表。为了初始化 users 表，我们将使用下面的代码。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="3dbc" class="ma km hu lr b fv mb mc l md me">User.sync({force: true}).then(() =&gt; {<br/>        // Table created<br/>});</span></pre><p id="1832" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将用户模型存储在模型文件夹的<code class="eh lo lp lq lr b">user.js</code>文件中。</p><p id="6148" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这部分很简单。对于注册，服务器接受用户名和密码，并将其存储在数据库中。我们将使用 bcrypt 库来加盐密码。如下所示，在将密码存储到数据库之前，我们对其进行了 10 次加盐处理。我们使用 Sequelize 的<code class="eh lo lp lq lr b">Model.create</code>来存储值。一旦用户被创建，我们将在我们的服务器上为他的上传创建一个目录。</p><p id="78e3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">代码如下:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="48fc" class="ma km hu lr b fv mb mc l md me">router.post('/', function(req, res, next) {<br/>       console.log(req);<br/>       bcrypt.hash(req.body.password, 10, function(err, hash) {<br/>         User<br/>         .create({ username: req.body.username, password: hash })<br/>         .then(user =&gt; {    <br/>         if (!fs.existsSync('storage/'+user.get('uid'))){<br/>         fs.mkdirSync('storage/'+user.get('uid'));<br/>         } <br/>           res.send({status: true, msg: 'User created', uid: user.get('uid')});<br/>         }).catch(err =&gt; {<br/>           res.send({status: false, msg: err });<br/>         })<br/>       });<br/>     });</span></pre><p id="610a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于登录，服务器接受用户名和密码，并根据数据库进行验证。我们使用<code class="eh lo lp lq lr b">Model.findAll</code>来获取数据库记录。我们用<code class="eh lo lp lq lr b">bcrypt.compare</code>来比较密码。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="e79d" class="ma km hu lr b fv mb mc l md me">router.post('/', function(req, res, next) {<br/>     console.log(req);<br/>     User.findAll({<br/>       attributes: ["username", "password"],<br/>       where: {<br/>         username: req.body.username<br/>       }<br/>     }).then(dbQ =&gt; {    <br/>         if(dbQ.length &gt; 0) {<br/>           bcrypt.compare(req.body.password, dbQ[0].dataValues.password, function(err, result) {<br/>             if (result == true){<br/>               res.send({status: true, msg: 'Login Success'});<br/>             } else {<br/>               res.send({status: false, msg: 'Incorrect Password'});<br/>             }            <br/>         });<br/>       } else {<br/>         res.send({status: false, msg: 'User not found'});<br/>       }         <br/>     });<br/>});</span></pre><h1 id="fab7" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">定义用户路线</h1><p id="f057" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">经过身份验证的用户可以执行以下功能:</p><ul class=""><li id="a62d" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">上传文件</li><li id="0153" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">下载文件</li><li id="f2ba" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">获取详细信息</li><li id="20ec" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">增加配额</li></ul><p id="79bd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">让我们定义这些功能的路线:</p><ul class=""><li id="137f" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">上传:<code class="eh lo lp lq lr b">POST /users/:id/upload</code></li><li id="8397" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">下载:<code class="eh lo lp lq lr b">GET /users/:id/download/:filename</code></li><li id="bd7b" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">详情:<code class="eh lo lp lq lr b">GET /users/:id/details</code></li><li id="aff8" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">增加额度:<code class="eh lo lp lq lr b">POST /users/:id/increasequota</code></li></ul><h1 id="60df" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">将文件上传到服务器</h1><p id="0c04" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">我们将使用<a class="ae jw" href="https://www.npmjs.com/package/multer" rel="noopener ugc nofollow" target="_blank"> multer </a>来处理上传。</p><p id="e68a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">multer 库对于处理多部分表单数据非常有用。最初，我们会将文件上传到上传文件夹。然后，文件将被移动到<code class="eh lo lp lq lr b">/storage/uid</code>文件夹，其中 uid 是用户 id。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="64a9" class="ma km hu lr b fv mb mc l md me">var storage = multer.diskStorage({<br/>     destination: function (req, file, cb) {<br/>       cb(null, 'uploads/')<br/>     },<br/>     filename: function (req, file, cb) {<br/>       cb(null, file.originalname )<br/>     }<br/>   });<br/>  <br/>   router.post('/:id/upload', upload.single('fileparam'), function(req, res, next) {<br/>     if (!req.file) {<br/>       console.log("No file received");<br/>       return res.send({<br/>         success: false,<br/>         msg: "Error Uploading files"<br/>       });<br/>     } else {<br/>       console.log('file received');<br/>       fs.rename('uploads/'+ req.file.originalname, 'storage/'+req.params.id+'/'+req.file.originalname, function (err) {<br/>           if (err) {<br/>                console.log(err);<br/>               return;<br/>           }  <br/>           return res.send({<br/>             success: true,<br/>             msg: "File Uploaded"<br/>           })   <br/>       });   <br/>     }<br/>});</span></pre><p id="aaa5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh lo lp lq lr b">upload.single</code>方法用于处理上传。此路由在 URL 调用中需要一个名为<code class="eh lo lp lq lr b">fileparam</code>的文件。这可以通过在 HTML 表单中添加 name 属性来快速完成。我们将需要名称属性应用程序端。</p><h1 id="d359" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">下载路线</h1><p id="9ddf" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">ExpressJS 为我们提供了一个设置下载路径的功能，方便称为下载。</p><p id="210e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这是我们遵循的逻辑:</p><ul class=""><li id="ab66" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">用户登录应用程序。</li><li id="4269" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">他选择了一个文件并开始下载。</li><li id="b2ba" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">服务器收到一个带有用户标识和文件名的请求。</li><li id="d166" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">服务器将文件发回给用户。</li></ul><p id="2094" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">该路线的代码如下</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="3439" class="ma km hu lr b fv mb mc l md me">router.get('/:id/download/:filename', function(req, res, next) {<br/>         const file = 'storage/'+req.params.id + '/' + req.params.filename;<br/>         res.download(file);<br/>});</span></pre><h1 id="6720" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">增加用户配额路线</h1><p id="c022" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">我们将调用<code class="eh lo lp lq lr b">Model.update</code>来调整配额。默认情况下，我们为每个用户分配了 104857600 字节，相当于 100 MB。您可以在下面找到查询。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="b81f" class="ma km hu lr b fv mb mc l md me">router.post('/:id/increasequota', function(req, res, next) {<br/>     User.update({<br/>       quota: req.body.quota,<br/>     }, {<br/>       where: {<br/>         uid: req.params.id        <br/>       }<br/>     }).then(response =&gt; {<br/>       res.send({status: true, msg: "Quota Increased"});<br/>     }).catch(err =&gt; {<br/>       res.send({status: false, msg: err});<br/>     }); <br/>   });</span></pre><h1 id="a64e" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">用户详细信息路线</h1><p id="26ba" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">这是我们将用于获取多个数据的路线，例如:</p><ul class=""><li id="a6e4" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">用户的存储限制:从数据库中，</li><li id="ab59" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">当前占用的文件空间:从<code class="eh lo lp lq lr b">/storage/userid</code>目录，</li><li id="4dbe" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">剩余空间:只有点 1 —点 2，</li><li id="7940" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">文件列表:文件列表，</li></ul><p id="1390" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以使用<code class="eh lo lp lq lr b">Model.findAll</code>获取用户的存储限制。为了获取文件名和存储空间，我们使用了<code class="eh lo lp lq lr b">fs .readdir</code>、<code class="eh lo lp lq lr b">fs.stat</code>和<code class="eh lo lp lq lr b">async</code>。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="099d" class="ma km hu lr b fv mb mc l md me">function getStorageSpace(relpath) {<br/>     let space = 0;<br/>     let fileNames = [];<br/>     let promise = new Promise(function (resolve, reject) {<br/>       fs.readdir(relpath, function (err, items) {<br/>         if (err){<br/>           reject(err);<br/>         }<br/>         fileNames = items;<br/>         let filesArr = items.map(function (val) {<br/>           return relpath + '/' + val;<br/>         });<br/>         async.map(filesArr, fs.stat, function (err, results) {<br/>          <br/>           for (let i = 0; i &lt; results.length; i++) {<br/>             if (err) {<br/>               reject(err);<br/>             }<br/>             space = space + results[i].size;<br/>           }<br/>           resolve({fileNames: fileNames, space: space });<br/>         });<br/>       });<br/>     });<br/>     return promise;<br/>   }<br/>  <br/>   function getStorageLimit(uid){<br/>     let promise = new Promise(function (resolve, reject) {<br/>       User.findAll({<br/>         attributes: ["quota"],<br/>         where: {<br/>           uid: uid<br/>         }<br/>       }).then(dbQ =&gt; {<br/>       <br/>         if(dbQ.length &lt; 1) {<br/>           reject("Quota Not Found")<br/>         } else {<br/>           resolve(dbQ[0].dataValues.quota);<br/>         }     <br/>       }).catch(err =&gt; {<br/>         reject(err);<br/>       });<br/>     });<br/>     return promise; <br/>   }</span><span id="985d" class="ma km hu lr b fv mf mc l md me">router.get('/:id/details', function(req, res, next) {<br/>     let it;<br/>     let relpath = 'storage/'+req.params.id;<br/>     Promise.all([getStorageSpace(relpath), getStorageLimit(req.params.id)]).then(result =&gt; {<br/>      <br/>       res.send({storageLimit: result[1], occupiedSpace: result[0].space, fileNames: result[0].fileNames, remainingSpace: result[1]- result[0].space});<br/>     })<br/>});</span></pre><p id="a052" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">注意:</strong>代码工作的前提是不允许用户在其文件夹中创建子目录。</p><p id="eff0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">实施存储限制的代码将在本文后面讨论。</p><h1 id="8038" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">NativeScript 应用程序</h1><p id="805d" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">对于应用程序方面，我们将采取另一种方法。一个基于角空白模板的演示项目将与用户共享。这篇文章的很大一部分将会详细介绍插件的功能。</p><h1 id="80a9" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">消费 Web 服务</h1><p id="acfa" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">我们正在为登录/注册/用户详细信息页面使用来自简单 web 服务的数据。</p><p id="f430" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">正如在<a class="ae jw" href="https://blog.jscrambler.com/introduction-to-nativescript/" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中提到的，我们可以使用<a class="ae jw" href="https://docs.nativescript.org/angular/ng-framework-modules/http" rel="noopener ugc nofollow" target="_blank"> HttpClient 模块</a>来访问这些 web 服务。基本步骤如下:</p><ul class=""><li id="23f9" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">在页面模块中导入<code class="eh lo lp lq lr b">NativeScriptHttpClientModule</code>。</li><li id="5680" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">在组件或提供者中导入<code class="eh lo lp lq lr b">HttpClient</code>和<code class="eh lo lp lq lr b">HttpHeaders</code>。</li><li id="ff39" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">像在 Angular 应用程序中一样使用 URL。</li><li id="48a3" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">我们将把<code class="eh lo lp lq lr b">Content-Type</code>标题设置为<code class="eh lo lp lq lr b">application/json</code>。</li></ul><p id="052e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于 JavaScript/TypeScript 模板，我们可以使用 NativeScript 核心<a class="ae jw" href="https://docs.nativescript.org/angular/ng-framework-modules/http#http" rel="noopener ugc nofollow" target="_blank"> http </a>模块。<code class="eh lo lp lq lr b">http. getJson</code>函数提供了消费 web 服务所需的框架。或者，我们也可以使用<a class="ae jw" href="https://docs.nativescript.org/ns-framework-modules/fetch" rel="noopener ugc nofollow" target="_blank">获取</a>模块。</p><p id="e77e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">作为来自服务器的响应，我们将接收用户的<code class="eh lo lp lq lr b">uid</code>。认证之后，我们需要存储<code class="eh lo lp lq lr b">uid</code>，这样我们就可以允许移动用户访问<code class="eh lo lp lq lr b">/users/uid route</code>。</p><h1 id="ccad" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">存储数据</h1><p id="2fe2" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">NativeScript 框架没有任何持久存储数据的方法。我们可以使用插件来添加这些功能。我们将会看到其中的两个插件。</p><ul class=""><li id="38d7" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated"><a class="ae jw" href="https://www.npmjs.com/package/nativescript-sqlite" rel="noopener ugc nofollow" target="_blank"> nativescript-sqlite </a>:这个插件为 sqlite 库提供了一个接口。如果您的应用程序需要存储大量记录，这种方法非常有效。安装时使用:</li></ul><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="6b6d" class="ma km hu lr b fv mb mc l md me">tns plugin add nativescript-sqlite</span></pre><ul class=""><li id="b894" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated"><a class="ae jw" href="https://www.npmjs.com/package/nativescript-localstorage" rel="noopener ugc nofollow" target="_blank">nativescript-local storage</a>:这个插件为字符串数据提供了一个键值 API，类似于<code class="eh lo lp lq lr b">window.localstorage</code>。如果你的应用程序没有太多记录，这很有用。安装时使用:</li></ul><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="2f8c" class="ma km hu lr b fv mb mc l md me">tns plugin add nativescript-localstorage</span></pre><p id="6f88" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">演示应用程序将使用<code class="eh lo lp lq lr b">nativescript-localstorage</code>。</p><h1 id="c3f1" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">将文件从设备上传到服务器</h1><p id="8fb7" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">让我们将这个功能分解成子任务:</p><ol class=""><li id="a6ca" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv mg kd ke kf dt translated">从设备中选择文件。</li><li id="f317" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv mg kd ke kf dt translated">获取文件路径。</li><li id="95f0" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv mg kd ke kf dt translated">通过上传网络服务上传文件。</li></ol><p id="2ca1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了选择一个文件并获得文件路径，我们将使用<code class="eh lo lp lq lr b">nativescript-mediapicker</code>插件。该插件有多种模式，我们可以为特定的使用情况定制它。你可以在这里查看插件文档<a class="ae jw" href="https://github.com/jibon57/nativescript-mediafilepicker" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ca67" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要选择一个文件，首先，我们需要定义扩展名。这对于两个操作系统是不同的。</p><p id="a4fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于 Android 设备，我们必须使用基于 mime 类型的文件扩展名，如 iOS 设备的<code class="eh lo lp lq lr b">let extensions = ["xlsx", "xls", "doc", "docx", "ppt", "pptx", "pdf", "txt", "png"]</code> <br/>，我们必须从统一类型标识符列表中定义扩展名:<code class="eh lo lp lq lr b">let extensions = [kUTTypePDF, kUTTypeText];</code></p><p id="492a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可以在这里和这里阅读更多关于 UTIs <a class="ae jw" href="https://developer.apple.com/documentation/mobilecoreservices/uttype" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="2a85" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">调用<code class="eh lo lp lq lr b">filepicker</code>的代码如下:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="7a2b" class="ma km hu lr b fv mb mc l md me">let options: FilePickerOptions = {<br/>       android: {<br/>           extensions: extensions,<br/>           maxNumberFiles: 1<br/>       },<br/>       ios: {<br/>           extensions: extensions,<br/>           multipleSelection: false<br/>       }<br/>   };<br/>  <br/>   let mediafilepicker = new Mediafilepicker();<br/>   mediafilepicker.openFilePicker(options);<br/>  <br/>   `mediafilepicker.on("getFiles", function (res) {<br/>       let results = res.object.get('results');<br/>       console.dir(results);<br/>   });<br/>  <br/>   mediafilepicker.on("error", function (res) {<br/>       let msg = res.object.get('msg');<br/>       console.log(msg);<br/>   });<br/>  <br/>   mediafilepicker.on("cancel", function (res) {<br/>       let msg = res.object.get('msg');<br/>       console.log(msg);<br/>   });`</span></pre><p id="6b68" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如上所述，我们将在<code class="eh lo lp lq lr b">getFiles</code>事件中接收一个文件的文件路径。</p><p id="ccbe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将使用<code class="eh lo lp lq lr b">nativescript-background-http</code>插件将文件发送到服务器。你可以在这里阅读插件<a class="ae jw" href="https://github.com/NativeScript/nativescript-background-http" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="632f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">前面我们定义了<code class="eh lo lp lq lr b">/users/:id/upload</code>路线。如前所述，我们的服务器期待名为<code class="eh lo lp lq lr b">fileparam</code>的属性中的文件。</p><p id="fb5e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">后台<code class="eh lo lp lq lr b">http</code>为我们提供了两个功能:<code class="eh lo lp lq lr b">uploadFile</code>和<code class="eh lo lp lq lr b">multipartUpload</code>。因为我们需要设置 name 属性，所以我们将使用<code class="eh lo lp lq lr b">multiPartUpload</code>函数。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="5117" class="ma km hu lr b fv mb mc l md me">let session = bgHttp.session("image-upload");<br/>    let request: bgHttp.Request = {<br/>        url: Config.apiUrl  + '/users/' + localStorage.getItem('uid') + '/upload'   ,<br/>        method: "POST",<br/>        headers: {<br/>            "Content-Type": "multipart/form-data"<br/>        },<br/>        description: 'FileName'<br/>    };<br/>    let params = [{<br/>        name: 'file',<br/>        filename: path<br/>    }];<br/>    let task: bgHttp.Task = session.multipartUpload(params, request);<br/>    task.on("error", (e) =&gt; {<br/>        reject(e);<br/>    });<br/>    task.on("complete", (e) =&gt; {<br/>        resolve(e);<br/>});</span></pre><h1 id="2473" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">将文件下载到设备</h1><p id="558d" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">我们将使用核心的<a class="ae jw" href="https://docs.nativescript.org/ns-framework-modules/file-system" rel="noopener ugc nofollow" target="_blank">文件系统</a>、<a class="ae jw" href="https://docs.nativescript.org/ns-framework-modules/platform" rel="noopener ugc nofollow" target="_blank">平台</a>和<a class="ae jw" href="https://docs.nativescript.org/core-concepts/utils" rel="noopener ugc nofollow" target="_blank">实用程序</a>模块来实现这个结果。Android 和 iOS 处理下载的方式都不一样。我们将使用来自平台模块的<code class="eh lo lp lq lr b">isAndroid</code>和<code class="eh lo lp lq lr b">isIOS</code>变量来分离代码。</p><p id="6933" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">文件系统模块为我们提供了一个<code class="eh lo lp lq lr b">knownFolders</code>子模块。Android 和 iOS 都有三个预定义的文件夹可用:</p><ul class=""><li id="2882" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated"><code class="eh lo lp lq lr b">knownFolders.currentApp()</code></li><li id="fe73" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated"><code class="eh lo lp lq lr b">knownFolders.documents()</code></li><li id="4821" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated"><code class="eh lo lp lq lr b">knownFolders.temp()</code></li></ul><p id="76b2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">另外，<a class="ae jw" href="https://docs.nativescript.org/api-reference/modules/_file_system_.knownfolders.ios" rel="noopener ugc nofollow" target="_blank"> iOS 子模块</a>为我们提供了一些其他预定义的文件夹。例如:</p><ul class=""><li id="5f76" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated"><code class="eh lo lp lq lr b">knownFolders.ios.download</code></li><li id="ae29" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated"><code class="eh lo lp lq lr b">knownFolders.ios.sharedPublic</code></li></ul><h2 id="422d" class="ma km hu bd kn mh mi mj kr mk ml mm kv jj mn mo kz jn mp mq ld jr mr ms lh mt dt translated">iOS 代码</h2><p id="d6fa" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">在 iOS 场景中，这很简单:</p><ul class=""><li id="77fe" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">显示服务器文件列表。</li><li id="b242" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">将文件下载到 documents 文件夹。</li><li id="4c1a" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">在单独的视图中列出下载的文件</li><li id="fb8f" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">使用<code class="eh lo lp lq lr b">utils.openFile</code>功能打开文件。</li></ul><p id="dd9f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了下载文件，我们将使用 NativeScript 框架的<a class="ae jw" href="https://docs.nativescript.org/ns-framework-modules/http" rel="noopener ugc nofollow" target="_blank"> http </a>模块。<code class="eh lo lp lq lr b">getFile</code>功能可用于从服务器获取文件，并将其保存到特定的文件位置。iOS 的代码片段如下:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="bea6" class="ma km hu lr b fv mb mc l md me">let filePath: string = path.join(knownFolders.documents().path, fileName);<br/>           getFile(download_url + fileName, filePath).then((resultFile) =&gt; {<br/>                   // The returned result will be File object<br/>   }, (e) =&gt; {<br/>       console.log(e);</span></pre><p id="5d65" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">文件下载完成后，我们可以使用<code class="eh lo lp lq lr b">utils</code>模块中的<code class="eh lo lp lq lr b">openFile</code>功能在 iOS 上打开文件。</p><h2 id="f977" class="ma km hu bd kn mh mi mj kr mk ml mm kv jj mn mo kz jn mp mq ld jr mr ms lh mt dt translated">Android 代码</h2><p id="405b" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">Android 方面的编码有点棘手。<code class="eh lo lp lq lr b">knownFolders</code>模块的位置如下。</p><ul class=""><li id="60f2" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">当前文件夹:<code class="eh lo lp lq lr b">/data/data/:appid/files/app</code></li><li id="6843" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">文件:<code class="eh lo lp lq lr b">/data/user/:androiduser/:appid/files</code></li><li id="1714" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">温度:<code class="eh lo lp lq lr b">/data/user/:androiduser/:appid/cache</code></li></ul><p id="fdc6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如您所见，所有文件夹都位于<code class="eh lo lp lq lr b">/data</code>中。<code class="eh lo lp lq lr b">/data</code>普通用户无法访问。此外，外部应用程序将无法访问这些文件夹中的文件。此外，安卓系统没有<code class="eh lo lp lq lr b">openFile</code>功能。</p><p id="5284" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">到目前为止，我们能做的就是:</p><ul class=""><li id="6470" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">显示服务器文件列表。</li><li id="1f7f" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">将文件下载到用户可访问的位置。</li><li id="6d33" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">列出该位置中存在的文件。</li></ul><p id="71f3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了实现该功能，我们将使用一些本机代码。<br/>在继续前进之前，我们必须安装<code class="eh lo lp lq lr b">tns-platform-declarations</code>和:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="2cf0" class="ma km hu lr b fv mb mc l md me">npm i tns-platform-declarations --save</span></pre><p id="2b36" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在根文件夹中创建一个<code class="eh lo lp lq lr b">reference.d.ts</code>文件，并添加以下几行:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="114d" class="ma km hu lr b fv mb mc l md me">`/// &lt;reference path="./node_modules/tns-platform-declarations/ios.d.ts" /&gt;`<br/>`/// &lt;reference path="./node_modules/tns-platform-declarations/android.d.ts" /&gt;`</span></pre><p id="d1e2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您可以查看<a class="ae jw" href="https://github.com/NativeScript/NativeScript/tree/master/tns-platform-declarations" rel="noopener ugc nofollow" target="_blank">自述文件</a>了解更多详情。</p><p id="95a1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><a class="ae jw" href="https://developer.android.com/reference/android/os/Environment" rel="noopener ugc nofollow" target="_blank"> Android OS </a>为我们提供了访问外部存储的功能。</p><p id="9823" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将使用常量<code class="eh lo lp lq lr b">DIRECTORY_DOWNLOADS</code>和函数<code class="eh lo lp lq lr b">getExternalStoragePublicDirectory</code>来创建一个可公开访问的下载位置。</p><p id="9484" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将添加一个路径“SimpleFileTransfer”来创建一个定制的<code class="eh lo lp lq lr b">folderPath</code>和<code class="eh lo lp lq lr b">filePath</code>。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="48b5" class="ma km hu lr b fv mb mc l md me">const androidDownloadsPath = android.os.Environment.getExternalStoragePublicDirectory(android.os.Environment.DIRECTORY_DOWNLOADS).toString();<br/>   const androidFolderPath = fs.path.join(androidDownloadsPath, "SimpleFileTransfer");<br/>   const filePath: string = fs.path.join(androidFolderPath, fileName);<br/>   getFile(download_url + fileName, filePath).then((resultFile) =&gt; {<br/>                   // The returned result will be File object<br/>   }, (e) =&gt; {<br/>       console.log(e);</span></pre><p id="0696" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您检查您的文件资源管理器，将在下载文件夹中创建一个名为 SimpleFileTransfer 的新目录。你会在那里找到所有下载的文件。</p><h1 id="a296" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">列出下载的文件</h1><p id="bc0b" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">我们将使用<code class="eh lo lp lq lr b">file-system</code>模块。<code class="eh lo lp lq lr b">file-system</code>模块的 Folder 类有一个<a class="ae jw" href="https://docs.nativescript.org/ns-framework-modules/file-system#read" rel="noopener ugc nofollow" target="_blank"> getEntities </a>函数，它允许我们列出文件夹中的文件。与 Node.js 中的<code class="eh lo lp lq lr b">fs.readdir</code>一样，我们只能列出文件。</p><p id="f287" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于 iOS，路径是</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="286d" class="ma km hu lr b fv mb mc l md me">const folderPath: string = fs.knownFolders.documents().path;</span></pre><p id="ebd1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">对于 Android，路径是</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="f704" class="ma km hu lr b fv mb mc l md me">const androidDownloadsPath  =  android.os.Environment.getExternalStoragePublicDirectory(android.os.Environment.DIRECTORY_DOWNLOADS).toString();</span><span id="c813" class="ma km hu lr b fv mf mc l md me">`const  folderPath=  fs.path.join(androidDownloadsPath, "SimpleFileTransfer");`</span></pre><p id="f534" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了访问文件夹功能，我们使用</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="e226" class="ma km hu lr b fv mb mc l md me">let internalFolder = fs.Folder.fromPath(folderPath);</span></pre><p id="60cb" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">然后，我们使用<code class="eh lo lp lq lr b">getEntities</code>来获取文件列表:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="a0ab" class="ma km hu lr b fv mb mc l md me">internalFolder.getEntities()<br/>               .then((entities) =&gt; {<br/>                   // entities is array with the document's files and folders.<br/>                  <br/>                   entities.forEach((entity) =&gt; {<br/>                   let  fileSize  =  fs.File.fromPath(entity.path).size;<br/>                       this.listArray.push({<br/>                           name: entity.name,<br/>                           path: entity.path,<br/>                           lastModified: entity.lastModified.toString(),<br/>                           size : fileSize<br/>                       });<br/>                   });                  <br/>               }).catch((err) =&gt; {<br/>                   // Failed to obtain folder's contents.<br/>                   console.log(err.stack);<br/>               });</span></pre><p id="1e77" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">此外，我们还使用了 File 类的 size 属性来获取文件大小。</p><h1 id="e028" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">强制实施存储限制</h1><p id="7448" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">可以通过两种方式强制实施存储限制:</p><ul class=""><li id="f4ed" class="jx jy hu ja b jb jc jf jg jj jz jn ka jr kb jv kc kd ke kf dt translated">上传文件到服务器→检查剩余空间→拒绝服务器端上传。</li><li id="cb2d" class="jx jy hu ja b jb kg jf kh jj ki jn kj jr kk jv kc kd ke kf dt translated">使用 webservice 检查剩余空间→检查文件大小→取消 app 端上传。</li></ul><p id="5a1f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了实施前者，我们可以修改上传路径如下:</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="d7af" class="ma km hu lr b fv mb mc l md me">Promise.all([getStorageSpace(relpath), getStorageLimit(req.params.id)]).then(result =&gt; {<br/>     if (result[1] - result[0].space &gt; req.file.size){<br/>       fs.rename('uploads/'+ req.file.originalname, 'storage/'+req.params.id+'/'+req.file.originalname, function (err) {<br/>         if (err) {<br/>           return res.send({<br/>             success: false,<br/>             msg: "Error Uploading files"<br/>           });<br/>         }  <br/>         return res.send({<br/>           success: true,<br/>           msg: "File Uploaded"<br/>         })   <br/>     });<br/>     } else {<br/>       return res.send({<br/>         success: false,<br/>         msg: "Storage Limit Exceeded"<br/>       });<br/>     } <br/>     })</span></pre><p id="eb29" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了实施后者，我们获取由<code class="eh lo lp lq lr b">mediafilepicker</code>插件选择的文件的文件大小，并使用 details webservice 检查它的剩余空间。</p><pre class="ls lt lu lv fq lw lr lx ly aw lz dt"><span id="d351" class="ma km hu lr b fv mb mc l md me">`let  fileSize  =  fs.File.fromPath(results[0].file).size;`</span><span id="9902" class="ma km hu lr b fv mf mc l md me">if(fileSize &lt; remainingSpace){<br/>    // Send To server<br/>   }`else {<br/>   // alert user about lack of space<br/>   }</span></pre><h1 id="df1a" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">结束语</h1><p id="2bb6" class="pw-post-body-paragraph iy iz hu ja b jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ln jt ju jv hn dt translated">这个演示涵盖了相当多不同的概念。</p><p id="88fe" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们将解决方案分为一系列功能。我们为 UX 使用核心 NativeScript，与后端、文件系统管理和路由交互。我们通过安装插件来扩展框架的功能，比如挑选文件。更进一步，我们使用了一些本地代码来解决一个特定的问题。</p><p id="e2a9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">使用 NativeScript 使我们能够更快地为两个平台开发应用程序，而不是单独开发。</p><p id="11b4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您想了解如何保护您的 NativeScript 源代码免受客户端攻击，请注册参加我们即将举办的关于“<a class="ae jw" href="https://www.progress.com/campaigns/kinvey/best-practices-for-securing-your-mobile-apps?utm_medium=listings&amp;utm_source=jscrambler&amp;utm_campaign=kinvey-webinar-secureapps" rel="noopener ugc nofollow" target="_blank">保护您的移动应用</a>的最佳实践”的免费网络研讨会。也一定要查看我们的<a class="ae jw" href="https://blog.jscrambler.com/protecting-your-nativescript-source-code-with-jscrambler/?utm_source=medium.com&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">教程</a>。</p></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="f651" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="nb">原载于</em><a class="ae jw" href="https://blog.jscrambler.com/create-a-file-storage-mobile-app-with-nativescript-5/?utm_source=medium.com&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"><em class="nb"/></a><em class="nb">。</em></p></div></div>    
</body>
</html>