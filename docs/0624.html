<html>
<head>
<title>Text Summarization made easy(2) , Text Representation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文本摘要变得简单(2)，文本表示</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/abstractive-text-summarization-tutorial-2-text-representation-made-very-easy-ef4511a1a46?source=collection_archive---------2-----------------------#2019-01-26">https://medium.com/hackernoon/abstractive-text-summarization-tutorial-2-text-representation-made-very-easy-ef4511a1a46?source=collection_archive---------2-----------------------#2019-01-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/66fa57cd8205563f4f9da41690880c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkVsqsRGfOsbl18sGAZyNQ.jpeg"/></div></div></figure><p id="4ced" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个故事是如何轻松构建一个抽象文本摘要器的系列文章的延续，(查看本系列文章的<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods" rel="noopener ugc nofollow" target="_blank"> github repo </a>)，今天我们将讨论如何构建一个能够理解文字的<strong class="je hv"/><strong class="je hv">摘要器，因此我们将通过向摘要器表示文字</strong></p><p id="1546" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在这个系列中的目标是以一种简单的方式呈现抽象文本摘要的最新方式，(你可以查看我的概述博客</p><ol class=""><li id="ca14" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">注意使用seq2seq模型的方法</li><li id="5a3a" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">使用指针生成器</li><li id="2846" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">将强化学习与深度学习结合使用</li></ol><p id="ad59" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用google colab，因此您不必使用功能强大的计算机，也不必将数据下载到您的设备，因为我们会将google drive连接到google colab，以获得完全集成的深度学习体验(您可以查看<a class="ae ka" href="https://hackernoon.com/begin-your-deep-learning-project-for-free-free-gpu-processing-free-storage-free-easy-upload-b4dba18abebc" rel="noopener ugc nofollow" target="_blank">我对免费深度学习生态系统平台的概述</a></p><p id="5b7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有代码都可以通过<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods" rel="noopener ugc nofollow" target="_blank"> my github repo </a>在线找到</p><blockquote class="kp kq kr"><p id="6163" class="jc jd ks je b jf jg jh ji jj jk jl jm kt jo jp jq ku js jt ju kv jw jx jy jz hn dt translated">本教程基于https://github . com/董军-李/text-summarying-tensorflow的工作，他们在简化使用tensor flow应用摘要所需的工作方面做了大量工作，我构建了他们的代码，将其转换为python笔记本以在google colab上工作，我真的很钦佩他们的工作</p></blockquote><p id="71ab" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以让我们开始吧！！</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="ab fr cl lh"><img src="../Images/16577fbdd2beff9f3d1dcb3f38417358.png" data-original-src="https://miro.medium.com/v2/format:webp/1*f1B-cGJMsFxL1gZ51ZPGlA.jpeg"/></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">EazyMind free Ai-As-a-service for text summarization</figcaption></figure><p id="8b81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在一个网站上添加了一个文本摘要模型<a class="ae ka" href="http://bit.ly/2VxhPqU" rel="noopener ugc nofollow" target="_blank"> eazymind </a>，这样你就可以实际尝试自己生成摘要(看看你能构建什么)，它可以通过简单的api调用来调用，并且通过一个<a class="ae ka" href="http://bit.ly/2Ef5XnS" rel="noopener ugc nofollow" target="_blank"> python包</a>，这样文本摘要就可以很容易地集成到你的应用程序中，而不需要设置tensorflow环境的麻烦，你可以免费注册<a class="ae ka" href="http://bit.ly/2VxhPqU" rel="noopener ugc nofollow" target="_blank">，并享受免费使用这个api的乐趣。</a></p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="6143" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">1-设置</h1><h2 id="a855" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">首先，我们首先创建一个google colab笔记本</h2><p id="86c0" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">1-前往<a class="ae ka" href="https://colab.research.google.com" rel="noopener ugc nofollow" target="_blank">https://colab.research.google.com</a></p><p id="85a0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2-选择google drive选项卡(将新的google colab保存到Google Drive)</p><p id="070d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3-选择<strong class="je hv">新的Python 3笔记本</strong>(也可以选择python 2笔记本)</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/24e5e860913e8dc72ce76625c1818414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BMrJ813UW88xjTudqYCQjg.jpeg"/></div></div></figure><p id="232a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个空白的笔记本会被创建到你的google drive中，看起来像这样</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/0f804f174346c6cd9b58257be64b7066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqRfGJpifQNcJZOGhHqAuQ.jpeg"/></div></div></figure><p id="75e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以通过选择顶部菜单中的运行时间按钮，将笔记本的运行时间更改为</p><ol class=""><li id="eecf" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">更改您正在使用的python版本</li><li id="8b5f" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">从(GPU，TPU)中选择硬件加速器</li></ol><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/8f5162328eb856c5357844f424f5710a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmElKyh0DVbgELIi8vy13A.jpeg"/></div></div></figure><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/18b9da1ad65f97cdfba10d2b5674dffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xopi8l7ZD9HtoNYuRk4tKQ.jpeg"/></div></div></figure><h2 id="3f5a" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">1-A-A或者你可以直接从我的github repo中克隆代码</h2><ol class=""><li id="11da" class="kb kc hu je b jf my jj mz jn ne jr nf jv ng jz kg kh ki kj dt translated">转到https://colab.research.google.com的<a class="ae ka" href="https://colab.research.google.com" rel="noopener ugc nofollow" target="_blank"/>，但这次我们会选择github标签页</li><li id="6259" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">然后我们只需粘贴这个<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods/blob/master/Implementation%20A%20(seq2seq%20with%20attention%20and%20feature%20rich%20representation)/Model%202/Model_2.ipynb" rel="noopener ugc nofollow" target="_blank">链接</a>，并点击上传</li></ol><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/f1d9e05578597fe0fa13bd308a023176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8i25F316D2VP6d7b9Zl9Yw.jpeg"/></div></div></figure><h2 id="ffc8" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">1-B现在，我们已经创建了我们的谷歌实验室，让我们连接到谷歌驱动器</h2><p id="b716" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">在新创建的笔记本中，添加一个新的代码单元</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/ce451f7f2dae3bb59962c360c81acbe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*bjCNJc3llLjRzndM23Suxw.jpeg"/></div></figure><p id="a9d3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后把这段代码粘贴进去</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="1480" class="mk ln hu nk b fv no np l nq nr">#<a class="ae ka" href="https://stackoverflow.com/questions/47744131/colaboratory-can-i-access-to-my-google-drive-folder-and-file" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/47744131/colaboratory-can-i-access-to-my-google-drive-folder-and-file</a></span><span id="dff3" class="mk ln hu nk b fv ns np l nq nr">!apt-get install -y -qq software-properties-common python-software-properties module-init-tools<br/>!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null<br/>!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null<br/>!apt-get -y install -qq google-drive-ocamlfuse fuse<br/>from google.colab import auth<br/>auth.authenticate_user()<br/>from oauth2client.client import GoogleCredentials<br/>creds = GoogleCredentials.get_application_default()<br/>import getpass<br/>!google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret} &lt; /dev/null 2&gt;&amp;1 | grep URL<br/>vcode = getpass.getpass()<br/>!echo {vcode} | google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret}</span><span id="49d7" class="mk ln hu nk b fv ns np l nq nr">!mkdir -p drive<br/>!google-drive-ocamlfuse drive</span></pre><p id="263e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这将连接到你的驱动器，并创建一个文件夹，你的笔记本可以访问你的谷歌驱动器</p><p id="fd7d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它会要求您访问您的驱动器，只需点击链接，并复制访问令牌，它会问这两次</p><p id="f7dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编写完这段代码后，您可以通过单击单元格(shift enter)或单击代码单元格顶部的play按钮来运行代码</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nh"><img src="../Images/1f3672634b266c8050fe14beeabafe19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRGxJpIddgJy_-9s5dN0Ow.jpeg"/></div></div></figure><p id="a009" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，您可以简单地通过文件的路径以</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="24dc" class="mk ln hu nk b fv no np l nq nr">path = "drive/test.txt"</span></pre><h2 id="78f2" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">1-C现在让我们获取我们要处理的数据</h2><p id="132b" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">我们要处理的数据集是以<strong class="je hv">新闻</strong>和它们的<strong class="je hv">标题的形式。</strong></p><p id="42c8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">输入将是<strong class="je hv">新闻内容</strong>，所需的输出将是其摘要，或者在这种情况下将是<strong class="je hv">标题</strong></p><p id="a1c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这项任务，有两个流行数据集</p><ol class=""><li id="8d56" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">亚马逊产品评论</li><li id="d2eb" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">CNN/每日新闻数据集<strong class="je hv">(我们将在我们的案例中使用)</strong></li></ol><p id="9702" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你不需要下载数据，你只需要把它拷贝到你的谷歌硬盘(T21)上，只需要几秒钟的时间。</p><p id="25af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是包含数据的文件夹的<a class="ae ka" href="https://drive.google.com/drive/folders/1Izsbg_p1s52dFNh8NmSG5jmDtRgHcLUN?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="12c6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们将使用<a class="ae ka" href="https://softgateon.herokuapp.com/urltodrive/" rel="noopener ugc nofollow" target="_blank"> Copy，Google Drive的URL</a>，这使您能够轻松地在不同的Google Drive之间复制文件</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff nt"><img src="../Images/7130773e6e83e9b3f180acd6f6afc6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*A-gOxSOsLLagerlCj-E2_Q.jpeg"/></div></figure><p id="ae3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先你要粘贴上面的<a class="ae ka" href="https://drive.google.com/drive/folders/1Izsbg_p1s52dFNh8NmSG5jmDtRgHcLUN?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a></p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/b1b83e1a0256efd1eef6c5101e5f3ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyUScRKtjL3z2oAKeMMNLg.jpeg"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">paste your link , name it , then save to google drive</figcaption></figure><p id="da52" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后你只需点击保存，复制到谷歌驱动器(认证后你的谷歌驱动器)</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nu"><img src="../Images/8718dfc6890c4246fce51f441692b45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4w3fdmSkpZ5IIC4oj_pfA.jpeg"/></div></div><figcaption class="li lj fg fe ff lk ll bd b be z ek">after authenticating , you just click save to google drive</figcaption></figure><p id="e28b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在在设置过程之后，我们可以开始我们的工作了，所以让我们开始吧！！</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="1658" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated"><span class="l nv nw nx bm ny nz oa ob oc di"> 2 </span> -依赖和路径</h1><h2 id="21f6" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">2-首先让我们安装所需的依赖项</h2><p id="3332" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">在google colab中，您可以使用pip进行安装，只需简单地！皮普，</p><p id="30c5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在你点击的每个代码段中</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff ni"><img src="../Images/ce451f7f2dae3bb59962c360c81acbe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*bjCNJc3llLjRzndM23Suxw.jpeg"/></div></figure><p id="6c68" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后开始写你的代码</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="b6c3" class="mk ln hu nk b fv no np l nq nr">!pip install gensim<br/>!pip install wget<br/>  <br/>import nltk<br/>nltk.download('punkt')</span></pre><h2 id="619c" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">2-b然后让我们设置所需的依赖关系</h2><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="b270" class="mk ln hu nk b fv no np l nq nr">from nltk.tokenize import word_tokenize<br/>import re<br/>import collections<br/>import pickle<br/>import numpy as np<br/>from gensim.models.keyedvectors import KeyedVectors<br/>from gensim.test.utils import get_tmpfile<br/>from gensim.scripts.glove2word2vec import glove2word2vec</span></pre><h2 id="0089" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">2-c然后让我们定义在哪里可以找到数据</h2><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="9519" class="mk ln hu nk b fv no np l nq nr"><strong class="nk hv">#default path for the folder inside google drive</strong><br/>default_path = "drive/Colab Notebooks/Model 2/"</span><span id="b176" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#path for training text (article)<br/></strong>train_article_path = default_path + "sumdata/train/train.article.txt"  </span><span id="3ab0" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#path for training text output (headline)<br/></strong>train_title_path   = default_path + "sumdata/train/train.title.txt" </span><span id="d077" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#path for validation text (article)<br/></strong>valid_article_path = default_path + "sumdata/train/valid.article.filter.txt"</span><span id="695e" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#path for validation text output(headline)<br/></strong>valid_title_path   = default_path + "sumdata/train/valid.title.filter.txt"</span></pre></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="66f9" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">3-建立字典</h1><p id="9371" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">要使文本摘要工作，您必须用字典格式表示您的单词</p><p id="ce49" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们有这样一篇文章</p><blockquote class="kp kq kr"><p id="1e1d" class="jc jd ks je b jf jg jh ji jj jk jl jm kt jo jp jq ku js jt ju kv jw jx jy jz hn dt translated">周三，五届世界冠军关颖珊退出了#美国花样滑冰锦标赛，但她将向美国滑冰官员申请参加#都灵奥运会#的机会</p></blockquote><p id="2d57" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">每个单词在字典中都有一个代表</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff od"><img src="../Images/a070367da5315574705bae10b5ca7659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*Q6i5x4Oy-WF3dk86AqwS2A.jpeg"/></div></figure><p id="dbd6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们还需要反向操作，比如</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oe"><img src="../Images/ac02f455936c494bc3219dab300abd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aWHa6oWghFE3td7hzeovA.jpeg"/></div></div></figure><p id="b39f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了应用它，我们需要一些辅助函数，比如</p><h2 id="1912" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">3-简单的清理数据功能</h2><p id="7d6a" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">这个函数的目标是简单地清理数据，只需用#替换一些不需要的字符</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="c933" class="mk ln hu nk b fv no np l nq nr">def clean_str(sentence):<br/>    sentence = re.sub("[#.]+", "#", sentence)<br/>    return sentence</span></pre><p id="c08e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种字符替换相当简单，您当然可以添加多个替换步骤</p><h2 id="2b71" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">实际返回文本的3-B函数</h2><p id="c001" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">并应用上述清洁功能</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="7935" class="mk ln hu nk b fv no np l nq nr">def get_text_list(data_path, toy):<br/>    with open (data_path, "r", encoding="utf-8") as f:<br/>        if not toy:<br/>            return [clean_str(x.strip()) for x in f.readlines()][:200000]<br/>        else:<br/>            return [clean_str(x.strip()) for x in f.readlines()][:50]</span></pre><p id="3ad4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该函数将在多种情况下调用</p><ol class=""><li id="82df" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">如果需要加载培训数据</li><li id="3bfa" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">或者测试数据</li><li id="afee" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">或者，如果你只是需要一个以上的例子，只需简单地设置<strong class="je hv">玩具=真</strong></li></ol><h2 id="8122" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">3-C现在让我们构建实际创建所需字典的函数</h2><p id="0b74" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">在这里，您会看到我们添加了4个内置单词，它们对于seq2seq算法至关重要，它们是</p><ol class=""><li id="7ce1" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><padding>这将用于制作相同长度的序列</padding></li><li id="6fa4" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated"><unk>这将用于识别在字典中没有找到该单词</unk></li><li id="2392" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">这将被用来确定一个句子的存在</li><li id="7d00" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">这将用于识别一个句子的结尾</li></ol><blockquote class="kp kq kr"><p id="ffe2" class="jc jd ks je b jf jg jh ji jj jk jl jm kt jo jp jq ku js jt ju kv jw jx jy jz hn dt translated">从github 中复制代码<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods/blob/master/Implementation%20A%20(seq2seq%20with%20attention%20and%20feature%20rich%20representation)/Model%202/Model_2.ipynb" rel="noopener ugc nofollow" target="_blank">，因为这里的填充由于媒体的编辑而不正确</a></p></blockquote><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="6033" class="mk ln hu nk b fv no np l nq nr">def build_dict(step, toy=False):<br/>    if step == "train":<br/>  <strong class="nk hv">#First lets load the training data</strong><br/>        train_article_list = get_text_list(train_article_path, toy)<br/>        train_title_list = get_text_list(train_title_path, toy)</span><span id="4745" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#then lets collect all words from the training data <br/>  #by simply tokenizing each text sample to its words<br/>  #here we would use the built-in function imported from nltk toolkit<br/>  #which simply return a list of words from a sentence</strong><br/>  words = list()<br/>        for sentence in train_article_list + train_title_list:<br/>            for word in word_tokenize(sentence):<br/>                words.append(word)</span><span id="8fba" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#we would only select the most common words</strong><br/>  word_counter = collections.Counter(words).most_common()<br/>  <strong class="nk hv">#first lets set the 4 built-in words</strong><br/>    word_dict = dict()<br/>    word_dict["&lt;padding&gt;"] = 0<br/>    word_dict["&lt;unk&gt;"] = 1<br/>    word_dict["&lt;s&gt;"] = 2<br/>    word_dict["&lt;/s&gt;"] = 3</span><span id="bd4d" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#then lets build our dict , by simply looping over word_co</strong><br/>        for word, _ in word_counter:<br/>            word_dict[word] = len(word_dict)</span><span id="2d79" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#then lets save this to a pickle</strong><br/>  with open(default_path + "word_dict.pickle", "wb") as f:<br/>     pickle.dump(word_dict, f)</span><span id="d5c8" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#all of the above was for the training step<br/>#when you are in the validation you can simply load the pickles that<br/>#you have just saved</strong></span><span id="0794" class="mk ln hu nk b fv ns np l nq nr">elif step == "valid":<br/>    with open(default_path + "word_dict.pickle", "rb") as f:<br/>     word_dict = pickle.load(f)</span><span id="852b" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#for both of the 2 cases (training , or validation) <br/>#we would create a reversed dict</strong></span><span id="5120" class="mk ln hu nk b fv ns np l nq nr">  reversed_dict = dict(zip(word_dict.values(), word_dict.keys()))</span><span id="1fe0" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#then we would simply for the 2 cases (training , or validation)<br/>#define a max len for article and for the summary</strong></span><span id="0d08" class="mk ln hu nk b fv ns np l nq nr">  article_max_len = 50<br/>   summary_max_len = 15<br/>return word_dict, reversed_dict, article_max_len, summary_max_len</span></pre><h1 id="e3c1" class="lm ln hu bd lo lp of lr ls lt og lv lw lx oh lz ma mb oi md me mf oj mh mi mj dt translated">现在让我们建立我们的数据集</h1><p id="838f" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">在为我们的数据构建dict之后，我们将开始构建将在我们的算法中使用的实际数据集</p><p id="8ff5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用上述文章的例子，</p><blockquote class="kp kq kr"><p id="57a2" class="jc jd ks je b jf jg jh ji jj jk jl jm kt jo jp jq ku js jt ju kv jw jx jy jz hn dt translated">周三，五届世界冠军关颖珊退出了#美国花样滑冰锦标赛，但她将向美国滑冰官员申请参加#都灵奥运会#的机会</p></blockquote><p id="5e54" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">算法需要用这个来表示</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ok"><img src="../Images/0fe27709321ad584892af200aeaed556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9vbrOIbRUG3ycjzn0oVfg.jpeg"/></div></div></figure><p id="1e20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就是简单地获取给定句子中单词的单词字典集合</p><p id="91f4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">测试数据也会出现同样的情况</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="3926" class="mk ln hu nk b fv no np l nq nr">def build_dataset(step, word_dict, article_max_len, summary_max_len, toy=False):<br/><strong class="nk hv">#---case of train <br/>#---we would load both (article , headline) for training<br/></strong>    if step == "train":<br/>        article_list = get_text_list(train_article_path, toy)<br/>        title_list = get_text_list(train_title_path, toy)<br/><strong class="nk hv">#---case of valid<br/>#---we only load articles<br/></strong>    elif step == "valid":<br/>        article_list = get_text_list(valid_article_path, toy)<br/><strong class="nk hv">#---if step is neither (train nor valid) raise error<br/></strong>    else:<br/>        raise NotImplementedError<br/><strong class="nk hv">#---(for each aricle) get list of words <br/>#--- so now x (article) contains list of words<br/></strong>    x = [word_tokenize(d) for d in article_list]</span><span id="bdf2" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#---(for each aricle) get index of word from word_dict for each article<br/>#---if not found , use "&lt;unk&gt;" tokken<br/>#---so now we have our train dataset</strong><br/>    x = [[word_dict.get(w, word_dict["&lt;unk&gt;"]) for w in d] for d in x]</span><span id="62dd" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#---(for each aricle) limit x to article_max_len<br/></strong>    x = [d[:article_max_len] for d in x]</span><span id="dd03" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#---(for each aricle) if x was less than article_max_len<br/>#--- pad the x by using "&lt;padding&gt;" tokken<br/></strong>    x = [d + (article_max_len - len(d)) * [word_dict["&lt;padding&gt;"]] for d in x]<br/>    <br/> <br/> <br/>    if step == "valid":<br/>        return x<br/>    else:      <br/><strong class="nk hv">#-------if step = "train"<br/>#-------we must do the same steps on headline<br/>#-------but here we don't use the concept of padding<br/></strong>        y = [word_tokenize(d) for d in title_list]<br/>        y = [[word_dict.get(w, word_dict["&lt;unk&gt;"]) for w in d] for d in y]<br/>        y = [d[:(summary_max_len - 1)] for d in y]<br/>        return x, y</span></pre><p id="779f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以让我们简单地调用两者(构建字典和构建数据集)</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="c3a9" class="mk ln hu nk b fv no np l nq nr">print("Building dictionary...")<br/>word_dict, reversed_dict, article_max_len, summary_max_len = build_dict("train", False)</span><span id="ca92" class="mk ln hu nk b fv ns np l nq nr">print("Loading training dataset...")<br/>train_x, train_y = build_dataset("train", word_dict, article_max_len, summary_max_len, False)</span></pre></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="5709" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">5字嵌入</h1><p id="b571" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">但是我们还不能给我们的神经网络提供一个包含单词索引的列表，因为它可以理解它们。</p><p id="2767" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要用一种我们的神经网络能够理解的格式来表示单词本身，这就产生了单词嵌入的概念</p><p id="5bd4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个简单的概念，用一个数字列表代替字典中的每个单词，(在我们的例子中，我们用一个300的浮点数列表来模拟每个单词)</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oe"><img src="../Images/191eda39b4497fe66c6836458bd9c6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbWKmtudrbWA4niXxJKQzQ.jpeg"/></div></div></figure><p id="4d19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">已经有经过训练的模型，这些模型已经经过数百万条文本的训练，可以正确地对单词进行建模，一旦你能够正确地对单词进行建模，你的神经网络就能够真正理解文章中的文本。</p><p id="0f9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在使用单词嵌入之后，识别算法理解文本的程度的一个非常公知的测试是对给定单词应用单词相似度</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff ol"><img src="../Images/ae918d948d8a9682bcb3d869e98a4b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*YNuIorAudcrt2ZZBmt-m2w.jpeg"/></div></figure><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff om"><img src="../Images/262382fdb310ad22b55ef653f1469412.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*cvGvtSWOwBRDh-hp2ShukQ.jpeg"/></div></figure><p id="969e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你所看到的，输出告诉我们，模型现在能够理解单词之间的关系，这是我们神经网络成功的一个极其重要的因素</p><h2 id="99c4" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated"><strong class="ak"> 5-A让我们得到我们工作的训练模型</strong></h2><p id="c23f" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">斯坦福提供了一个非常有名的预训练模型叫做<a class="ae ka" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank">手套预训练向量</a>，你可以从https://nlp.stanford.edu/projects/glove/<a class="ae ka" href="https://nlp.stanford.edu/projects/glove/" rel="noopener ugc nofollow" target="_blank">下载</a></p><p id="0c2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者你可以像我之前解释的那样从我的google drive中简单地复制它，这里是pickle格式的手套向量的<a class="ae ka" href="https://drive.google.com/drive/folders/1qxBKLczcqA5Y682SpZhWX6Z_COrNjMDj?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a></p><h2 id="d372" class="mk ln hu bd lo ml mm mn ls mo mp mq lw jn mr ms ma jr mt mu me jv mv mw mi mx dt translated">5-B构建一个函数来获得单词嵌入数组</h2><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="8c75" class="mk ln hu nk b fv no np l nq nr">def get_init_embedding(reversed_dict, embedding_size):</span><span id="8e6b" class="mk ln hu nk b fv ns np l nq nr">print("Loading Glove vectors...")</span><span id="bd90" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#---Load glove model which is in a pickle format <br/></strong>    with open( default_path + "glove/model_glove_300.pkl", 'rb') as handle:<br/>        word_vectors = pickle.load(handle)<br/>  <br/><strong class="nk hv">#---Loop through all words within the reversed_dict  <br/></strong>    used_words = 0<br/>    word_vec_list = list()<br/>    for _, word in sorted(reversed_dict.items()):<br/>        try:<br/><strong class="nk hv">#-----------if the word i found in the dict , <br/>#-----------save its value</strong><br/>            word_vec = word_vectors.word_vec(word)<br/>            used_words += 1<br/>        except KeyError:<br/><strong class="nk hv">#-----------else , generate an array of zeros <br/>#-----------of length = embedding_size<br/>#-----------which in this case would be 300<br/>#-----------this is the case also for &lt;padding&gt; and &lt;unk&gt;<br/>#-----------where &lt;s&gt;, &lt;/s&gt; token would be zeros<br/>#-----------like seen below</strong><br/>            word_vec = np.zeros([embedding_size], dtype=np.float32) #to generate for &lt;padding&gt; and &lt;unk&gt;</span><span id="56ab" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#-------add it to the array<br/>#-------remember that we are looping in sorted reversed_dict<br/>#-------so the index of the element inside word_vec_list <br/>#-------would be the same as  index of word<br/>#-------no need of a dict , an array is sufficient</strong><br/>        word_vec_list.append(word_vec)</span><span id="a0dc" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#---just print out the percentage of knwon words<br/></strong>    print("words found in glove percentage = " + str((used_words/len(word_vec_list))*100) )<br/>   <br/><strong class="nk hv">#----Assign random vector to &lt;s&gt;, &lt;/s&gt; token<br/></strong>    word_vec_list[2] = np.random.normal(0, 1, embedding_size)<br/>    word_vec_list[3] = np.random.normal(0, 1, embedding_size)</span><span id="2d58" class="mk ln hu nk b fv ns np l nq nr"><strong class="nk hv">#----then return the array<br/></strong>return np.array(word_vec_list)</span></pre><p id="ce8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">来调用我们简单调用的函数</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="ba29" class="mk ln hu nk b fv no np l nq nr">word_embedding = get_init_embedding(reversed_dict, 300)</span></pre></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="b6d9" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">总而言之</h1><p id="445f" class="pw-post-body-paragraph jc jd hu je b jf my jh ji jj mz jl jm jn na jp jq jr nb jt ju jv nc jx jy jz hn dt translated">因此，我们可以说，我们现在已经正确地表示了文本摘要任务的文本</p><p id="65d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总而言之，我们已经构建了代码来</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oe"><img src="../Images/191eda39b4497fe66c6836458bd9c6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fbWKmtudrbWA4niXxJKQzQ.jpeg"/></div></div></figure><p id="9e80" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只需拨打电话</p><pre class="ld le lf lg fq nj nk nl nm aw nn dt"><span id="a28d" class="mk ln hu nk b fv no np l nq nr">word_dict, reversed_dict, article_max_len, summary_max_len = build_dict("train", False)</span><span id="6dc5" class="mk ln hu nk b fv ns np l nq nr">train_x, train_y = build_dataset("train", word_dict, article_max_len, summary_max_len, False)</span><span id="9a3e" class="mk ln hu nk b fv ns np l nq nr">word_embedding = get_init_embedding(reversed_dict, 300)</span></pre><p id="0b23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在接下来的教程中，如果上帝愿意，我们将介绍如何构建模型本身，我们将使用LSTM构建一个seq2seq编码器解码器模型，我们将介绍使用tensorflow构建这样一个模型的详细信息，这将是该系列下一个教程的基础，将介绍解决该问题的最新方法</p><ol class=""><li id="e4f4" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">使用指针生成器模型</li><li id="9726" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz kg kh ki kj dt translated">将强化学习与深度学习结合使用</li></ol><p id="d290" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要忘记从我的<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods" rel="noopener ugc nofollow" target="_blank"> repo </a>中克隆本教程的代码</p><p id="7348" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以看一下<a class="ae ka" rel="noopener" href="/@theamrzaki/text-summarizer-using-deep-learning-made-easy-490880df6cd">之前的教程</a>关于文本摘要的概述</p><p id="ad33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你也可以查看这个<a class="ae ka" href="https://hackernoon.com/begin-your-deep-learning-project-for-free-free-gpu-processing-free-storage-free-easy-upload-b4dba18abebc" rel="noopener ugc nofollow" target="_blank">的博客</a>谈论一个免费深度学习平台的生态系统</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><blockquote class="kp kq kr"><p id="5773" class="jc jd ks je b jf jg jh ji jj jk jl jm kt jo jp jq ku js jt ju kv jw jx jy jz hn dt translated">我真心希望你喜欢这个教程，我在等待你的反馈，如果上帝愿意，我在下一个教程里等着你</p></blockquote></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="ae7c" class="lm ln hu bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">后续教程</h1><ul class=""><li id="aa3d" class="kb kc hu je b jf my jj mz jn ne jr nf jv ng jz on kh ki kj dt translated"><a class="ae ka" href="https://hackernoon.com/tutorial-3-what-is-seq2seq-for-text-summarization-and-why-68ebaa644db0" rel="noopener ugc nofollow" target="_blank">什么是seq2seq文本摘要，为什么(教程3) </a></li><li id="e4bd" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz on kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/eazysum_tu4" rel="noopener ugc nofollow" target="_blank">多层双向LSTM/GRU使文本摘要变得简单(教程4) </a></li><li id="1a9b" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz on kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/2G4XCo3" rel="noopener ugc nofollow" target="_blank">波束搜索&amp;注意让文本摘要变得简单(教程5) </a></li><li id="4b66" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz on kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/2ZeEmvO" rel="noopener ugc nofollow" target="_blank">在Tensorflow的94行中构建一个抽象的文本摘要器！！(教程6) </a></li><li id="7e8a" class="kb kc hu je b jf kk jj kl jn km jr kn jv ko jz on kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/2EhcRIZ" rel="noopener ugc nofollow" target="_blank">用于文本摘要的抽象提取方法的组合&amp;(教程7) </a></li></ul></div></div>    
</body>
</html>