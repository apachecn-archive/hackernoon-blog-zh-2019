<html>
<head>
<title>Trustless Upgrades in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性的可靠升级</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/trustless-upgrades-in-solidity-bf0bd4047d28?source=collection_archive---------6-----------------------#2019-06-03">https://medium.com/hackernoon/trustless-upgrades-in-solidity-bf0bd4047d28?source=collection_archive---------6-----------------------#2019-06-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="e4dd" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">可升级性并不总是缺陷。</h2></div><p id="70ce" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">罗布·希钦斯和阿里·阿扎姆</p><figure class="ki kj kk kl fq km fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff kh"><img src="../Images/bdff3633d2b05b1b807716b4d0613956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3gTBFXhiTJqkRYmd"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Photo by <a class="ae kx" href="https://unsplash.com/@jamesmhammond?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Hammond</a> on <a class="ae kx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="be3d" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">几周前，我们出版了<a class="ae kx" href="https://blog.b9lab.com/selfdestruct-is-a-bug-9c312d1bb2a5" rel="noopener ugc nofollow" target="_blank">自毁是一个错误</a>，它本身的灵感来自于<a class="ae kx" rel="noopener" href="/consensys-diligence/upgradeability-is-a-bug-dba0203152ce">可升级性是一个错误</a>作者是Consensys Diligence的Steve Marx。两篇文章的主旨都是，改变合约会破坏不变性。有人可能会问——如果特权用户可以随心所欲地修改代码，那么区块链有什么特别之处呢？</p><h2 id="cd5b" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">如果你没有失眠，你可能做错了</h2><p id="6274" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">以太坊Dapp开发人员必须处理一种不熟悉的范式(区块链)和一种不熟悉的语言(稳固性)，以便为不熟悉的问题(博弈论、业务流程再造、市场等等)创建不熟悉的解决方案(治理、资产、权利)。难怪可升级性是一种受欢迎的可能性。</p><h2 id="fe9c" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">可升级的合同来拯救！</h2><p id="f795" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">2016年，Coloney发表了<a class="ae kx" href="https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/" rel="noopener ugc nofollow" target="_blank">在Solidity中编写可升级合同</a>。他们“永久存储”模式的要点是</p><blockquote class="ly"><p id="89b1" class="lz ma hu bd mb mc md me mf mg mh kf ek translated">…将您的数据存储与代码的其余部分隔离开来，并使其尽可能灵活，这样就不太可能需要升级。</p></blockquote><p id="8927" class="pw-post-body-paragraph jk jl hu jm b jn mi iv jp jq mj iy js jt mk jv jw jx ml jz ka kb mm kd ke kf hn dt translated">冒着过分简化的风险，你可以拥有一个如此简单、灵活、解决得如此好的数据存储<code class="eh mn mo mp mq b">contract</code>，以至于你可以确信它永远不需要<em class="kg">修改。至少，是这样的想法。例如，您可能决定使用一个键/值存储，然后停止。</em></p><p id="3663" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">考虑一些简单的事情:</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="35f1" class="ky kz hu mq b fv mv mw l mx my">contract EternalStorage is Ownable { </span><span id="76ea" class="ky kz hu mq b fv mz mw l mx my">  mapping(bytes32 =&gt; uint) UIntStorage;</span><span id="bd07" class="ky kz hu mq b fv mz mw l mx my">  function setUintValue(bytes32 record, uint value) public {<br/>     UintStorage[record] = value;<br/>  }</span><span id="1e7b" class="ky kz hu mq b fv mz mw l mx my">  function getUIntValue(bytes32 record) constant returns (uint){<br/>    return UIntStorage[record]; <br/>  }<br/>}  </span><span id="1e80" class="ky kz hu mq b fv mz mw l mx my">// the end</span></pre><p id="ca83" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">当然，我们可以像那样回答问题，称之为胜利。我们可能会庆幸自己至少应该永远这么做。</p><p id="d9e8" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">另一个<code class="eh mn mo mp mq b">contract</code>、<em class="kg">逻辑</em>、<em class="kg">拥有</em>存储器。所有权可以转让给另一份<em class="kg">逻辑</em>合同。这种结构提供了用新逻辑替换旧逻辑的可能性。瞧啊。只要把数据层做好，你就能拥有一个可升级的<code class="eh mn mo mp mq b">contracts</code>系统。看看<a class="ae kx" rel="noopener" href="/rocket-pool/upgradable-solidity-contract-design-54789205276d"> RocketPool </a>中一个在有多个合同的系统中采用这种方法的项目的例子。</p><p id="6f31" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">对这种方法的一个经常性的批评是上升到逻辑层次的复杂性。所有持久化的东西都需要以存储<code class="eh mn mo mp mq b">contract</code>能够理解的方式来描述。这可能会增加复杂性并降低可读性，因为将所有变量名、数组和映射元素减少到键/值存储的唯一键会在以这种方式存储所有内容的契约中增加额外的步骤。</p><p id="551e" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">例如，你不能说:</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="246f" class="ky kz hu mq b fv mv mw l mx my">counter++</span></pre><p id="75e7" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">你可能会说:</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="a419" class="ky kz hu mq b fv mv mw l mx my">counter = datastore.get(keyForCounter);<br/>datastore.set(keyForCounter, counter++);</span></pre><p id="242c" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">不恐怖，但是视觉噪音加起来。</p><h2 id="a5e9" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">委托调用、库和代理模式</h2><p id="4ac1" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">通过Homestead hard fork，EVM获得了一个名为<code class="eh mn mo mp mq b">DELEGATECALL</code>的操作码。顾名思义，一个契约将一个功能“委托”给另一个契约。Solidity团队添加了使用它的<code class="eh mn mo mp mq b">library</code>。</p><p id="b0fe" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">一个<code class="eh mn mo mp mq b">library</code>看起来很像一个<code class="eh mn mo mp mq b">contract</code>，但是有一个可能奇怪的限制。它们不能保存任何数据。那是因为它们运行在决定<code class="eh mn mo mp mq b">DELEGATECALL</code>的<code class="eh mn mo mp mq b">contract</code>的上下文中。因此，如果<code class="eh mn mo mp mq b">contract I</code>决定将<code class="eh mn mo mp mq b">DELEGATECALL</code>传递给一个名为<code class="eh mn mo mp mq b">makeBed</code>的<code class="eh mn mo mp mq b">library</code>函数，那么将生成I的床(我的)，而不是<code class="eh mn mo mp mq b">library</code>的床。如果我想升级<code class="eh mn mo mp mq b">makeBed</code>进程，我需要一个新的<code class="eh mn mo mp mq b">library</code>并且我需要<code class="eh mn mo mp mq b">contract</code>来开始委托对新库的调用。</p><p id="f50c" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">你可以有一个main <code class="eh mn mo mp mq b">contract</code>，将所有重要的事情委托给一个或多个<code class="eh mn mo mp mq b">libraries</code>。</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="1949" class="ky kz hu mq b fv mv mw l mx my">pragma solidity 0.5.1;</span><span id="3499" class="ky kz hu mq b fv mz mw l mx my">library DoStuff {<br/>    <br/>    struct DataStore {<br/>        mapping(bytes32 =&gt; uint) value;<br/>    }<br/>    <br/>    function setVal(DataStore storage self, bytes32 key, uint value)<br/>        internal <br/>    {<br/>        self.value[key]= value;<br/>    }<br/>    <br/>    function getVal(DataStore storage self, bytes32 key) <br/>        internal view returns(uint) <br/>    {<br/>        return self.value[key];<br/>    }<br/>}</span><span id="cae0" class="ky kz hu mq b fv mz mw l mx my">contract Switchboard {<br/>    <br/>    using DoStuff for DoStuff.DataStore;<br/>    DoStuff.DataStore data;<br/>    <br/>    function set(bytes32 key, uint value) public {<br/>        data.setVal(key,value);<br/>    }<br/>    <br/>    function get(bytes32 key) public view returns(uint) {<br/>        return data.getVal(key);<br/>    }<br/>    <br/>}</span></pre><p id="009f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这不是一个关于<code class="eh mn mo mp mq b">libraries,</code>的完整教程，但这里有一些快速的提示:</p><ul class=""><li id="0cc9" class="na nb hu jm b jn jo jq jr jt nc jx nd kb ne kf nf ng nh ni dt translated">实际值存储在<code class="eh mn mo mp mq b">SwitchBoard</code>中，但是<code class="eh mn mo mp mq b">library</code>定义了它理解的数据类型的布局。</li><li id="668a" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">一个存储指针给了<code class="eh mn mo mp mq b">library</code>一些工作。<code class="eh mn mo mp mq b">library </code>直接写入<code class="eh mn mo mp mq b">Switchboard's</code>存储器。你可能会说，<code class="eh mn mo mp mq b">Switchboard</code>在它传递一个存储指针时授权它这么做。</li><li id="f603" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">这里有语法上的好处，这就是为什么a)似乎缺少了一个参数(计算一下), b)函数<code class="eh mn mo mp mq b">library</code>被神奇地调用为<code class="eh mn mo mp mq b">data</code>的方法，而<code class="eh mn mo mp mq b">data</code>在<code class="eh mn mo mp mq b">library</code>中被定义为<code class="eh mn mo mp mq b">struct</code>(仅用于布局)的一个实例。</li><li id="ba49" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated"><code class="eh mn mo mp mq b">contract</code>的功能非常简单。他们只是接受输入，并把它们传递给一个应该知道它在做什么的库。</li></ul><p id="9250" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">关于<code class="eh mn mo mp mq b">libraries</code>的一个好处是，一旦你理解了整体思想，它们不需要对熟悉的<code class="eh mn mo mp mq b">contract</code>编码风格做太多调整。简而言之，我们有一个<code class="eh mn mo mp mq b">library</code>，它会“做”你扔给它的任何适当布局的<code class="eh mn mo mp mq b">DataStore</code>。</p><h2 id="0a3c" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">功能也需要升级</h2><p id="c5ec" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">简而言之，让我们把允许我们换入一个新的<code class="eh mn mo mp mq b">library</code>的机制放在一边，只需多花一点努力就可以完成。这个我们就不细说了，因为还有一个更大的问题。如果我们想添加一个<code class="eh mn mo mp mq b">SwitchBoard</code>没有的功能怎么办？如果我们想在现有的函数中添加一个参数，该怎么办？</p><p id="9510" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">假设函数签名可以在任何时候都预先计算出来是不完全合理的。未来是不可知的，这也是为什么我们会对升级感兴趣的部分原因。</p><p id="4337" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">“代理”契约可以通过将<em class="kg">任何东西</em>转发给实现契约，并返回<em class="kg">任何东西</em>来解决灵活的接口。汇编，就其本质而言，对作者来说有点过时了，但是汇编代码已经存在了几年了。这是一个非常流行和众所周知的模式。</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="0f85" class="ky kz hu mq b fv mv mw l mx my">function () external payable {<br/>  assembly {<br/>    let ptr := mload(0x40)<br/>    calldatacopy(ptr, 0, calldatasize)<br/>    let result := delegatecall(<br/>      gas, <br/>      implementationAddress, <br/>      ptr, calldatasize, 0, 0)<br/>    let size := returndatasize<br/>    returndatacopy(ptr, 0, size)<br/><br/>    switch result<br/>    case 0 { revert(ptr, size) }<br/>    default { return(ptr, size) }<br/>  }<br/>}</span></pre><ul class=""><li id="7c65" class="na nb hu jm b jn jo jq jr jt nc jx nd kb ne kf nf ng nh ni dt translated">首先，它是一个后备函数，所以当代理契约找不到匹配时运行。在这种情况下，每次都是故意的。它是<code class="eh mn mo mp mq b">payable</code>因为它应该支持<code class="eh mn mo mp mq b">payable</code>实现函数才是有用的。</li><li id="c5fa" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">它复制输入的<code class="eh mn mo mp mq b">calldata</code>并将其传递给<code class="eh mn mo mp mq b">delegatecall</code>，后者将它发送给<code class="eh mn mo mp mq b">implementationAddress</code>，希望它知道该做什么。<code class="eh mn mo mp mq b">implementationAddress</code>是一个<code class="eh mn mo mp mq b">contract</code> <code class="eh mn mo mp mq b">address</code>我们就目前而言，预先假定是成立的。</li><li id="1d2d" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">也许<code class="eh mn mo mp mq b">implementationAddress</code>不知道该做什么，或者也许它恢复了。在这种情况下,<code class="eh mn mo mp mq b">delegatecall</code>将返回<code class="eh mn mo mp mq b">0/false</code>,所以这个实现检查它，如果<code class="eh mn mo mp mq b">implementationAddress</code>想要恢复，就恢复</li><li id="d1df" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">如果操作成功，该函数返回<code class="eh mn mo mp mq b">implementationAddress </code>响应。它不知道输入或输出意味着什么，但是您可以在代理契约的地址使用实现<code class="eh mn mo mp mq b"> contract</code> <em class="kg">的ABI。这种轻微的手工创建了一个令人信服的直接与实现契约一起工作的假象，而事实上，人们是通过代理传递一切。</em></li></ul><p id="85fb" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这种模式的一个非常好的特性是<code class="eh mn mo mp mq b">implementationAddress</code>是一个<code class="eh mn mo mp mq b">contract</code>，它不一定知道它是可升级的。它使用通常的语法，以通常的方式布置了状态变量，但是，事实上，所有东西都被写入代理<code class="eh mn mo mp mq b">contract's</code>状态。</p><p id="86aa" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">事实上，这非常受欢迎，以至于Zeppelin将其作为ZeppelinOS的透明代理的基础。你也会在Gnosis Safe 中找到它。</p><p id="7f3f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">您将发现的一个重要注意事项是，如果替换实现有缺陷或有恶意，很有可能会覆盖重要的状态数据。重要的是建立一个框架和/或实践来确保这样的事故是不可能的。</p><p id="290f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">即使一切都像预期的那样工作，它似乎也没有解决由可升级性本身引起的一个重要问题。让我们回到更高层次的考虑，可升级性本身减少了不变性。让我们考虑一下我们可以做些什么来减轻这种担忧。</p><h2 id="9df0" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">什么时候可升级性不是Bug？</h2><p id="35af" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">在这个概述中，我们已经触及了永久存储、开关板和透明代理模式，如果你愿意深入研究更多关于<em class="kg">如何</em>的内容，你可能会对其中任何一个感兴趣。</p><blockquote class="ly"><p id="1484" class="lz ma hu bd mb mc md me mf mg mh kf ek translated">你还是会遇到一个令人困扰的问题。如果你的合同是可升级的，为什么有人要相信它呢？</p></blockquote><p id="ded2" class="pw-post-body-paragraph jk jl hu jm b jn mi iv jp jq mj iy js jt mk jv jw jx ml jz ka kb mm kd ke kf hn dt translated">毕竟，这种形式的软件不就是为了创造确定性吗？如果特权用户可以更改实现，确定性会发生什么？它消失了。你还不如用你最喜欢的语言编写软件，部署在你最喜欢的平台上，用传统的方法让你的用户相信，你自己不会做任何不利于他们的事情。很可能你会省去很多麻烦。</p><p id="e275" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">作者第一次听说Ali Azam解决这个问题的方法是在DevCon IV上。他的方法是需要用户的同意。请注意，不是所有的用户。这不是一个民主的过程，可能会让少数用户被迫接受他们不想要的升级。</p><blockquote class="ly"><p id="526a" class="lz ma hu bd mb mc md me mf mg mh kf ek translated">每一个用户都应该自己决定是否继续他们已经签署的合同，或者自愿将<em class="jj">迁移到新版本。</em></p></blockquote><h2 id="64c5" class="ky kz hu bd la lb no ld le lf np lh li jt nq lk ll jx nr ln lo kb ns lq lr ls dt translated">注册处</h2><p id="e553" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">这是一个更细粒度的升级过程，每个用户都可能使用他们最喜欢的实现<code class="eh mn mo mp mq b">contract.</code>。注册中心<code class="eh mn mo mp mq b">contract</code>负责记录可用的实现<code class="eh mn mo mp mq b">contracts</code>，以及每个用户的首选实现。总之，注册中心保存了每个用户想要使用的版本。</p><p id="a8b2" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">该设置如下所示:</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="a06f" class="ky kz hu mq b fv mv mw l mx my">mapping(address =&gt; address) userImplementationChoices;</span></pre><p id="a7ff" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">前面介绍的透明代理通过查找用户的首选实现，然后继续使用前面描述的代理机制来适应这种情况:</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="7e75" class="ky kz hu mq b fv mv mw l mx my">address implementationAddress = userImplementation(msg.sender);</span></pre><p id="cec1" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">函数<code class="eh mn mo mp mq b">userImplementation(address)</code>计算出一些细节并为用户返回一个实现<code class="eh mn mo mp mq b">contract</code>地址<em class="kg">。是用户决定他们是否想要选择某个实现或选择加入来推送更新。</em></p><blockquote class="ly"><p id="6d0e" class="lz ma hu bd mb mc md me mf mg mh kf ek translated">可信升级意味着用户决定。</p></blockquote><p id="d83e" class="pw-post-body-paragraph jk jl hu jm b jn mi iv jp jq mj iy js jt mk jv jw jx ml jz ka kb mm kd ke kf hn dt translated">敏锐的读者可能会意识到，不同的支持契约可能意味着需要不同的客户端组件，比如UI。是的，的确如此，要知道哪个ABI在玩，就去问注册处。</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="3efb" class="ky kz hu mq b fv mv mw l mx my">function userImplementation(address user) public view returns(address) {</span></pre><h2 id="e270" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">通过设计，更加分散</h2><p id="02a4" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">让每个人使用他们喜欢的任何<code class="eh mn mo mp mq b">contract </code>可能是疯狂的，尤其是当他们在一个系统中共享公共存储时。不，我们想把这限制在开发人员和QA专业人员同意兼容的有效选择上。</p><p id="341a" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">注册中心允许特权用户批准用户可以选择的新合同，<em class="kg">如果他们愿意的话。</em>“特权用户”可以是一个治理合同，在该合同中，用户会考虑甚至应该接纳哪些申请人。</p><p id="1492" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">该流程可以轻松容纳明确的提议和批准。</p><ul class=""><li id="438c" class="na nb hu jm b jn jo jq jr jt nc jx nd kb ne kf nf ng nh ni dt translated">有人部署了新的实现。</li><li id="28bf" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">有人<em class="kg">提议</em>将<code class="eh mn mo mp mq b">0x123...</code>处的<code class="eh mn mo mp mq b">contract</code>添加到注册中心的有效实现列表中。</li><li id="5b75" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">决定，添加到注册表:</li></ul><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="4124" class="ky kz hu mq b fv mv mw l mx my">function addImplementation(address implementationAddress) <br/>  public <br/>  onlyOwner <br/></span></pre><p id="538f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">重要的是，没有人可以被迫离开最初的合同，就像他们签约时那样。而且，用户不必相信可升级性特性不会对他们不利。它旨在促进与此相反的过程——一个透明的过程，在该过程中，审查代码和公共审议是规范，没有规避商定的治理策略和控制版本准入的可能性，并且用户自己决定他们更喜欢使用哪个被认可的版本。</p><h2 id="3721" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">默认实现和其他管理问题</h2><p id="45fa" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">除了基本的运作原则之外，剩下的问题主要是管理上的。用户可以:</p><ul class=""><li id="dc59" class="na nb hu jm b jn jo jq jr jt nc jx nd kb ne kf nf ng nh ni dt translated">选择加入，并接受出现的新版本，或</li><li id="8642" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">选择退出，不接受新版本，除非他们手动更改他们的首选项。</li><li id="b796" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">所有新用户的默认选择(选择加入或选择退出)是部署后不能修改的注册表设置，因为改变用户对他们所拥有的选择和他们可以依赖的流程的理解将是一个错误。</li><li id="a000" class="na nb hu jm b jn nj jq nk jt nl jx nm kb nn kf nf ng nh ni dt translated">紧急召回功能允许特权用户否决一个版本。这将把<em class="kg">受影响的用户，</em>只有那些使用过时版本的用户，迁移到另一个推荐的选项。特权用户控制建议的版本，称为默认实现。召回是用户可以被强制迁移到其他地方的唯一情况。另一种方法是对受影响的用户禁用实现，直到他们明确选择另一个版本。我们为了用户体验的利益而设计了这一点，期望治理能够阻止恶意的实现出现在列表中。</li></ul><h2 id="79ba" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">版本样式指南</h2><p id="b8ce" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">该模块包含一个可继承的<code class="eh mn mo mp mq b">contract</code>，它解决了一个安全问题，即任何人都不应该直接调用实现契约(即不通过代理)。这毫无意义，因为数据驻留在代理中，而不是实现中。一个修饰符，<code class="eh mn mo mp mq b">onlyProxy</code>阻止了不适当的调用。</p><p id="e029" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">一般来说，实现的后续版本应该继承以前的实现。这样做可以确保状态布局总是以累加的方式发展。覆盖函数是可以接受的。添加新函数和新参数是可以接受的。禁用功能是可以接受的(用<code class="eh mn mo mp mq b">revert("deprecated");</code>覆盖)。</p><p id="93ed" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">示例实现包括一个Hello World <code class="eh mn mo mp mq b">contract</code>和第二个版本<code class="eh mn mo mp mq b">HelloUniverse</code>。上述问题都以最小的侵扰性得到解决:</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="6c31" class="ky kz hu mq b fv mv mw l mx my">contract HelloWorld is Upgradable {</span><span id="6a1b" class="ky kz hu mq b fv mz mw l mx my">  function doSomething() ... onlyProxy ...{<br/>    ...</span><span id="e025" class="ky kz hu mq b fv mz mw l mx my">contract HelloUniverse is HelloWorld {<br/>  ...</span></pre><p id="49fb" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">就是这样。</p><p id="7ae3" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">等等。还有一件事。注册中心使用一个任意的叫做“componentId”的T2。这将在部署代理时生成，代理本身部署相应的注册中心(每个代理一个注册中心，每个可升级代理一个注册中心<code class="eh mn mo mp mq b">contract</code>)。</p><p id="1ffd" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><code class="eh mn mo mp mq b">componentId</code>很容易用<code class="eh mn mo mp mq b">Registry.componentId()</code>检查，它的值必须传递到每个可升级的合同中。例如，在Hello World中:</p><pre class="ki kj kk kl fq mr mq ms mt aw mu dt"><span id="3aa7" class="ky kz hu mq b fv mv mw l mx my">constructor(bytes32 componentUid) Upgradable(componentUid) public {</span></pre><p id="6852" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这有助于进行基本的检查，以帮助捕捉部署时的错误，例如在生产中将错误组件的实现放入注册表中。注册中心将拒绝没有声明实现预期组件的实现<code class="eh mn mo mp mq b">contracts</code>。</p><h2 id="407a" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">变体</h2><p id="bde2" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">示例代码将实现视为一个用户一个用户的问题。上下文感知代理的思想可以以其他方式应用。例如，考虑离线数据和在线验证<code class="eh mn mo mp mq b">contracts</code>。有可能使用一个可升级的验证<code class="eh mn mo mp mq b">contract</code>来获得来自链外资产的信号——一个文档说，大约<em class="kg">使用验证版本3.2来解析我。</em></p><h2 id="4463" class="ky kz hu bd la lb lc ld le lf lg lh li jt lj lk ll jx lm ln lo kb lp lq lr ls dt translated">代码</h2><p id="a159" class="pw-post-body-paragraph jk jl hu jm b jn lt iv jp jq lu iy js jt lv jv jw jx lw jz ka kb lx kd ke kf hn dt translated">试验性回购，<a class="ae kx" href="https://github.com/rob-Hitchens/TrustlessUpgrades" rel="noopener ugc nofollow" target="_blank">https://github.com/rob-Hitchens/TrustlessUpgrades</a>有时可能比社区回购，<a class="ae kx" href="https://github.com/ali2251/Upgradable-contracts" rel="noopener ugc nofollow" target="_blank">https://github.com/ali2251/Upgradable-contracts</a>提前几个提交</p><p id="9d6d" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">阿里的无信任升级文档和研讨会讲义可在https://docs.upgradablecontracts.com/<a class="ae kx" href="https://docs.upgradablecontracts.com/" rel="noopener ugc nofollow" target="_blank">在线获得。</a></p><p id="17c7" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><a class="ae kx" href="https://ethereum.stackexchange.com/users/5549/rob-hitchens" rel="noopener ugc nofollow" target="_blank"><em class="kg">Rob Hitchens</em></a><em class="kg">是加拿大智能合约设计顾问，以太坊智能合约审计师</em><a class="ae kx" href="https://www.solidified.io" rel="noopener ugc nofollow" target="_blank"><em class="kg">solidified . io</em></a><em class="kg">和以太坊、Hyperledger Fabric、Hyperledger锯齿湖、Corda、Quorum和Tezos bootcamps的课件合著者和导师由</em><a class="ae kx" href="https://www/b9lab.com" rel="noopener ugc nofollow" target="_blank"><em class="kg">B9 lab</em></a><em class="kg">。</em></p><p id="7728" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><a class="ae kx" href="https://www.linkedin.com/in/ali-azam-01112b71/" rel="noopener ugc nofollow" target="_blank"> <em class="kg">阿里·阿扎姆</em> </a> <em class="kg">是</em><a class="ae kx" href="https://vaultplatform.com/" rel="noopener ugc nofollow" target="_blank"><em class="kg">vault platform</em></a><em class="kg">的资深区块链开发者，之前在伦敦大学国王学院工作了两年多，在伦敦大学国王学院、Devcon4、Blockercon等许多地方举办过各种研讨会和主题演讲。阿里是区块链每月区块链开发者训练营的高级导师和核心成员，并领导在伦敦举行的智能合同升级研讨会。</em></p><figure class="ki kj kk kl fq km"><div class="bz el l di"><div class="nt nu l"/></div></figure></div></div>    
</body>
</html>