<html>
<head>
<title>How to setup Redux for a REST api</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为 REST api 设置 Redux</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/state-management-with-redux-50f3ec10c10a#2019-03-31">https://medium.com/hackernoon/state-management-with-redux-50f3ec10c10a#2019-03-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="aabf" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">关于如何以通用方式设置 Redux 的指南，以减少样板文件并简化高达 90%的 API 调用</h2></div><h1 id="6eef" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">动机</h1><p id="9ee8" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我在 React London Meetup 上做了一个关于 Redux 状态管理的演讲，我想写一篇文章来更深入地解释我提出的解决方案的架构。</p><p id="f02a" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">您还可以在本文末尾找到一个具有完整 Redux 设置的<a class="ae lc" href="https://github.com/onoufriosm/redux-setup-guide" rel="noopener ugc nofollow" target="_blank"> Github </a> repo，准备用于真实世界的 React 应用程序，以及我的演讲视频。</p><h1 id="3235" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">问题是</h1><p id="098a" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">Redux 是一个令人惊叹的库。它非常简单，同时功能强大。它也非常灵活。这很好，因为它让我们可以自由地按照我们想要的方式设置它，并根据我们的应用程序的需要来调整它。但是这种灵活性也使得将它集成到大型应用程序中变得困难，因为我们有太多的方法可以做到这一点。</p><p id="9981" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">关于如何设置 Redux 来执行 api 调用的一般共识是:</p><ul class=""><li id="5136" class="ld le hu kd b ke kx kh ky kk lf ko lg ks lh kw li lj lk ll dt translated">声明常量(<code class="eh lm ln lo lp b">REQUEST_ACTION</code>、<code class="eh lm ln lo lp b">SUCCESS_ACTION</code>、<code class="eh lm ln lo lp b">FAIL_ACTION</code>)</li><li id="c151" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw li lj lk ll dt translated">创建一个负责分派请求操作的操作创建者</li><li id="a036" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw li lj lk ll dt translated">使用 API 服务调用端点(使用像 redux-thunk、saga、observables 这样的第三方库来实现)</li><li id="3223" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw li lj lk ll dt translated">接收有效载荷。如果成功，派遣<code class="eh lm ln lo lp b">SUCCESS_ACTION</code>，如果不成功，则派遣<code class="eh lm ln lo lp b">FAIL_ACTION</code></li><li id="b20c" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw li lj lk ll dt translated">处理减速器中的有效负载</li><li id="381a" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw li lj lk ll dt translated">连接 redux 以对组件做出反应(使用<code class="eh lm ln lo lp b">mapStateToProps</code>和<code class="eh lm ln lo lp b">mapDispatchToProps</code>)</li></ul><p id="043d" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">并且这必须为每个单独的 API 调用重复<strong class="kd hv">。这很快导致大量重复的样板文件和不可维护的代码。</strong></p><h1 id="f991" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">解决办法</h1><p id="ccc5" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">让我们看看如何通过一个读取单个用户的例子来解决上述问题。</p><p id="c50a" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv">动作创建者</strong></p><p id="331f" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">现在，如果我们想要读取一个用户，我们通常要做的第一件事就是声明一些常量，如下所示:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="3556" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">我们要做的第一个改进就是彻底<strong class="kd hv">去掉这些</strong>！我们真的不需要将它们声明为常量。我们可以很容易地动态计算它们，并通过一些单元测试来确保一切按预期运行。</p><p id="e9ed" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">我们通常要做的下一件事是像这样定义一个动作创建者:</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/e3d32fdb6c5cb85a1f3a02528d9ec92c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N-rOJDHDwkle5Sny"/></div></div></figure><p id="eda8" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这个动作创建器使用 redux-thunk 首先发送一个<code class="eh lm ln lo lp b">request</code>动作，然后执行 API 调用并根据响应触发一个<code class="eh lm ln lo lp b">success</code>或<code class="eh lm ln lo lp b">fail</code>动作。但是这段代码有两个问题:</p><ol class=""><li id="ea12" class="ld le hu kd b ke kx kh ky kk lf ko lg ks lh kw mj lj lk ll dt translated">这个动作创建者非常特定于<code class="eh lm ln lo lp b">user</code>实体。读取实体的功能几乎是相同的，所以只为用户定义一个动作创建者是不太可重用的。例如，如果我们想读取一个组实体，代码几乎是相同的。</li><li id="82ab" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">我们通过触发请求动作和 api 调用来混合关注点。动作创建者应该只负责发送动作。</li></ol><p id="9a57" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">让我们看看如何解决这些问题。动作创建器被重写，其唯一的责任是触发一个<code class="eh lm ln lo lp b">REQUEST</code>动作。同时，它现在能够用于系统中的任何实体。它看起来是这样的:</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mk"><img src="../Images/b6d0326455c08c0b5cbb28c23d4a3094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S5ejOCsTpEcXJyNZ"/></div></div></figure><p id="fc64" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">从这个动作创建者的名字可以看出，它是通用的(与上一节的<code class="eh lm ln lo lp b">readUser</code>相对)。它可以被系统中的任何实体使用。这个动作创建者接受两个参数:这个<code class="eh lm ln lo lp b">entityName</code>(可能是<code class="eh lm ln lo lp b">user</code>、<code class="eh lm ln lo lp b">group</code>、<code class="eh lm ln lo lp b">post</code>等等)和我们想要读取的实体的 ID。此操作创建者正在启动具有以下字段的操作:</p><ol class=""><li id="5306" class="ld le hu kd b ke kx kh ky kk lf ko lg ks lh kw mj lj lk ll dt translated">类型，将是<code class="eh lm ln lo lp b">REQUEST_READ_${entityName}</code>(我们将<code class="eh lm ln lo lp b">entityName</code>设为大写只是为了统一)</li><li id="1a14" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated"><code class="eh lm ln lo lp b">urlParams</code>，它将保存我们将用来计算我们将调用的 API 端点的参数。</li><li id="b61d" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">元数据，将被我们的 reducers 和中间件使用。</li></ol><p id="3a93" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">因此，我们在这里实现的是创建一个动作创建器，它可以与系统中的任何实体一起工作，类型是动态计算的，因此我们不再需要常数，它的唯一目的是返回一个动作。</p><p id="60b0" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv"> API 中间件</strong></p><p id="722d" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">接下来，我们想要创建一个 API 中间件，我们将把所有用于发送 API 调用的逻辑放在其中，然后根据响应分派成功或失败的操作。</p><p id="4cb5" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这是它看起来的样子:</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/a0aaddbfc44feb68ae9e6626ba7bcaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YA5PFNajRILVmTtP"/></div></div></figure><p id="397d" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这里我们监听其类型以<code class="eh lm ln lo lp b">REQUEST_READ</code>(例如<code class="eh lm ln lo lp b">REQUEST_READ_USER</code>)开始的任何动作，然后我们调用 API 端点并根据响应触发<code class="eh lm ln lo lp b">SUCCESS</code>或<code class="eh lm ln lo lp b">FAIL</code>动作。</p><p id="80ed" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这里需要注意两件事是:</p><ol class=""><li id="7c8a" class="ld le hu kd b ke kx kh ky kk lf ko lg ks lh kw mj lj lk ll dt translated">在上一节的请求动作中定义的<code class="eh lm ln lo lp b">urlParams</code>用于计算 api 端点。</li><li id="03fa" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">动作类型也是动态计算的。</li></ol><p id="3c59" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">因此，这个 API 中间件适用于系统中的任何实体，消除了动作类型常量和任何外部库的使用，使我们能够进行 API 调用。</p><p id="734f" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv">规范化中间件</strong></p><p id="850d" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">接下来，我们应该规范化我们从 API 得到的响应。在我们看到如何做到这一点之前，让我们看看什么是规范化:</p><p id="c099" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">许多应用程序处理本质上是嵌套的或关系的数据。下面显示了一个示例:</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff ml"><img src="../Images/be5eca4ab92d434ee87b680c9729bff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*28zrqN-idW1XsvWm"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">Payload with nested data (before normalization)</figcaption></figure><p id="fe3b" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这是一个<code class="eh lm ln lo lp b">post</code>实体，它有一个作者和一些评论(评论本身也有作者)。</p><p id="7708" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">通过规范化，我们可以返回包含 id 的嵌套实体，这些 id 收集在字典中。下面你可以看到<code class="eh lm ln lo lp b">post</code>的规格化版本。</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mq"><img src="../Images/4865451d308eb5d59e30664b128f47b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NsOlyRlt55HvHS1P"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">Normalized Payload</figcaption></figure><p id="7f5b" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">所有嵌套数据现在都通过<code class="eh lm ln lo lp b">id</code>键引用一个实体。</p><p id="01f3" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">规范化数据的一个主要好处是更新变得非常容易。例如，如果我们将带有<code class="eh lm ln lo lp b">id</code> 1 的用户名从“Jeff”更改为“Peter ”,那么使用第一种方法，我们需要在两个地方更新它。但是对于规范化的数据，我们只需要在一个地方更新它。您可以看到第一种方法如何在大型应用程序中变得不可维护。在非标准化版本中，我们可能最终不得不在 20 个不同的地方更新状态！</p><p id="30fe" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">规范化有效负载的中间件将如下所示:</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mr"><img src="../Images/8d2850af06d34bfb0f2414a501b4e512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YweAh2hKHbiajIzExhlxKQ.png"/></div></div></figure><p id="fa02" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">在这里，我们监听其类型以<code class="eh lm ln lo lp b">SUCCES_READ</code>(例如<code class="eh lm ln lo lp b">SUCCES_READ_USER</code>)开始的任何动作，然后规范化有效载荷数据。</p><p id="109d" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv">注意:</strong>对于我们所有的标准化需求，我们将使用<a class="ae lc" href="https://github.com/paularmstrong/normalizr" rel="noopener ugc nofollow" target="_blank"> normalizr </a>库</p><p id="ef72" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv">减速器-存储结构</strong></p><p id="134d" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这就是我们将如何构建我们的商店:</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/9ce94b6216011608f545286ad55450ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UjN1FFcBbBgswPQ_"/></div></div></figure><p id="a980" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">来自我们 api 的所有数据都将存在于<code class="eh lm ln lo lp b">entities</code>键下。在该目录下，我们将为系统中的每个实体保留一个密钥(例如<code class="eh lm ln lo lp b">user</code>、<code class="eh lm ln lo lp b">post</code> e.t.c)。</p><p id="0053" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">在每个实体键下，我们将有:</p><ol class=""><li id="31ee" class="ld le hu kd b ke kx kh ky kk lf ko lg ks lh kw mj lj lk ll dt translated">一个<code class="eh lm ln lo lp b">byId</code>键，我们将在这里保存从我们的 API 返回的有效载荷(在一个规范化的结构中)。</li><li id="c77f" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">一个<code class="eh lm ln lo lp b">readIds</code>键，我们将在这里保存 api 调用的状态。</li></ol><p id="ca98" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">为了达到这个目的，我们需要一个 reducer creator。reducer creator 是一个接受参数并返回 reducer 的函数，如下所示:</p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff ms"><img src="../Images/82baa21af53321ec5c78212ac6e52e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HYKgYelC8vvXS1Me"/></div></div></figure><p id="073a" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这个<code class="eh lm ln lo lp b">getReducers</code> reducer 创建器接受<code class="eh lm ln lo lp b">entityName</code>参数并返回两个 reducer(使用<code class="eh lm ln lo lp b"><a class="ae lc" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank">redux</a></code>库的<code class="eh lm ln lo lp b">combineReducer</code>函数)。</p><h1 id="0e6b" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated"><strong class="ak">重要提示:</strong></h1><p id="3ce6" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我们将不得不为系统中的每个实体调用这个 reducer creator。所以<strong class="kd hv">每个</strong>实体都有自己的<code class="eh lm ln lo lp b">byId</code>和<code class="eh lm ln lo lp b">readIds</code>减速器。当我们解释减速器如何工作时，理解这一点很重要。每个 redux 动作都要经过所有的 reducers。这意味着在每一个<code class="eh lm ln lo lp b">byId</code>和每一个<code class="eh lm ln lo lp b">readIds</code>缩减器中，我们只需要考虑与这个缩减器对应的实体相关的动作类型或动作有效负载。为了充分理解这些减速器是如何工作的，看看 Github repo(在本文末尾)也是一个好主意。</p><p id="6261" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv"> byId 减速器</strong></p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/a5bb4636f5030aefe65816db3e8030bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eXfSU9ZQ0q4jOo_H"/></div></div></figure><p id="7cf7" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><code class="eh lm ln lo lp b">byId</code>缩减器将监听任何以<code class="eh lm ln lo lp b">SUCCESS</code>(例如<code class="eh lm ln lo lp b">SUCCESS_READ_USER</code>)开始的动作类型，如果在我们的有效载荷中有这个实体类型的数据，它将在状态中被合并。例如，如果我们的有效载荷看起来像上面规范化有效载荷中的数据，并且这是<code class="eh lm ln lo lp b">comment</code>实体的<code class="eh lm ln lo lp b">byId</code>缩减器，则有效载荷的注释部分将被合并到状态中。</p><p id="214c" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv">准备好减速器</strong></p><figure class="lv lw lx ly fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mc"><img src="../Images/2eb682f372ce03e63d5850754d217c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EjuWo65E6a-4LrLw"/></div></div></figure><p id="8bbe" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">在这里，我们将听到任何以<code class="eh lm ln lo lp b">READ</code>开始的动作，这是相关的<code class="eh lm ln lo lp b">readIds</code>减速器。例如，如果动作是<code class="eh lm ln lo lp b">REQUEST_READ_USER</code>并且这是<code class="eh lm ln lo lp b">user</code>实体的<code class="eh lm ln lo lp b">readIds</code>缩减器，我们将继续更新状态。</p><p id="38cf" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="kd hv">连接高阶组件</strong></p><p id="84ed" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">当我把 redux 代码和 react 代码连接起来时，我最不想做的事情就是减少样板文件。通常，在我们想要与 redux 连接的每个 React 组件中，我们必须使用<code class="eh lm ln lo lp b">react-redux</code>的连接库，然后定义一个<code class="eh lm ln lo lp b">mapStateToProps</code>和一个<code class="eh lm ln lo lp b">mapDispatchToProps</code>函数来实现这一点。为了实现可重用性，我想将这段代码移到一个更高阶的组件(HOC)中，如下所示:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="14c6" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这个特设收到了两个论点。<code class="eh lm ln lo lp b">entityName</code>和一个<code class="eh lm ln lo lp b">id</code>。然后它传递给我们的孩子三个论点:</p><ol class=""><li id="0a2c" class="ld le hu kd b ke kx kh ky kk lf ko lg ks lh kw mj lj lk ll dt translated">一个读取函数，调用我们在前面章节看到的<code class="eh lm ln lo lp b">readEntity</code>动作创建器。</li><li id="f846" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated"><code class="eh lm ln lo lp b">entity</code>是从相关<code class="eh lm ln lo lp b">byId</code>减速器中选择的数据。</li><li id="cf35" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated"><code class="eh lm ln lo lp b">status</code>是从相关<code class="eh lm ln lo lp b">readIds</code>缩减器中选择的 api 调用的状态。</li></ol><p id="33f1" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这个 HOC 可以这样使用:</p><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="ma mb l"/></div></figure><p id="d910" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">在第 22 行中，我们实现了上面看到的特设。我们传递两个必需的参数。的<code class="eh lm ln lo lp b">entityName</code>，在这种情况下，它将是<code class="eh lm ln lo lp b">user</code>，因为我们要读取一个用户。以及<code class="eh lm ln lo lp b">id</code>，在本例中是<code class="eh lm ln lo lp b">1</code>，因为我们想要读取 id 为 1 的用户。</p><p id="b7c6" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">特设给我们三个参数(读，状态，实体)。然后在我们的<code class="eh lm ln lo lp b">User</code>组件中，我们可以在组件挂载时调用<code class="eh lm ln lo lp b">read</code>。我们还可以使用状态来查看 api 调用是否已经完成。如果有，那么我们显示用户名，否则我们可以显示一个<code class="eh lm ln lo lp b">Loading..</code>文本。</p><p id="c288" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这里我们可以看到 react 组件中的样板文件减少了多少。我们唯一需要连接 react 和 redux 并进行 read api 调用的就是使用这个 HOC。</p><h1 id="8c69" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">概述</h1><ol class=""><li id="7c46" class="ld le hu kd b ke kf kh ki kk mt ko mu ks mv kw mj lj lk ll dt translated">我们<strong class="kd hv">去掉了动作类型常量</strong></li><li id="2368" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">我们定义了一个通用的<strong class="kd hv"> readEntity 动作创建器</strong>,它可以被系统中的任何实体使用，它唯一的职责就是触发请求动作。</li><li id="d917" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">我们定义了一个<strong class="kd hv"> api 中间件</strong>来调用我们的端点，并根据响应触发成功或失败操作。</li><li id="d4b9" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">我们定义了一个<strong class="kd hv">标准化中间件</strong>负责标准化我们的有效负载。</li><li id="7b96" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">我们定义了一个<strong class="kd hv">get reducers</strong>reducer creator，它返回两个子 reducer<strong class="kd hv">byId 和 readIds </strong></li><li id="21c1" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">我们将逻辑移动到<strong class="kd hv">连接</strong>我们的 react 组件和<strong class="kd hv">高阶组件中的 redux。</strong></li></ol><h1 id="c690" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">达到 90%的覆盖率(或更高)</h1><p id="a3f2" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">需要注意的是，上面所有的代码都是非常通用的。这意味着我们可以读取系统中的任何实体，而无需编写任何额外的代码。但是，为了实现 90%或更多的 api 调用需求，我们必须处理以下所有情况:</p><ol class=""><li id="974c" class="ld le hu kd b ke kx kh ky kk lf ko lg ks lh kw mj lj lk ll dt translated">创造</li><li id="6e2f" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">ead</li><li id="33c3" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">更新</li><li id="94d9" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">删除</li><li id="d87e" class="ld le hu kd b ke lq kh lr kk ls ko lt ks lu kw mj lj lk ll dt translated">以多对多关系将一个实体与另一个实体连接或分离。</li></ol><p id="1ef5" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">我们必须允许单个或多个实体(例如，我们应该能够读取单个用户或多个用户，或者一次删除一个或多个帖子)。</p><p id="b6eb" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">实际上，为了实现这一点，不需要很多额外的代码。</p><p id="b74b" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">你可以在下面的 Github repo 中找到完整的代码库。</p><h1 id="8296" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">Github 回购</h1><div class="mw mx fm fo my mz"><a href="https://github.com/onoufriosm/redux-setup-guide" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">onofriosm/redux-设置-指南</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">描述如何以一种通用的方式设置 Redux 以方便 90%的 api 调用的指南…</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn mh mz"/></div></div></a></div><p id="0f3d" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">本报告作为如何以通用方式设置 Redux 的指南。这是一个麻省理工学院许可回购，所以请随意使用它，叉它或使用它作为一个灵感。</p><h1 id="5929" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">React 伦敦 meetup 演讲视频</h1><figure class="lv lw lx ly fq lz"><div class="bz el l di"><div class="no mb l"/></div></figure></div><div class="ab cl np nq hc nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="hn ho hp hq hr"><div class="lv lw lx ly fq mz"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">学习 React -最佳 React 教程(2019) | gitconnected</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">排名前 49 的 React 教程-免费学习 React。课程由开发人员提交并投票，使您能够…</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">gitconnected.com</p></div></div><div class="ni l"><div class="nw l nk nl nm ni nn mh mz"/></div></div></a></div></div></div>    
</body>
</html>