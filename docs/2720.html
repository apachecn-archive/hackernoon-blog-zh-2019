<html>
<head>
<title>A Guide to Logistic Regression in SAS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SAS中的逻辑回归指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/logistic-regression-using-sas-enterprise-guide-3ffb7774f765?source=collection_archive---------1-----------------------#2019-04-28">https://medium.com/hackernoon/logistic-regression-using-sas-enterprise-guide-3ffb7774f765?source=collection_archive---------1-----------------------#2019-04-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4a15" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">让我们探索一种使用SAS分析模型的简单方法。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/a725c64d3275e63b492dba383a5fc994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/0*V5f7ILugjSJR5doa.png"/></div></figure><p id="b40b" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">什么是逻辑回归？</strong></p><blockquote class="kn ko kp"><p id="c05d" class="jr js kq jt b ju jv iv jw jx jy iy jz kr kb kc kd ks kf kg kh kt kj kk kl km hn dt translated">逻辑回归是一种受监督的机器学习分类算法，用于预测分类因变量的概率。因变量是一个二元变量，包含编码为1(是/真)或0(否/假)的数据，用作二元分类器(不在回归中)。逻辑回归可以利用大量的特征，包括连续和离散变量以及非线性特征。在逻辑回归中，使用了<strong class="jt hv"> Sigmoid </strong>(又名逻辑)函数。</p></blockquote><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/236e62af9e39274c70ca0e5eed04c461.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*S7WJIgkqjisQYOOyH908ZQ.jpeg"/></div></figure><blockquote class="kn ko kp"><p id="f3af" class="jr js kq jt b ju jv iv jw jx jy iy jz kr kb kc kd ks kf kg kh kt kj kk kl km hn dt translated">我们想要一个预测概率在0到1之间的模型，也就是S形。有许多S形曲线。我们用的是logistic模型:概率= 1 / [1 +exp (B0 + b1X)]或者loge[P/(1-P)] = B0 +B1X。左边的函数loge[P/(1-P)]称为逻辑函数。</p></blockquote><h2 id="7d5d" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">使用SAS企业指南建立物流模型</strong></h2><p id="9a8b" class="pw-post-body-paragraph jr js hu jt b ju lq iv jw jx lr iy jz ka ls kc kd ke lt kg kh ki lu kk kl km hn dt translated">我使用的是来自Kaggle.com的泰坦尼克号数据集，其中包含一个训练和测试数据集。在这里，我们将尝试预测分类——幸存或死亡。我们的目标变量是“幸存”。我使用SAS企业指南来分析这个数据集。SAS给出了很多输出，所以我只发布了与我们的分析相关的部分。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="d972" class="kv kw hu lw b fv ma mb l mc md"><strong class="lw hv">Setting the library path and importing the dataset using proc import</strong></span><span id="d67b" class="kv kw hu lw b fv me mb l mc md">/* Setting the library path */</span><span id="46e5" class="kv kw hu lw b fv me mb l mc md">%let path=C:\dev\projects\SAS\PRACDATA;</span><span id="96c5" class="kv kw hu lw b fv me mb l mc md">libname PRAC “&amp;path”;</span><span id="0d12" class="kv kw hu lw b fv me mb l mc md">/* Importing dataset using proc import */</span><span id="a92a" class="kv kw hu lw b fv me mb l mc md">proc import datafile = “C:/dev/projects/sas/pracdata/train.csv”</span><span id="0dbd" class="kv kw hu lw b fv me mb l mc md">out = PRAC.titanic</span><span id="407a" class="kv kw hu lw b fv me mb l mc md">dbms = CSV;</span><span id="0b4e" class="kv kw hu lw b fv me mb l mc md">run;</span><span id="04d4" class="kv kw hu lw b fv me mb l mc md"><strong class="lw hv">Checking the contents of the dataset by using proc contents functio</strong>n</span><span id="9c70" class="kv kw hu lw b fv me mb l mc md">/* Checking the contents of the data*/</span><span id="2fa5" class="kv kw hu lw b fv me mb l mc md">proc contents data=work.train;</span><span id="8a13" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/f8a13323784f34c0508b94d07c91fbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*aUxUgeynDmEfHQq4JGVEgA.png"/></div></figure><p id="2a21" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们有12个变量。我们的目标变量是有1和0的“存活”。1表示存活，0表示未存活。<strong class="jt hv">类别变量</strong>:客舱，性别，Pclass。<strong class="jt hv">数字变量:</strong>乘客ID、SibSp、Parch、幸存者、年龄和票价。<strong class="jt hv">文本变量:</strong>票证和名称</p><h2 id="0df6" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">使用proc frequency </strong>检查目标变量“存活”的频率</h2><p id="6e76" class="pw-post-body-paragraph jr js hu jt b ju lq iv jw jx lr iy jz ka ls kc kd ke lt kg kh ki lu kk kl km hn dt translated">/*检查目标变量幸存的频率*/</p><p id="7823" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">proc freq data = work.train</p><p id="fdc4" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">表幸存；</p><p id="2e84" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">跑步；</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/f32821a94b5bc1edeea3bbeceae4c908.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*eJWr-Aoh4hQTjwAu2HUhgw.png"/></div></figure><p id="3a52" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们可以清楚地看到，342人幸存，549人没有生还。观察总数= 891。</p><h2 id="a3f7" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">数据可视化</strong></h2><p id="57b2" class="pw-post-body-paragraph jr js hu jt b ju lq iv jw jx lr iy jz ka ls kc kd ke lt kg kh ki lu kk kl km hn dt translated">通常，通过使用可视化来研究数据是一种很好的做法。我使用<code class="eh mh mi mj lw b">proc sgplot</code>来可视化这个类，<code class="eh mh mi mj lw b">Embark</code>。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="66f9" class="kv kw hu lw b fv ma mb l mc md">title "Analysis of embarkation locations";</span><span id="cba9" class="kv kw hu lw b fv me mb l mc md">proc sgplot data=prac.titanic;<br/>vbar Embarked / datalabel missing;</span><span id="ae5c" class="kv kw hu lw b fv me mb l mc md">label Embarked = "Passenger Embarking Port";</span><span id="52e8" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mk"><img src="../Images/f526eec2892feadbbe88e721113fe6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDbnZdYpO7PzNAxW1u6ZqA.jpeg"/></div></div></figure><p id="fe94" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在价值分布中没有什么不寻常的。让我们用其他变量来分析幸存率。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="2550" class="kv kw hu lw b fv ma mb l mc md">title "Survived vs Gender";</span><span id="353b" class="kv kw hu lw b fv me mb l mc md">proc sgplot data=prac.titanic pctlevel=group;</span><span id="7720" class="kv kw hu lw b fv me mb l mc md">vbar sex / group=Survived stat=percent missing;</span><span id="c013" class="kv kw hu lw b fv me mb l mc md">label Embarked = "Passenger Embarking Port";</span><span id="0648" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mp"><img src="../Images/d79f9c30185f75138f5e3b51ba83e0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Fu0hTTFAGtUmZjf9e8zcQ.jpeg"/></div></div></figure><p id="9fff" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">在这里，我们看到一种趋势，即女性比男性存活的更多。乘坐三等舱旅行的人死亡最多。尽管如此，还是有很多方法可以将数据可视化。我就不细说了。</p><h2 id="621a" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">使用proc方法检查缺失值</strong></h2><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="6a23" class="kv kw hu lw b fv ma mb l mc md">/* Checking the missing value and Statistics of the dataset */</span><span id="de7f" class="kv kw hu lw b fv me mb l mc md">proc means data=work.train N Nmiss mean std min P1 P5 P10 P25 P50 P75 P90 P95 P99 max;</span><span id="8992" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/8a00c6694c741a165c213bb407ccefef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*5lDybjLmE4jJheZAPcSPkQ.png"/></div></figure><p id="c314" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们可以看到Age有177个缺失值，并且没有检测到异常值。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="a138" class="kv kw hu lw b fv ma mb l mc md"><strong class="lw hv">Checking for categorical variables:</strong></span><span id="8fa0" class="kv kw hu lw b fv me mb l mc md">title “Frequency tables for categorical variables in the training set”;</span><span id="2357" class="kv kw hu lw b fv me mb l mc md">proc freq data=PRAC.TITANIC nlevels;</span><span id="6af8" class="kv kw hu lw b fv me mb l mc md">tables Survived; tables Sex; tables Pclass; tables SibSp; tables Parch; tables Embarked; tables Cabin;</span><span id="7c68" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/26eef88f4216e8c50c6c022b2a148291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*2THGs5RVHRHZv9SQjbcBJQ.png"/></div></figure><p id="6bfd" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们失去了年龄、船和船舱的价值。我们需要填充所有缺失的年龄，而不是删除缺失的行。用平均年龄填充的一种方法。但是，我们可以使用箱线图检查乘客等级的平均年龄。在SAS中，我们需要先将它从班级和年龄变量中分离出来，然后再制作盒状图。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="01a4" class="kv kw hu lw b fv ma mb l mc md">/* Sorting out the Pclass and Age for creating boxplot */</span><span id="e988" class="kv kw hu lw b fv me mb l mc md">proc sort data=work.train out=sorted;</span><span id="e48b" class="kv kw hu lw b fv me mb l mc md">by Pclass descending Age;</span><span id="b1cc" class="kv kw hu lw b fv me mb l mc md">run;</span><span id="b41c" class="kv kw hu lw b fv me mb l mc md">title ‘Box Plot for Age vs Class’;</span><span id="a1ac" class="kv kw hu lw b fv me mb l mc md">proc boxplot data=sorted;</span><span id="db8d" class="kv kw hu lw b fv me mb l mc md">plot Age*Pclass;</span><span id="65cb" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/0bf3d8fc8c645cf23d94a07fba5b2a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*dhUBwHtKVu2ci81TBtbLbw.png"/></div></figure><p id="6f77" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我们可以看到，在较高的阶层中，较富裕的乘客往往年龄较大，这是有道理的。我们将根据年龄的Pclass使用这些平均年龄值进行估算。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="863d" class="kv kw hu lw b fv ma mb l mc md">/* Imputing Mean value for the age column */</span><span id="15f9" class="kv kw hu lw b fv me mb l mc md">data work.train2;</span><span id="9b2d" class="kv kw hu lw b fv me mb l mc md">set work.train;</span><span id="ebe8" class="kv kw hu lw b fv me mb l mc md">if age=”.” and Pclass = 1 then age = 37;</span><span id="26e4" class="kv kw hu lw b fv me mb l mc md">else if age = “.” and Pclass = 2 then age = 29;</span><span id="2f98" class="kv kw hu lw b fv me mb l mc md">else if age = “.” and Pclass = 3 then age = 24;</span><span id="9259" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><p id="8616" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">我已经放弃了客舱变量，因为我认为它不会影响我们的模型，并使用中位数填充了“已装船”中缺少的值。(由于类别变量而选择的中间值)。</p><h2 id="db41" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">数据分区</strong></h2><p id="a0a5" class="pw-post-body-paragraph jr js hu jt b ju lq iv jw jx lr iy jz ka ls kc kd ke lt kg kh ki lu kk kl km hn dt translated">使用70:30的比例将数据集拆分为定型和验证数据集。首先，我需要使用<code class="eh mh mi mj lw b">proc sort</code>整理数据，并使用<code class="eh mh mi mj lw b">proc surveyselect</code>进行拆分。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="0fdb" class="kv kw hu lw b fv ma mb l mc md">/* Splitting the dataset into traning and validation using 70:30 ratio */</span><span id="4440" class="kv kw hu lw b fv me mb l mc md">proc sort data = prac.train6 out = train_sorted;</span><span id="84ce" class="kv kw hu lw b fv me mb l mc md">by Survived;</span><span id="fb22" class="kv kw hu lw b fv me mb l mc md">run;</span><span id="d80d" class="kv kw hu lw b fv me mb l mc md">proc surveyselect data = train_sorted out = train_survey outall</span><span id="a781" class="kv kw hu lw b fv me mb l mc md">samprate = 0.7 seed = 12345;</span><span id="0a02" class="kv kw hu lw b fv me mb l mc md">strata Survived;</span><span id="beb4" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/cfbf8e2c88354c177f522f3849a67f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*4nr9SdmYr4hkoIrNL0sYfw.png"/></div></figure><p id="c22f" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">为了验证正确的数据分区，我正在使用<code class="eh mh mi mj lw b">proc freq</code>生成一个频率表。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="98b7" class="kv kw hu lw b fv ma mb l mc md">/* Generating frequency table */</span><span id="cb7a" class="kv kw hu lw b fv me mb l mc md">proc freq data = train_survey;</span><span id="b504" class="kv kw hu lw b fv me mb l mc md">tables Selected*Survived;</span><span id="1077" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/5c33be68d27c8e01efe98b317c527809.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*_SL56f9lxTSb95VskOlCUw.png"/></div></figure><p id="072e" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">值为1的选定变量将是我们对训练部分的目标观察。让我们也执行快速设置处理，以便只留下我们感兴趣的列，并正确命名变量。</p><h2 id="7788" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">建筑模型</strong></h2><p id="8cce" class="pw-post-body-paragraph jr js hu jt b ju lq iv jw jx lr iy jz ka ls kc kd ke lt kg kh ki lu kk kl km hn dt translated">我们填充了所有缺失的值，数据集已准备好构建模型。我现在使用<code class="eh mh mi mj lw b">proc logistic</code>创建一个逻辑回归模型。逻辑回归非常适合为二元变量建立模型。在我们的例子中，目标变量是存活的。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="4a35" class="kv kw hu lw b fv ma mb l mc md">/* Creating Logistic regression model */</span><span id="b0be" class="kv kw hu lw b fv me mb l mc md">proc logistic data=titanic descending;</span><span id="f323" class="kv kw hu lw b fv me mb l mc md">where part=1;</span><span id="8177" class="kv kw hu lw b fv me mb l mc md">class Embarked Parch Pclass Sex SibSp Survived;</span><span id="0932" class="kv kw hu lw b fv me mb l mc md">model Survived(event=’1') = Age Fare Embarked Parch Pclass Sex SibSp /</span><span id="c65f" class="kv kw hu lw b fv me mb l mc md">selection=stepwise expb stb lackfit;</span><span id="f679" class="kv kw hu lw b fv me mb l mc md">output out = temp p=new;</span><span id="3350" class="kv kw hu lw b fv me mb l mc md">store titanic_logistic;</span><span id="e6cc" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><p id="d3c1" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">SAS的一个优点是，对于逻辑回归中的分类变量，我们不需要创建虚拟变量。在这里，我们可以在一个类中声明所有的类别变量。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/57daaf0c4365c99b37f8e6bf490700d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*wRq7K28Ce22SOTjJqmASXw.png"/></div></figure><p id="37b5" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">变量选择算法决定模型将包括年龄、阶级和性别变量。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="fe ff mw"><img src="../Images/da6958de1ac090ca9d2d33d65a31a40e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YcnycJxwfgactEWhHxEahg.png"/></div></div></figure><p id="c97b" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">对于训练集(部分=1)和验证集(部分=0)，Good=1都是近似值。训练集和验证集的正确率分别为82.56%和80.08%。这是一个稳定的模型，但是，如果我们看到霍斯默测试的p值较小。根据这本书，p值越高，模型拟合得越好。</p><p id="e018" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果我们能看到一致的配对，它是86.6 %。一致性用于评估记分卡如何区分开发样本中的好客户和坏客户。一致性越高，好账户和坏账户之间的分数分离就越大。</p><h2 id="ee22" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">测试测试数据集</strong></h2><p id="a6f4" class="pw-post-body-paragraph jr js hu jt b ju lq iv jw jx lr iy jz ka ls kc kd ke lt kg kh ki lu kk kl km hn dt translated">我们可以通过使用测试数据集来测试我们的训练模型。使用Proc import在SAS中导入测试数据集和估算所有缺失值的过程是相同的。</p><h2 id="4971" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated"><strong class="ak">使用我们的模型</strong>测试测试数据集</h2><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="b87d" class="kv kw hu lw b fv ma mb l mc md">/* Testing with our model titanic_logisitic */</span><span id="ff9f" class="kv kw hu lw b fv me mb l mc md">proc plm source=titanic_logistic;</span><span id="c075" class="kv kw hu lw b fv me mb l mc md">score data=test1 out=test_scored predicted=p / ilink;</span><span id="f25b" class="kv kw hu lw b fv me mb l mc md">run;</span></pre><p id="7383" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">现在，我们使用proc export将结果导出到CSV文件中。我通过使用概率0.5并在结果中只保留<code class="eh mh mi mj lw b">PassengerId</code>和<code class="eh mh mi mj lw b">Survived</code>变量来分离存活率。</p><pre class="jk jl jm jn fq lv lw lx ly aw lz dt"><span id="9dc8" class="kv kw hu lw b fv ma mb l mc md">data test_scored;</span><span id="d62f" class="kv kw hu lw b fv me mb l mc md">set test_scored;</span><span id="c748" class="kv kw hu lw b fv me mb l mc md">if p &gt; 0.5 then Survived = 1;</span><span id="b977" class="kv kw hu lw b fv me mb l mc md">else Survived = 0;</span><span id="3359" class="kv kw hu lw b fv me mb l mc md">keep PassengerId Survived;</span><span id="b4df" class="kv kw hu lw b fv me mb l mc md">run;</span><span id="a33e" class="kv kw hu lw b fv me mb l mc md">/* Exporting the output into csv file */</span><span id="3eb4" class="kv kw hu lw b fv me mb l mc md">proc export data=test_scored</span><span id="3aa9" class="kv kw hu lw b fv me mb l mc md">file=”C:/dev/projects/sas/pracdata/Result.csv” replace;</span><span id="22ef" class="kv kw hu lw b fv me mb l mc md">run;</span><span id="d90b" class="kv kw hu lw b fv me mb l mc md"><strong class="lw hv">Note:</strong></span></pre><p id="352e" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">模型中仅使用了三个变量(年龄、阶级和性别),结果为74.64 %。这是一个不错的模型；然而，我们有很大的空间通过使用其他变量来改进模型。</p><h2 id="6654" class="kv kw hu bd kx ky kz la lb lc ld le lf ka lg lh li ke lj lk ll ki lm ln lo lp dt translated">下一步是什么</h2><p id="b7a4" class="pw-post-body-paragraph jr js hu jt b ju lq iv jw jx lr iy jz ka ls kc kd ke lt kg kh ki lu kk kl km hn dt translated">在我的下一篇文章中，我将尝试使用其他变量并改进模型。此外，我们可以应用其他算法，如决策树，随机森林来检查准确性水平。我会试着在我的下一篇博客中发表。</p><p id="f3c3" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">如果您发现任何错误或需要改进的地方，请不吝赐教。</p><p id="0d78" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated"><strong class="jt hv">参考:</strong></p><p id="bc79" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">1)【https://support.sas.com/en/documentation.html】T4</p><p id="1891" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">2)<a class="ae mx" href="https://en.wikipedia.org/wiki/Logistic_regression" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Logistic_regression</a></p><p id="c443" class="pw-post-body-paragraph jr js hu jt b ju jv iv jw jx jy iy jz ka kb kc kd ke kf kg kh ki kj kk kl km hn dt translated">3)<a class="ae mx" href="https://www.kaggle.com/c/titanic" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/c/titanic</a></p></div></div>    
</body>
</html>