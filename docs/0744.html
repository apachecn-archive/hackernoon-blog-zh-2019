<html>
<head>
<title>Asynchronous Operations in React-Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-Redux中的异步操作</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/asynchronous-operations-in-react-redux-5fd34b639aa0?source=collection_archive---------20-----------------------#2019-01-30">https://medium.com/hackernoon/asynchronous-operations-in-react-redux-5fd34b639aa0?source=collection_archive---------20-----------------------#2019-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><a href="https://blog.jscrambler.com/asynchronous-operations-in-react-redux/?utm_source=medium.com&amp;utm_medium=referral"><div class="fe ff ir"><img src="../Images/98f2e3b605a2b71a73a3c67f1c8fec2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OWCuC-usahaJwNT7.jpg"/></div></a></figure><p id="dde7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在对浏览器编程时，异步操作是一个困难的挑战。</p><p id="b76a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">很难想象发送一个请求，然后等待一个没有阻塞的响应。浏览器可以将请求放在回调之后，继续执行代码。</p><p id="df92" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">React-Redux库在不影响简单性的情况下为您完成了大部分工作。可以把React想象成用普通HTML呈现UI组件的库。Redux是具有异步功能的状态管理库。</p><p id="19e5" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在过去，您可以通过链式回调来委托异步行为。这有局限性，因为大的回调链有回调地狱的风险。为了保持代码尽可能的干净，强烈的纪律性是必要的。当你缺乏坚实的原则时，回调地狱会使任何项目变得一团糟。</p><p id="c192" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是，有了React-Redux，异步编程有什么样的改进呢？为此，我们将在太阳系的行星上做一个演示。目标是将它们与图像异步加载到页面上。我们将关注Redux的状态管理以及它如何处理异步行为。我们假设你有npm和ES6的工作知识。为了保持代码示例的重点，我们只展示相关的代码。如果你对更多的管道感兴趣，请随意查看GitHub 上的整个<a class="ae jw" href="https://github.com/JscramblerBlog/async-operations-react-redux" rel="noopener ugc nofollow" target="_blank">演示。</a></p><p id="9a2d" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">本演示的依赖关系如下:如果您正在跟进，请键入:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="ee73" class="kg kh hu kc b fv ki kj l kk kl">npm install --save next react react-dom prop-types axios redux react-redux redux-thunk redux-logger</span></pre><p id="48ce" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">确保有一个<code class="eh km kn ko kc b">package.json</code>可用于保存所有依赖项。请随意探索每个依赖项将做什么。要记住的两个是发出异步请求的<code class="eh km kn ko kc b">axios</code>和管理异步状态的<code class="eh km kn ko kc b">redux-thunk</code>。</p><p id="ed09" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">首先，获取我们将在整个演示中使用的常量。这些常量将驱动异步操作的状态:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="55f3" class="kg kh hu kc b fv ki kj l kk kl">export const REQUEST_PLANETS = 'request planets';<br/>export const RECEIVE_PLANETS = 'receive planets';</span></pre><p id="80bf" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请求由组件的<code class="eh km kn ko kc b">componentDidMount</code>方法触发，然后触发<code class="eh km kn ko kc b">fetchPlanets</code>。为了帮助您直观地看到结果，下面是工作演示:</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div class="fe ff kp"><img src="../Images/8fdfba9504fc7b4787bc9cbbe96a9694.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/0*T4dL_NQRQWnu375b.jpg"/></div></figure><h1 id="a3df" class="kq kh hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">为什么不用Ajax？</h1><p id="d845" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">您可以将Redux-Thunk视为在浏览器中实现Ajax的另一种方式。thunk描述了一个函数，它可以代替您稍后进行的计算。执行不会立即发生，而是被委托。</p><p id="c62e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">例如:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="2ee3" class="kg kh hu kc b fv ki kj l kk kl">const foo = (i) =&gt; i + 1;</span></pre><p id="4f53" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在JavaScript中，您可能认为thunk是一个回调函数。回调函数委托计算，以便稍后执行。在Redux-Thunk中，您仍然使用同样的回调概念，但是以一种抽象的方式。Redux的语句管理系统处理所有的实现细节。这消除了长回调链和回调地狱的风险。</p><p id="3a7f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在Redux-Store中连接Redux-Thunk的时间到了:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="e4a6" class="kg kh hu kc b fv ki kj l kk kl">const logger = createLogger();</span><span id="ab67" class="kg kh hu kc b fv ls kj l kk kl">const planetStore = createStore(<br/>  reducers,<br/>  applyMiddleware(logger, thunk)<br/>);</span></pre><p id="9750" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">至此，您已经为一些异步编程做好了准备。Thunk现在设置动作调度程序，这样它就可以处理thunk回调函数。Redux-Store是您将Redux-Thunk设置为中间件管道的地方。注意，我们借此机会包含了日志记录器，这样我们就可以看到Redux-Thunk的运行。记录器捕获调度程序消息，并在浏览器的控制台中打印出来。</p><h1 id="40af" class="kq kh hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">Axios的异步操作</h1><p id="a225" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">接下来，让我们设置通过商店发送的动作。在Redux中，动作就像在状态管理系统中荡漾的消息。你可以把任何UI交互看作一个动作。当您想象激发和接收消息来管理状态时，这非常合适。UI记录状态变化，触发动作，Redux通过消息处理状态变化。</p><p id="8993" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><code class="eh km kn ko kc b">PlanetAction</code>如下所示:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="f281" class="kg kh hu kc b fv ki kj l kk kl">let PlanetAction = {<br/>  fetchPlanets() {<br/>    return (dispatch) =&gt; {<br/>      dispatch({ type: REQUEST_PLANETS });</span><span id="09d3" class="kg kh hu kc b fv ls kj l kk kl">axios.get('/static/solar-system-planets.json')<br/>        .then((response) =&gt; dispatch({<br/>          type: RECEIVE_PLANETS,<br/>          success: true,<br/>          planets: response.data.planets<br/>        }))</span><span id="f39b" class="kg kh hu kc b fv ls kj l kk kl">.catch((error) =&gt; dispatch({<br/>          type: RECEIVE_PLANETS,<br/>          error: error.message,<br/>          planets: null<br/>        }));<br/>    };<br/>  }<br/>};</span></pre><p id="b47c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意使用<code class="eh km kn ko kc b">axios</code>通过一个承诺在浏览器中封装Ajax请求。<code class="eh km kn ko kc b">.then()</code>函数处理一个成功的响应。<code class="eh km kn ko kc b">.catch()</code>函数处理一个错误。React-Thunk使您可以使用Thunk作为返回类型。底层状态管理系统处理调度程序。注意thunk和<code class="eh km kn ko kc b">return (dispatch) =&gt; { }</code>的用法。</p><p id="7e09" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为了优雅地处理错误，我们选择捕获调度程序消息中的<code class="eh km kn ko kc b">error.message</code>。这有助于我们调试应用程序，因为这条消息显示在控制台中。<code class="eh km kn ko kc b">.catch()</code>函数通过dispatcher回调函数启用错误处理。</p><p id="063f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">控制台中的消息如下所示:</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lt"><img src="../Images/02c1789523466eb3b19a2fbbb1481370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9zLB4ksoyjUV_W3q.jpg"/></div></div></figure><h1 id="6e70" class="kq kh hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">反应还原剂</h1><p id="8562" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">缩减器接收消息，并通过一个纯函数返回当前状态。一个纯函数就是给定一个输入，你总是得到完全相同的结果。这种范式是函数式编程，它减少了程序中不可预测的行为。</p><p id="b784" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面是异步操作期间改变状态的减速器:</p><pre class="jx jy jz ka fq kb kc kd ke aw kf dt"><span id="58cd" class="kg kh hu kc b fv ki kj l kk kl">const INITIAL_STATE = [];</span><span id="7497" class="kg kh hu kc b fv ls kj l kk kl">const planets = (state = INITIAL_STATE, action) =&gt; {<br/>  switch (action.type) {<br/>    case REQUEST_PLANETS:<br/>      return INITIAL_STATE;</span><span id="5793" class="kg kh hu kc b fv ls kj l kk kl">case RECEIVE_PLANETS:<br/>      return action.planets;</span><span id="fb49" class="kg kh hu kc b fv ls kj l kk kl">default:<br/>      return state;<br/>  }<br/>};</span></pre><p id="30c8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们可以重用<code class="eh km kn ko kc b">INITIAL_STATE</code>,因为应用程序在页面加载和请求期间有相同的数据。注意，结果总是与给定的输入一一匹配。Reducers使用纯函数并返回异步操作中给定的状态。然后，动作分派器使用这个纯函数来计算当前状态。注意这个缩减器是thunk函数中的回调函数。</p><p id="c8d6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">现在，下面是快乐之路的控制台消息:</p><figure class="jx jy jz ka fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lt"><img src="../Images/d4cc2954c72065109d4e09cb6c6ed431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OPT7W9JhMdXCSbqB.jpg"/></div></div></figure><h1 id="899a" class="kq kh hu bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">结论</h1><p id="7915" class="pw-post-body-paragraph iy iz hu ja b jb ln jd je jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv hn dt translated">Redux-Thunk有一个包装Thunk函数的异步方法。这包含了最好的编程，比如委托和纯函数。</p><p id="619a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果您通过回调熟悉遗留Ajax，那么thunk就没什么不同。React-Redux抓住了你所知道的关于普通JavaScript的最好的东西，并将其包装起来以便于使用。这个库没有重新发明轮子，而是通过抽象来自动化声音编程。</p><p id="d2ba" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后，但同样重要的是，如果您正在开发JavaScript应用程序，并希望保护它们免受代码窃取和逆向工程的影响，请务必查看<a class="ae jw" href="https://jscrambler.com/code-integrity?utm_source=blog.jscrambler.com&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jscrambler </a>。</p></div><div class="ab cl ly lz hc ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hn ho hp hq hr"><p id="dc63" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="mf">最初发表于</em><a class="ae jw" href="https://blog.jscrambler.com/asynchronous-operations-in-react-redux/?utm_source=medium.com&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">T5【blog.jscrambler.com】</a><em class="mf">。</em></p></div></div>    
</body>
</html>