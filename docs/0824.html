<html>
<head>
<title>Adding ElasticSearch To Legacy Application Using Logstash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Logstash向遗留应用程序添加ElasticSearch</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/adding-elasticsearch-to-legacy-application-using-logstash-98c19ac2f0fb?source=collection_archive---------5-----------------------#2019-02-03">https://medium.com/hackernoon/adding-elasticsearch-to-legacy-application-using-logstash-98c19ac2f0fb?source=collection_archive---------5-----------------------#2019-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/670b858524edab706969e404ca70a7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNR_e2gAr8kwLKW2ZoZOhA.png"/></div></div></figure><p id="2989" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ElasticSearch凭借其近实时存储、扩展、执行全文搜索和分析海量数据的能力，在市场上创造了繁荣。ElasticSearch是开源搜索和分析引擎，通常用于具有复杂搜索功能的应用程序。</p><p id="b225" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本教程中，我们将考虑一个场景，我们希望将ElasticSearch添加到我们的遗留应用程序中，作为辅助数据源。假设我们有一个使用MySQL数据库的遗留应用程序，现在我们有一个需要大量搜索的需求，我们决定迁移到ElasticSearch。我在这里的想法仍然是将关系数据库作为<strong class="je hv">主数据存储</strong>，将ElasticSearch作为<strong class="je hv">辅助数据存储</strong>，以满足我们需要大量搜索的需求。</p><blockquote class="ka kb kc"><p id="108e" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">因此，我们的关系数据库将是一个真实的单一来源，我们可以随时扁平化的表格和索引的数据弹性搜索。为了执行繁重的搜索，我们将查询ElasticSearch并使用关系数据库，就像通常的应用程序数据库事务一样。</p></blockquote><p id="7965" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以现在我们脑海中可能出现的问题是，</p><ul class=""><li id="bb75" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">如何将我的所有数据从结构化数据源(MySQL)迁移到非结构化数据源(弹性搜索)？</li><li id="9f6b" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">能否在不停机的情况下完成迁移？</li><li id="908f" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">我如何保持两个数据源同步？</li></ul><p id="c8b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解决方法之一是使用<strong class="je hv"> Logstash输入插件。</strong></p><figure class="kw kx ky kz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kv"><img src="../Images/735f2345dbd52cea8f6442bef7b8907b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2uEl6LQYIBZp57hNegOhA.jpeg"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Replication of data from Relational database to ElasticSearch using Logstash</figcaption></figure><p id="be10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Logstash是一个基于插件的数据收集和处理引擎。它带有各种插件，可以轻松地配置它，以便在许多不同的架构中收集、处理和转发数据。</p><figure class="kw kx ky kz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/b98c6b9c6a7c9e3a16865880c81249da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mCh4Afr56GKmsiGA.png"/></div></div></figure><p id="e72c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">处理被组织到一个或多个流水线中。在每个管道中，一个或多个<em class="kd">输入插件</em>接收或收集数据，然后放入内部队列。默认情况下，它很小，保存在内存中，但是可以配置为比<em class="kd">大，并保存在磁盘</em>上，以提高可靠性和弹性。</p><p id="8c73" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">处理线程以微批处理的方式从队列中读取数据，并通过任何已配置的<a class="ae lf" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" rel="noopener ugc nofollow" target="_blank">过滤器插件</a>按顺序处理这些数据。Logstash开箱即用，带有大量针对特定处理类型的插件，这就是数据被解析、处理和丰富的方式。</p><p id="8904" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">处理完数据后，处理线程会将数据发送到适当的输出插件，这些插件负责格式化和向前发送数据，例如发送到Elasticsearch。</p><figure class="kw kx ky kz fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lg"><img src="../Images/f7b3e4f2d648ad7ef65c5d0fee3c11c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZSZqQGhXDGq1NVG908xMJA.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek"><strong class="bd lh">Sample Logstash Pipeline</strong></figcaption></figure><p id="d28e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们考虑一个简单的电子商务网站，其中我们维护与客户及其订单相关的数据。现在，我们希望将我们的客户相关数据索引到ElasticSearch，以便执行广泛的搜索操作。</p><p id="9c02" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 1。MySQL数据库创建</strong></p><p id="6cda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建一个名为<strong class="je hv"> ecomdb </strong>的示例数据库，并确保我们使用的是同一个数据库</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="6e2f" class="ln lo hu lj b fv lp lq l lr ls">CREATE DATABASE ecomdb;<br/>USE ecomdb;</span></pre><p id="44a4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。现在用下面的查询创建一个客户表，并插入样本数据</strong></p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="fe86" class="ln lo hu lj b fv lp lq l lr ls">CREATE TABLE customer (<br/>id INT(6)  AUTO_INCREMENT PRIMARY KEY,<br/>firstname VARCHAR(30) NOT NULL,<br/>lastname VARCHAR(30) NOT NULL,<br/>email VARCHAR(50),<br/>regdate TIMESTAMP<br/>)<br/>INSERT INTO `ecomdb`.`customer` (`id`, `firstname`, `lastname`, `email`, `regdate`) VALUES (1, 'Roger', 'Federer', '<a class="ae lf" href="mailto:roger.federer@yomail.com" rel="noopener ugc nofollow" target="_blank">roger.federer@yomail.com</a>', '2019-01-21 20:21:49');<br/>INSERT INTO `ecomdb`.`customer` (`id`, `firstname`, `lastname`, `email`, `regdate`) VALUES (2, 'Rafael', 'Nadal', '<a class="ae lf" href="mailto:rafael.nadal@yomail.com" rel="noopener ugc nofollow" target="_blank">rafael.nadal@yomail.com</a>', '2019-01-22 20:21:49');<br/>INSERT INTO `ecomdb`.`customer` (`id`, `firstname`, `lastname`, `email`, `regdate`) VALUES (3, 'John', 'Mcenroe', '<a class="ae lf" href="mailto:john.mcenroe@yomail.com" rel="noopener ugc nofollow" target="_blank">john.mcenroe@yomail.com</a>', '2019-01-23 20:21:49'); <br/>INSERT INTO `ecomdb`.`customer` (`id`, `firstname`, `lastname`, `email`, `regdate`) VALUES (4, 'Ivan', 'Lendl', '<a class="ae lf" href="mailto:ivan.lendl@yomail.com" rel="noopener ugc nofollow" target="_blank">ivan.lendl@yomail.com</a>', '2019-01-23 23:21:49'); <br/>INSERT INTO `ecomdb`.`customer` (`id`, `firstname`, `lastname`, `email`, `regdate`) VALUES (5, 'Jimmy', 'Connors', '<a class="ae lf" href="mailto:jimmy.connors@yomail.com" rel="noopener ugc nofollow" target="_blank">jimmy.connors@yomail.com</a>', '2019-01-23 22:21:49');</span></pre><p id="84f7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3。创建我们的Logstash配置。</strong></p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="7d0b" class="ln lo hu lj b fv lp lq l lr ls">input {<br/>  jdbc {<br/>    jdbc_driver_library =&gt; "&lt;pathToYourDataBaseDriver&gt;\mysql-connector-java-5.1.39.jar"<br/>    jdbc_driver_class =&gt; "com.mysql.jdbc.Driver"<br/>    jdbc_connection_string =&gt; "jdbc:mysql://localhost:3306/ecomdb"<br/>    jdbc_user =&gt; &lt;db username&gt;<br/>    jdbc_password =&gt; &lt;db password&gt;<br/>    <strong class="lj hv">tracking_column¹ =&gt; "regdate"</strong><br/>    <strong class="lj hv">use_column_value²=&gt;true</strong><br/>    statement =&gt; "SELECT * FROM ecomdb.customer where regdate &gt;:sql_last_value;"<br/><strong class="lj hv">schedule³ =&gt; " * * * * * *"</strong><br/>  }<br/>}<br/>output {<br/>  elasticsearch {<br/>    <strong class="lj hv">document_id</strong>⁴<strong class="lj hv">=&gt; "%{id}"</strong><br/>    document_type =&gt; "doc"<br/>    index =&gt; "test"<br/>    hosts =&gt; ["<a class="ae lf" href="http://localhost:9200" rel="noopener ugc nofollow" target="_blank">http://localhost:9200</a>"]<br/>  }<br/>  stdout{<br/>  codec =&gt; rubydebug<br/>  }<br/>}</span></pre><blockquote class="ka kb kc"><p id="c4c9" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><strong class="je hv"> tracking_column : </strong>要跟踪其值是否有任何更改的列。这里我们将跟踪<code class="eh lt lu lv lj b"><em class="hu">regdate</em></code>列，因为每当我们的数据库中有新条目时，它都会被更新。</p><p id="77ff" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><strong class="je hv">使用列值:</strong>设置为<code class="eh lt lu lv lj b"><em class="hu">true</em></code>时，使用定义的<code class="eh lt lu lv lj b"><em class="hu">tracking_column</em></code>值作为<code class="eh lt lu lv lj b"><em class="hu">:sql_last_value</em></code>。当设置为<code class="eh lt lu lv lj b"><em class="hu">false</em></code>时，<code class="eh lt lu lv lj b"><em class="hu">:sql_last_value</em></code>反映最后一次执行查询的时间。</p><p id="29c1" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">jdbc插件将以元数据文件的形式保存<code class="eh lt lu lv lj b"><em class="hu">sql_last_value</em></code>参数，该文件的默认位置是<code class="eh lt lu lv lj b"><em class="hu">c:/users/&lt;yourUser&gt;</em></code>。在执行查询时，该文件将被更新为当前值<code class="eh lt lu lv lj b"><em class="hu">sql_last_value</em></code>。下次管道启动时，将通过读取文件来更新该值。<code class="eh lt lu lv lj b"><em class="hu">sql_last_value</em></code>将被设置为1970年1月1日，如果<code class="eh lt lu lv lj b"><em class="hu">use_column_value</em></code>为真，则设置为0</p><p id="bb6c" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><strong class="je hv"> schedule </strong>:这将定期运行语句，值以Cron格式定义，例如:“* * * * *”(每分钟执行查询，在分钟)。在这里，我们将每秒执行一次该语句，因此，即使对我们的数据进行了任何更新或插入，我们也能够在下一次执行查询时将其迁移，并且我们的数据将保持同步。</p><p id="c523" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">⁴ <strong class="je hv"> document_ID: </strong>索引的文档id对于覆盖Elasticsearch中具有相同id的现有条目非常有用。如果logstash实例失败，这将解决<strong class="je hv">重复</strong>问题。</p></blockquote><p id="8b74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的配置文件可以分为两个主要部分。</p><ul class=""><li id="3cdf" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">输入插件(JDBC插件):在这里我们定义哪个数据库URI连接，用户凭证和查询，这将为我们提供所需的数据。</li><li id="d297" class="kh ki hu je b jf kq jj kr jn ks jr kt jv ku jz km kn ko kp dt translated">output plugin(ElasticSearch plugin):这里我们定义elastic search主机URL和索引名称，数据将被索引到这个名称。</li></ul><p id="bb28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将上述代码保存在名为<strong class="je hv"><em class="kd"/>logstash-sample . conf</strong>的文件中，该文件的位置应该在您的log stash安装的<strong class="je hv"> bin文件夹</strong>中。</p><p id="b521" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 4。从Logstash安装</strong>的bin文件夹中用下面的命令运行Logstash</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="0e5c" class="ln lo hu lj b fv lp lq l lr ls">logstash -f logstash-sample.conf</span></pre><p id="c769" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Logstash会从你的数据库中获取你的数据，并发布到ElasticSearch。</p><p id="0241" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 5。通过执行下面的命令</strong>来验证我们在ElasticSearch上的数据</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="9d82" class="ln lo hu lj b fv lp lq l lr ls">curl -X GET "localhost:9200/test/_search"</span></pre><p id="79b2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上述命令的输出将是</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="817f" class="ln lo hu lj b fv lp lq l lr ls">{<br/>  "took": 0,<br/>  "timed_out": false,<br/>  "_shards": {<br/>    "total": 5,<br/>    "successful": 5,<br/>    "skipped": 0,<br/>    "failed": 0<br/>  },<br/>  "hits": {<br/>    "total": 3,<br/>    "max_score": 1,<br/>    "hits": [<br/>      {<br/>        "_index": "test",<br/>        "_type": "doc",<br/>        "_id": "4",<br/>        "_score": 1,<br/>        "_source": {<br/>          "firstname": "Ivan",<br/>          "id": 4,<br/>          "email": "<a class="ae lf" href="mailto:ivan.lendl@yomail.com" rel="noopener ugc nofollow" target="_blank">ivan.lendl@yomail.com</a>",<br/>          "lastname": "Lendl",<br/>          "<a class="ae lf" href="http://twitter.com/version" rel="noopener ugc nofollow" target="_blank">@version</a>": "1",<br/>          "regdate": "2019-01-23T17:51:49.000Z",<br/>          "<a class="ae lf" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>": "2019-02-02T06:20:12.413Z"<br/>        }<br/>      },<br/>      {<br/>        "_index": "test",<br/>        "_type": "doc",<br/>        "_id": "2",<br/>        "_score": 1,<br/>        "_source": {<br/>          "firstname": "Rafael",<br/>          "id": 2,<br/>          "email": "<a class="ae lf" href="mailto:rafael.nadal@yomail.com" rel="noopener ugc nofollow" target="_blank">rafael.nadal@yomail.com</a>",<br/>          "lastname": "Nadal",<br/>          "<a class="ae lf" href="http://twitter.com/version" rel="noopener ugc nofollow" target="_blank">@version</a>": "1",<br/>          "regdate": "2019-01-22T14:51:49.000Z",<br/>          "<a class="ae lf" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>": "2019-02-02T06:20:12.411Z"<br/>        }<br/>      },<br/>      {<br/>        "_index": "test",<br/>        "_type": "doc",<br/>        "_id": "1",<br/>        "_score": 1,<br/>        "_source": {<br/>          "firstname": "Roger",<br/>          "id": 1,<br/>          "email": "<a class="ae lf" href="mailto:roger.federer@yomail.com" rel="noopener ugc nofollow" target="_blank">roger.federer@yomail.com</a>",<br/>          "lastname": "Federer",<br/>          "<a class="ae lf" href="http://twitter.com/version" rel="noopener ugc nofollow" target="_blank">@version</a>": "1",<br/>          "regdate": "2019-01-21T14:51:49.000Z",<br/>          "<a class="ae lf" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>": "2019-02-02T06:20:12.389Z"<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span></pre></div><div class="ab cl lw lx hc ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hn ho hp hq hr"><p id="522b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们给上面的用例增加一些变化。假设我们希望在同一个文档中索引每个用户的订单细节以及用户细节。</p><ol class=""><li id="8024" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz md kn ko kp dt translated"><strong class="je hv">在MySQL DB中创建一个订单表。</strong></li></ol><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="e838" class="ln lo hu lj b fv lp lq l lr ls">CREATE TABLE orders (<br/>orderid INT(6)  AUTO_INCREMENT PRIMARY KEY,<br/>product VARCHAR(300) NOT NULL,<br/>description VARCHAR(300) NOT NULL,<br/>price int(6),<br/>customerid int(6),<br/>ordertime TIMESTAMP,<br/>FOREIGN KEY fk_userid(customerid)<br/>REFERENCES customer(id)<br/>)</span><span id="52c2" class="ln lo hu lj b fv me lq l lr ls">INSERT INTO `ecomdb`.`orders` (`orderid`, `product`, `description`, `price`, `customerid`,`ordertime`)<br/> VALUES (1, 'Tennis Ball', 'Wilson Australian Open', '330', '5','2019-01-22 20:21:49');<br/>INSERT INTO `ecomdb`.`orders` (`orderid`, `product`, `description`, `price`, `customerid`,`ordertime`)<br/> VALUES (2, 'Head Xtra Damp Vibration Dampner', 'Dampens string vibration to reduce the risk of pain', '500', '4','2019-01-23 02:21:49');<br/> INSERT INTO `ecomdb`.`orders` (`orderid`, `product`, `description`, `price`, `customerid`,`ordertime`)<br/> VALUES (3, 'HEAD Wristband Tennis 2.5" (White)', '80 % Cotton, 15% Nylon, 5 % Rubber (Elasthan)', '530', '3','2019-01-21 21:21:49');<br/> INSERT INTO `ecomdb`.`orders` (`orderid`, `product`, `description`, `price`, `customerid`,`ordertime`)<br/> VALUES (4, 'YONEX VCORE Duel G 97 Alfa (290 g)', 'Head Size 97', '4780', '2','2019-01-22 14:21:49');<br/> INSERT INTO `ecomdb`.`orders` (`orderid`, `product`, `description`, `price`, `customerid`,`ordertime`)<br/> VALUES (5, 'Wilson Kaos Stroke - White &amp; Black', 'Wilson Australian Open', '9000', '1','2019-01-25 03:53:49');</span></pre><p id="00c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，一旦我们准备好数据库，并且我们希望在同一个文档中索引订单细节作为嵌套的JSON对象以及用户细节，我们将利用Logstash提供的<a class="ae lf" href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" rel="noopener ugc nofollow" target="_blank">过滤器插件。Logstash支持各种插件，我们可以根据需要选择一个。我们将使用<strong class="je hv">红宝石滤镜</strong> <em class="kd">。有了ruby过滤器，我们可以执行任何随机的ruby代码。</em></a></p><p id="49fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可能会想到的问题是</p><ul class=""><li id="afd3" class="kh ki hu je b jf jg jj jk jn kj jr kk jv kl jz km kn ko kp dt translated">我们如何使用JDBC输入插件从两个不同的表中获取数据？我们将使用<strong class="je hv">连接查询。</strong></li></ul><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="dbb7" class="ln lo hu lj b fv lp lq l lr ls">select c.id as customerid,c.firstname ,c.lastname ,c.email, c.regdate ,<br/>od.orderid ,od.product ,od.description , od.price ,od.ordertime<br/>from customer as c left join  orders as od on c.id = od.customerid;</span></pre><p id="8397" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。按照我们的要求编写Ruby代码。</strong></p><p id="2c65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">操纵我们文档的Ruby代码如下</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="9962" class="ln lo hu lj b fv lp lq l lr ls"># the filter method receives an event and must return a list of events.<br/># Dropping an event means not including it in the return array,<br/># while creating new ones only requires you to add a new instance of<br/># LogStash::Event to the returned array<br/>def filter(event)<br/>orderid =event.get("orderid")<br/>product = event.get("product")<br/>description = event.get("description")<br/>price = event.get("price")<br/>ordertime = event.get("ordertime")<br/>orderDetails ={<br/>   "orderid" =&gt; orderid,<br/>   "product" =&gt; product,<br/>   "description" =&gt; description,<br/>   "price" =&gt; price,<br/>   "ordertime" =&gt; ordertime<br/>}<br/>event.set('orderDetails',orderDetails)<br/>event.remove('orderid')<br/>event.remove('product')<br/>event.remove('description')<br/>event.remove('price')<br/>event.remove('ordertime')<br/>return [event]  <br/>end</span></pre><p id="1df1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将ruby文件命名为<strong class="je hv"> sampleRuby.rb <em class="kd">。</em> </strong> Ruby过滤器有一个强制的<strong class="je hv">过滤器方法</strong>，它接受一个Logstash事件并且必须返回一个事件数组。在上面的代码中，我们通过创建订单详情的<strong class="je hv"> <em class="kd"> </em> </strong> <em class="kd">散列来操纵事件，并将该散列设置为事件中的新字段。我们还删除了添加订单详细信息散列后不需要的字段。</em></p><p id="4296" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 3。将ruby过滤器添加到logstash配置文件中。</strong></p><p id="ca5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新版本的<strong class="je hv"> logstash-sample.conf </strong>文件将如下所示</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="c879" class="ln lo hu lj b fv lp lq l lr ls">input {<br/>  jdbc {<br/>    jdbc_driver_library =&gt; "&lt;pathToYourDataBaseDriver&gt;\mysql-connector-java-5.1.39.jar"<br/>    jdbc_driver_class =&gt; "com.mysql.jdbc.Driver"<br/>    jdbc_connection_string =&gt; "jdbc:mysql://localhost:3306/ecomdb"<br/>    jdbc_user =&gt; &lt;db user name&gt;<br/>    jdbc_password =&gt; &lt;db password&gt;<br/>    tracking_column =&gt; "regdate"<br/>    use_column_value=&gt;true<br/>    statement =&gt; "select c.id as customerid,c.firstname ,c.lastname  ,c.email, c.regdate ,od.orderid ,od.product ,od.description , od.price ,od.ordertime from customer as c left join  orders as od on c.id = od.customerid where c.regdate&gt;:sql_last_value;"<br/>schedule =&gt; " * * * * * *"  <br/>}<br/>}<br/>filter{<br/>ruby{<br/><strong class="lj hv">path¹ =&gt; 'sampleRuby.rb'</strong><br/>}<br/>}<br/>output {<br/>  elasticsearch {<br/>    document_id=&gt; "%{customerid}"<br/>    document_type =&gt; "doc"<br/>    index =&gt; "test"<br/>    hosts =&gt; ["<a class="ae lf" href="http://localhost:9200" rel="noopener ugc nofollow" target="_blank">http://localhost:9200</a>"]<br/>  }<br/>  stdout{<br/>  codec =&gt; rubydebug<br/>  }<br/>}</span></pre><blockquote class="ka kb kc"><p id="ffe3" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">实现<code class="eh lt lu lv lj b"><em class="hu">filter</em></code>方法的ruby脚本文件的路径。<strong class="je hv">ruby文件的位置应该与logstash-sample.conf的位置相同</strong></p></blockquote><p id="6675" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 4。使用下面的命令</strong>运行上面的配置文件</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="0a1c" class="ln lo hu lj b fv lp lq l lr ls">logstash -f logstash-sample.conf</span></pre><p id="75c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上述脚本的输出如下所示</p><pre class="kw kx ky kz fq li lj lk ll aw lm dt"><span id="0801" class="ln lo hu lj b fv lp lq l lr ls">{<br/>  "took": 0,<br/>  "timed_out": false,<br/>  "_shards": {<br/>    "total": 5,<br/>    "successful": 5,<br/>    "skipped": 0,<br/>    "failed": 0<br/>  },<br/>  "hits": {<br/>    "total": 5,<br/>    "max_score": 1,<br/>    "hits": [<br/>      {<br/>        "_index": "test",<br/>        "_type": "doc",<br/>        "_id": "5",<br/>        "_score": 1,<br/>        "_source": {<br/>          <strong class="lj hv">"orderDetails": {<br/>            "orderid": 1,<br/>            "description": "Wilson Australian Open",<br/>            "product": "Tennis Ball",<br/>            "ordertime": "2019-01-22T14:51:49.000Z",<br/>            "price": 330<br/>          },</strong><br/>          "<a class="ae lf" href="http://twitter.com/version" rel="noopener ugc nofollow" target="_blank">@version</a>": "1",<br/>          "email": "<a class="ae lf" href="mailto:jimmy.connors@yomail.com" rel="noopener ugc nofollow" target="_blank">jimmy.connors@yomail.com</a>",<br/>          "<a class="ae lf" href="http://twitter.com/timestamp" rel="noopener ugc nofollow" target="_blank">@timestamp</a>": "2019-02-02T14:13:46.754Z",<br/>          "regdate": "2019-01-23T16:51:49.000Z",<br/>          "firstname": "Jimmy",<br/>          "customerid": 5,<br/>          "lastname": "Connors"<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="942c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如上面所强调的，我们可以看到我们已经在现有的文档中添加了一个嵌套的JSON。</p><p id="af1d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Logstash插件可以帮助我们将遗留系统迁移到ElasticSearch。这样，我们将应用程序的搜索部分迁移到了搜索引擎，而不是使用数据存储提供的搜索功能。我们将我们的真实来源保存在SQL数据库中，但是您也可以想象从传统数据存储迁移到NoSQL。</p><blockquote class="ka kb kc"><p id="daaa" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><strong class="je hv">注意:JDBC输入插件无法跟踪数据库中的删除事件(硬删除)。您可以考虑用isdeleted标志修改数据库表，并将该列用作跟踪列。</strong></p></blockquote></div></div>    
</body>
</html>