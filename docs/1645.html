<html>
<head>
<title>High-velocity software development using nested Git branches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用嵌套Git分支的高速软件开发</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/high-velocity-software-development-using-nested-git-branches-69bfc2d1e54d?source=collection_archive---------4-----------------------#2019-03-10">https://medium.com/hackernoon/high-velocity-software-development-using-nested-git-branches-69bfc2d1e54d?source=collection_archive---------4-----------------------#2019-03-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1388c074a48a1d7c274f82549ceabc5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mmfml1UipKBSWUT6kkcIIA.jpeg"/></div></div></figure><p id="8484" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在同一个特性分支中同时实现几个不同的不相关的代码更改，就像试图与同一个人同时就几个完全不同的主题进行对话，或者其他形式的多任务处理。从来都没有成果。我们最终会混淆问题或忘记考虑一个主题的重要边缘情况，因为我们被其他主题分散了注意力。我们只有部分大脑可以用来思考每个话题。同时处理几个问题可能会让人产生高效的错觉，但最终，分别处理每个主题会更快、更容易、更安全、更干净、更不容易出错。</p><p id="0de4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这篇博客文章描述了一种通过使用一系列嵌套的Git分支实现代码更改的高度集中开发技术。我们使用专门的工具(<a class="ae ka" href="http://www.git-town.com/" rel="noopener ugc nofollow" target="_blank"> Git Town </a>，一个Git的开源插件)来使这种工作变得简单高效。</p><h1 id="072a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">例子</h1><p id="4fa0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">举个例子，假设我们想为现有产品实现一个新特性。但是要做出如此复杂的改变，我们必须首先准备好代码库:</p><ul class=""><li id="004f" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">通过改进不再有意义的类名和函数名来清除一些技术上的偏差</li><li id="5b20" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">给架构增加一些灵活性，这样就可以用更少的工作量来构建新特性</li><li id="f361" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">在查看代码库时，我们还发现了一些我们想要修复的错别字</li></ul><p id="17f0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们将这些东西实现为一个独立但相互连接的功能分支链！我提供了<a class="ae ka" href="http://www.git-town.com/" rel="noopener ugc nofollow" target="_blank"> Git Town </a>命令，以及那些不熟悉该工具的人在没有Git Town的情况下必须运行的单个Git命令。首先，让我们修复这些错别字，因为这是最容易的改变，没有理由继续查看它们。</p><h1 id="5b60" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">修复错别字</h1><p id="4203" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们创建一个名为<code class="eh ls lt lu lv b">1-fix-typos</code>的特性分支来包含来自<code class="eh ls lt lu lv b">master</code>分支的错别字修复:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="1977" class="me kc hu lv b fv mf mg l mh mi">git hack 1-fix-typos</span></pre><p id="825e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> git hack </strong>是git Town添加的Git命令。相应的普通Git命令是:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="0ee5" class="me kc hu lv b fv mf mg l mh mi">git checkout master<br/>git pull<br/>git checkout -b 1-fix-typos</span></pre><p id="806d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们总是希望在主分支的最新版本之上构建新的变更。</p><p id="cd81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们执行一些提交操作来修复打字错误，并提交一个拉取请求:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="752c" class="me kc hu lv b fv mf mg l mh mi">git new-pull-request</span></pre><p id="bf2f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个Git Town命令打开一个浏览器窗口，在您的代码托管服务上创建pull请求。</p><p id="cab9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有这些只花了我们不到一分钟的时间。当那些变更的代码评审发生时，我们继续修正技术偏差。</p><h1 id="b32b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">重命名<code class="eh ls lt lu lv b">foo</code></h1><p id="b36a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们不想再看到我们刚刚修复的错别字，所以让我们在branch <code class="eh ls lt lu lv b">1-fix-typos</code>的顶部执行任何进一步的更改:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="5775" class="me kc hu lv b fv mf mg l mh mi">git append 2-rename-foo</span></pre><p id="5375" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh ls lt lu lv b">git append</code>通过从当前分支中剪切创建一个新的特征分支，产生如下分支层次:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="ae2e" class="me kc hu lv b fv mf mg l mh mi">master<br/>  \<br/>   1-fix-typos<br/>     \<br/>      2-rename-foo</span></pre><p id="c36d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相应的普通Git命令是:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="69a9" class="me kc hu lv b fv mf mg l mh mi">git checkout -b 2-rename-foo</span></pre><p id="c281" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们提交重命名变量<code class="eh ls lt lu lv b">foo</code>的更改，并开始下一个拉请求:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="fdc3" class="me kc hu lv b fv mf mg l mh mi">git new-pull-request</span></pre><p id="0c09" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们使用了<code class="eh ls lt lu lv b">git append</code>来创建新的分支，Git Town知道分支的层次结构，并从分支<code class="eh ls lt lu lv b">2-rename-foo</code>创建一个针对分支<code class="eh ls lt lu lv b">1-fix-typos</code>的拉请求。这保证了分支2的pull请求只显示该分支中所做的更改(重命名变量)，而不显示分支1中所做的语法修正。</p><h1 id="dacd" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">重命名<code class="eh ls lt lu lv b">bar</code></h1><p id="8970" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这与重命名<code class="eh ls lt lu lv b">foo</code>不同，所以让我们在不同的分支中进行。其中一些变化可能发生在我们刚刚重命名为foo的地方。我们不希望以后不得不处理合并冲突。那些又无聊又冒险。因此，让我们在步骤2中所做的更改的基础上进行这些更改:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="d90a" class="me kc hu lv b fv mf mg l mh mi">git append 3-rename-bar</span></pre><p id="4ba5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们以这种分支层次结构结束:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="c6f0" class="me kc hu lv b fv mf mg l mh mi">master<br/>  \<br/>   1-fix-typos<br/>     \<br/>      2-rename-foo<br/>        \<br/>         3-rename-bar<!-- --> </span></pre><p id="925a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相应的普通Git命令是</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="1733" class="me kc hu lv b fv mf mg l mh mi">git checkout -b 3-rename-bar</span></pre><h1 id="3769" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">修复更多错别字</h1><p id="763a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在重命名<code class="eh ls lt lu lv b">bar</code>的时候，我们又发现了一些错别字。让我们将它们添加到第一个分支。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="524d" class="me kc hu lv b fv mf mg l mh mi">git checkout 1-fix-typos<br/># make the changes and commit them here<br/>git checkout 3-rename-bar</span></pre><p id="a214" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回到分支<code class="eh ls lt lu lv b">3-rename-bar</code>，新修复的错别字再次可见，因为修复它们的提交现在只存在于分支<code class="eh ls lt lu lv b">1-fix-typos</code>中。幸运的是，Git Town可以通过所有其他分支自动传播这些更改:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="8495" class="me kc hu lv b fv mf mg l mh mi">git sync</span></pre><p id="0e5a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相应的普通Git命令是:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="4c87" class="me kc hu lv b fv mf mg l mh mi">git checkout -b 2-rename-foo<br/>git merge 1-fix-typos<br/>git push<br/>git checkout 3-rename-bar<br/>git merge 2-rename-foo<br/>git push</span></pre><h1 id="9f62" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">推广基础设施</h1><p id="9a12" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">好吧，我们说到哪了？对！有了正确的名称，现在更容易理解更大的变化。我们剪切分支<code class="eh ls lt lu lv b">4-generalize-infrastructure</code>并在其中执行重构。它必须是<code class="eh ls lt lu lv b">3-rename-bar</code>的子分支，因为之前改进的变量命名将使我们现在要做的更大的改变更加直观。</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="8c4c" class="me kc hu lv b fv mf mg l mh mi">git append 4-generalize-infrastructure</span></pre><p id="979f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">同样，在香草Git中:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="9ddd" class="me kc hu lv b fv mf mg l mh mi">git checkout -b 4-generalize-infrastructure</span></pre><p id="c764" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大量的编码和提交到这个分支中来概括事物。因为这就是我们在这里所做的一切，而不是别的，所以很容易就能完成。针对这些变更的代码评审开始了。</p><h1 id="53a7" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">发布打字错误修复</h1><p id="5a2a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">与此同时，我们获得了对步骤1中的错别字修复的批准。让我们运送他们！</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="3dba" class="me kc hu lv b fv mf mg l mh mi">git ship 1-fix-typos</span></pre><p id="a71a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">普通Git命令:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="c8ae" class="me kc hu lv b fv mf mg l mh mi">git stash -u         # move open changes out of the way<br/>git checkout master  # update master so that we ship our changes <br/>                     # on top of the most current changes<br/>git pull<br/>git checkout 1-fix-typos  # make sure the local machine<br/>                          # has all the changes made in the <br/>                          # 1-fix-typos branch<br/>git pull<br/>git merge master  # resolve any merge conflicts <br/>                  # between our feature and the latest master now,<br/>                  # on the feature branch<br/>git checkout master<br/>git merge — squash 1-fix-typos  # use a squash merge <br/>                                # to remove all temporary commits <br/>                                # on the branch<br/>git push                   # make our shipped feature visible to<br/>                           # all other developers<br/>git branch -d 1-fix-typo   # delete the shipped branch <br/>                           # from the local machine<br/>git push origin :1-fix-typo  # delete the shipped branch <br/>                             # from the remote repository<br/>git checkout 4-generalize-infrastructure  # return to the branch <br/>                                          # we were working on<br/>git stash pop         # restore open changes we were working on</span></pre><p id="6bc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">随着分支<code class="eh ls lt lu lv b">1-fix-typos</code>的发布，我们的分支层次结构现在看起来像这样:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="2031" class="me kc hu lv b fv mf mg l mh mi">master<br/>  \<br/>   2-rename-foo<br/>     \<br/>      3-rename-bar<br/>        \<br/>         4-generalize-infrastructure</span></pre><h1 id="9f14" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">让我们的工作与世界同步</h1><p id="7f29" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们已经做了一段时间了。团队中的其他开发人员也发布了一些东西，从技术上来说，分支<code class="eh ls lt lu lv b">2-rename-foo</code>仍然指向master上的前一次提交。我们不希望我们的分支与主分支上发生的事情偏离太多，因为这会导致以后更严重的合并冲突。让我们让一切同步！</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="28db" class="me kc hu lv b fv mf mg l mh mi">git sync</span></pre><p id="b527" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">相应的普通Git命令是:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="9d85" class="me kc hu lv b fv mf mg l mh mi">git stash -u  # move open changes out of the way<br/>git checkout master<br/>git pull<br/>git checkout 2-rename-foo<br/>git merge master<br/>git push<br/>git checkout 3-rename-bar<br/>git merge 2-rename-foo<br/>git push<br/>git checkout 4-generalize-infrastructure<br/>git merge 3-rename-bar<br/>git push<br/>git stash pop     # restore what we were working on</span></pre><p id="c3be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们使用了<code class="eh ls lt lu lv b">git append</code>来创建新的分支，Git Town知道哪个分支是哪个分支的子分支，并且能够以正确的顺序进行合并。</p><h1 id="795e" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构建新功能</h1><p id="eb92" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">回到正题。有了新的通用代码架构，我们现在可以以一种简洁的方式添加新特性。要在新基础架构之上构建新功能，请执行以下操作:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="fc7a" class="me kc hu lv b fv mf mg l mh mi">git append 5-add-feature</span></pre><p id="141d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们到此为止吧。希望，Git Town如何允许在几个Git分支中并行工作已经很清楚了。让我们回顾一下:</p><ul class=""><li id="3cfb" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">每个变化都发生在它自己的特征分支中</li><li id="954e" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><code class="eh ls lt lu lv b">git append</code>在现有工作的基础上创建一个新的特性分支</li><li id="9e5a" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><code class="eh ls lt lu lv b">git sync</code>保持所有功能分支与世界其他地方同步——一天做几次</li><li id="8510" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><code class="eh ls lt lu lv b">git ship</code>舰船一个特色分支</li></ul><h1 id="b196" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">优势</h1><p id="c059" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这种工作方式有许多重要的优势:</p><ul class=""><li id="fc5d" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">专注的改变更容易、更快地产生:如果你只改变一件事，你可以很快地完成它，确保它有意义，然后转移到另一个分支的下一个问题。不要再陷入不确定在过去10分钟内你做的许多改变中的哪一个破坏了构建，也不需要启动调试器来解决这个混乱。</li><li id="d125" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">它们更容易和更快地被审查:拉请求可以有一个简单的描述来总结它。审阅者可以很容易地理解他们正在查看的更改，并确保它们是正确和完整的。如果只是自己写代码也是如此。</li><li id="a3c5" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">与包含许多变更的分支相比，包含焦点变更的分支导致的合并冲突较少。这让Git有更多的机会自动解决合并问题。</li><li id="0e47" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">如果您不得不手动解决合并冲突，那么解决它们也更加容易和安全，因为每个分支中的变化更加明显。</li><li id="b1ef" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">其他人可以更快地开始审查您的部分变更，因为您更早地开始提交拉取请求。</li></ul><p id="f735" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最终，使用这种技术，你会更快地完成更多的工作。你会有更多的乐趣，因为很少会陷入困境、原地打转和重新开始。以这种方式工作需要运行更多的Git命令，但是对于Git Town来说，这完全不是问题，因为它可以为您自动完成这种重复。</p><h1 id="2c8f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">最佳实践</h1><p id="dbd8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了充分利用这一技术，您所要做的就是遵循一些简单的规则:</p><p id="8137" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">推迟想法:当你正在做某件事，突然想到另一个改变的想法时，抑制住立即去做的冲动。相反，写下你想做的改变(在一张纸上或一个简单的文本文件上)，完成你现在正在做的改变，然后几分钟后在一个新的分支执行新的改变。如果你不能等待，将你打开的变更提交到当前分支，创建下一个分支，在那里执行新的变更，然后返回到前一个分支，在那里完成工作。</p><p id="b22e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">使用一个分支链:</strong>当不确定变更是否依赖于先前的变更，并且以后是否会导致合并冲突时，就在子分支中工作。它几乎没有副作用，除了你必须先运送祖先分支。如果你的分支是专注的，你会得到非常快的评论，能够快速出货，而且不会积累。</p><p id="e02a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">首先进行大的重构:</strong>在我们的例子中，我们在链中相对较晚的时候进行重构，因为它不是那么重要。但是，涉及大量文件的大型重构最有可能与来自其他人的变更产生合并冲突。你不想让它们停留太长时间，但是尽快把它们运出去。您可以使用<a class="ae ka" href="https://github.com/Originate/git-town/blob/master/documentation/commands/prepend.md" rel="noopener ugc nofollow" target="_blank"> git prepend </a>在当前检出的特征分支之前插入特征分支<em class="mj">。如果您已经有一长串未审查的特性分支，那么尝试将大的重构插入到您的链的开始，以便它可以被尽快审查和发布:</em></p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="8058" class="me kc hu lv b fv mf mg l mh mi">git checkout 2-rename-foo<br/>git prepend 1-other-large-refactor</span></pre><p id="3023" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这导致了以下分支层次结构:</p><pre class="lw lx ly lz fq ma lv mb mc aw md dt"><span id="b337" class="me kc hu lv b fv mf mg l mh mi">master<br/>  \<br/>   1-other-large-refactor<br/>     \<br/>      2-rename-foo<br/>        \<br/>         3-rename-bar<br/>           \<br/>            4-generalize-infrastructure</span></pre><p id="f242" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">新的大型refactor在生产线的最前面，可以在审查时立即发布，我们的其他更改现在都建立在它的基础上。</p><p id="baa5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">黑客快乐！</p></div></div>    
</body>
</html>