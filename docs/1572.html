<html>
<head>
<title>Julia: a Language for the Future of Cybersecurity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅:未来网络安全的语言</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/julia-a-language-for-the-future-of-cybersecurity-76f13b869924#2019-03-06">https://medium.com/hackernoon/julia-a-language-for-the-future-of-cybersecurity-76f13b869924#2019-03-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="8a4f" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">2018 年发布了 Julia 1.0。这是一种既有 python 的高级简单性，又有 c 的低级性能的语言。</h2></div><p id="1295" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Julia 是一种相对较新的语言，旨在拥有 C 的性能和 Python 的简单性。Julia 能够毫无困难地执行数据分析，同时以具有竞争力的性能发布代码，有望成为金融科技行业的强大工具。但是我认为就目前 T2 网络安全的趋势来看，它也有很大的潜力。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="ab fr cl kk"><img src="../Images/ea65d41fb42b50d1e439fac9e2cd25ee.png" data-original-src="https://miro.medium.com/v2/format:webp/1*k2Sb9WHmDqRHsatTILOl6A.png"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Julia, Image from <a class="ae kr" rel="noopener" href="/syncedreview/julia-1-0-released-b13916e61b7">Medium</a></figcaption></figure><p id="353a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我将解释为什么 Julia 也可以成为<strong class="jl hv">网络安全</strong>未来的一个伟大工具。同时，我会分享我是如何在我的<strong class="jl hv"> Mac </strong>电脑上写了一个 Julia 脚本来破解一个用<strong class="jl hv">凯撒码移位</strong>和<strong class="jl hv">列换位</strong>加密的密文。最后，我将在附录中分享一些性能比较和该项目的代码。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><h1 id="2347" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated"><strong class="ak">密码学，从凯撒密码转移到生物认证</strong></h1><p id="5a44" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">首先让我们回顾一下网络安全的一些基础知识。我们如何加密信息和认证用户。我们将回顾一下代码示例中涉及到的老式的凯撒码移位和列换位。然后，我们将讨论生物认证，以及为什么 Julia 可以成为未来网络安全的重要工具。</p><h2 id="a04b" class="lw la hu bd lb lx ly lz lf ma mb mc lj js md me ll jw mf mg ln ka mh mi lp mj dt translated">凯撒码移位和列换位</h2><p id="837d" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">作为人类，我们彼此交流，但有时我们不希望每个人都知道我们在交流什么。自古罗马以来，朱利叶斯·凯撒就一直通过在信息中转换密码字母来发送秘密军事信息。例如,“A”将被转换为“B”,“Z”将被转换为“A”。“HAL”一词将被转换为“IBM”。这项技术后来以他的名字命名，被称为凯撒密码。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/6a2f1314a669de91a2df7048919db4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*yb1EEDVrFtvEsvNgKiJ8fQ.png"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">A Caesar cipher disk, image from <a class="ae kr" href="https://en.wikipedia.org/wiki/Caesar_cipher" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="a688" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种基于代码转换的加密存在巨大的漏洞。在第二次世界大战早期，数学家们分析了每个字母在德国出现的频率。通过比较频率条形图，他们能够计算出这种变化。这个故事延伸到德国人如何发明了“谜”,以及艾伦·图灵(T21)如何设法用他的巨型计算机破解了它。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ml"><img src="../Images/54c895deadf15bb258043a72dedbb557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*IBBUaC9GM8BfjPSj"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Enigma, image from <a class="ae kr" href="http://home.bt.com/tech-gadgets/enigma-machine-cracking-artificial-intelligence-11364235568160" rel="noopener ugc nofollow" target="_blank">BT.com</a></figcaption></figure><p id="76f2" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还使用了许多其他技术来加密信息。还有一个是<a class="ae kr" href="http://practicalcryptography.com/ciphers/columnar-transposition-cipher/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">柱状换位</strong> </a>。其中包括将文本放入表格，然后重新排列各列并读回文本。</p><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="mm mn l"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">A video demo of columnar transposition</figcaption></figure><p id="ac50" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">其他加密方法如<strong class="jl hv"> RSA </strong>、<strong class="jl hv"> ECC </strong>和<strong class="jl hv"> MD5 </strong>被广泛用于在互联网上安全地发送信息。例如，RSA 是一种<strong class="jl hv">非对称加密</strong>，它利用了<strong class="jl hv">素数</strong>的特性。</p><h2 id="db79" class="lw la hu bd lb lx ly lz lf ma mb mc lj js md me ll jw mf mg ln ka mh mi lp mj dt translated">生物识别认证和人工智能</h2><p id="56d7" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">我们的祖先第一次利用<strong class="jl hv">生物识别认证</strong>可能比他们开始玩代码转换要早得多。人们通过看不同的脸来区分彼此。再比如，指纹被广泛用作一个人的身份证明。后来，技术公司使用它来提供简单快速的设备认证用户体验。例如，iPhone 上的<strong class="jl hv">触控 ID </strong>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/58132fb7f6e64aadd0b773a18c4eb064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*7LgCgXve_wjS7OjBviKizQ.png"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Touch ID illustrated, image from <a class="ae kr" href="https://www.cultofmac.com/498052/ios-11-lets-quickly-disable-touch-id-prevent-forced-unlocks/" rel="noopener ugc nofollow" target="_blank">Cult of Mac</a></figcaption></figure><p id="6de3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv">生物特征分析</strong>作为<strong class="jl hv">人机交互</strong>的一个子分支，广泛应用于各种应用中。众所周知<a class="ae kr" href="https://thenextweb.com/artificial-intelligence/2017/05/10/artificial-intelligence-revolutionizing-human-computer-interaction/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">趋势</strong> </a>将会有更多的人工智能应用于人机交互领域，这在相关<a class="ae kr" href="https://iui.acm.org/2019/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">会议</strong> </a>中被广泛鼓励。根据我对数百份出版物的调查，机器学习、计算机视觉和数据分析已被证明对生物识别认证领域有很大影响。数据科学和人工智能将成为<strong class="jl hv">网络安全</strong>中<a class="ae kr" href="https://www.cnbc.com/2016/04/05/biometrics-future-of-digital-cyber-security.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">防御者</strong> </a>和<a class="ae kr" href="https://gizmodo.com/ai-can-now-fake-fingerprints-that-fool-biometric-id-sca-1830464777" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">攻击者</strong> </a>双方的有用工具。</p><h2 id="3ca9" class="lw la hu bd lb lx ly lz lf ma mb mc lj js md me ll jw mf mg ln ka mh mi lp mj dt translated">为什么朱莉娅很重要？</h2><p id="d1e6" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">作为一门为<strong class="jl hv">数据科学</strong>、<strong class="jl hv">机器学习</strong>和其他流行技术设计的语言，Julia 让研究变得更容易，同时又不会牺牲太多性能。这是一种专为我们设计的语言，可以让我们不用用另一种语言重写就能发布我们的数据科学算法。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff mp"><img src="../Images/8f0566d4b59a9bb31cbb7090c7bea831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eAE_IfK5z2HvSoAT8nRtEg.gif"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Julia is a powerful tool for Data Science and Machine Learning</figcaption></figure><p id="3021" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">随着数据科学和人工智能越来越多地涉及网络安全，这也需要在其相关应用程序中有良好的表现，Julia 肯定会成为一个得心应手的人选。想了解它是如何工作的吗？让我们马上看一个例子！</p><h1 id="ac67" class="kz la hu bd lb lc mu le lf lg mv li lj ja mw jb ll jd mx je ln jg my jh lp lq dt translated">用朱莉娅破解凯撒码移位和列换位</h1><blockquote class="mz na nb"><p id="4886" class="jj jk nc jl b jm jn iv jo jp jq iy jr nd jt ju jv ne jx jy jz nf kb kc kd ke hn dt translated">kuhpvibqkvoswhxbpofuxhrpvlddwvoskpredvvidwqrbbgllbbpkqunrvohqeirlwokkrdd</p></blockquote><p id="4684" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我被要求破译上述密文。暗示是它是用<strong class="jl hv">凯撒码移位</strong>和<strong class="jl hv">柱状换位</strong>加密的，密钥长度小于 10。解密这些秘密消息通常涉及某种暴力方法，这在计算上可能是昂贵的。为了降低它的一些复杂性，与字典的碰撞也是必要的。</p><p id="d5cc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了让它更快，我首先想到的是<strong class="jl hv"> C </strong>。但是这些头文件和内存管理可能会很难处理。另一方面，Python 有强大的库和极简语法支持，但是牺牲了很多速度。经过一番考虑后，我最终和茱莉亚做了这件事。</p><h2 id="e86e" class="lw la hu bd lb lx ly lz lf ma mb mc lj js md me ll jw mf mg ln ka mh mi lp mj dt translated">1.入门指南</h2><p id="fb4b" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">现在让我们开始吧！</p><p id="bc51" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先，我们将不得不下载 Julia 的一个<strong class="jl hv"> Mac 版本</strong>的下载可以在<a class="ae kr" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">这里</strong> </a>找到。其他版本和信息也可以访问官方<a class="ae kr" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">下载页面</strong> </a>。</p><p id="6c7c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下载完成后，我们可以通过双击应用图标打开<strong class="jl hv">命令行控制台</strong>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff ng"><img src="../Images/55e98f4ab1b6c5a656dad0b2673e1090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/1*mSTxdBfFzpxAcFNZBfO8vg.gif"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Opening Julia’s Command Line Console</figcaption></figure><p id="7390" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">要运行任何保存为本地文件的脚本，我们可以使用<strong class="jl hv">命令行控制台</strong>中的<strong class="jl hv"> <em class="nc"> include() </em> </strong>命令:</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="26ed" class="lw la hu ni b fv nm nn l no np">include("&lt;PATH_TO_YOUR_JULIA_SCRIPT&gt;/hello_world.jl")</span></pre><p id="ea2c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">文件名的扩展名为<strong class="jl hv"> <em class="nc">。jl </em> </strong>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/12045da48fa55b9aec5937b8e6adb458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/1*v1Ly_n_XFXXF387Zn8mMCw.gif"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Running Local Script in Julia</figcaption></figure><p id="0b70" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在为了完成这个项目，我们还需要<strong class="jl hv">导入</strong>两个包:</p><ul class=""><li id="3b2b" class="nr ns hu jl b jm jn jp jq js nt jw nu ka nv ke nw nx ny nz dt translated">我们将需要使用<strong class="jl hv">组合学</strong>来为列转置生成置换</li><li id="e0db" class="nr ns hu jl b jm oa jp ob js oc jw od ka oe ke nw nx ny nz dt translated">我们需要显示解密进度的<strong class="jl hv">进度条</strong>。</li></ul><p id="fdff" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以用下面的命令做到这一点。</p><p id="8593" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">安装<strong class="jl hv">组合学</strong>:</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="1d14" class="lw la hu ni b fv nm nn l no np">#import Pkg; Pkg.add("Combinatorics")</span></pre><p id="c0e8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">安装<strong class="jl hv">进程表</strong>:</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="7430" class="lw la hu ni b fv nm nn l no np">import Pkg; Pkg.add("ProgressMeter")</span></pre><p id="01cb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还需要一个字典文件，可以从<a class="ae kr" href="https://github.com/first20hours/google-10000-english/blob/master/google-10000-english.txt" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">这里</strong> </a>下载。字典中包含了常用的英语单词，我们可以在未来使用这些单词来与我们的密文进行冲突。</p><h2 id="4eed" class="lw la hu bd lb lx ly lz lf ma mb mc lj js md me ll jw mf mg ln ka mh mi lp mj dt translated">2.导入密文和英文词频</h2><p id="7b9f" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">我们可以像在任何其他语言中一样在 Julia 中定义一个字符串，并且我们不需要指定类型。<strong class="jl hv"> <em class="nc"> println() </em> </strong>函数像 Java 等其他语言一样将字符串打印到新的一行。字符串用逗号<strong class="jl hv">而不是加号</strong>连接<strong class="jl hv">。</strong></p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="4518" class="lw la hu ni b fv nm nn l no np">cipherText = "KUHPVIBQKVOSHWHXBPOFUXHRPVLLDDWVOSKWPREDDVVIDWQRBHBGLLBBPKQUNRVOHQEIRLWOKKRDD"<br/>println("Begin to decrypt cipher text: ", cipherText)</span></pre><p id="a92a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">每个字母在英语中出现的频率不同，在这里可以找到一个列表<a class="ae kr" href="https://code.activestate.com/recipes/142813-deciphering-caesar-code/" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">这里</strong> </a>。不同来源的统计数据可能略有不同。我们可以用下面的命令在 Julia 中定义一个浮点列表。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="d7f8" class="lw la hu ni b fv nm nn l no np">println("Initializing frequency array for ENGLISH...")<br/>ENGLISH = [0.0749, 0.0129, 0.0354, 0.0362, 0.1400, 0.0218, 0.0174, 0.0422, 0.0665, 0.0027, 0.0047, 0.0357, <br/>           0.0339, 0.0674, 0.0737, 0.0243, 0.0026, 0.0614, 0.0695, 0.0985, 0.0300, 0.0116, 0.0169, 0.0028, <br/>           0.0164, 0.0004]</span></pre><p id="e0ea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们要对每个字母进行计数，所以我们必须创建一个 0 的列表，其大小与英语中的字母表相同。我们可以用下面的命令做到这一点。列表的长度可以用<strong class="jl hv"><em class="nc">【length()</em></strong>来检索。我们可以用<strong class="jl hv"> <em class="nc"> Int() </em> </strong>将一个字符强制转换为整数。可以使用<strong class="jl hv"> <em class="nc"> "+=" </em> </strong>运算符增加数值。Julia 中的 for 循环如下所示:</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="6afb" class="lw la hu ni b fv nm nn l no np">counts = zeros(length(ENGLISH))<br/>for letter in cipherText<br/> code = Int(letter) - Int('A')<br/> if code &lt; 1<br/>  code += 26<br/> end<br/> counts[code] += 1<br/>end</span></pre><p id="660f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">英语中的字母表有多少种，我们就做多少种转换，总共 26 种转换，包括无转换。我们可以用<strong class="jl hv"> <em class="nc"> circshift() </em> </strong>函数来实现。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="71a8" class="lw la hu ni b fv nm nn l no np">variances = zeros(length(ENGLISH))<br/>for shift in 0:length(ENGLISH) - 1<br/> println("Applying inverse caesar shift: ", shift)<br/> shiftedCounts = circshift(counts, -1 * shift)<br/> variance = sum(broadcast(abs, ((shiftedCounts / length(cipherText) - ENGLISH) / ENGLISH)))<br/> variances[shift + 1] = variance;<br/>end<br/>println("The variance for each shift is calculated to be: \n", variances)<br/>minshift = argmin(variances)</span></pre><p id="a962" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在 for 循环中，我们计算每个字母表的计数频率和它们在英语单词中的频率之差。减法和除法可以直接在列表级完成。函数<strong class="jl hv"> <em class="nc"> boardcast() </em> </strong>将<strong class="jl hv"> <em class="nc"> abs() </em> </strong>函数映射到类似于<strong class="jl hv"> Scheme </strong>或<strong class="jl hv"> Java Script </strong>的列表内的每个元素。<strong class="jl hv"> <em class="nc"> sum() </em> </strong>函数求出列表的总和。每个字母的方差除以它们在英语中的频率，因此方差不受字母出现频率的影响。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="5412" class="lw la hu ni b fv nm nn l no np">variance = sum(broadcast(abs, ((counts / length(cipherText) - ENGLISH) / ENGLISH)))</span></pre><p id="a005" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">列表操作工作类似于<strong class="jl hv"> <em class="nc"> Python </em> </strong>，而<strong class="jl hv"> <em class="nc">。*</em></strong>用于乘法运算。还不支持从数组中减去整数这样的功能。更多信息可以在<a class="ae kr" href="https://docs.julialang.org/en/v1/base/arrays/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">官方文档</strong> </a>中找到。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff of"><img src="../Images/486226964b775794d6f1b601f34878b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioY6mIrxKx2Hf8WzBRdg2Q.png"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Array Operations in Julia</figcaption></figure><p id="6e1f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果我们运行代码，我们应该得到以下结果，程序计算出<strong class="jl hv">最合理的移动是 3 </strong>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/68c113fd1cad2d774b8f2628effc9001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/1*yWugedlkmaKsoWIcEo_-aA.gif"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Finding the Best Shift</figcaption></figure><p id="2ea6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们可以用下面的脚本打印移位后的字符串。<strong class="jl hv"> Char() </strong>函数将整数代码转换回字符，<strong class="jl hv"> append！()</strong>函数将字符追加到列表中，<strong class="jl hv"> join() </strong>函数将<strong class="jl hv">字符列表</strong>连接成一个<strong class="jl hv">字符串</strong>。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="d774" class="lw la hu ni b fv nm nn l no np">shiftedTextList = []<br/>for letter in cipherText<br/> code = Int(letter) - minshift<br/> if code &lt; Int('A')<br/>  code += 26<br/> end<br/> append!(shiftedTextList, Char(code))<br/>end<br/>shiftedText = join(shiftedTextList)<br/>println("Deciphering minimal variance shifted text: ", shiftedText, " with columnar transposition...")</span></pre><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/a984c065a4c41d47d96c5eeea838837e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/1*VJNQAzN83NREifL5lFxE3g.gif"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Most Plausible Shift String Printed</figcaption></figure><h2 id="3bc3" class="lw la hu bd lb lx ly lz lf ma mb mc lj js md me ll jw mf mg ln ka mh mi lp mj dt translated">3.应用列转置&amp;利用字典冲突</h2><p id="7c5c" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">首先，我们必须引用我们在前面几节中安装的必要的包，我们可以用下面的代码这样做。这些声明可以在使用之前放在任何地方，而不是必须放在代码的顶部。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="1016" class="lw la hu ni b fv nm nn l no np">using Combinatorics<br/>using ProgressMeter</span></pre><p id="f746" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我们可以用下面的代码导入我们的字典。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="1417" class="lw la hu ni b fv nm nn l no np">filename = "&lt;PATH_TO_YOUR_DICTIONARY_FILE&gt;/google-10000-english.txt"<br/>println("Loading common words DICTIONARY from: ", filename)<br/>DICTIONARY = readlines(filename)</span></pre><p id="fc44" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们保存并运行代码之后，这应该会打印出字典的一个片段。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff nq"><img src="../Images/960fc3a1950d86dbed663313f169ac75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/1*ndp3lZG5-iBev_zPUZSbUQ.gif"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Loading Dictionary File In Julia</figcaption></figure><p id="7a17" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们要<strong class="jl hv">构造列矩阵</strong>和<strong class="jl hv">遍历每个排列</strong>。下面的代码将完成这项工作。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="3f30" class="lw la hu ni b fv nm nn l no np">for width in 2:3<br/> println("Applying columnar transposition with width: ", width)<br/> matrix = []<br/> height = Int(ceil(length(shiftedText) / width))<br/> total = width * height<br/> for index in 1:total<br/>  if index &lt;= length(shiftedText)<br/>   append!(matrix, shiftedText[index])<br/>  else<br/>   append!(matrix, "?")<br/>  end<br/> end<br/> matrix = reshape(matrix, (height, width))<br/> orders = collect(permutations(collect(1:width)))<br/> println(matrix)<br/> println(orders)<br/>end</span></pre><p id="af85" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jl hv"> <em class="nc"> ceil() </em> </strong>函数<strong class="jl hv">将数字向上舍入到最接近的整数。我们用<strong class="jl hv"> <em class="nc">“填补空白？”</em> </strong>。<strong class="jl hv"> <em class="nc"> reshape() </em> </strong>函数<strong class="jl hv">将矩阵</strong>整形到<strong class="jl hv">指定的尺寸</strong>。我们用<strong class="jl hv"><em class="nc">permutations()</em></strong>生成订单，它将一个元素列表作为输入，并返回所有可能的排列。输入是用<strong class="jl hv"><em class="nc">collect(1:width)</em></strong>生成的，其中 collect 将<strong class="jl hv"><em class="nc">【1:width】</em></strong>范围转换成一个集合，换句话说就是一个列表。</strong></p><p id="8b6b" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，在<strong class="jl hv">保存并重新加载</strong>之后，我们应该会看到重新构建的列表打印出排列。<strong class="jl hv">分号</strong>表示一个<strong class="jl hv">新行</strong>。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff og"><img src="../Images/29e2508a1168414ace6ceac40a155b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvmHcDwawvEso5ULy8vcRQ.png"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Columnar Tables and Permutations printed in Julia</figcaption></figure><p id="4377" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们进行排列之前，我们应该显示一个<strong class="jl hv">进度条</strong>，因为这个任务需要一些时间。我们不想坐在那里怀疑这个项目是否还在运行。对于我们已经导入的包，循环之前的代码<strong class="jl hv">将初始化进度条。</strong></p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="76b0" class="lw la hu ni b fv nm nn l no np">n = length(orders)<br/>p = Progress(n, 1, "Computing all permutations:", 50, :black)</span></pre><p id="53db" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们把这个放在循环的最后，让<strong class="jl hv">更新</strong>进度条。关于如何使用<strong class="jl hv"> ProgressMeter </strong>的更多信息，请看这里<a class="ae kr" href="https://github.com/timholy/ProgressMeter.jl" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv"/></a>。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="c2e4" class="lw la hu ni b fv nm nn l no np">next!(p)</span></pre><p id="ef1a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">字典冲突的完整代码可以在下面找到。其中它使用<strong class="jl hv"> <em class="nc">大写()</em> </strong>将字典中的单词大写，<strong class="jl hv"> <em class="nc"> occursin() </em> </strong>查看它是否出现在重新排列的文本中。一旦常用词在重新排列的文本中占了很大一部分，它就会将它们打印出来，并跟踪常用词比例最高的排列。</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="c843" class="lw la hu ni b fv nm nn l no np">completed = 0<br/>n = length(orders)<br/>p = Progress(n, 1, "Computing all permutations:", 50, :black)<br/>bestPlainText = "?"<br/>bestPlainTextCommonPercentage = 0<br/>for permutation in orders<br/> plainTextMatrix = []<br/> for row in 1:height<br/>  for columnIndex in 1:width<br/>   char = matrix[row, permutation[columnIndex]]<br/>   if char != '?'<br/>    append!(plainTextMatrix, char)<br/>   end<br/>  end<br/> end<br/> plainText = join(plainTextMatrix)<br/> wordCount = 0<br/> wordLengthSum = 0<br/> words = []<br/> for word in DICTIONARY<br/>  if length(uppercase(word)) &gt; 3 &amp;&amp; occursin(uppercase(word), plainText)<br/>   wordCount += 1;<br/>   wordLengthSum += length(word)<br/>   push!(words, uppercase(word))<br/>  end<br/> end<br/> percentageCommon = wordLengthSum / length(plainText) * 100<br/> if percentageCommon &gt; 50<br/>  println("\rColumnar transposition with the order of: ", permutation, " yielded a string containing ", wordCount, " common word(s) which makes it ", percentageCommon, "% common words, below is the string:\n", plainText, "\ncontaining the words:\n", words)<br/>  if percentageCommon &gt; bestPlainTextCommonPercentage<br/>   bestPlainText = plainText<br/>   bestPlainTextCommonPercentage = percentageCommon<br/>  end<br/>  println("Currently, the best plain text is:\n", bestPlainText, " which is ", bestPlainTextCommonPercentage, "% common words...")<br/> end<br/> next!(p)<br/>end</span></pre><p id="b5a9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个算法并不完美，如果有重叠的单词，这个百分比可能会超过 100%。让它变得完美需要做太多的工作，因为你必须考虑所有的单词排列，所以现在让我们坚持快速和肮脏的方法。这里的百分比也只是作为参考。</p><p id="9a2f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我们进行测试之前，我们还必须<strong class="jl hv">将表的最大宽度</strong>增加到 10，因为我们从提示中知道这是键的最大长度。</p><p id="bfca" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们改变:</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="9e56" class="lw la hu ni b fv nm nn l no np">for width in 2:3</span></pre><p id="e2bb" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">变成:</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="547e" class="lw la hu ni b fv nm nn l no np">for width in 2:10</span></pre><p id="7a52" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们应该<strong class="jl hv">删除</strong>之前的测试代码:</p><pre class="kf kg kh ki fq nh ni nj nk aw nl dt"><span id="0347" class="lw la hu ni b fv nm nn l no np">println(matrix)<br/>println(orders)</span></pre><p id="6135" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们应该能够保存并启动代码了。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff oh"><img src="../Images/6ef3f809e014c4c9cf000ec834b3211f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Q0jrEFYJOFDXp2Myq03j0Q.gif"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Deciphering with Julia Scripts</figcaption></figure><p id="1517" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一段时间后，我们应该会看到纯文本被打印出来，因为它包含了最高比例的常用词。该文本被破译为:</p><blockquote class="mz na nb"><p id="363a" class="jj jk nc jl b jm jn iv jo jp jq iy jr nd jt ju jv ne jx jy jz nf kb kc kd ke hn dt translated">behappyforemmentthismonentisyourlife by khayyamahandalsothisclassisreallyfun</p></blockquote><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff oh"><img src="../Images/e87bde190576a8b5ab2a64eec90e8541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wiZ5_DoDjK7Zj_t8t82jpQ.gif"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Julia Script Successfully Decrypted the Text</figcaption></figure><p id="c753" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">恭喜你！！！你刚刚学会了如何在 Julia 中编写一个密文破解程序！希望这是你探索这门语言的一个良好开端。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><h1 id="5944" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">最后…</h1><p id="d00b" class="pw-post-body-paragraph jj jk hu jl b jm lr iv jo jp ls iy jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">Julia 是一种简单而强大的数据分析语言。您可以通过下面的链接了解有关其性能的更多信息:</p><ul class=""><li id="5344" class="nr ns hu jl b jm jn jp jq js nt jw nu ka nv ke nw nx ny nz dt translated"><a class="ae kr" href="https://modelingguru.nasa.gov/docs/DOC-2676" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">Python、Julia、Matlab、IDL、Java 基础对比(2018 版)</strong> </a></li><li id="ec21" class="nr ns hu jl b jm oa jp ob js oc jw od ka oe ke nw nx ny nz dt translated"><a class="ae kr" href="https://modelingguru.nasa.gov/docs/DOC-2625" rel="noopener ugc nofollow" target="_blank"><strong class="jl hv">Python、Julia、R、Matlab 和 IDL 的基本比较</strong> </a></li><li id="4f29" class="nr ns hu jl b jm oa jp ob js oc jw od ka oe ke nw nx ny nz dt translated"><a class="ae kr" href="https://www.ibm.com/developerworks/community/blogs/jfp/entry/A_Comparison_Of_C_Julia_Python_Numba_Cython_Scipy_and_BLAS_on_LU_Factorization?lang=en" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hv">一个 C、Julia、Python、Numba、Cython 对 LU 因式分解的速度比较</strong> </a></li></ul><p id="45b3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你会看到<strong class="jl hv"> Julia </strong>的性能在更大的输入规模上远远领先于<strong class="jl hv"> Python </strong>，在矩阵计算上甚至超过了<strong class="jl hv"> C </strong>。矩阵计算广泛应用于机器学习和数据科学，输入大小一般会变得非常大。</p><p id="bd6c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我是一个充满激情的程序员，喜欢学习新的东西并与社区分享。如果你有什么特别想看的，请告诉我。我现在主要关注<strong class="jl hv">人工智能</strong>、<strong class="jl hv">人机交互</strong>和<strong class="jl hv">机器人</strong>，但是我可以写很多东西。</p><p id="7b3d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我可以继续写关于 Julia 的文章，可能还会写一点关于数据科学的文章。我的许多研究工作是保密的，但一旦它们被公开，我将有很多东西可以分享。我还可以在<strong class="jl hv"> Julia </strong>中重新创建<strong class="jl hv">数据科学模型</strong>，就像我在<strong class="jl hv"> Unity C# </strong>中如何在他们的机器学习模块构建好之前编写一个<strong class="jl hv">人工神经网络</strong>。希望你和我一样喜欢学习这些很酷的新东西！</p><p id="a7bc" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我已将该项目的完整代码附在附录中。</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><h1 id="14c7" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">附录(该项目的完整代码):</h1><figure class="kf kg kh ki fq kj"><div class="bz el l di"><div class="oi mn l"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Complete Julia Code for decrypt.jl</figcaption></figure><p id="f7f9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我的代码在总共 16 个小时后完成了所有的排列:</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="fe ff oj"><img src="../Images/927fcbdec1f3f6a6310d0361c1c3170a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpWBo1M_i6WXTJTJVVmQyA.png"/></div></div></figure></div></div>    
</body>
</html>