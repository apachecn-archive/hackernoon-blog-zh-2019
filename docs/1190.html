<html>
<head>
<title>React Hooks are live. Here is your introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩是活的。这是你的简介</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-hooks-are-live-here-is-your-introduction-cd971a576561#2019-02-19">https://medium.com/hackernoon/react-hooks-are-live-here-is-your-introduction-cd971a576561#2019-02-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/790cccbbc0c7cf398851449f895bd87d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IGtx2-HWINkyQnhA160Vw.png"/></div></div></figure><p id="606f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">React 团队的<a class="ae ka" href="https://reactjs.org/docs/hooks-intro.html#classes-confuse-both-people-and-machines" rel="noopener ugc nofollow" target="_blank">表示，班级可能是学习 React 的一大障碍。它们不能很好地缩小，并且使热重装变得不可靠。有了 React 钩子，你不需要把一个函数组件转换成类组件。您可以在功能组件中使用状态和生命周期方法<em class="kb">。</em></a></p><p id="6776" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好吧，但是钩子到底是什么？</p><p id="4781" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它们是让您从功能组件中<a class="ae ka" href="https://reactjs.org/docs/hooks-overview.html#but-what-is-a-hook" rel="noopener ugc nofollow" target="_blank">“挂钩”到</a>反应内部状态和生命周期特性<em class="kb">的功能</em></p><p id="72bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">太好了！我该怎么做？</strong></p><p id="0327" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，更新项目中的 React 和 React DOM 依赖项。钩子今天在 React 16.8.0 新鲜出炉！</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="47c5" class="kl km hu kh b fv kn ko l kp kq">npm install --save react@^16.8.0 react-dom@^16.8.0</span></pre><p id="d45e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们来看看<code class="eh kr ks kt kh b">useState</code>挂钩。这是演示:</p><figure class="kc kd ke kf fq iv"><div class="bz el l di"><div class="ku kv l"/></div></figure><h1 id="bae0" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated"><code class="eh kr ks kt kh b">useState</code>挂钩</h1><p id="6a71" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">我们需要一个带有状态的简单类组件来进行比较。我能想到的最简单的例子是输入表单:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="5b54" class="kl km hu kh b fv kn ko l kp kq">class NameForm extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { value: '' };<br/>  }</span><span id="bf81" class="kl km hu kh b fv ly ko l kp kq">handleChange = event =&gt; {<br/>    this.setState({ value: event.target.value });<br/>  }</span><span id="7c28" class="kl km hu kh b fv ly ko l kp kq">render() {<br/>    return (<br/>      &lt;form&gt;<br/>        &lt;label&gt;<br/>          Name:<br/>          &lt;input type="text" <br/>            value={this.state.value} <br/>            onChange={this.handleChange} /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="5157" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们用<code class="eh kr ks kt kh b">useState</code>钩子重写它。我们将从<code class="eh kr ks kt kh b">react</code>包中导入它，这样我们就不用一直写<code class="eh kr ks kt kh b">React.useState</code>。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="4330" class="kl km hu kh b fv kn ko l kp kq">import React, <strong class="kh hv">{ useState }</strong> from 'react';</span></pre><p id="d73d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在把我们的<code class="eh kr ks kt kh b">NameForm</code>改成一个函数组件</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="14d3" class="kl km hu kh b fv kn ko l kp kq">function NameForm(props) { </span><span id="4520" class="kl km hu kh b fv ly ko l kp kq">}</span></pre><p id="4943" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kr ks kt kh b">useState</code> hook 带一个参数，就是初始状态，它返回两个值:当前状态和一个可以用来更新状态的函数。您可以在构造函数中替换状态初始化:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="de1c" class="kl km hu kh b fv kn ko l kp kq">this.state = { value: '' };</span></pre><p id="317b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">变成这样:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="a888" class="kl km hu kh b fv kn ko l kp kq">function NameForm(props) {<br/>  const [value, setValue] = useState(''); <br/>}</span></pre><p id="032d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意声明状态变量时方括号<code class="eh kr ks kt kh b">[]</code>的使用。这是 ES6 "<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring" rel="noopener ugc nofollow" target="_blank">array destructing</a>"语法，它意味着我们把由<code class="eh kr ks kt kh b">useState</code>返回的第一个值赋给<code class="eh kr ks kt kh b">value</code>，把第二个值赋给<code class="eh kr ks kt kh b">setValue</code>。</p><p id="b621" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着我们有一个名为<code class="eh kr ks kt kh b">value</code>的状态，我们可以通过调用<code class="eh kr ks kt kh b">setValue</code>函数来更新它。让我们在渲染方法中使用它:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="6f37" class="kl km hu kh b fv kn ko l kp kq">function NameForm(props) {<br/>  <strong class="kh hv">const [value, setValue] = useState('');</strong></span><span id="3cd7" class="kl km hu kh b fv ly ko l kp kq">  return (<br/>    &lt;form&gt;<br/>        &lt;label&gt;<br/>          Name:<br/>          &lt;input type="text" <br/>            <strong class="kh hv">value={value} <br/>            onChange={event =&gt; (setValue(event.target.value))}</strong> /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>  )<br/>}</span></pre><p id="c98b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">道具不再调用一个<code class="eh kr ks kt kh b">handleChange</code>方法，取而代之的是我们有一个箭头函数，它将调用<code class="eh kr ks kt kh b">setValue</code>函数，更新我们的<code class="eh kr ks kt kh b">state</code>。哦，不像类组件中的<code class="eh kr ks kt kh b">this.setState</code>，使用钩子<em class="kb">更新状态变量总是替换它而不是合并它。</em></p><h1 id="9532" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">有多种状态？</h1><p id="bf53" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">然后根据需要多次呼叫<code class="eh kr ks kt kh b">useState</code>。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="8709" class="kl km hu kh b fv kn ko l kp kq">function SimpleForm(props) {<br/>  <strong class="kh hv">const [firstName, setFirstName] = useState('');<br/>  const [lastName, setLastName] = useState('');<br/>  const [age, setAge] = useState('');</strong></span><span id="50ed" class="kl km hu kh b fv ly ko l kp kq">return (<br/>    &lt;form&gt;<br/>        &lt;label&gt;<br/>          First Name:<br/>          &lt;input type="text" <br/>            <strong class="kh hv">value={firstName} <br/>            onChange={event =&gt; (setFirstName(event.target.value))}</strong>/&gt;<br/>        &lt;/label&gt;<br/>        &lt;label&gt;<br/>          Last Name:<br/>          &lt;input type="text" <br/>            <strong class="kh hv">value={lastName} <br/>            onChange={event =&gt; (setLastName(event.target.value))}</strong> /&gt;<br/>        &lt;/label&gt;<br/>        &lt;label&gt;<br/>          Age:<br/>          &lt;input type="number" <br/>            <strong class="kh hv">value={age} <br/>            onChange={event =&gt; (setAge(event.target.value))}</strong> /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>  )<br/>}</span></pre><p id="844f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有就是用<code class="eh kr ks kt kh b">useState</code>勾，真的！</p><h1 id="144c" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">从道具设置初始状态</h1><p id="6a18" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">哦，这很简单！</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="f04a" class="kl km hu kh b fv kn ko l kp kq">function SimpleForm(<strong class="kh hv">props</strong>) {<br/>  const [firstName, setFirstName] = useState(<strong class="kh hv">props.firstName</strong>);<br/>  const [lastName, setLastName] = useState(<strong class="kh hv">props.lastName</strong>);<br/>  const [age, setAge] = useState(<strong class="kh hv">props.age</strong>);</span><span id="6e4d" class="kl km hu kh b fv ly ko l kp kq">//...<br/>}</span><span id="e9aa" class="kl km hu kh b fv ly ko l kp kq">ReactDOM.render(<br/>  &lt;SimpleForm <strong class="kh hv">firstName="JOHN" lastName="Edward" age={30}</strong> /&gt;,<br/>  document.getElementById("root")<br/>);</span></pre><h1 id="18d0" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">我可以在状态中使用对象吗？</h1><p id="9082" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">当然可以！正如类<code class="eh kr ks kt kh b">state</code>可以接受对象或数组一样，<code class="eh kr ks kt kh b">useState</code>也可以拥有它们。但是为了让它工作，让我们给你的输入元素添加名称道具。我们还使用<a class="ae ka" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals" rel="noopener ugc nofollow" target="_blank">扩展属性</a>来更新我们的状态。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="030b" class="kl km hu kh b fv kn ko l kp kq">function SimpleForm(props) {<br/>  //create object state<br/>  <strong class="kh hv">const [form, setForm] = useState({<br/>    FirstName: '',<br/>    LastName:'', <br/>    age:''<br/>  });</strong></span><span id="d901" class="kl km hu kh b fv ly ko l kp kq">  <strong class="kh hv">const handleChange = event =&gt; {<br/>    // use spread operator<br/>    setForm({<br/>      ...form,<br/>      [event.target.name]: event.target.value<br/>    });<br/>  }</strong></span><span id="cf31" class="kl km hu kh b fv ly ko l kp kq">  return (<br/>    &lt;form&gt;<br/>        &lt;label&gt;<br/>          First Name:<br/>          &lt;input <br/>            type="text" <br/>            <strong class="kh hv">name="firstName"<br/>            value={form.firstName} <br/>            onChange={handleChange}</strong> /&gt;<br/>        &lt;/label&gt;<br/>        &lt;label&gt;<br/>          Last Name:<br/>          &lt;input <br/>            type="text" <br/>            <strong class="kh hv">name="lastName"<br/>            value={form.lastName} <br/>            onChange={handleChange}</strong> /&gt;<br/>        &lt;/label&gt;<br/>        &lt;label&gt;<br/>          Age:<br/>          &lt;input <br/>            type="number" <br/>            <strong class="kh hv">name="age"<br/>            value={form.age} <br/>            onChange={handleChange}</strong> /&gt;<br/>        &lt;/label&gt;<br/>        &lt;input type="submit" value="Submit" /&gt;<br/>      &lt;/form&gt;<br/>  )<br/>}</span></pre><h1 id="037d" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">数组呢？</h1><p id="f5b9" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">这一个有点不寻常，但是是的，就像在第九课一样。我们将在数组更新中使用<a class="ae ka" href="https://www.w3schools.com/jsref/jsref_concat_array.asp" rel="noopener ugc nofollow" target="_blank"> concat </a>。</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="1acd" class="kl km hu kh b fv kn ko l kp kq">function SampleArrayState(props) {<br/>  //create array state<br/>  <strong class="kh hv">const [nameArray, setNameArray] = useState(["Carl"]);</strong></span><span id="5f95" class="kl km hu kh b fv ly ko l kp kq">  <strong class="kh hv">const updateArray = () =&gt; {<br/>    setNameArray(nameArray.concat("John"));<br/>  };</strong></span><span id="2d6e" class="kl km hu kh b fv ly ko l kp kq">return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;button onClick={<strong class="kh hv">updateArray</strong>}&gt;Click me!&lt;/button&gt;<br/>      &lt;div&gt;<strong class="kh hv">{nameArray.toString()}</strong>&lt;/div&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>}</span></pre><h1 id="9267" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">和布尔？</h1><p id="835b" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">这里有你的掩护:</p><pre class="kc kd ke kf fq kg kh ki kj aw kk dt"><span id="bc54" class="kl km hu kh b fv kn ko l kp kq">function SampleBooleanState(props) {<br/>  <strong class="kh hv">const [show, setShow] = useState(true);<br/>  const visibility = show ? 'visible' : 'hidden';</strong></span><span id="1798" class="kl km hu kh b fv ly ko l kp kq">  return (<br/>    &lt;React.Fragment&gt;<br/>      <strong class="kh hv">&lt;h1 style={{ visibility }}&gt;useState Hook is awesome!&lt;/h1&gt;<br/>      &lt;button<br/>        onClick={() =&gt; { setShow(!show) }}<br/>      &gt;{`${show ? 'Hide' : 'Show'} the Header!`}&lt;/button&gt;</strong><br/>    &lt;/React.Fragment&gt;<br/>  );<br/>}</span></pre><h1 id="5de1" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">钩子的规则</h1><p id="595b" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">重要的是要记住钩子在类组件中不起作用。它们是为功能组件制造的。</p><ol class=""><li id="1f69" class="lz ma hu je b jf jg jj jk jn mb jr mc jv md jz me mf mg mh dt translated">不要从嵌套函数、循环或条件中调用钩子。</li><li id="6a4e" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated">不要从普通的 JavaScript 函数中调用钩子。</li><li id="aa15" class="lz ma hu je b jf mi jj mj jn mk jr ml jv mm jz me mf mg mh dt translated">这</li></ol><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/35d6e888a9d3a45aa278e25ce7831992.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*QSTMLetlklkSVKbq5TKYrQ.png"/></div><figcaption class="mo mp fg fe ff mq mr bd b be z ek"><a class="ae ka" href="https://news.ycombinator.com/item?id=19094170" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><h1 id="09e3" class="kw km hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">结论</h1><p id="27e2" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated"><code class="eh kr ks kt kh b">useState</code>钩子使得函数组件能够访问 React 的内部状态并更新它。状态可以是任意数据类型:<em class="kb">字符串</em>，<em class="kb">数字</em>，<em class="kb">布尔</em>，<em class="kb">数组</em>，或者<em class="kb">对象</em>。<code class="eh kr ks kt kh b">useState</code>接受一个参数:初始数据，它返回两个值的数组:当前状态值和可用于更新状态的函数/方法。</p><p id="5ea9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不仅仅只有<code class="eh kr ks kt kh b">useState</code>挂钩，但是让我们在它们自己的单个帖子中涵盖每个挂钩。</p><p id="7b12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里列出了所有<a class="ae ka" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">内置钩子</a>(是的，你可以写一个自定义钩子！)在撰写本文时可用。我将在接下来的文章中介绍它们。</p><p id="f758" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下次见！</p></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="dd34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另外，我正在写一本关于学习在没有压力的情况下做出适当反应的书。你可能想看看这里的<a class="ae ka" href="https://sebhastian.com/react-distilled/" rel="noopener ugc nofollow" target="_blank"><em class="kb"/></a><em class="kb">。</em></p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><a href="https://sebhastian.com/react-distilled"><div class="fe ff mz"><img src="../Images/3830c0419a4ece9b9c71fcd9fa6a7abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0aPcRwy_r7HH1Wxy8mJkng.jpeg"/></div></a></figure><p id="cda7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kb">最初发表于</em><a class="ae ka" href="https://sebhastian.com/react-hooks-introduction" rel="noopener ugc nofollow" target="_blank"><em class="kb">【sebhastian.com】</em></a><em class="kb">。</em></p></div></div>    
</body>
</html>