<html>
<head>
<title>Enterprise™ AF Solution for Text Classification (using BERT)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于文本分类的 enterprise AF 解决方案(使用 BERT)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/enterprise-af-solution-for-text-classification-using-bert-9fe2b7234c46#2019-02-16">https://medium.com/hackernoon/enterprise-af-solution-for-text-classification-using-bert-9fe2b7234c46#2019-02-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="89a4" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">伯特是什么？如何使用 BERT 解决问题？Google Cloud 上的 Google Colab、Tensorflow、Kubernetes</h2></div><h1 id="e124" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">概观</h1><p id="264d" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">这是为那些想要使用由 BERT 构建的模型来创建 REST 服务的人准备的，这是最好的 NLP 基础模型。我花了很多时间想出如何将一个解决方案放在一起，所以我想我应该写下如何部署一个解决方案并分享！</p><h1 id="ff67" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">你为什么要读这个？</h1><p id="6265" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">今天，我们有机器学习工程师、软件工程师和数据科学家。深度学习的趋势是，模型变得如此强大，以至于几乎不需要了解特定算法的细节，并且可以立即应用于定制用例。这种趋势将把机器学习工程师的工作变成软件工程师拥有的技能。仍然会有数据科学家，因为将需要应用传统的机器学习方法，并在“小”数据上整合领域知识，以解决问题并获得所需的性能。</p><h1 id="c410" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">什么是<a class="ae kx" href="https://github.com/google-research/bert" rel="noopener ugc nofollow" target="_blank">伯特</a>？</h1><blockquote class="ky kz la"><p id="74db" class="kb kc lb kd b ke lc iv kg kh ld iy kj le lf km kn lg lh kq kr li lj ku kv kw hn dt translated">BERT，即来自变压器的双向编码器表示，是一种预训练语言表示的新方法，它在各种自然语言处理(NLP)任务上获得了最先进的结果。— Github 项目页面</p></blockquote><h1 id="a6c2" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">为什么<a class="ae kx" href="https://github.com/google-research/bert" rel="noopener ugc nofollow" target="_blank">伯特</a>很重要？</h1><h2 id="eeb9" class="lk jk hu bd jl ll lm ln jp lo lp lq jt kk lr ls jv ko lt lu jx ks lv lw jz lx dt translated">当<a class="ae kx" href="https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html" rel="noopener ugc nofollow" target="_blank">发布时，第一名</a>在 11 个 NLP 任务中执行了最先进的技术。</h2><blockquote class="ky kz la"><p id="901f" class="kb kc lb kd b ke lc iv kg kh ld iy kj le lf km kn lg lh kq kr li lj ku kv kw hn dt translated">在<a class="ae kx" href="https://rajpurkar.github.io/SQuAD-explorer/" rel="noopener ugc nofollow" target="_blank"> SQuAD v1.1 </a>上，BERT 获得了 93.2%的 F1 分数(一种准确性衡量标准)，超过了之前 91.6%的最高水平分数和 91.2%的人类水平分数</p><p id="43bf" class="kb kc lb kd b ke lc iv kg kh ld iy kj le lf km kn lg lh kq kr li lj ku kv kw hn dt translated">BERT 还在极具挑战性的<a class="ae kx" href="https://gluebenchmark.com/" rel="noopener ugc nofollow" target="_blank"> GLUE benchmark </a>上提高了 7.6%的绝对值，这是一组 9 个不同的自然语言理解(NLU)任务。</p></blockquote><h2 id="9adc" class="lk jk hu bd jl ll lm ln jp lo lp lq jt kk lr ls jv ko lt lu jx ks lv lw jz lx dt translated"># 2<a class="ae kx" href="https://visualcommonsense.com/" rel="noopener ugc nofollow" target="_blank">视觉常识</a>性能的主要驱动因素</h2><blockquote class="ky kz la"><p id="ddbc" class="kb kc lb kd b ke lc iv kg kh ld iy kj le lf km kn lg lh kq kr li lj ku kv kw hn dt translated">深度纯文本模型的性能要好得多:最值得注意的是，BERT [17]获得了 35.0%的准确率。[……]我们的模型 R2C 比 BERT 的精度提高了 9%,最终性能提高了 44%。[……]当使用手套表示代替 BERT 时，模型损失最大:损失 24%。</p></blockquote><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff ly"><img src="../Images/b2c3cd78115a1dbbedd5c94c8514baa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cxn-wVSC6KWzyrFtaZCSLw.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Image Credit: <a class="ae kx" href="https://arxiv.org/abs/1811.10830" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1811.10830</a></figcaption></figure><p id="2bcd" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">在不同领域的不同任务中使用 BERT 的经验证据给出了尝试 BERT 的充分理由。让我们用 BERT 来解决一个分类问题！</p><h1 id="b70d" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">找到要解决的问题</h1><p id="916c" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><a class="ae kx" href="http://ruder.io/" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·鲁德</a>启动了<a class="ae kx" href="https://github.com/sebastianruder/NLP-progress" rel="noopener ugc nofollow" target="_blank">一个跟踪自然语言处理任务</a>进展的项目。</p><p id="9f21" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">本演练将解决文本分类问题。为简单起见，我们将选择<a class="ae kx" href="https://github.com/sebastianruder/NLP-progress/blob/master/english/text_classification.md#ag-news" rel="noopener ugc nofollow" target="_blank"> AG 新闻数据集</a>，因为该数据集大小合理，并且与传统的分类问题密切相关。</p><blockquote class="mo"><p id="ce28" class="mp mq hu bd mr ms mt mu mv mw mx kw ek translated"><em class="my">参考</em> <a class="ae kx" rel="noopener" href="/@lapolonio/parse-the-ags-corpus-of-news-articles-8c99a794310a"> <em class="my">本文</em> </a> <em class="my">获取 AG 新闻数据集准备训练。</em></p></blockquote><h1 id="d944" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja mz jb jv jd na je jx jg nb jh jz ka dt translated">第 1 部分:使用 AG 新闻数据集微调 BERT</h1><p id="8cd9" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">遵循这整个教程的结果就是<a class="ae kx" href="https://github.com/lapolonio/bert" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hv">这里</strong> </a>。Google Colab 笔记本处理数据集、训练和导出模型可以在<a class="ae kx" href="https://colab.research.google.com/gist/lapolonio/5ac6552fa4d58ea1419cc444d42ff5ff/bert-finetuning-with-cloud-tpu-sentence-and-sentence-pair-classification-tasks.ipynb#scrollTo=uu2dQ_TId-uH" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hv">这里找到</strong> </a>。下面将在较高的层次上回顾为 REST 服务重新创建所需的资源。</p><p id="9f09" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated"><strong class="kd hv">首先</strong>，克隆<a class="ae kx" href="https://github.com/google-research/bert" rel="noopener ugc nofollow" target="_blank"> BERT repo </a>以便我们扩展项目来满足我们的需求。</p><p id="826b" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated"><strong class="kd hv">第二个</strong>，<code class="eh nc nd ne nf b">run_classifier.py</code>是用于句子分类扩展的文件。要添加新的数据源，请添加一个扩展 DataProcessor 的类。DataProcessor 类指定了要实现的方法，您可以参考扩展 DataProcessor 的其他类来找出合理的实现。</p><pre class="lz ma mb mc fq ng nf nh ni aw nj dt"><span id="9b11" class="lk jk hu nf b fv nk nl l nm nn">class AgnewsProcessor(DataProcessor):<br/>  """Processor for the MultiNLI data set (GLUE version)."""</span><span id="da50" class="lk jk hu nf b fv no nl l nm nn">def get_train_examples(self, data_dir):<br/>    """See base class."""<br/>    return self._create_examples(<br/>      self._read_tsv(os.path.join(data_dir, "train.tsv")), "train")</span><span id="d833" class="lk jk hu nf b fv no nl l nm nn">def get_dev_examples(self, data_dir):<br/>    """See base class."""<br/>    return self._create_examples(<br/>      self._read_tsv(os.path.join(data_dir, "dev.tsv")),<br/>      "dev_matched")</span><span id="67f4" class="lk jk hu nf b fv no nl l nm nn">def get_test_examples(self, data_dir):<br/>    """See base class."""<br/>    return self._create_examples(<br/>      self._read_tsv(os.path.join(data_dir, "test.tsv")), "test")</span><span id="fc7d" class="lk jk hu nf b fv no nl l nm nn">def get_labels(self):<br/>    """See base class."""<br/>    return [<br/>      "World",<br/>      "Entertainment",<br/>      "Sports",<br/>      "Business",<br/>    ]</span><span id="0f06" class="lk jk hu nf b fv no nl l nm nn">def _create_examples(self, lines, set_type):<br/>    """Creates examples for the training and dev sets."""<br/>    examples = []<br/>    for (i, line) in enumerate(lines):<br/>      if i == 0:  # for header<br/>        continue<br/>      single_example = self._create_example(line, set_type)<br/>      examples.append(single_example)<br/>    return examples</span><span id="7e5c" class="lk jk hu nf b fv no nl l nm nn">def _create_example(self, line, set_type):<br/>    guid = "%s-%s" % (set_type, tokenization.convert_to_unicode(line[0]))<br/>    text_a = tokenization.convert_to_unicode(line[1])<br/>    if set_type == "test":<br/>      label = "World"<br/>    else:<br/>      label = tokenization.convert_to_unicode(line[-1])<br/>    single_example = InputExample(guid=guid, text_a=text_a, label=label)<br/>    return single_example</span></pre><p id="c1f3" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated"><strong class="kd hv">第三个</strong>，复制这个<a class="ae kx" href="https://colab.research.google.com/gist/lapolonio/5ac6552fa4d58ea1419cc444d42ff5ff/bert-finetuning-with-cloud-tpu-sentence-and-sentence-pair-classification-tasks.ipynb#scrollTo=5U_c8s2AvhgL" rel="noopener ugc nofollow" target="_blank"> <strong class="kd hv">笔记本</strong> </a> <strong class="kd hv"> </strong>到<strong class="kd hv"> </strong>训练，评估并导出模型。对于培训，本教程将使用谷歌 Colab 笔记本。要按设计使用笔记本，创建一个 Google 存储桶来存储基本模型和训练模型。</p><p id="2045" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">为什么要用谷歌 Colab 笔记本？它们是免费计算资源，易于共享。</p><p id="00bf" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">初步评估结果不太乐观。更深入的分析请看这里的<strong class="kd hv"><a class="ae kx" href="https://colab.research.google.com/gist/lapolonio/07c1ef27e850452b6b4951dac515ed6f/bert-fine-tuned-model-analysis-sentence-classification-tasks.ipynb#scrollTo=OcUyCka9HblV&amp;uniqifier=1" rel="noopener ugc nofollow" target="_blank"><strong class="kd hv">。</strong></a></strong></p><pre class="lz ma mb mc fq ng nf nh ni aw nj dt"><span id="7b59" class="lk jk hu nf b fv nk nl l nm nn">***** Eval results *****   <br/>eval_accuracy = 0.25   <br/>eval_loss = 7.6698585   <br/>global_step = 12000   <br/>loss = 7.3534603</span></pre><p id="d5a9" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">在第 1 部分结束时，您应该已经导出了一个根据您选择的数据训练的微调过的 BERT 模型。本教程将模型保存到 Google 云存储中。</p><h1 id="8ef9" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">第 2 部分:编写为客户服务的 Tenorflow</h1><p id="cd31" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">现在我们有了一个保存的模型。我们需要创建一些代码来调用 Tensorflow 模型并获得预测。代码需要在服务器上运行，最容易使用的轻量级代码是<a class="ae kx" href="http://flask.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Flask </a>。</p><p id="c3be" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated"><strong class="kd hv">首先是</strong>，通过调用<code class="eh nc nd ne nf b">_create_example</code>使用 FullTokenizer 解析和处理输入，输出 BERT 模型期望的<code class="eh nc nd ne nf b">InputExample</code>。</p><pre class="lz ma mb mc fq ng nf nh ni aw nj dt"><span id="8a81" class="lk jk hu nf b fv nk nl l nm nn">inputExample = processor._create_example([request_id, content['description']], 'test')</span></pre><p id="0c6d" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated"><strong class="kd hv">其次，</strong>使用<code class="eh nc nd ne nf b">from_record_to_tf_example</code>将<code class="eh nc nd ne nf b">InputExample</code>转换为<code class="eh nc nd ne nf b">tf.train.Example</code></p><pre class="lz ma mb mc fq ng nf nh ni aw nj dt"><span id="a496" class="lk jk hu nf b fv nk nl l nm nn">tf_example = classifiers.from_record_to_tf_example(3, inputExample, label_list, 64, tokenizer)</span></pre><p id="43b3" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated"><strong class="kd hv">第三，</strong>现在将格式化的输入发送到 Tensorflow 服务容器。</p><pre class="lz ma mb mc fq ng nf nh ni aw nj dt"><span id="491d" class="lk jk hu nf b fv nk nl l nm nn">### create predict request object<br/>model_request = predict_pb2.PredictRequest()</span><span id="452b" class="lk jk hu nf b fv no nl l nm nn">### specify name of model<br/>model_request.model_spec.name = 'bert'</span><span id="0fcf" class="lk jk hu nf b fv no nl l nm nn">### specify name of function to call<br/>model_request.model_spec.signature_name = 'serving_default'</span><span id="31b4" class="lk jk hu nf b fv no nl l nm nn">### specify dimetion of request<br/>dims = [tensor_shape_pb2.TensorShapeProto.Dim(size=1)]<br/>tensor_shape_proto = tensor_shape_pb2.TensorShapeProto(dim=dims)</span><span id="5378" class="lk jk hu nf b fv no nl l nm nn">### create model input object<br/>tensor_proto = tensor_pb2.TensorProto(<br/>  dtype=types_pb2.DT_STRING,<br/>  tensor_shape=tensor_shape_proto,<br/>  string_val=[model_input])</span><span id="bcab" class="lk jk hu nf b fv no nl l nm nn">### actually send request to model and wait for output<br/>model_request.inputs['examples'].CopyFrom(tensor_proto)<br/>result = stub.Predict(model_request, 10.0)  # 10 secs timeout<br/>result = tf.make_ndarray(result.outputs["probabilities"])<br/>pretty_result = "Predicted Label: " + label_list[result[0].argmax(axis=0)]<br/>app.logger.info("Predicted Label: %s", label_list[result[0].argmax(axis=0)])</span></pre><h1 id="a84b" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">第 3 部分:为 Tensorflow 服务和 Tenorflow 服务客户端构建 Docker 容器</h1><p id="d003" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">使用 flask 应用程序和 Tensorflow 模型，我们可以创建 docker 容器并使用 Kubernetes 部署它们。</p><blockquote class="ky kz la"><p id="ea7f" class="kb kc lb kd b ke lc iv kg kh ld iy kj le lf km kn lg lh kq kr li lj ku kv kw hn dt translated">Kubernetes(k8s)是一个开源系统，用于自动化部署、扩展和管理容器化的应用程序。—项目页面</p></blockquote><p id="d8fb" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">如果你对 Kubernetes 一无所知，我建议你浏览一下这套<a class="ae kx" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><p id="e8b7" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">使用 Kubernetes 的真正好处之一是网络的抽象。您可以将应用程序的不同部分部署在不同节点上的不同 pod 中，并在内部无缝地相互通信，同时公开一个称为“服务”的单一入口点。</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div class="fe ff np"><img src="../Images/23ce3f7971fbe3e8b6dcb90304809dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*dloW6XEZxGt_hOLNk5GsGQ.png"/></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Image Credit: <a class="ae kx" href="https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/</a></figcaption></figure><h2 id="5353" class="lk jk hu bd jl ll lm ln jp lo lp lq jt kk lr ls jv ko lt lu jx ks lv lw jz lx dt translated">构建 Docker 容器并将容器推送到 Dockerhub</h2><p id="6104" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">先决条件:创建一个 Dockerhub 帐户</p><pre class="lz ma mb mc fq ng nf nh ni aw nj dt"><span id="24ad" class="lk jk hu nf b fv nk nl l nm nn"># Create Tensorflow Serving Container and host on Dockerhub<br/>IMAGE_NAME=tf_serving_bert_agnews<br/>VER=1547919083_v2<br/>MODEL_NAME=bert<br/>DOCKER_USER=lapolonio<br/><em class="lb">cd </em>~<br/><em class="lb">docker </em>run -d --name $IMAGE_NAME tensorflow/serving<br/><em class="lb">mkdir </em>~/models<br/><em class="lb">gsutil </em>cp -r  gs://bert-finetuning-ag-news/bert/export/AGNE/1547919083 ~/models<br/><em class="lb">docker </em>cp ~/models/1547919083/ $IMAGE_NAME:/models/$MODEL_NAME</span><span id="76b3" class="lk jk hu nf b fv no nl l nm nn"><em class="lb">### the </em>MODEL_NAME is an internal convention in Tensorflow Serving used to refer to the model and create/name the corresponding model REST endpoint<em class="lb"><br/>docker </em>commit --change "ENV MODEL_NAME $MODEL_NAME" $IMAGE_NAME $USER/$IMAGE_NAME</span><span id="a3b8" class="lk jk hu nf b fv no nl l nm nn"><em class="lb">docker </em>tag $USER/$IMAGE_NAME $DOCKER_USER/$IMAGE_NAME:$VER<br/><em class="lb">docker </em>push $DOCKER_USER/$IMAGE_NAME:$VER<br/><br/># Create client to call Bert Model<br/><em class="lb">git </em>clone https://github.com/lapolonio/bert.git<br/><em class="lb">cd </em>~/bert<br/><br/>CLIENT_IMAGE_NAME=bert_agnews_client<br/>CLIENT_VER=v3<br/>DOCKER_USER=lapolonio<br/><em class="lb">mkdir </em>asset<br/><em class="lb">gsutil </em>cp gs://cloud-tpu-checkpoints/bert/uncased_L-12_H-768_A-12/vocab.txt asset/<br/><em class="lb">docker </em>build -t $USER/$CLIENT_IMAGE_NAME .<br/><em class="lb">docker </em>tag $USER/$CLIENT_IMAGE_NAME $DOCKER_USER/$CLIENT_IMAGE_NAME:$CLIENT_VER<br/><em class="lb">docker </em>push $DOCKER_USER/$CLIENT_IMAGE_NAME:$CLIENT_VER</span></pre><h2 id="6ea3" class="lk jk hu bd jl ll lm ln jp lo lp lq jt kk lr ls jv ko lt lu jx ks lv lw jz lx dt translated">创建一个 Kubernetes 集群，在 Google Cloud 中将容器部署到 Kubernetes</h2><pre class="lz ma mb mc fq ng nf nh ni aw nj dt"><span id="3250" class="lk jk hu nf b fv nk nl l nm nn"><em class="lb">### create k8s cluster<br/>gcloud </em>container clusters create bert-cluster</span><span id="a668" class="lk jk hu nf b fv no nl l nm nn"><em class="lb">### set the target cluster to the created cluter<br/>gcloud </em>config set container/cluster bert-cluster</span><span id="4ce2" class="lk jk hu nf b fv no nl l nm nn"><em class="lb">### get credentials from google cloud to allow deployment<br/>gcloud </em>container clusters get-credentials bert-cluster --zone us-east1-b --project bert-227121</span><span id="6807" class="lk jk hu nf b fv no nl l nm nn"><em class="lb">### deploy containers<br/>kompose </em>convert --stdout | <em class="lb">kubectl </em>apply -f -</span></pre><p id="acaf" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">在 Google Cloud 控制台中，有一个连接到 Google Cloud 的选项，当您选择该选项时，会打开以下提示:</p><figure class="lz ma mb mc fq md fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff nq"><img src="../Images/c0deabbdf717b680b974e009d4d85e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5s1PMJKL0hfCrXCz3q2gw.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Image Credit: Google Cloud Console Interface</figcaption></figure><h1 id="6f3c" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">结论:企业就绪与生产就绪</h1><p id="f58a" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">本教程介绍了如何在 Google Cloud 上的 Kubernetes 中部署使用 BERT 构建的 Tensorflow 模型。我们使用 BERT 作为基本模型来解决 NLP 分类任务。这个解决方案模式创建了一个概念验证生态系统，以测试 Kubernetes 是否是一个在云中提供 Tensorflow 生产模型的可行解决方案。使用 Kubernetes / Tensorflow 服务可能存在障碍，例如网络或性能限制。</p><p id="013b" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">如果 Kubernetes 是可行的，那么要使该解决方案投入生产还需要很多步骤:</p><ul class=""><li id="b99e" class="nr ns hu kd b ke lc kh ld kk nt ko nu ks nv kw nw nx ny nz dt translated">自动扩展(处理不同的工作负载)</li><li id="8d6a" class="nr ns hu kd b ke oa kh ob kk oc ko od ks oe kw nw nx ny nz dt translated">记录</li><li id="3a18" class="nr ns hu kd b ke oa kh ob kk oc ko od ks oe kw nw nx ny nz dt translated">CNAMES(除非您同意提及可能更改 IP)</li><li id="6edb" class="nr ns hu kd b ke oa kh ob kk oc ko od ks oe kw nw nx ny nz dt translated">警报(在服务中断时发出通知)</li><li id="09e6" class="nr ns hu kd b ke oa kh ob kk oc ko od ks oe kw nw nx ny nz dt translated">自动构建和部署(CI/CD)</li><li id="6e94" class="nr ns hu kd b ke oa kh ob kk oc ko od ks oe kw nw nx ny nz dt translated">不同的测试环境</li></ul><p id="a856" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated">Kubernetes 是大规模服务无状态应用程序的优秀解决方案。Tensorflow Serving 是为 Tensorflow 模型提供服务的强大平台。Tensorflow 服务提供了模型版本控制功能和模型状态端点，这些功能和端点非常适合心跳，并随时可用于警报。</p><p id="281b" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt">__________</p><h1 id="7d65" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">其他资源:</h1><div class="of og fm fo oh oi"><a href="http://jalammar.github.io/illustrated-bert/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">有插图的伯特、埃尔莫等人(NLP 如何破解迁移学习)</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">2018 年是机器学习模型处理文本(或者更准确地说，自然…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">jalammar.github.io</p></div></div></div></a></div><p id="3adf" class="pw-post-body-paragraph kb kc hu kd b ke lc iv kg kh ld iy kj kk lf km kn ko lh kq kr ks lj ku kv kw hn dt translated"><a class="ae kx" href="https://github.com/google-research/bert#sentence-and-sentence-pair-classification-tasks" rel="noopener ugc nofollow" target="_blank">https://github . com/Google-research/Bert # sentence-and-sentence-pair-class ification-task</a></p><div class="of og fm fo oh oi"><a href="https://www.tensorflow.org/guide/saved_model#cli_to_inspect_and_execute_savedmodel" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">保存和恢复|张量流</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">张量流变量是表示由程序操纵的共享、持久状态的最佳方式…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">www.tensorflow.org</p></div></div><div class="or l"><div class="os l ot ou ov or ow mi oi"/></div></div></a></div><div class="of og fm fo oh oi"><a href="https://www.tensorflow.org/serving/api_rest" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">RESTful API | TensorFlow 服务| TensorFlow</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">RESTful APIs 支持 JSON 中的规范编码，这使得在系统之间共享数据变得更加容易。对于受支持的…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">www.tensorflow.org</p></div></div></div></a></div><div class="of og fm fo oh oi"><a href="https://www.tensorflow.org/serving/docker" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">将 TensorFlow 服务与 Docker | TensorFlow 服务| TensorFlow 一起使用</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">这将运行 docker 容器并启动 TensorFlow 服务模型服务器，绑定 REST API 端口 8501，并映射…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">www.tensorflow.org</p></div></div></div></a></div><div class="of og fm fo oh oi"><a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">互动教程-部署应用程序</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">要与终端交互，请使用台式机/平板电脑版本继续学习模块 3</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">kubernetes.io</p></div></div><div class="or l"><div class="ox l ot ou ov or ow mi oi"/></div></div></a></div><div class="of og fm fo oh oi"><a href="https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">部署容器化的 web 应用程序| Kubernetes 引擎教程|谷歌云</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">谷歌云提供安全、开放、智能和变革性的工具，帮助企业实现现代化，以适应当今的…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">cloud.google.com</p></div></div></div></a></div><div class="of og fm fo oh oi"><a href="https://scotch.io/tutorials/google-cloud-platform-i-deploy-a-docker-app-to-google-container-engine-with-kubernetes" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">Google 云平台 I:使用 Kubernetes 将 Docker 应用部署到 Google 容器引擎</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">谷歌云平台(GCP)是谷歌的云计算服务，提供一套企业云服务…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">scotch.io</p></div></div><div class="or l"><div class="oy l ot ou ov or ow mi oi"/></div></div></a></div><div class="of og fm fo oh oi"><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/exposing-apps#creating_a_service_of_type_loadbalancer" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab ej"><div class="ok ab ol cl cj om"><h2 class="bd hv fv z el on eo ep oo er et ht dt translated">使用服务公开应用程序| Kubernetes 引擎|谷歌云</h2><div class="op l"><h3 class="bd b fv z el on eo ep oo er et ek translated">谷歌云提供安全、开放、智能和变革性的工具，帮助企业实现现代化，以适应当今的…</h3></div><div class="oq l"><p class="bd b gc z el on eo ep oo er et ek translated">cloud.google.com</p></div></div></div></a></div></div></div>    
</body>
</html>