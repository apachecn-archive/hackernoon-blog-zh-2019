<html>
<head>
<title>Visualizing Cold Starts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化冷启动</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/visualizing-cold-starts-ddb7c3267419?source=collection_archive---------15-----------------------#2019-04-01">https://medium.com/hackernoon/visualizing-cold-starts-ddb7c3267419?source=collection_archive---------15-----------------------#2019-04-01</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c4b0067519ed118e997c0ac84e8dd167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8qpRcWiFUGfxa51gzX8Ww.jpeg"/></div></div></figure><p id="ad95" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我<a class="ae ka" href="https://mikhail.io/serverless/coldstarts/" rel="noopener ugc nofollow" target="_blank">写了很多</a>关于无服务器功能的冷启动。这些文章充满了图表和数字，希望有用，但可能很难消化。我决定想出一个视觉上表现感冒开始的方法。</p><p id="0f14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我创建了服务于地理地图的HTTP函数(地图信用<a class="ae ka" href="https://www.openstreetmap.org/" rel="noopener ugc nofollow" target="_blank">开放街道地图</a>)。地图是小方块的组合；每个单幅图块为256 x256像素。我选择的地图视图由12个图块组成，因此向无服务器函数发出12个请求来加载单个视图。</p><p id="db2a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在每个实验中，我加载地图，然后放大三次。第一个视图击中了处于冷状态的功能。随后，缩放的视图从温暖功能加载。地图旁边有一个计时器，显示从开始到最后一个图块到达所经过的总时间。</p><h1 id="ec08" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">冷启动可视化</h1><p id="aebb" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">所有功能都在Node.js中实现，运行在地理上离我最近的地区(西欧)。</p><p id="ec9a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些函数从云存储(AWS S3、<a class="ae ka" href="https://hackernoon.com/tagged/google" rel="noopener ugc nofollow" target="_blank"> Google </a>云存储和Azure Blob存储)加载地图切片。因此，启动时加载SDK和存储读取延迟会增加持续时间。</p><h2 id="f8e7" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">自动气象站λ</h2><p id="f9a5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">以下GIF影片是针对AWS Lambda的实验记录:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/080919d044ca8c617440ed42f0ff1ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FLeQfZQKqmASElJzvHqNsQ.gif"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Map loads from AWS Lambda backend</figcaption></figure><p id="9d13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">冷视图的加载时间为1.9秒，而热视图的加载时间在200到600毫秒之间。这种区别相当明显，但并不令人讨厌:第一个负载感觉起来像一个小的网络故障。</p><h2 id="4bd8" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">谷歌云功能</h2><p id="48a9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这张GIF展示了针对谷歌云功能的实验:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/0e460491b0a1c2ef8f7f7aaca6ae1c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*69Ur3bkqoIc23aVzzN8aFQ.gif"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Map loads from Google Cloud Functions backend</figcaption></figure><p id="ecf7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">加载初始视图比AWS多花了一秒钟。这不是一个交易破坏者，但3秒钟的延迟通常被认为是心理上的重要因素。</p><p id="1496" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">瓷砖似乎越来越多地出现；请阅读下面的更多内容。</p><h2 id="a064" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">Azure函数</h2><p id="675a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这是另一部电影，这次是关于Azure函数的:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ls"><img src="../Images/05407b1e5adaa886c2a334b9282991c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2L4MlpmUjqbiIvImk4jG8Q.gif"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Map loads from Azure Functions backend</figcaption></figure><p id="359f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我之前发布的测量结果所预期的那样，Azure函数的启动时间要长得多。用户有足够的时间开始怀疑地图是否损坏。</p><p id="86d8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望用C#实现的函数会有更好的结果，但这不是苹果与苹果之间的比较。</p><h1 id="5a8c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">提供商如何处理并行请求？</h1><p id="13e9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">map控件并行发出12个请求。所有函数都使用HTTP/2，因此旧的连接数限制不再适用。让我们比较一下这些并行请求是如何处理的。</p><h2 id="3cb9" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">自动气象站λ</h2><p id="84c1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">AWS Lambda的每个实例一次可以处理一个请求。因此，我们不是只进行一次冷启动，而是同时进行12次冷启动。为了说明这一点，我修改了函数，根据Lambda实例ID对每个图块进行颜色编码，并将ID打印在图像上:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mb"><img src="../Images/fcac4abc9e866850af1c05a0f4370175.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i8rKH-ulgDgyWFIn.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">AWS Lambda provisioned 12 instances to serve 12 requests in parallel</figcaption></figure><p id="2074" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，测量的持续时间代表了12个并行请求中最慢的<em class="mc">的往返时间。这不是冷启动的平均或中间持续时间。</em></p><h2 id="ce5a" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">谷歌云功能</h2><p id="c0e1" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">谷歌使用相同的每个实例执行一次的模型，所以我预计GCP云函数的行为与AWS Lambda完全相同。然而，我错了:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff md"><img src="../Images/9f1746a02918f87e76e76cef07897455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vTPmdvTMZuXv7Wfi.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Google Cloud Function provisioned 3 instances to serve 12 parallel requests</figcaption></figure><p id="8ed0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">只创建了三个实例，其中两个处理多个请求。看起来像是GCP序列化了传入的请求，并通过有限的实例集传播它们。</p><h2 id="354e" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">Azure函数</h2><p id="605a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">Azure函数有不同的设计:函数的每个实例可以同时处理多个并行请求。因此，理论上，冷启动后创建的第一个实例可以服务所有12个瓦片。</p><p id="07b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，会创建多个实例。这幅画看起来很像GCP:</p><figure class="lt lu lv lw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff me"><img src="../Images/653cde53bb3562e2537c907f68fa6ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YUOktvdi3JCMggjy.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Azure Function provisioned 4 instances to serve 12 parallel requests</figcaption></figure><p id="659b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有四个活动实例，但同一实例处理了12个请求中的9个。这种行为在多次运行之间似乎相当一致。</p><h1 id="096c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="cf25" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我希望这些可视化有助于更好地理解无服务器功能的冷启动。</p><p id="304d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然而，它们只是例子。不要将这些数字视为特定云提供商的精确统计数据。如果你很好奇，可以在<a class="ae ka" href="https://mikhail.io/serverless/coldstarts/" rel="noopener ugc nofollow" target="_blank">无服务器冷启动</a>系列文章中了解更多。</p></div><div class="ab cl mf mg hc mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hn ho hp hq hr"><p id="e65b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更新:函数源代码可用:<a class="ae ka" href="https://github.com/mikhailshilkov/cloudbench/tree/master/aws/http/jsmaptiles" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>、<a class="ae ka" href="https://github.com/mikhailshilkov/cloudbench/tree/master/gcp/http/jsmaptiles" rel="noopener ugc nofollow" target="_blank"> Google Cloud函数</a>、<a class="ae ka" href="https://github.com/mikhailshilkov/cloudbench/tree/master/azure/http/v2/jsmaptiles" rel="noopener ugc nofollow" target="_blank"> Azure函数</a>。</p></div><div class="ab cl mf mg hc mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hn ho hp hq hr"><p id="49b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mc">最初发表于</em><a class="ae ka" href="https://mikhail.io/2019/03/visualizing-cold-starts/" rel="noopener ugc nofollow" target="_blank"><em class="mc">Mikhail . io</em></a><em class="mc">。</em></p><figure class="lt lu lv lw fq iv"><div class="bz el l di"><div class="mm mn l"/></div></figure></div></div>    
</body>
</html>