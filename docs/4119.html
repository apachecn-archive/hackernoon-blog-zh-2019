<html>
<head>
<title>Long-distance React hooks 📞🎣</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">长距离反应钩📞🎣</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/long-distance-react-hooks-bd47a2e6d98c#2019-07-13">https://medium.com/hackernoon/long-distance-react-hooks-bd47a2e6d98c#2019-07-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/af43288f7aa9adc821eec2693139c9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yonxgDtE2g-GDKiIQu6Rw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by Mike Meyers on <a class="ae jg" href="https://unsplash.com/photos/-haAxbjiHds" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ac4f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个问题由来已久:</p><ol class=""><li id="7b54" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">有一个组件树</li><li id="c3ff" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">他们两个需要谈谈。</li></ol><p id="5e6b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个显而易见的解决方案是使用某种状态管理库，比如 Redux 或 MobX。但是让我们假设上面的问题陈述就是它的全部——应用程序没有其他状态，它是一个安静的、不连接的组件的海洋。恰好他们两个需要共享一个变量。</p><p id="84f9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下一个镜头是<a class="ae jg" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">背景</a>。这就是它的作用，对吗？上下文为组件树提供了一个共享变量！但是不幸的是，上下文不是自由的——需要将一个组件指定为上下文值的持有者。因为在 React 中，如果某个东西是一种状态(它会改变)，那么它必须生活在一个组件中。</p><p id="7e2f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">添加上下文引入了另一个组件(或者至少强制一个层次)，这不是我们在这里想要的。我们想让两个孤独的组件进行长途通话。句号。</p><h1 id="7ffa" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">钩子来拯救</h1><p id="fcc8" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">还好有 React 里的钩子！钩子是一种将组件绑定到 React 运行时的方法(<em class="lw">钩子</em>进入，对吗？).</p><p id="162a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这在以前的功能组件中是不可能的。React 将它们视为纯粹的函数:接受一些道具，吐出 DOM 元素，故事结束。功能组件没有生命周期——例如，不可能只在第一次渲染或保持状态时执行某些操作。数据输入，HTML 输出，就是这样。</p><p id="f83c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用钩子，一个功能组件可能是不纯的。一些状态可以添加到一个组件中，或者一个动作只执行一次(比如获取数据)。钩子很神奇，它减轻了 React 开发的痛苦，同时简化了我们使用 React 的方式。</p><h1 id="ce67" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated"><em class="lx">只是</em>一个勾</h1><p id="77cc" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">我非常喜欢从 API 设计开始编写代码的方法。当您想象您将要使用的代码已经存在时，您可以专注于这个幻想的 API。您不会被一些实现细节或约束所强迫。</p><p id="e9c0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以在这种情况下，我们想要的是一个钩子，钩子应该提供一种读写共享变量的方法:</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="bbcf" class="mh ku hu md b fv mi mj l mk ml">const { answer, setAnswer } = useAnswer()</span></pre><p id="71a1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不错！这基本上就是组件与共享变量交互所需要的全部内容。真快。正如你可能已经注意到的，这种 fantasy-API-first 的方法与<a class="ae jg" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>结合得很好。首先，我们想象一个完美的世界，编写一些测试来表达它应该如何工作，然后——最后——创建它。</p><p id="4045" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们开始吧。我们从一个变量开始:</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="0bcd" class="mh ku hu md b fv mi mj l mk ml">let answer</span></pre><p id="ea4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是真理的源泉。这只是一个在文件中定义的变量——再简单不过了。现在让我们为状态更新程序获取一个<code class="eh mm mn mo md b">Set</code>。每个使用钩子的组件都有自己的更新函数，并且会被单独通知。</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="e1c4" class="mh ku hu md b fv mi mj l mk ml">const stateUpdaters = new Set()</span></pre><p id="3a96" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么是<code class="eh mm mn mo md b">Set</code>？有一个很好的特性，即不允许重复值，这在这里会很方便。接下来是值的更新函数，传递给组件——整个业务的“写”部分:</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="313a" class="mh ku hu md b fv mi mj l mk ml">const setValue = newValue =&gt; {<br/>  value = newValue<br/>  stateUpdaters.forEach(fn =&gt; fn(value))<br/>}</span></pre><p id="6a4c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">同样，我们在这里处理的是纯 JavaScript。它只是一个函数。最后，React 发挥作用的部分，即<code class="eh mm mn mo md b">setState</code>挂钩(React 自带):</p><pre class="ly lz ma mb fq mc md me mf aw mg dt"><span id="c9e6" class="mh ku hu md b fv mi mj l mk ml">export default () =&gt; {<br/>  const [, setState] = useState();<br/>  stateUpdaters.add(setState);<br/>  return [value, setValue];<br/>}</span></pre><p id="1741" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">仅此而已！在这里，你可以看到所有这些都聚集在一起:</p><figure class="ly lz ma mb fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure><h2 id="c702" class="mh ku hu bd kv mr ms mt kz mu mv mw ld js mx my lh jw mz na ll ka nb nc lp nd dt translated">不过有一点！</h2><p id="648f" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">如果您对 React 有点经验，您可能会注意到这段代码的一个问题。由于每个调用者组件都会触发一个更新函数的注册，所以它在卸载时也应该取消注册！我鼓励您派生这个代码示例并处理那个场景。提示:它涉及到另一个钩子，叫做<code class="eh mm mn mo md b">useEffect</code>😉。</p><h1 id="7bf5" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">为什么不呢？</h1><p id="5e1c" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">让我们考虑一下开发人员使用这种方法可能会遇到的一些问题:</p><blockquote class="ne nf ng"><p id="c6e6" class="jh ji lw jj b jk jl jm jn jo jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd ke hn dt translated">上下文之所以过时，是因为它引入了第三方——真理的来源，而这个解决方案也提出了一个，以变量的形式！</p></blockquote><p id="9df0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">是的，但是环境迫使一个树状结构，而事实的来源是一个组件。在这里，它只是一个变量。这大大简化了整个过程，并避免了对组件树的污染。</p><blockquote class="ne nf ng"><p id="d9fe" class="jh ji lw jj b jk jl jm jn jo jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd ke hn dt translated">这不是惯用的反应！而这种变异的变量是 React 的功能精神所憎恶的！</p></blockquote><p id="934c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">编程通常是为工作寻找合适的工具。引入更复杂的状态管理解决方案，而所需要的只是在组件之间共享的变量，这是不必要的。</p><p id="8329" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">即使在一个大的 Redux 支持的应用程序中，本地组件状态也有它的用途(例如，选项卡容器中的选定选项卡)。这种共享可变变量的方法介于局部组件状态和全局应用程序状态之间。</p><blockquote class="ne nf ng"><p id="9735" class="jh ji lw jj b jk jl jm jn jo jp jq jr nh jt ju jv ni jx jy jz nj kb kc kd ke hn dt translated">这不可扩展…</p></blockquote><p id="312b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">没错。如果您所需要的只是在多个地方显示一些东西，而组件树挡住了去路，那么这种方法可能比在全局状态管理代码中添加 20 行逻辑更好。</p><h1 id="b024" class="kt ku hu bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">它应该扩展吗？</h1><p id="dc37" class="pw-post-body-paragraph jh ji hu jj b jk lr jm jn jo ls jq jr js lt ju jv jw lu jy jz ka lv kc kd ke hn dt translated">您可能喜欢这种方法，但是想更进一步。存储大量数据，而不仅仅是一个数字。使用类似 reducer 的逻辑使更新更容易。然后就把那个钩子作为<em class="lw"/>状态管理解决方案。</p><p id="c155" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，正如在 JavaScript 领域经常发生的那样，有<a class="ae jg" href="https://www.npmjs.com/search?q=hook%20state" rel="noopener ugc nofollow" target="_blank">大量的包</a>就是这么做的——用钩子简化状态管理。虽然我个人更喜欢 Redux，但这些都是有趣的命题，以一种更“直观”的方式解决了全局状态的问题。</p><p id="b01c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">坦白地说，我不会用全局变异状态来表示比单个变量更大的东西。即使那样，我使用它也会感到有点恶心。如果一个状态应该在组件树中共享，这暗示它可能属于全局状态。</p><p id="df26" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是我希望，尽管整个概念是反推荐的，我已经设法向您展示了 React hooks 的一个有趣的用例！这就是它们最终的用途——构成和实验的基石。这也是我喜欢 React 的原因。</p></div></div>    
</body>
</html>