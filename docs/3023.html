<html>
<head>
<title>Word to PDF + Serverless = 💕</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Word转PDF +无服务器=💕</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/word-to-pdf-serverless-437c26c73604?source=collection_archive---------5-----------------------#2019-05-14">https://medium.com/hackernoon/word-to-pdf-serverless-437c26c73604?source=collection_archive---------5-----------------------#2019-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/31a6460f6e7316b1ecbff8d0455e4d42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vil3FPuycD4IIFjH0wNLrw.png"/></div></div></figure><p id="bc7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如何解决将Word文档大规模转换为PDF的普遍问题？</p><p id="ed5c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我的<a class="ae ka" href="https://hackernoon.com/generating-pdfs-in-javascript-for-fun-and-profit-c7af594cf697" rel="noopener ugc nofollow" target="_blank">早期文章</a>主要针对Javascript开发人员；它展示了docx模板现在是用Javascript创建pdf的最简单的方法。你生成一个docx，然后用我们的<a class="ae ka" href="https://www.npmjs.com/package/@nativedocuments/docx-wasm" rel="noopener ugc nofollow" target="_blank"> docx-wasm </a>把它转换成PDF。</p><p id="4ba2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我将向您展示无服务器如何实现从docx的大规模转换；想想每小时一百万个pdf。容易且成本低。虽然在这里我们将再次使用node.js，但作为一名Java开发人员，这种无服务器的方法对于其他领域的开发人员来说也非常有效。</p><p id="5ed2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我将在六月西雅图PDF协会会议上的<a class="ae ka" href="https://www.pdfa.org/electronic-document-conference-agenda/#nativedocuments" rel="noopener ugc nofollow" target="_blank">演讲</a>中涉及的更多内容的一个预览。在那里见？</p><p id="d934" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">转换是CPU密集型的</strong></p><p id="6dd0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">docx到PDF转换的一个特点是它本身就是CPU密集型的。基本上每个CPU内核一次可以转换一个输入文件。试着做2，它会花两倍的时间。“多长”取决于文档的复杂程度。页数是复杂性的粗略代表，但是它包含的内容也很重要:想想表格、图片、分页符、目录等等。</p><p id="b2eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从历史上看，更多的内核意味着更多的服务器，因此您可以通过投入更多的服务器来解决问题。但是这是昂贵的:在硬件、软件许可和管理复杂性(也就是人)方面。您要么过度配置硬件(浪费资金)，要么冒着超负荷的风险(即延迟或丢失工作)。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/e91520d0acb8d8753f9b4e3a7c4dc122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*ypdslqAm5hhm1S4yv2w0bw.png"/></div></div></figure><p id="0a6f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">无服务器救援！</strong></p><p id="b799" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我不打算在这里解释基础知识；可以说，所有主要的云提供商(AWS、Azure、Google等)现在都有无服务器/FaaS(功能即服务)产品，也有更多开放/可移植的替代产品，如无服务器框架、OpenWhisk和Kubernetes上的无服务器选项。</p><p id="f69a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我们将使用AWS Lambda，但是我们的方法很容易转移到其他无服务器环境。这主要是因为这些其他环境也支持用node.js编写的函数。</p><p id="9359" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">切入正题，这是在Lambda上执行转换时可以预期的可伸缩性:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kg"><img src="../Images/c6f4fc09d2805b671719f574d75573ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mplB_nlsmI52GarRYxNlRA.png"/></div></div><figcaption class="kh ki fg fe ff kj kk bd b be z ek">200,000 PDFs in 10 mins on AWS Lambda</figcaption></figure><p id="c2bb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，我们创建了20万个pdf。花了10分钟。</p><p id="9940" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个PDF大约需要1秒钟，AWS总共启动了591个函数实例来完成这项工作。启动一个运行我们函数的实例大约需要8秒钟，所以在10，000毫秒标记下有591个点(这个时间包括实际转换)。</p><p id="05ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面，我将解释如何使用SQS来生成这个负载。不过，这里要强调的要点是如何简单(而且便宜！)就是把那590个“核”火起来。我们真的不需要做任何事情；AWS Lambda为我们做了这一切。无服务器的本质是你不用考虑服务器。</p><p id="c274" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它是如何工作的？</p><p id="c6e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">基本上，我们的docx到PDF函数的执行是为了响应某个<strong class="je hv">触发事件</strong>。在AWS中，可能的触发事件有一长串，但值得注意的包括REST API调用、S3对象创建事件、SQS(消息)和步进函数。</p><p id="0b8d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们希望我们的触发事件告诉函数要转换什么docx，以及如何处理结果。由于AWS对调用有效负载的大小施加了限制，我们的设计将围绕某个S3桶中的输入docx，生成的PDF将被写入S3。</p><p id="27c0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如何告诉函数要转换哪个S3 docx对象？</p><p id="c86e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<a class="ae ka" href="https://github.com/NativeDocuments/docx-to-pdf-on-AWS-Lambda" rel="noopener ugc nofollow" target="_blank">https://github . com/native documents/docx-to-pdf-on-AWS-Lambda</a>的示例代码中，我们支持在S3创建docx对象时触发，或者当我们接收到一个step函数事件，或者一个标识该对象的SQS消息时触发。如何识别输入docx和输出PDF取决于触发事件:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kl"><img src="../Images/a1feb6e18b0c2eb658155d7d126dc284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hD0wdmP6XUEBl0txcoPCMQ.png"/></div></div></figure><p id="e7b6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">详见<a class="ae ka" href="https://github.com/NativeDocuments/docx-to-pdf-on-AWS-Lambda" rel="noopener ugc nofollow" target="_blank">自述文件</a>。S3对象创建事件对于开发测试很有用，但是其他事件对于真正的无服务器应用程序更好，因为您可以更好地控制要转换的文档和要写入的PDF。如果您需要一些其他的Lambda触发器，添加它应该很简单:只需克隆或派生GitHub repo就可以开始了。</p><p id="a244" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一旦lambda有了docx，执行实际的转换就是一个简单的API调用，使用<a class="ae ka" href="https://www.npmjs.com/package/@nativedocuments/docx-wasm" rel="noopener ugc nofollow" target="_blank"> docx-wasm </a>。PDF将被写入S3存储桶，密钥如上表所示。</p><p id="d46e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在来试试吧，我们在无服务器repo里有一个app:<a class="ae ka" href="https://serverlessrepo.aws.amazon.com/applications/arn:aws:serverlessrepo:us-east-1:992364115735:applications~docx-to-pdf" rel="noopener ugc nofollow" target="_blank">https://server lessrepo . AWS . Amazon . com/applications/arn:AWS:server lessrepo:us-east-1:992364115735:applications ~ docx-to-pdf</a>或者在<a class="ae ka" href="https://serverlessrepo.aws.amazon.com/applications" rel="noopener ugc nofollow" target="_blank">无服务器应用库</a>里搜索“docx-to-pdf”。或者可以从<a class="ae ka" href="https://github.com/NativeDocuments/docx-to-pdf-on-AWS-Lambda" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获取源码。</p><p id="c08a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在结束这篇文章之前，让我谈三点。</p><p id="b214" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">负载测试</strong></p><p id="b7ce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">生成S3创建事件的一个简单方法是在S3 web控制台中复制/粘贴docx。这样做的好处是，一旦你在S3有了docx，你就不需要再上传了。您可以简单地复制/粘贴对象来生成事件。如果您在S3复制/粘贴一个文件夹，也会发生同样的事情:您会为其中的每个docx获得一个事件。</p><p id="9d13" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这对于基本测试来说很方便(比方说，有1000个文档的目录)。</p><p id="ae70" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是它不适合快速触发200，000次λ。怎么做呢？</p><p id="61af" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">SQS在这里帮忙。当lambda完成时，我让它生成一个SQS事件，该事件触发lambda运行另一个转换。实际上，不是一个SQS事件，而是9或10个，所以每个lambda有效地启动了9或10个额外的转换。例如，在第1代中，有9个转换请求；在第二代中，有10 x 9 = 90，以此类推，因此在第五代中有90，000。SQS消息包含一个值，表示它属于哪一代，经过一定数量的代(比如5代)后，我们停止生成事件。</p><p id="0116" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我发现这是一种快速简单的生成负载的方法:Lambda本身在SQS的帮助下生成负载。请注意，AWS确实提醒您避免递归代码，它说:</p><blockquote class="km kn ko"><p id="c11c" class="jc jd kp je b jf jg jh ji jj jk jl jm kq jo jp jq kr js jt ju ks jw jx jy jz hn dt translated">这可能会导致意外的函数调用量和成本增加。如果您不小心这样做了，在您更新代码时，立即将函数并发执行限制设置为0，以限制对函数的所有调用。</p></blockquote><p id="90e7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> Lambda内存(MB)设置</strong></p><p id="ff10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你应该注意你的内存配置设置，因为它会影响<a class="ae ka" href="https://aws.amazon.com/lambda/pricing/" rel="noopener ugc nofollow" target="_blank">你花了多少钱</a>，以及事情需要多长时间。</p><p id="5d28" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我之前提到过转换成PDF是CPU密集型的。但是它不占用太多内存(至少Native Documents已经实现了它)。不幸的是，云提供商总是把CPU和内存绑在一起:想要更多的CPU？你必须带更多的内存。对于Lambda，他们只有一个RAM滑块，它决定了你得到多少CPU。</p><p id="c238" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于更多的RAM (CPU)成本更高(每100毫秒的执行时间)，理想情况下，我们希望工作完成得更快<em class="kp">和</em>花费更少。确认这一点需要对您的特定文档进行实验，但经验表明，2048MB会产生足够的处理器，转换速度更快，成本更低。要知道docx-wasm最少使用500MB左右的RAM，Node下的WebAssembly最多可以使用2GB RAM，所以这些是上限和下限。</p><p id="2123" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">云API和敏感文档不要混用</strong></p><p id="e55c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">公司倾向于担心通过互联网发送到某个第三方API端点的文档的命运，这是有道理的。</p><p id="fbd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在AWS Lambda上自己执行转换可以帮助您晚上睡得安稳。您可以控制端点，并且还可以获得简单且透明的可扩展性(第三方端点<em class="kp">到底能扩展到什么程度呢？).</em></p><p id="c4f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不喜欢什么？:-)</p></div></div>    
</body>
</html>