<html>
<head>
<title>Building chat with Odi (Node.js)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Odi 建立聊天(Node.js)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-chat-with-odi-node-js-e77ecd3891b2#2019-01-18">https://medium.com/hackernoon/building-chat-with-odi-node-js-e77ecd3891b2#2019-01-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ae819291bcdd161db9b2c163344dd33e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sgX66LJwz_v0hyL83JGhQ.png"/></div></div></figure><h1 id="5563" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">介绍</h1><p id="498f" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">聊天应用程序是一个非常常见的例子，用来显示客户端和服务器之间简单的实时通信。本教程描述了如何使用 Odi，<strong class="kc hv"/>TypeScript server-side framework for node . js 轻松实现这一点。</p><h1 id="f527" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">项目设置</h1><p id="3268" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们要开发的应用程序不仅要建立实时通信通道，还要向客户端呈现前端，包括所需的资产。</p><h2 id="5452" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">基本设置</h2><p id="ebb6" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">让我们建立 Odi 项目。首先要初始化<code class="eh lm ln lo lp b">package.json</code>和<code class="eh lm ln lo lp b">tsconfig.json</code>文件。我们可以用两个简单的命令来完成。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="a3a4" class="ky jd hu lp b fv ly lz l ma mb">npm init -y<br/>tsc --init</span></pre><p id="99bb" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">并安装<strong class="kc hv"> Odi </strong>。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="0928" class="ky jd hu lp b fv ly lz l ma mb">npm install odi</span></pre><p id="1dd2" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">此外，我们需要修改<code class="eh lm ln lo lp b">tsconfig.json</code>文件，因为有几个选项必须编辑。Odi 主动使用 decorators 和元数据，所以我们需要启用这些特性。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="359e" class="ky jd hu lp b fv ly lz l ma mb">"experimentalDecorators": true,<br/>"emitDecoratorMetadata": true</span></pre><p id="b38d" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">另一件事是<code class="eh lm ln lo lp b">target</code>选项。默认情况下，它设置为<code class="eh lm ln lo lp b">es5</code>，但是在这个规范中有几个东西是不支持的。由于我们是渐进的，让我们把它设置为最新版本</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="8e1f" class="ky jd hu lp b fv ly lz l ma mb">"target": "ES2018"</span></pre><h2 id="66d4" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">项目结构</h2><p id="1678" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们将为视图、资产和服务器源代码建立不同的文件夹。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff mh"><img src="../Images/24b29dfb5a294febd8be20e399797330.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*2jLFB3kGBqfnLp3YfUWvXQ.png"/></div></figure><ul class=""><li id="c846" class="mi mj hu kc b kd mc kh md kl mk kp ml kt mm kx mn mo mp mq dt translated"><strong class="kc hv"> src </strong> —服务器源代码。</li><li id="371e" class="mi mj hu kc b kd mr kh ms kl mt kp mu kt mv kx mn mo mp mq dt translated"><strong class="kc hv">视图</strong> —将呈现给客户的 JSX 模板。</li><li id="1306" class="mi mj hu kc b kd mr kh ms kl mt kp mu kt mv kx mn mo mp mq dt translated"><strong class="kc hv">资产</strong> —客户端<em class="mw"> JS </em>和<em class="mw"> CSS </em>文件。</li></ul><p id="27d8" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">JSX 模板是必须编译的文件。将<strong class="kc hv">视图</strong>文件夹添加到<code class="eh lm ln lo lp b">tsconfig.json</code>文件的<em class="mw">根目录</em>中，并设置<em class="mw"> outDir </em>。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="e1c2" class="ky jd hu lp b fv ly lz l ma mb">"outDir": "./build",<br/>"rootDirs": ["./src", "./views"]</span></pre><h1 id="a692" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">开始获取</h1><p id="8f93" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Odi 基于<em class="mw">依赖注入</em>模式，所以每个应用组件都会被自动导入、实例化和注入。</p><p id="547e" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">必须只指定包含源文件的文件夹，然后 Odi 可以扫描它以导入应用程序组件(控制器、服务、存储库等)。</p><h2 id="a1d6" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">主文件</h2><p id="fc49" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在<code class="eh lm ln lo lp b">src</code>文件夹中创建<code class="eh lm ln lo lp b">index.ts</code>文件。它将是服务器入口点文件。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="f9fb" class="ky jd hu lp b fv ly lz l ma mb">import { Core } from "odi";<br/>import { join } from "path";</span><span id="e9f5" class="ky jd hu lp b fv mx lz l ma mb">new Core({<br/>    sources: __dirname,<br/>    server: {<br/>        port: 8080,<br/>        socket: true,<br/>        static: {<br/>            root: join(__dirname, '../../assets'),<br/>            prefix: '/assets'<br/>        }<br/>    }<br/>}).listen(() =&gt; console.log("Server successfully started!"));</span></pre><p id="80e5" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们只需要实例化<code class="eh lm ln lo lp b">Core</code>类。<code class="eh lm ln lo lp b">Core</code>构造函数接受单个参数，设置对象。有很多可能的选择，但是现在，我们只需要其中的几个。</p><p id="4d4e" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">首先，我们需要指定<code class="eh lm ln lo lp b">sources</code>属性。这是 Odi 应用程序的必需设置。作为我们为服务器端代码选择的<code class="eh lm ln lo lp b">src</code>文件夹中的<code class="eh lm ln lo lp b">index.ts</code>文件，我们可以使用<code class="eh lm ln lo lp b">__dirname</code>来设置当前目录。</p><p id="09de" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated"><code class="eh lm ln lo lp b">port</code>属性也是必需的。它将服务器绑定到指定的端口。</p><p id="c520" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">现在谈谈以下部分:</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="ede4" class="ky jd hu lp b fv ly lz l ma mb">socket: true,<br/>static: {<br/>     root: join(__dirname, '../../assets'),<br/>     prefix: '/assets'<br/>}</span></pre><p id="51ec" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们必须启用套接字并设置静态文件服务选项。所有来自<strong class="kc hv"> assets </strong>文件夹的文件都可以通过带有<code class="eh lm ln lo lp b">/assets</code>前缀的 URL 获得。</p><h2 id="6c66" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">安装依赖项</h2><p id="3706" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">Odi 框架自动只包含几个必需的包。不同特性的所有其他依赖项都是可选的，因此只有在使用某个特性时才需要安装。</p><p id="18b4" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">比如你准备搭建一个简单的 REST 服务器，不需要 GraphQL、WebSockets、SSR 等包。</p><p id="352e" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们希望在我们的聊天应用程序中有 WebSockets 和模板(JSX)。因此，让我们安装缺失的软件包:</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="22ef" class="ky jd hu lp b fv ly lz l ma mb">npm install socket.io react react-dom</span></pre><p id="05f4" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">仅此而已，Odi 会自动导入。正如你所看到的，<a class="ae my" href="http://socket.io" rel="noopener ugc nofollow" target="_blank"> socket.io </a>被用于实现实时功能。模板处理也需要 React 包。</p><p id="9b1c" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">现在我们可以开始写代码了:)</p><h1 id="3ffe" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">应用</h1><p id="7a3c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">我们将创建一个 web 服务器，它使用模板向客户端呈现 HTML，为客户端提供文件(<em class="mw"> JS </em>，<em class="mw"> CSS </em>)，并使用 WebSockets 建立一个实时通信通道进行聊天。让我们在聊天中加入历史。因此，最后 10 条消息将保存在我们的系统中。</p><h2 id="d63d" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">消息和历史</h2><p id="d82c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><code class="eh lm ln lo lp b">Message</code>会相当简单，只有<code class="eh lm ln lo lp b">username</code>和<code class="eh lm ln lo lp b">text</code>字段。我们可以用一个简单的界面来完成，因为我们不打算使用数据库。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="6005" class="ky jd hu lp b fv ly lz l ma mb">export interface Message {<br/>    username: string;<br/>    text: string;<br/>}</span></pre><p id="24e0" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">和历史服务</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="7f44" class="ky jd hu lp b fv ly lz l ma mb">@Service()<br/>export default class HistoryService {<br/>    private store: Message[] = [];<br/>    <br/>    getMessages() {<br/>        return this.store;<br/>    }</span><span id="ce2a" class="ky jd hu lp b fv mx lz l ma mb">    addMessage(message: Message) {<br/>        if(this.store.length &gt; 10)<br/>            this.store.shift();</span><span id="ac20" class="ky jd hu lp b fv mx lz l ma mb">        this.store.push(message);<br/>    }<br/>}</span></pre><p id="1e14" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们的存储是一个简单的消息数组。商店管理的方法很少。如果我们得到的消息超过 10 条，我们只需从数组中删除第一条消息。</p><p id="2213" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">正如你所看到的，<code class="eh lm ln lo lp b">Service</code> decorator 被用于<code class="eh lm ln lo lp b">HistoryService</code>类来将 is 设置为一个服务组件。服务在依赖注入容器中是单例的。现在，它可以被注入到其他应用程序组件中。</p><p id="70ba" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">将所有这些代码放在<code class="eh lm ln lo lp b">src/services</code>文件夹的<code class="eh lm ln lo lp b">history.ts</code>文件中。</p><h2 id="15f7" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">Web 套接字</h2><p id="2271" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">用下面的代码在<code class="eh lm ln lo lp b">src/sockets</code>目录下创建<code class="eh lm ln lo lp b">chat.socket.ts</code>文件。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="a572" class="ky jd hu lp b fv ly lz l ma mb">import { Socket, OnEvent, ISocket, Autowired } from "odi";<br/>import HistoryService, { Message } from "../services/history";</span><span id="4187" class="ky jd hu lp b fv mx lz l ma mb">@Socket('chat')<br/>export default class ChatSocket extends ISocket {</span><span id="0508" class="ky jd hu lp b fv mx lz l ma mb">    @Autowired()<br/>    history: HistoryService;</span><span id="e457" class="ky jd hu lp b fv mx lz l ma mb">    @OnEvent('massage:send') <br/>    onmessage(message: Message) {<br/>       this.history.addMessage(message); <br/>       this.emit('message:new', message);<br/>    }<br/>}</span></pre><p id="e786" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们用<code class="eh lm ln lo lp b">message:send</code>事件的处理程序定义了<code class="eh lm ln lo lp b">/chat</code>名称空间。如果触发了<code class="eh lm ln lo lp b">message:send</code>事件，所有连接到该名称空间的客户端都将收到<code class="eh lm ln lo lp b">message:new</code>事件和消息数据的通知。</p><p id="c291" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">您可以注意到<code class="eh lm ln lo lp b">Socket</code> decorator 定义了名称空间。不需要前导斜杠。要将方法设置为某个事件的处理程序，使用<code class="eh lm ln lo lp b">OnEvent</code> decorator，它接受事件名称作为参数。</p><p id="cd7d" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">此外，我们使用<code class="eh lm ln lo lp b">Autowired</code>装饰器注入了<code class="eh lm ln lo lp b">HistoryService</code>。<code class="eh lm ln lo lp b">ChatSocket</code>类的<code class="eh lm ln lo lp b">history</code>字段会被 Odi 初始化，所以你不需要做任何额外的事情。</p><p id="dd2f" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">唯一可以从 TypeScript 中看到的错误是</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="d756" class="ky jd hu lp b fv ly lz l ma mb">[ts] Property 'history' has no initializer and is not definitely assigned in the constructor.</span></pre><p id="7868" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">Odi 自动初始化注入的字段，所以只需在<code class="eh lm ln lo lp b">tsconfig.json</code>中禁用该检查</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="7be2" class="ky jd hu lp b fv ly lz l ma mb">"strictPropertyInitialization": false</span></pre><h2 id="828c" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">模板(JSX)</h2><p id="b350" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">有很多模板处理器——EJS、杰德、帕格。但是这些技术有很多限制和不便。在大多数情况下，要让 IntelliSense 和代码突出显示模板，需要安装 IDE/Editor 的扩展。</p><p id="7628" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">在 Odi 中，由 React 支持的 JSX 用于模板化。你可以简单地用 JSX 创建组件。但是记住，这只针对模板，任何逻辑，监听器或者客户端代码在渲染的时候都会被忽略。<br/> <em class="mw">(目前，我们正在全力进行 SSR。希望很快发布)</em></p><p id="481d" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们需要告诉 TypeScript 编译器，我们将使用 React JSX。<code class="eh lm ln lo lp b">tsconfig.json</code>中的<br/></p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="e112" class="ky jd hu lp b fv ly lz l ma mb">...<br/>"jsx": "react"</span></pre><h2 id="2cb5" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">布局</h2><p id="3ecb" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">让我们创建我们的布局组件<code class="eh lm ln lo lp b">layout.view.tsx</code>，它将是所有页面的包装器。如上所述，所有模板都将在<strong class="kc hv">视图</strong>文件夹中。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="8ea1" class="ky jd hu lp b fv ly lz l ma mb">import React, { SFC } from 'react';</span><span id="8de9" class="ky jd hu lp b fv mx lz l ma mb">export const Html: SFC = ({ children }) =&gt; (<br/>    &lt;html lang="en"&gt;<br/>        &lt;head&gt;<br/>            &lt;meta charSet="UTF-8" /&gt;<br/>            &lt;meta name="viewport" /&gt;<br/>            &lt;meta httpEquiv="X-UA-Compatible" content="ie=edge"/&gt;<br/>            &lt;link href="/assets/index.css" type="text/css" ... /&gt;<br/>            &lt;title&gt; Simple chat &lt;/title&gt;<br/>        &lt;/head&gt;<br/>        &lt;body&gt;<br/>            {children}<br/>        &lt;/body&gt;</span><span id="dc4a" class="ky jd hu lp b fv mx lz l ma mb">        &lt;script src="path/to/socket.io" /&gt;<br/>        &lt;script src="/assets/index.js" /&gt;<br/>    &lt;/html&gt;<br/>)</span></pre><p id="91b4" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">对于 socket.io-client 库，我们可以使用 CDN。所以只需用下面的链接<code class="eh lm ln lo lp b">https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js</code>替换脚本标签中的<code class="eh lm ln lo lp b">path/to/socket.io</code></p><p id="e3dc" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">在第二个脚本标记中指定了客户端 js 文件。稍后我们将在<strong class="kc hv">资产</strong>文件夹中创建它。</p><h2 id="6f75" class="ky jd hu bd je kz la lb ji lc ld le jm kl lf lg jq kp lh li ju kt lj lk jy ll dt translated">聊天组件</h2><p id="dea4" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">实际上，我们的聊天需要 3 个组成部分:</p><ol class=""><li id="1ad9" class="mi mj hu kc b kd mc kh md kl mk kp ml kt mm kx mz mo mp mq dt translated">消息表示</li><li id="7960" class="mi mj hu kc b kd mr kh ms kl mt kp mu kt mv kx mz mo mp mq dt translated">控件(发送按钮、消息输入、用户名输入)</li><li id="ce06" class="mi mj hu kc b kd mr kh ms kl mt kp mu kt mv kx mz mo mp mq dt translated">聊天容器</li></ol><p id="1c26" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我认为我们可以将所有这些组件放在一个文件中，<code class="eh lm ln lo lp b">chat.view.tsx</code></p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="d8d0" class="ky jd hu lp b fv ly lz l ma mb">import React from 'react';<br/>import { Message } from './services/history.service';</span><span id="5b38" class="ky jd hu lp b fv mx lz l ma mb">export const ChatMessage = ({ username, text }: Message) =&gt; (<br/>    &lt;div&gt;<br/>        &lt;b&gt;{username}: &lt;/b&gt;<br/>        &lt;span&gt;{text}&lt;/span&gt;<br/>    &lt;/div&gt;<br/>)</span></pre><p id="e572" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们可以使用<code class="eh lm ln lo lp b">Message</code>接口作为<code class="eh lm ln lo lp b">ChatMessage</code>组件的道具类型。</p><p id="6797" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">让我们添加聊天控件。为了方便起见，使用了属性，因为我们将在客户端使用 js，而不使用任何库或框架。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="870b" class="ky jd hu lp b fv ly lz l ma mb">export const ChatControlls = () =&gt; (<br/>    &lt;div className="message-box"&gt;<br/>        &lt;input placeholder="User" id="user-input" /&gt;<br/>        &lt;input placeholder="Message" id="message-input" /&gt;<br/>        &lt;button&gt; Send &lt;/button&gt;<br/>    &lt;/div&gt;<br/>)</span></pre><p id="bbf8" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">最后一件事，聊天包装。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="97ed" class="ky jd hu lp b fv ly lz l ma mb">interface ChatProps {<br/>    messages: Message[];<br/>}</span><span id="d057" class="ky jd hu lp b fv mx lz l ma mb">export const Chat = ({ messages }: ChatProps) =&gt; (<br/>    &lt;div className="chat"&gt;<br/>        &lt;div className="container"&gt;<br/>          {messages.map(msg,i) =&gt; &lt;ChatMessage key={i} {...msg}/&gt; )}<br/>         &lt;/div&gt;<br/>        &lt;ChatControlls /&gt;<br/>    &lt;/div&gt;<br/>)</span></pre><p id="3386" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">该组件接受 props 中的一组消息(我们的历史)，以便在页面加载时呈现出来。</p><p id="cbe3" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">现在我们可以把所有东西放在一起，定义我们的页面组件<code class="eh lm ln lo lp b">page.view.tsx</code></p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="626c" class="ky jd hu lp b fv ly lz l ma mb">import React from 'react';<br/>import { Chat } from './chat.view';<br/>import { Html } from './layout.view';<br/>import { Message } from './services/history.service';</span><span id="c208" class="ky jd hu lp b fv mx lz l ma mb">interface ChatPageProps {<br/>    history: Message[];<br/>}</span><span id="14d2" class="ky jd hu lp b fv mx lz l ma mb">export const ChatPage = ({ history }: ChatPageProps) =&gt; (<br/>    &lt;Html&gt;<br/>        &lt;Chat messages={history} /&gt;        <br/>    &lt;/Html&gt;<br/>)</span></pre><p id="1c92" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">这就是我们聊天应用程序的模板。我有几行 CSS 代码，我会把它们包含在源代码中，你可以在文章的结尾找到它们。</p><p id="378f" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们可以转向控制器。</p><h1 id="0524" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">控制器</h1><p id="509d" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">控制器是一种简单而强大的路由机制。控制器方法被映射到 web 服务器路径。方法返回的值作为响应发送。</p><p id="2e5b" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">为了创建一个控制器，您必须使用<code class="eh lm ln lo lp b">@Controller</code>装饰器并继承<code class="eh lm ln lo lp b">IController</code>类。装饰器设置组件类型，因此 DI(依赖注入)容器可以检测该类的用途。</p><p id="2c52" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">对于我们的聊天，我们只需要一个控制器向客户端呈现模板。由于我们要使用 JSX 内部的控制器文件，它必须有<code class="eh lm ln lo lp b">tsx</code>文件扩展名。所以，让我们在<code class="eh lm ln lo lp b">src/controllers</code>文件夹中创建<code class="eh lm ln lo lp b">render.controller.tsx</code>。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="61b0" class="ky jd hu lp b fv ly lz l ma mb">import React from 'react';<br/>import { Controller, IController, Get, Autowired } from "odi";<br/>import { ChatPage } from '../../views/page.view';<br/>import HistoryService from '../services/history.service';</span><span id="60e2" class="ky jd hu lp b fv mx lz l ma mb">@Controller()<br/>export default class RenderController extends IController {</span><span id="a327" class="ky jd hu lp b fv mx lz l ma mb">    @Autowired()<br/>    history: HistoryService;</span><span id="f943" class="ky jd hu lp b fv mx lz l ma mb">    @Get index() {<br/>        return &lt;ChatPage history={this.history.getMessages()}/&gt;;<br/>    }<br/>}</span></pre><p id="a207" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">如您所见，我们将<code class="eh lm ln lo lp b">HistoryService</code>注入到<code class="eh lm ln lo lp b">history</code>属性中。此外，使用<code class="eh lm ln lo lp b">Get</code>方法定义了<code class="eh lm ln lo lp b">/</code>路径的处理程序。我们可以简单地返回我们的 JSX 组件。结果，Odi 自动检测到它是一个模板，并将其作为简单的 HTML 呈现给客户端(web 浏览器)。</p><h1 id="2bca" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">启动应用程序</h1><p id="c8e0" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">现在，我们可以开始我们的应用程序，看看我们得到了什么。让我们在<code class="eh lm ln lo lp b">package.json</code>文件中指定<code class="eh lm ln lo lp b">start</code>脚本:</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="99b1" class="ky jd hu lp b fv ly lz l ma mb">"scripts": {<br/>    "start": "tsc &amp;&amp; node build/src/index.js"<br/>}</span></pre><p id="f0e2" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">运行<code class="eh lm ln lo lp b">npm start</code>命令编译我们的源代码并运行服务器入口文件。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/a66aed3fd65fa9e73f4e8b17e406b737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MOMjK0wTD3qdXbVLot83qQ.png"/></div></div></figure><p id="a6eb" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">让我们打开浏览器并检查<code class="eh lm ln lo lp b">localhost:8080</code></p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/aee7de5fd1a82facd1cfdac4b26b5a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*FW2ep25-HbxJQCpewczhPQ.png"/></div></figure><p id="5b0d" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">如您所见，我们刚刚清空了没有任何功能的聊天，因为我们没有将客户端<code class="eh lm ln lo lp b">index.js</code>指定到<strong class="kc hv">资产</strong>文件夹中。</p><h1 id="ee40" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">客户</h1><p id="8f71" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">首先，让我们获取聊天容器和控件的引用。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="1120" class="ky jd hu lp b fv ly lz l ma mb">const button = document.querySelector('button');</span><span id="d2bd" class="ky jd hu lp b fv mx lz l ma mb">const messageInput = document.querySelector('#message-input');<br/>const usernameInput = document.querySelector('#user-input');<br/>const container = document.querySelector('.container');</span></pre><p id="6109" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">当一个新消息到来时，我们需要将它作为一个子元素添加到<code class="eh lm ln lo lp b">container</code>元素中。我们需要创建表示消息的元素的函数。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="e341" class="ky jd hu lp b fv ly lz l ma mb">function createMessage({ username, text }) {<br/>    const element = document.createElement('div');<br/>    <br/>    element.innerHTML = `<br/>        &lt;b&gt;${username}: &lt;/b&gt;<br/>        &lt;span&gt;${text}&lt;/span&gt;<br/>    `;</span><span id="2086" class="ky jd hu lp b fv mx lz l ma mb">    return element;<br/>}</span></pre><p id="7cfd" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">然后，让我们连接到我们的<code class="eh lm ln lo lp b">chat</code>名称空间，并为<code class="eh lm ln lo lp b">message:new</code>事件添加事件处理程序。当激发此事件时，消息元素将被追加到容器中。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="7360" class="ky jd hu lp b fv ly lz l ma mb">const socket = io('/chat');<br/>socket.on('message:new', message =&gt; {<br/>    const messageElement = createMessage(message);<br/>    container.appendChild(messageElement);<br/>});</span></pre><p id="abc6" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">还有最后一步，<code class="eh lm ln lo lp b">onclinck</code>为我们的按钮处理程序。</p><pre class="lq lr ls lt fq lu lp lv lw aw lx dt"><span id="c389" class="ky jd hu lp b fv ly lz l ma mb">button.onclick = () =&gt; {<br/>    socket.emit('massage:send', { <br/>        text: messageInput.value, <br/>        username: usernameInput.value<br/>    });</span><span id="acae" class="ky jd hu lp b fv mx lz l ma mb">    messageInput.value = "";<br/>}</span></pre><p id="cf6e" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">我们从输入中收集数据，并将其作为<code class="eh lm ln lo lp b">message:send</code>事件发送。此外，每次发送后，消息输入文本将被清除。</p><p id="bfc3" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">现在我们可以刷新页面，看看我们得到了什么。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/0bc6f25a8572e3c457f78607d19767ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eUyiuOZdH4Fe55QAHhb5yQ.gif"/></div></div></figure><p id="1fff" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">刷新页面后，我们将拥有消息的历史记录。</p><h1 id="bcc3" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">沙箱</h1><p id="3bdb" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">您可以在这里查看源代码并与应用程序进行交互:</p><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="nd ne l"/></div></figure><h1 id="24e5" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">附言（同 postscript）；警官（police sergeant）</h1><p id="bee9" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">谢谢你的阅读！如果你喜欢 Odi，请在<a class="ae my" href="https://github.com/Odi-ts/odi" rel="noopener ugc nofollow" target="_blank"> GitHub Odi </a>上支持我们</p><p id="48bc" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">此外，如果您想了解更多信息，可以查看以前的文章和文档:</p><ol class=""><li id="c128" class="mi mj hu kc b kd mc kh md kl mk kp ml kt mm kx mz mo mp mq dt translated"><a class="ae my" href="https://odi.gitbook.io" rel="noopener ugc nofollow" target="_blank">文件</a></li><li id="41ab" class="mi mj hu kc b kd mr kh ms kl mt kp mu kt mv kx mz mo mp mq dt translated"><a class="ae my" rel="noopener" href="/@dantsk/odi-ddd54848c1c3">第一篇</a></li><li id="7d5d" class="mi mj hu kc b kd mr kh ms kl mt kp mu kt mv kx mz mo mp mq dt translated"><a class="ae my" rel="noopener" href="/@dantsk/odi-jsx-openapi-and-more-ca67555527b">第二篇</a></li></ol><p id="2d30" class="pw-post-body-paragraph ka kb hu kc b kd mc kf kg kh md kj kk kl me kn ko kp mf kr ks kt mg kv kw kx hn dt translated">如果你有任何想法或问题，请随时离开！非常感谢！:)</p></div></div>    
</body>
</html>