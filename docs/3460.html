<html>
<head>
<title>Calculating Derived State in JavaScript Using Selectors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用选择器计算 JavaScript 中的派生状态</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/calculating-derived-state-in-javascript-using-selectors-7f6ce06ac247#2019-06-04">https://medium.com/hackernoon/calculating-derived-state-in-javascript-using-selectors-7f6ce06ac247#2019-06-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/17378074a381591cea67e0fd0a5d0f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6F73W2zrdny0ul7aVkhZg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Knowledge based on information based on data</figcaption></figure><p id="cd08" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">状态管理具有挑战性。我们可以通过确保不在状态中存储任何冗余信息来降低难度。我什么意思？假设在我们的程序中，我们需要确定是否允许人们进入我们的酒吧。我们可以通过检查这个人的几个属性来确定这一点:我们可以看他或她的年龄(任何 21 岁或以上的人都可以进入酒吧)，或者我们可以看他或她是否是酒吧的员工(所有酒吧员工都可以进入，无论年龄大小)。现在，我们可以将所有这些信息存储在状态对象中:</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="7418" class="kn ko hu kj b fv kp kq l kr ks">const state = {<br/>  name: "Joe",<br/>  age: 15,<br/>  employee: false,<br/>  allowedIn: false<br/>};</span></pre><p id="55d5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里的问题是,<code class="eh kt ku kv kj b">allowedIn</code>可以很容易地从<code class="eh kt ku kv kj b">age</code>和<code class="eh kt ku kv kj b">employee</code>道具中导出，这意味着从技术上讲，这些信息是多余的。这是最有问题的，因为它为我们的国家提供了自相矛盾的机会。</p><p id="f570" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt">***</p><h2 id="5b33" class="kn ko hu bd kw kx ky kz la lb lc ld le jr lf lg lh jv li lj lk jz ll lm ln lo dt translated">通过注册我的免费时事通讯，在您的收件箱中获得快速 JavaScript 技巧！</h2><figure class="ke kf kg kh fq iv"><div class="bz el l di"><div class="lp lq l"/></div></figure><p id="8355" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt">***</p><h1 id="e685" class="lr ko hu bd kw ls lt lu la lv lw lx le ly lz ma lh mb mc md lk me mf mg ln mh dt translated">介绍选择器</h1><p id="8f0f" class="pw-post-body-paragraph jg jh hu ji b jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd hn dt translated">我们可以使用选择器来解决这个问题。选择器是以<code class="eh kt ku kv kj b">state</code>为属性并返回派生状态值的函数。让我们看看是否可以创建一个选择器来替换我们的<code class="eh kt ku kv kj b">allowedIn</code>属性。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="82da" class="kn ko hu kj b fv kp kq l kr ks">const state = {<br/>  name: "Joe",<br/>  age: 15,<br/>  employee: false<br/>};</span><span id="6d7d" class="kn ko hu kj b fv mn kq l kr ks">const allowedIn = state =&gt; state.age &gt;= 21 || state.employee;</span></pre><p id="92d0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在我们看到，如果我们需要确定这个人是否被允许进入我们的酒吧，我们可以简单地使用调用<code class="eh kt ku kv kj b">allowedIn(state)</code>的布尔结果！</p><h1 id="41c9" class="lr ko hu bd kw ls lt lu la lv lw lx le ly lz ma lh mb mc md lk me mf mg ln mh dt translated">使用可组合选择器深入探索</h1><p id="8b6f" class="pw-post-body-paragraph jg jh hu ji b jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd hn dt translated">如果我们有一些更复杂的需求呢？也许我们需要根据他们是否被允许进入酒吧<em class="mo">和</em>做出一个叫做<code class="eh kt ku kv kj b">highFiveThem</code>的决定，他们是友好的。让我们首先假设我们有一个新的状态对象，其中包括他们是否友好。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="8415" class="kn ko hu kj b fv kp kq l kr ks">const state = {<br/>  name: "Judy",<br/>  age: 22,<br/>  employee: false,<br/>  isFriendly: true<br/>};</span></pre><p id="b326" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的决定不再仅仅基于我们的状态对象，还基于另一个选择器的结果。这是我们开始使用高阶函数从其他选择器合成选择器的地方。让我们看看这在实践中是如何工作的，然后我们可以在引擎盖下窥视一下。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="6050" class="kn ko hu kj b fv kp kq l kr ks">const state = {<br/>  name: "Judy",<br/>  age: 22,<br/>  employee: false,<br/>  isFriendly: true<br/>};</span><span id="6467" class="kn ko hu kj b fv mn kq l kr ks">const allowedIn = state =&gt; state.age &gt;= 21 || state.employee;<br/>const isFriendly = state =&gt; state.isFriendly;</span><span id="cf72" class="kn ko hu kj b fv mn kq l kr ks">const highFiveThem = createSelector(<br/>    allowedIn,<br/>    isFriendly,<br/>    (allowedIn, isFriendly) =&gt; allowedIn &amp;&amp; isFriendly;<br/>)</span><span id="2bad" class="kn ko hu kj b fv mn kq l kr ks">highFiveThem(state);<br/>// true</span></pre><p id="b15b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这实际上将计算<code class="eh kt ku kv kj b">allowedIn(state)</code>和<code class="eh kt ku kv kj b">isFriendly(state)</code>选择器的结果，并将这些输入传递给<code class="eh kt ku kv kj b">createSelector</code>的最终函数。</p><p id="8c40" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">理论上，让我们看看这个高阶函数是如何工作的。</p><pre class="ke kf kg kh fq ki kj kk kl aw km dt"><span id="33d0" class="kn ko hu kj b fv kp kq l kr ks">const createSelector = (...funcs) =&gt; {<br/>  const last = funcs.pop();<br/>  return state =&gt; {<br/>    const inputs = funcs.map(func =&gt; func(state));<br/>    return last(...inputs);<br/>  };<br/>};</span></pre><p id="61f9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">工作原理:</p><ul class=""><li id="02de" class="mp mq hu ji b jj jk jn jo jr mr jv ms jz mt kd mu mv mw mx dt translated"><code class="eh kt ku kv kj b">createSelector</code>函数接受任意数量的<code class="eh kt ku kv kj b">funcs</code>。</li><li id="af33" class="mp mq hu ji b jj my jn mz jr na jv nb jz nc kd mu mv mw mx dt translated">我们创建一个名为<code class="eh kt ku kv kj b">last</code>的变量来存储传递给<code class="eh kt ku kv kj b">createSelector</code>的最后一个函数，因为这个函数将使用所有先前函数的结果。</li><li id="6d0d" class="mp mq hu ji b jj my jn mz jr na jv nb jz nc kd mu mv mw mx dt translated">我们返回一个函数(我们的新选择器！).</li><li id="5eaf" class="mp mq hu ji b jj my jn mz jr na jv nb jz nc kd mu mv mw mx dt translated">每当执行该函数时，我们映射所有的输入函数，根据传递的<code class="eh kt ku kv kj b">state</code>来确定它们的结果。</li><li id="55c4" class="mp mq hu ji b jj my jn mz jr na jv nb jz nc kd mu mv mw mx dt translated">给定前面所有函数的结果，我们返回我们的<code class="eh kt ku kv kj b">last</code>函数的值。</li></ul><p id="f9a0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">很漂亮吧？</p><h1 id="3a52" class="lr ko hu bd kw ls lt lu la lv lw lx le ly lz ma lh mb mc md lk me mf mg ln mh dt translated">关于效率的思考</h1><p id="d7db" class="pw-post-body-paragraph jg jh hu ji b jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd hn dt translated">许多选择器库(例如，为 Redux 重新选择)包括附加功能来记忆选择器结果。这是因为如果选择器的输入没有根本改变，那么重新计算选择器是低效的。在这里映射我们的记忆功能有点超出范围，但是请记住，由于这种优化，使用其中一个库可能是有益的(相对于使用您自己的选择器解决方案)。</p><h1 id="e233" class="lr ko hu bd kw ls lt lu la lv lw lx le ly lz ma lh mb mc md lk me mf mg ln mh dt translated">谢谢！</h1><p id="2b7e" class="pw-post-body-paragraph jg jh hu ji b jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd hn dt translated">喜欢这篇文章吗？请为它鼓掌👏(还是 50！)来帮助传播消息！另外，欢迎在<a class="ae nd" href="https://twitter.com/nas5w" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae nd" href="https://github.com/nas5w" rel="noopener ugc nofollow" target="_blank"> Github </a>上关注我，了解更多(通常是 JavaScript 相关的)编程想法。</p></div></div>    
</body>
</html>