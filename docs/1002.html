<html>
<head>
<title>React Hooks — Slower than HOC?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子——比 HOC 慢？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-hooks-slower-than-hoc-ff105586036#2019-02-10">https://medium.com/hackernoon/react-hooks-slower-than-hoc-ff105586036#2019-02-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4487" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，备受期待的 React Hooks API 已经正式发布，我终于能够将它的执行速度与以前的 HOCs 进行比较了。而结果让我大吃一惊！</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/860847d4e57c54bc9338614add1cf569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TG28-cSxSs-i4knJ-V5amg.png"/></div></div></figure><p id="377c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在对闪亮的新鱼钩的兴奋中，值得信赖的老鱼钩可能已经被不必要的诋毁了。我马上会说，我的简单基准测试表明 HOCs 可能仍然更快，尽管最近它被指责为“包装地狱”。当然，如果你发现我的测试有缺陷，我会感谢被纠正。</p><h1 id="94e1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">测试应用程序</h1><p id="77a9" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我设计了一个基本的测试应用程序，它可以呈现 10，000 个具有 3 个状态值的功能组件实例，并在第一次呈现后设置 3 个状态值。主组件记录从根组件的实例化到它完成呈现 10，000 个项目所经过的时间。为此，它还使用了一种效果。</p><p id="b329" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后我创建了测试应用的两个版本，一个使用钩子，另一个使用 HOCs(使用我最近发布的<strong class="it hv">反应堆库</strong>:https://github.com/arnelenero/reactorlib#reactor-library<a class="ae le" href="https://github.com/arnelenero/reactorlib#reactor-library" rel="noopener ugc nofollow" target="_blank">)。</a></p><h2 id="887d" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">钩子版本</h2><pre class="jq jr js jt fq lt lu lv lw aw lx dt"><span id="abb7" class="lf kc hu lu b fv ly lz l ma mb">import React, { useEffect, useState } from 'react';<br/>import { render } from 'react-dom';</span><span id="61f5" class="lf kc hu lu b fv mc lz l ma mb">const array = [];<br/>for (let i = 0; i &lt; 10000; i++) array[i] = true;</span><span id="bf83" class="lf kc hu lu b fv mc lz l ma mb">const Component = () =&gt; {<br/>  const [a, setA] = useState('');<br/>  const [b, setB] = useState('');<br/>  const [c, setC] = useState('');<br/>  <br/>  useEffect(() =&gt; {<br/>    setA('A');<br/>    setB('B');<br/>    setC('C');<br/>  }, []);</span><span id="0f98" class="lf kc hu lu b fv mc lz l ma mb">  return &lt;div&gt;{a + b + c}&lt;/div&gt;;<br/>};</span><span id="2413" class="lf kc hu lu b fv mc lz l ma mb">const Benchmark = ({ start }) =&gt; {<br/>  useEffect(() =&gt; {<br/>    console.log(Date.now() - start);<br/>  });</span><span id="3f0e" class="lf kc hu lu b fv mc lz l ma mb">  return array.map((item, index) =&gt; &lt;Component key={index} /&gt;);<br/>};</span><span id="b0e7" class="lf kc hu lu b fv mc lz l ma mb">render(&lt;Benchmark start={Date.now()} /&gt;, document.getElementById('root'));</span></pre><h2 id="4cc2" class="lf kc hu bd kd lg lh li kh lj lk ll kl jc lm ln kp jg lo lp kt jk lq lr kx ls dt translated">反应堆库版本</h2><pre class="jq jr js jt fq lt lu lv lw aw lx dt"><span id="439b" class="lf kc hu lu b fv ly lz l ma mb">import React from 'react';<br/>import { render } from 'react-dom';<br/>import { compose, withState, withEffect } from '@reactorlib/core';</span><span id="b882" class="lf kc hu lu b fv mc lz l ma mb">const array = [];<br/>for (let i = 0; i &lt; 10000; i++) array[i] = true;</span><span id="f2db" class="lf kc hu lu b fv mc lz l ma mb">const _Component = ({ a, b, c }) =&gt; {<br/>  return &lt;div&gt;{a + b + c}&lt;/div&gt;;<br/>};</span><span id="cf38" class="lf kc hu lu b fv mc lz l ma mb">const Component = compose(<br/>  withState({<br/>    a: '',<br/>    b: '',<br/>    c: ''<br/>  }),<br/>  withEffect(({ setA, setB, setC }) =&gt; {<br/>    setA('A');<br/>    setB('B');<br/>    setC('C');<br/>  }, true)<br/>)(_Component);</span><span id="c546" class="lf kc hu lu b fv mc lz l ma mb">const _Benchmark = () =&gt; {<br/>  return array.map((item, index) =&gt; &lt;Component key={index} /&gt;);<br/>};</span><span id="0d39" class="lf kc hu lu b fv mc lz l ma mb">const Benchmark = compose(<br/>  withEffect(({ start }) =&gt; {<br/>    console.log(Date.now() - start);<br/>  })<br/>)(_Benchmark);</span><span id="51e6" class="lf kc hu lu b fv mc lz l ma mb">render(&lt;Benchmark start={Date.now()} /&gt;, document.getElementById('root'));</span></pre><h1 id="5986" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">测试设置</h1><p id="2d3f" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">测试是在 2015 年初运行 MacOS Sierra 10.12.3 和 Chrome 71 的 12 英寸 Macbook (1.1GHz Core M，8GB RAM)上进行的。</p><p id="8d84" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">两个版本都在 React 16.8.1 上。</p><h1 id="b1f4" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">测试结果</h1><p id="7219" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">我获得了在 MacOS Chrome 上进行 10 次测试的结果，所有结果都显示出明显的赢家。</p><pre class="jq jr js jt fq lt lu lv lw aw lx dt"><span id="91d1" class="lf kc hu lu b fv ly lz l ma mb">Rendering Time in milliseconds</span><span id="cb28" class="lf kc hu lu b fv mc lz l ma mb">Run#     Hooks        HOCs<br/>-----------------------------<br/> 1       2197         1440<br/> 2       2302         1757<br/> 3       2749         1407<br/> 4       2243         1309<br/> 5       2167         1644<br/> 6       2219         1516<br/> 7       2322         1673<br/> 8       2268         1630<br/> 9       2164         1446<br/>10       2071         1597</span></pre><p id="33ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是不要相信我的话。你可以运行我上面贴的两个版本，自己看看。</p><h1 id="47a8" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="13a3" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">如果渲染速度的差异对您的用例至关重要(例如组件的循环实例)，这些数字表明您可能需要重新考虑使用 hoc。但是，对于典型的用例，这种差异可能不足以影响您的决策。</p><h1 id="938d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">其他考虑</h1><p id="f9dd" class="pw-post-body-paragraph ir is hu it b iu kz iw ix iy la ja jb jc lb je jf jg lc ji jj jk ld jm jn jo hn dt translated">在 Hooks 和 HOC 之间做出选择可能并不像我们最初认为的那样容易。除了我在这里提到的，还有其他因素会影响这个选择，比如您的代码重用的特定策略。好消息是，我们不会被迫只选择其中之一；我们可以两者都用，仔细判断哪些组件应该优先于另一个。</p><p id="8593" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在你需要 hoc 的地方，你可能想看看我的反应堆库(【https://github.com/arnelenero/reactorlib#reactor-library】<a class="ae le" href="https://github.com/arnelenero/reactorlib#reactor-library" rel="noopener ugc nofollow" target="_blank"/>)。不，不仅仅是功能组件的问题；它还有很多其他的东西可以帮助你简化 React/Redux 开发。请随意使用，它既是你的也是我的。</p></div></div>    
</body>
</html>