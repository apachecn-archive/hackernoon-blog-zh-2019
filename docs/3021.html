<html>
<head>
<title>Staging Environments Are Overlooked — Here’s Why They Matter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">暂存环境被忽略了—这就是它们重要的原因</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/staging-environments-are-overlooked-heres-why-they-matter-2082d2ee274a#2019-05-14">https://medium.com/hackernoon/staging-environments-are-overlooked-heres-why-they-matter-2082d2ee274a#2019-05-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0f17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">许多开发团队忽略了为他们的应用程序准备一个登台环境。他们提交一个 PR，可能在 CI 系统中运行测试，合并到 master，然后部署到生产中。这是一个有风险的管道，因为没有真正的集成环境或正在执行的集成测试。更糟糕的是，如果出现问题，他们可能会进行“牛仔编码”，试图在他们的实际生产环境中解决问题。</p><p id="dce8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本文中，我们将讨论在您的软件开发生命周期中使用登台环境的一些优势，以及它们如何帮助确保您期望的产品被交付到生产中。</p><h1 id="0afc" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">什么是分期环境，真的吗？</h1><p id="6849" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">登台环境是您在软件开发和部署过程中部署到的另一个环境。在部署到生产环境之前，先部署到临时环境。</p><p id="c681" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">暂存环境通常意味着与生产环境完全相同或几乎完全相同。这意味着它们具有相同的硬件、软件和配置。您越接近这一点，您的登台环境就越有用。</p><p id="982a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了更好地模拟真实世界的生产环境，登台环境甚至可能具有匿名的或完整的生产数据集。这意味着通常不会向您的生产用户群发布或提供登台环境，而是向内部或试点用户群提供。</p><p id="7d9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了控制成本，您可以作为发布周期的一部分部署到您的临时环境中，然后在发布进入生产环境后将其拆除。</p><p id="17d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法为您提供了发现任何代码质量问题、更高层次的数据质量问题、集成问题和/或其他依赖问题的能力，这些问题在集成测试环境或较低的本地或开发环境中是不存在或不明显的。</p><p id="9aa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种方法还使您能够高度自信地预测您的生产部署是否会成功，允许您回答诸如“我们编写的新服务在生产中启动时会挂起吗？”例如，如果我们使用的库在我们的计算机上工作，但在我们用来部署的 Linux VM 上工作不一样。</p><p id="9c6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用试运行环境迫使您验证您在开发过程中做出的所有假设，并确保您已经进行了确保部署成功所必需的相关思考练习。</p><h1 id="2feb" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">使用暂存环境的传统部署</h1><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/8997bfdc4c7555c188d6e5dbb0630bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*K3cSSEbtfSZTaZfe"/></div></figure><h1 id="600b" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">部署而不试运行的风险</h1><p id="fe65" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">无论如何，本地测试或运行单元测试都不是对产品质量和功能的充分检验。单元测试是由人类编写的，人类是会犯错误的。如果你只测试已知的问题，那么你不能覆盖你不知道的问题。</p><p id="4a10" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">人们经常忘记跨越服务边界的变更，或者掩盖与上游用户和数据库迁移的依赖性。有时，您正在使用的库可能在本地机器上工作，但在云中可能不工作，并且您唯一能发现依赖失败的时候，就是您部署到生产环境的时候。</p><p id="6b17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">通常，在较低环境中测试的数据集是生产环境中不切实际的模拟。有些人可能认为在使用 canary 或 blue/green 部署时没有必要使用暂存环境，因为问题会在早期被发现，但是您仍然会将用户暴露在错误和错误配置面前。</p><p id="a0a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总而言之，这将用户暴露于潜在的破坏性更改，并且根据更改的级别，它可能会影响生产数据或其他相关服务和流程。</p><p id="24a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">依靠信念和希望作为策略来确保成功的生产部署将不可避免地带来对您的产品质量产生负面看法的风险，并最终导致销售损失、客户流失以及可能违反您的客户 SLA。</p><p id="bfaf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与这些类型的部署或代码失败相关的成本包括:</p><ul class=""><li id="0276" class="la lb hu it b iu iv iy iz jc lc jg ld jk le jo lf lg lh li dt translated">必须提供即时修补程序</li><li id="4f91" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">回滚版本</li><li id="01ab" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">对开发时间表的影响</li><li id="d0f2" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">潜在的数据丢失</li><li id="e0f6" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">负面用户体验影响</li><li id="65e7" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">错过的 SLA</li><li id="a2b4" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">声誉/品牌风险</li><li id="0e9b" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">交易/销售损失</li><li id="bc8a" class="la lb hu it b iu lj iy lk jc ll jg lm jk ln jo lf lg lh li dt translated">流失的客户</li></ul><p id="3826" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用暂存环境的好处是更高程度的质量保证和客户满意度。</p><h1 id="fc18" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">三个真实世界的场景</h1><p id="69c2" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们浏览一些潜在的场景，如果您使用暂存环境，这些场景可以很容易地避免。我们正在与马克·查韦斯开发的名为<a class="ae lo" href="https://bitcoinpriceindex.netlify.com/" rel="noopener ugc nofollow" target="_blank">比特币价格指数</a>的应用合作。这是一个简单的基于 React 的应用程序，它将用户连接到<a class="ae lo" href="https://www.coindesk.com/" rel="noopener ugc nofollow" target="_blank"> CoinDesk </a> API，根据所选货币提供比特币价格的趋势信息。</p><h2 id="c691" class="lp jq hu bd jr lq lr ls jv lt lu lv jz jc lw lx kd jg ly lz kh jk ma mb kl mc dt translated">1.不正确的服务 URL</h2><p id="fa4d" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">在我们的第一个场景中，当在我们较低的(开发/本地)环境中执行开发时，我们将我们的应用指向一个模拟 CoinDesk API 服务，以减少我们的 API 使用和控制成本。在部署到生产环境之前，这个 URL 应该指向真正的 CoinDesk API。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff md"><img src="../Images/2909afe1d9205c3e17dac6ff4e8e8a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XNPJPh68zY4-RAvy"/></div></div></figure><p id="533f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如您在上面看到的，这个模拟 URL 不知何故进入了我们的主服务应用程序代码。(我知道这是一种不好的做法，但这种情况比你想象的要经常发生！)</p><p id="9067" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一突破性的变化在开发人员环境中可以无缝地工作，因为模拟 URL 可能已经在开发人员的网络中可用。在模拟生产的阶段环境中，服务依赖性不会存在，这种突破性的变化会在直接进入生产之前被发现。</p><p id="3fae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就是拥有一个阶段环境的主要价值:通过提供一个镜像环境来测试和验证您的变更，防止您的重大变更直接进入生产环境。</p><h2 id="ea96" class="lp jq hu bd jr lq lr ls jv lt lu lv jz jc lw lx kd jg ly lz kh jk ma mb kl mc dt translated">2.源代码控制和审查中的错误</h2><p id="3695" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">让我们看另一个例子:两个开发人员提交了具有相同样式名的新特性，但是在 CSS 文件的不同行中。在每个开发人员的单个特性分支中，风格和后续产品看起来都和预期的一样。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff mi"><img src="../Images/779e4098f8ec4c3268ae574fd6c00bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Fq5YIcBKzfwPbAsiXJhDQ.png"/></div></div></figure><p id="fc8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">合并部署到生产的变更</strong></p><p id="3036" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，当每个开发人员发出 pull 请求以将其合并回开发中时，重叠的样式在评审期间不会被挑选出来，因为它们在不同的 pull 请求中。它们被错误地合并并部署到生产中。最终结果使产品处于不理想的状态。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/8782d86f4f4ab80fee4c32bfd707755a.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*v20CMi82AFTvwChY418TAg.png"/></div></figure><h2 id="7b24" class="lp jq hu bd jr lq lr ls jv lt lu lv jz jc lw lx kd jg ly lz kh jk ma mb kl mc dt translated">3.未满足的依赖性</h2><p id="92d3" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">最后，让我们深入到老开发者的表述<em class="mk">“它在我的机器上工作”。</em></p><p id="1233" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这里，一名开发人员将<a class="ae lo" href="https://www.imagemagick.org/" rel="noopener ugc nofollow" target="_blank"> imagemagick </a>添加到堆栈中，以处理上传到网站的个人资料图像的修改。关联的 NPM imagemagick 库"<a class="ae lo" href="https://www.npmjs.com/package/imagemagick" rel="noopener ugc nofollow" target="_blank"> imagemagick </a>"已安装并保存到 package.json，<em class="mk">，但底层的</em><a class="ae lo" href="https://imagemagick.org/script/command-line-processing.php" rel="noopener ugc nofollow" target="_blank"><em class="mk">imagemagick-CLI</em></a><em class="mk">只安装在开发人员的机器上。</em></p><p id="6dbe" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，在本地测试时，该功能完全按照预期工作，但是当推向生产时，该功能不起作用，并且在日志中产生以下错误。</p><p id="9708" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="mk">错误:命令失败:CreateProcessW:系统找不到指定的文件</em></p><p id="bb1d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果没有一个临时环境，这种类型的问题更容易一直出现在生产中。</p><p id="7c3f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所有这些例子的最终现实是，它们都是完全可以避免的错误。这些错误不可避免地会发生，如果没有试运行环境，在生产之前可能不会被发现。随着您的应用程序变得越来越复杂，出现这类错误的可能性也会呈指数级增长。</p><p id="40ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用暂存环境作为 SDLC 和部署生命周期的一部分，可以降低这些错误成为公开错误或私人错误的风险。</p><h1 id="1062" class="jp jq hu bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">暂存环境不需要复杂</h1><p id="39bf" class="pw-post-body-paragraph ir is hu it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hn dt translated">不使用暂存环境的一个常见借口是它们设置起来太复杂或成本太高。这是有一定道理的，因为它们可能是额外的费用。相关的开发操作可能是一项成本高昂的工作，并且转移环境的设置可能与您的生产环境一样困难。如果没有自动化流程来简化我们的流程，我们将不得不调配与我们的生产环境完全相同的机器或容器，然后手动部署它们。</p><p id="30be" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现代云平台提供了根据需要启动暂存环境的能力，并允许您自动将其部署为标准部署管道的一部分。一旦自动化到位，时间就不再是借口。</p><p id="db32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最简单的开始方式是采用现代云提供商及其 DevOps 工具链，如<a class="ae lo" href="https://devcenter.heroku.com/articles/pipelines" rel="noopener ugc nofollow" target="_blank"> Heroku Pipelines </a>，这可以使部署暂存环境变得更容易，甚至更具成本效益，而且相对来说更容易。</p><figure class="kt ku kv kw fq kx fe ff paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="fe ff ml"><img src="../Images/5d545474e0dbbf8970a4b82464cf3e71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UNzSF9Owdyml7_rL"/></div></div></figure><p id="01f1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当你提交一个拉取请求时，Heroku 会自动启动一个审核应用程序，当你将它合并到你的主分支机构时，它们会创建一个暂存环境。一旦您验证了应用程序，升级到生产就像点击一个按钮一样简单。</p><p id="11cf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自动部署暂存环境的替代方法包括代码形式的基础设施和容器编排解决方案，如 Terraform 或 Kubernetes。</p><p id="4ec3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终，使用一个阶段化的环境可以帮助你接受现代的软件开发和发布方法来提高你的团队的生产力。更重要的是，它有助于提高您交付给客户的产品质量。</p></div></div>    
</body>
</html>