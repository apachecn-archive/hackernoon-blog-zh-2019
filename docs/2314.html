<html>
<head>
<title>Start Using Superior Image Compression Today</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">立即开始使用高级图像压缩</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/start-using-superior-image-compression-today-932e8e086b72?source=collection_archive---------4-----------------------#2019-04-11">https://medium.com/hackernoon/start-using-superior-image-compression-today-932e8e086b72?source=collection_archive---------4-----------------------#2019-04-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/032b103b92d3d5aa3b6acd2a62aa1358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDCYb3Yx8exGZVu5lLRPNw.png"/></div></div></figure><p id="ce5d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka">本文提出了新图像编解码器的使用案例，并介绍了在前端和后端使用它的库。</em></p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><h1 id="18c4" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">压缩概述</h1><p id="dcca" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">首先，为什么要用更好的压缩，网络带宽不是每年都在增加吗？为什么媒体行业<a class="ae ll" href="http://blog.chiariglione.org/forty-years-of-video-coding-and-counting/" rel="noopener ugc nofollow" target="_blank">继续推动</a>要求更高压缩比的编解码器标准？</p><p id="d7cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这有三个主要原因:</p><ul class=""><li id="fa12" class="lm ln hu je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu dt translated"><strong class="je hv">网络覆盖</strong>。虽然你在5G蜂窝附近实现了20 Gbps，但镇上有许多地方的速度根本不是那么快。</li><li id="0b8f" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated"><strong class="je hv">流量成本</strong>。即使你下载得很快，大多数电信公司也会对每一字节的数据收费。</li><li id="1623" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated"><strong class="je hv">更高的分辨率和质量</strong>。12.9英寸平板电脑至少需要<a class="ae ll" href="https://www.wolframalpha.com/input/?i=sqrt((12.9%5E2+%2F+2)+*+(655.6%5E2)+*+(16%2F9))" rel="noopener ugc nofollow" target="_blank"> 8K才能达到</a><a class="ae ll" href="https://en.wikipedia.org/wiki/Fovea_centralis#Angular_size_of_foveal_cones" rel="noopener ugc nofollow" target="_blank">人眼分辨率</a>，理想情况下无损。我们还没有到那一步。</li></ul><p id="40cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">例如，我经常在地下浏览网页，在隧道内，奇妙的LTE Advanced转换为荒谬的100 Kbit/s。在我主持并经常访问的论坛上，用户上传的照片大多没有经过任何预处理，因此通常图片需要1-4 MBs，如果你不时打开一堆照片，这就相当多了。更喜欢800×1200而不是2000×3000(导出照片的典型分辨率)会很奇怪，因为后者在高DPI显示器上看起来更好。</p><p id="8e08" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，更高的压缩率是必不可少的，但我们不是已经有了大量的解决方案吗？基于VP8格式的WebP怎么样呢？VP8格式是JPEG的替代品，最近在大多数浏览器中获得了支持。此外，还有许多其他候选标准，例如JPEG 2000、JPEG XR以及基于HEVC视频编解码标准的HEIF。</p><p id="1c96" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一件值得注意的事情是，800×1200的4 MB照片显然没有优化，即使使用普通的JPEG，我们也可以将它们压缩到500 KB，而不会损失太多的视觉质量。更有先进的JPEG编码器，如<a class="ae ll" href="https://github.com/mozilla/mozjpeg" rel="noopener ugc nofollow" target="_blank"> mozjpeg </a>和<a class="ae ll" href="https://github.com/google/guetzli" rel="noopener ugc nofollow" target="_blank"> guetzli </a>。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/72c56ba6bd4a7e2a41e0c56819c39409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0v-EzP4dqOnmulLjOltIfg.png"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">MSU Codec Comparison (April 4, 2019)</figcaption></figure><p id="d6b4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">嗯，AV1 的<a class="ae ll" href="https://jmvalin.ca/papers/AV1_tools.pdf" rel="noopener ugc nofollow" target="_blank">编码工具，由开放媒体联盟开发的新视频编码格式，似乎是目前最有希望获得最高压缩的工具，尤其是在低比特率的情况下。例如，参见</a><a class="ae ll" href="http://www.compression.ru/video/codec_comparison/hevc_2018/#hq_report" rel="noopener ugc nofollow" target="_blank">的这个</a>和<a class="ae ll" href="https://forum.doom9.org/showpost.php?p=1857587&amp;postcount=1234" rel="noopener ugc nofollow" target="_blank">的这个</a>基准。既然我们无论如何都需要重新压缩图像来获得新格式的好处，为什么不选择最好的呢？</p><blockquote class="mj mk ml"><p id="ee2c" class="jc jd ka je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated">如果你对利用AV1进行视频压缩感兴趣，可以看看我之前关于这个主题的文章。</p></blockquote><p id="af65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">AV1的另一个优势是它是一种免版税的格式，这意味着你不必向专利持有者付费。不幸的是，软件专利仍然是一个东西。像JPEG XR这样的格式没有被广泛采用主要是因为涉及到专利。因此，从技术和法律角度来看，基于AV1的解决方案都很有吸引力。</p><h1 id="c43c" class="ki kj hu bd kk kl mp kn ko kp mq kr ks kt mr kv kw kx ms kz la lb mt ld le lf dt translated">认识AVIF</h1><p id="d324" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">AVIF (AV1静止图像文件格式)是基于AV1的一种新的静止图像格式。就在最近，1.0.0 的规范发布了，而<a class="ae ll" href="https://github.com/AOMediaCodec/av1-avif/commit/67a92add6cd642a8863e386fa4db87954a6735d1" rel="noopener ugc nofollow" target="_blank">也获得了批准，这意味着它已经可以用于生产了。AVIF文件基本上是一个AV1关键帧，打包在ISOBMFF容器中，几乎与HEIF结构相同，除了使用AV1视频格式而不是HEVC。</a></p><p id="a489" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">理论上看起来很棒，但实践呢？鉴于这种格式的新颖方面，工具支持目前并不尽如人意。例如，最新版本的Chrome和Firefox支持AV1视频解码，但仍然不能显示AVIF图像，通常需要一些时间才能添加新格式。例如，参见<a class="ae ll" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1443863" rel="noopener ugc nofollow" target="_blank"> Firefox问题</a>。</p><p id="211f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编码也一样。大多数现有软件甚至不知道这种格式。所以我必须自己实现编码和解码库。有关详细信息，请参见下一节。</p><h1 id="0ffe" class="ki kj hu bd kk kl mp kn ko kp mq kr ks kt mr kv kw kx ms kz la lb mt ld le lf dt translated">编码AVIF</h1><p id="1155" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">如前所述，AVIF文件无非是ISOBMFF容器中的AV1 intra帧。所以我们可以使用任何可用的AV1编码器来产生实际的图像。</p><p id="493c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">目前可用的三款开源AV1编码器，<a class="ae ll" href="https://aomedia.googlesource.com/aom/" rel="noopener ugc nofollow" target="_blank"> libaom </a>、<a class="ae ll" href="https://github.com/xiph/rav1e" rel="noopener ugc nofollow" target="_blank"> rav1e </a>和<a class="ae ll" href="https://github.com/OpenVisualCloud/SVT-AV1" rel="noopener ugc nofollow" target="_blank"> SVT-AV1 </a>选哪个？</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mu"><img src="../Images/72bcb6eb48a61719c3642898a8903253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dxLjTisqj29Pf6P8r1oTw.png"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Comparison of intra coding efficiency</figcaption></figure><p id="e54c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由av1-bench 制作的这张图宣传libaom是一个明显的赢家:它在VMAF指标上得分最高，其最慢的编码预设实际上比竞争对手的更快，至少在我的AVX2之前的CPU上是这样。(提供libjpeg结果供参考。)这可以用SVT-AV1和rav1e中选择的速度比质量的权衡来解释。这还不错，尽管静态图像被表示为单帧视频，即使使用最慢的压缩设置，编码一帧也不需要太长时间。所以libaom应该是个不错的选择。不是说如果需要的话，我们不能通过速度控制让它更快。</p><blockquote class="mj mk ml"><p id="895c" class="jc jd ka je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated">我还用我的眼睛比较了libaom和SVT-AV1编码，因为客观指标不是唯一的事实来源。从我的主观角度来看，它与VMAF结果非常相关，尽管有时很难从两者中选择最好的。</p></blockquote><p id="5560" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以选择了AV1编码器，接下来呢？我要用AVIF的论坛后端是用Go写的，所以我需要一个该语言的库。经过一番搜索，我找到了<a class="ae ll" href="https://github.com/AOMediaCodec/av1-avif/wiki" rel="noopener ugc nofollow" target="_blank">官方avif维基</a>中提到的<a class="ae ll" href="https://github.com/joedrago/avif" rel="noopener ugc nofollow" target="_blank"> libavif C库</a>。它可能工作得很好，应该允许编写Go绑定，但是为了更好地理解这种格式，我决定自己编写一个。</p><p id="330a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于我们不会从头开始实现encoder，所以整个库可以归结为libaom cgo wrapper和pure Go ISOBMFF muxer。</p><p id="5fed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">libaom提供了典型的编码器库C API。我们需要准备帧，即将像素数据封装到库的结构中，对其运行编码功能，并返回结果。</p><p id="71e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大多数编码器都是用<a class="ae ll" href="https://en.wikipedia.org/wiki/YCbCr" rel="noopener ugc nofollow" target="_blank"> Y'CbCr颜色模型</a>操作的，而<a class="ae ll" href="https://en.wikipedia.org/wiki/Chroma_subsampling#4:2:0" rel="noopener ugc nofollow" target="_blank"> 4:2:0子采样</a>是最常见的。我正在使用标准Go库中的图像包从用户提供的图像中获取RGB像素值。它支持解码最流行的JPEG和PNG格式。像素英寸。png已经被存储为RGB和for。jpg Go会自动将它们转换成RGB。我们只需要将RGB转换成Y'CbCr BT.709 4:2:0有限范围，并可以传递给编码器。如果听起来很吓人，不用担心。该操作归结为将每个像素的R、G和B分量乘以某个系数和少量加法。</p><p id="4b9e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们需要将数据传递给libaom，我使用小型C包装器<a class="ae ll" href="https://github.com/Kagami/go-avif/blob/master/av1.c" rel="noopener ugc nofollow" target="_blank"> av1.c </a>来简化C和Go之间的互操作性。libaom的API非常简单，但是有几件事值得注意:</p><ul class=""><li id="59a4" class="lm ln hu je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu dt translated">即使是单幅图片，我们也采用两遍编码。libaom(和libvpx) <a class="ae ll" href="https://forum.doom9.org/showpost.php?p=1860083&amp;postcount=1117" rel="noopener ugc nofollow" target="_blank">以这种方式产生更好的结果</a>。</li><li id="1189" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">CRF(libaom术语中的Q模式)很好地映射到我们习惯的JPEG转换器的质量滑块。只是从0到63的范围有点不同，其中0表示无损，63表示质量最差。嗯，编解码器可能很奇怪😉</li><li id="bcb6" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">我们可以在0到8的范围内控制编码速度，4是默认的，这似乎是合理的。</li><li id="eb00" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">多线程是默认启用的，否则会太慢。行-mt并行度和4个瓦片给出了相当好的结果。</li></ul><p id="a84f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Go部分在<a class="ae ll" href="https://github.com/Kagami/go-avif/blob/master/avif.go" rel="noopener ugc nofollow" target="_blank"> avif.go </a>中可用。</p><p id="3314" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编码器部分已经完成，现在是复用器部分。集装箱的规格可在这里免费获得<a class="ae ll" href="https://standards.iso.org/ittf/PubliclyAvailableStandards/c068960_ISO_IEC_14496-12_2015.zip" rel="noopener ugc nofollow" target="_blank"/>。<a class="ae ll" href="https://standards.iso.org/ittf/PubliclyAvailableStandards/c066067_ISO_IEC_23008-12_2017.zip" rel="noopener ugc nofollow" target="_blank">这里的</a>是HEIF分机<a class="ae ll" href="https://aomediacodec.github.io/av1-avif/" rel="noopener ugc nofollow" target="_blank">这里的</a>是AVIF分机。我就不赘述了，你可以在<a class="ae ll" href="https://github.com/Kagami/go-avif/blob/master/mp4.go" rel="noopener ugc nofollow" target="_blank"> mp4.go </a>里查看最终实现，代码应该是不言自明的。实现这么多ISOBMFF盒看起来很乏味，但实际上这很有趣。</p><p id="bc37" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">整个围棋库在这里发表<a class="ae ll" href="https://github.com/Kagami/go-avif" rel="noopener ugc nofollow" target="_blank">。使用归结为<code class="eh mv mw mx my b">avif.Encode</code>调用和一点准备/错误处理样板文件:</a></p><pre class="mb mc md me fq mz my na nb aw nc dt"><span id="ddd0" class="nd kj hu my b fv ne nf l ng nh">package main<br/><br/>import (<br/>    "image"<br/>    _ "image/jpeg"<br/>    "log"<br/>    "os"<br/><br/>    "github.com/Kagami/go-avif"<br/>)<br/><br/>func main() {<br/>    if len(os.Args) != 3 {<br/>        log.Fatalf("Usage: %s src.jpg dst.avif", os.Args[0])<br/>    }<br/><br/>    srcPath := os.Args[1]<br/>    src, err := os.Open(srcPath)<br/>    if err != nil {<br/>        log.Fatalf("Can't open sorce file: %v", err)<br/>    }<br/><br/>    dstPath := os.Args[2]<br/>    dst, err := os.Create(dstPath)<br/>    if err != nil {<br/>        log.Fatalf("Can't create destination file: %v", err)<br/>    }<br/><br/>    img, _, err := image.Decode(src)<br/>    if err != nil {<br/>        log.Fatalf("Can't decode source file: %v", err)<br/>    }<br/><br/>    err = avif.Encode(dst, img, nil)<br/>    if err != nil {<br/>        log.Fatalf("Can't encode source image: %v", err)<br/>    }<br/><br/>    log.Printf("Encoded AVIF at %s", dstPath)<br/>}</span></pre><p id="18e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更多详情参见<a class="ae ll" href="https://godoc.org/github.com/Kagami/go-avif" rel="noopener ugc nofollow" target="_blank"> GoDoc文档</a>。<code class="eh mv mw mx my b">go-avif</code>还提供简单的CLI实用程序，通过控制台的单一命令将图像转换为AVIF格式。你可以在这里下载Windows、Linux和macOS的二进制文件。用法备忘单:</p><pre class="mb mc md me fq mz my na nb aw nc dt"><span id="f1fe" class="nd kj hu my b fv ne nf l ng nh"># Encode JPEG to AVIF with default settings<br/>avif -e cat.jpg -o kitty.avif</span><span id="a862" class="nd kj hu my b fv ni nf l ng nh"># Encode PNG with slowest speed and quality 15<br/>avif -e dog.png -o doggy.avif --best -q 15</span><span id="b711" class="nd kj hu my b fv ni nf l ng nh"># Fastest encoding<br/>avif -e pig.png -o piggy.avif --fast</span></pre><h1 id="e396" class="ki kj hu bd kk kl mp kn ko kp mq kr ks kt mr kv kw kx ms kz la lb mt ld le lf dt translated">解码AVIF</h1><p id="0162" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">现在我们可以生成AVIF文件，但是我们如何显示它呢？如前所述，浏览器还不支持它，我们不能简单地将新的解码器库发布到浏览器，我们受限于JavaScript和各种web APIs。</p><p id="052a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">幸运的是，在过去的十年中，浏览器供应商实现了很多这样的功能，这使得添加新的图像格式成为可能，并且几乎实现了本地集成。我特别指的是<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" rel="noopener ugc nofollow" target="_blank">服务人员</a>和<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/WebAssembly" rel="noopener ugc nofollow" target="_blank">网络组装</a>。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/4e8390346aca2d154d26f7d2e2b4cfd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*Yej1sJoCGMJ5nw_ny0bUvg.png"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Service Worker fetch interceptor (MDN docs)</figcaption></figure><p id="ee40" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第一个API提供了一种方法来拦截页面上发生的任何获取请求，并使用定制的JavaScript处理的答案进行响应。令人印象深刻，不是吗？如果没有这个特性，我们将被限制在命令式的<em class="ka">解码我的文件并在这里画出它</em>风格的库API，它当然也是可用的，但是很难看。我们，web开发人员，习惯于透明的polyfills，它将实现细节隐藏在引擎盖下，提供珍贵而干净的API。对于图像格式，这意味着能够显示它与<code class="eh mv mw mx my b">&lt;IMG&gt;</code>标签，CSS属性等。你可能已经猜到了，我将要提出的库正是使用了这种嵌入机制。</p><p id="d59d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">第二个API呢？由于格式本身还不被支持，我们还需要以某种方式解码它，也就是说，将字节转换成实际的像素来显示。嗯，JavaScript(显然)是图灵完全语言，所以完全有可能用纯JS编写任何复杂度的解码器。这实际上在过去已经演示过了，例如参见<a class="ae ll" href="https://github.com/phoboslab/jsmpeg" rel="noopener ugc nofollow" target="_blank"> JavaScript MPEG-1解码器</a>。</p><p id="4ab1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不幸的是，解码器往往计算量很大，尤其是在AV1等新格式的情况下。即使是用计算机最好的朋友语言如C和汇编语言实现的本机代码也往往很慢，因为完全可以访问SIMD指令、线程和其他东西。</p><p id="382a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最近，我们在JS land中获得了一个有用的工具，可以帮助完成这类任务。这是WebAssembly，一种新的二进制格式，旨在以接近本机的速度评估代码。</p><p id="9812" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我已经写了一篇关于在网络上使用它的文章<a class="ae ll" href="https://hackernoon.com/creating-webassembly-powered-library-for-modern-web-846da334f8fc" rel="noopener ugc nofollow" target="_blank"/>,所以这里就不赘述了。我们需要知道的是，它允许以这样的形式转换用C/C++编写的库，即它可以在网页内执行，而无需对代码进行任何更改。这尤其有用，因为已经存在很好AV1解码器。我说的是<a class="ae ll" href="https://code.videolan.org/videolan/dav1d" rel="noopener ugc nofollow" target="_blank"> dav1d </a>，当前的艺术状态</p><blockquote class="mj mk ml"><p id="659f" class="jc jd ka je b jf jg jh ji jj jk jl jm mm jo jp jq mn js jt ju mo jw jx jy jz hn dt translated">有一点值得注意，因为这个原因，我们不会用WebAssembly获得全速(<a class="ae ll" href="https://www.reddit.com/r/AV1/comments/azrxfu/aomdec_vs_dav1d_021_performance/" rel="noopener ugc nofollow" target="_blank"> &lt; 7 ms </a>每全高清帧)的原生代码。它目前是32位的，没有SIMD，没有线程(或者在标志后面)，沙盒也带来了一些开销。但是对于静止图像，100-200毫秒的延迟应该没问题。</p></blockquote><p id="fafd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要编写的唯一代码是C和JavaScript的小包装器，用于将所有东西粘合在一起。可以分别在<a class="ae ll" href="https://github.com/Kagami/dav1d.js/blob/master/dav1d.c" rel="noopener ugc nofollow" target="_blank"> dav1d.c </a>和<a class="ae ll" href="https://github.com/Kagami/dav1d.js/blob/master/dav1d.js" rel="noopener ugc nofollow" target="_blank"> dav1d.js </a>文件中看到实现。此处和npm 处<a class="ae ll" href="https://github.com/Kagami/dav1d.js" rel="noopener ugc nofollow" target="_blank">均有完整的聚合填料。</a></p><p id="e466" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">WebAssembly很酷，但是我们能做得更好吗？最敏锐的读者应该已经注意到，AVIF的AV1和视频中的完全一样，所以我们应该能够使用已经发布的HTML5视频的AV1编解码器进行解码。原来我们可以！嗯，至少在支持AV1的浏览器中，它还是前沿技术。</p><p id="7f45" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">棘手的是，我们不能将AVIF文件原样插入到<code class="eh mv mw mx my b">&lt;video&gt;</code>标签中，这根本行不通。我们需要编写ISOBMFF容器格式的解析器(demuxer ),以便提取帧(OBUs)的实际内容。然后编写一个muxer将该帧打包成可播放的. mp4视频，该视频也使用ISOBMFF容器。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nk"><img src="../Images/eba01c4fe9036a32b9d8e5966af7d6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALmYXfQ-7tZCHA9M7NggKQ.png"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">AVIF file in ISOBMFF Box Structure Viewer</figcaption></figure><p id="1d4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这原来是相当有趣和令人兴奋的任务，我的实现可以在<a class="ae ll" href="https://github.com/Kagami/avif.js/blob/master/mov.js" rel="noopener ugc nofollow" target="_blank">这里找到</a>。我建议你也浏览一下<a class="ae ll" href="https://standards.iso.org/ittf/PubliclyAvailableStandards/c068960_ISO_IEC_14496-12_2015.zip" rel="noopener ugc nofollow" target="_blank"> ISOBMFF规格</a>。MP4文件类似于XML，即具有一些属性和内容的嵌套标签，但是是二进制的。设计干净简单，我真的很喜欢。</p><p id="26dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在类型化数组中获得. mp4文件后，我们需要将其转换为blob并传递给标准视频元素。信不信由你，但事实证明这确实是一项艰巨的任务。这是因为在Service Worker内部，你不能访问DOM，也不能用<code class="eh mv mw mx my b">document.createElement</code>创建新的HTML元素。失败。</p><p id="7877" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经过一番思考，我得出了一个解决方案，这个方案让图书馆的架构变得非常笨拙。因为我们必须在接收它的同一个服务工作者中响应截取的获取事件，但是只能在主线程中处理它，所以我们将只使用消息传递来完成解码任务并返回结果。结果证明它运行得相当好。而且比dav1d的WebAssembly版本快一点，因为可以访问SIMD之类的东西。</p><p id="b101" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还有一件小事需要做。浏览器不会理解解码器返回的未压缩Y'CbCr帧。我们只能用标准<code class="eh mv mw mx my b">&lt;IMG&gt;</code>标签支持的图像数据来响应。那些是JPEG，PNG，BMP和类似的。最简单的解决方案是使用canvas组件的标准<code class="eh mv mw mx my b">toDataURL("image/jpeg")</code>方法来获取字符串形式的JPEG数据。虽然这种方式会导致质量和性能的损失，所以我实现了小的。纯JS中的bmp muxer改为:<a class="ae ll" href="https://github.com/Kagami/avif.js/blob/master/bmp.js" rel="noopener ugc nofollow" target="_blank"> bmp.js </a>。BMP可以包含未压缩的RGB像素数据，所以这只是一个写头和重新排序RGB到BGR三元组的问题。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div class="fe ff nl"><img src="../Images/ff03768f82fac9f35b55733947fabfce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*ob_t2nWLeJ2jnjuMcL2h4w.png"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">avif.js demo in Chrome for Android</figcaption></figure><p id="faba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">整个库在这里发布<a class="ae ll" href="https://github.com/Kagami/avif.js" rel="noopener ugc nofollow" target="_blank">，也在</a><a class="ae ll" href="https://www.npmjs.com/package/avif.js" rel="noopener ugc nofollow" target="_blank"> npm </a>发布。用法非常简单:</p><pre class="mb mc md me fq mz my na nb aw nc dt"><span id="5c9c" class="nd kj hu my b fv ne nf l ng nh">// Install library <br/>npm install avif.js</span><span id="064c" class="nd kj hu my b fv ni nf l ng nh">// Put this to reg.js and serve avif-sw.js from web root<br/>// Both scripts should be transpilled (either manually with e.g.<br/>// browserify or automatically by parcel)<br/>require("avif.js").register("/avif-sw.js");</span><span id="b3a2" class="nd kj hu my b fv ni nf l ng nh">// HTML<br/>&lt;body&gt;<br/>  &lt;!-- Register worker --&gt;<br/>  &lt;script src="reg.js"&gt;&lt;/script&gt;</span><span id="28eb" class="nd kj hu my b fv ni nf l ng nh">  &lt;!-- Can embed AVIF with IMG tag now --&gt;<br/>  &lt;img src="image.avif"&gt;</span><span id="511e" class="nd kj hu my b fv ni nf l ng nh">  &lt;!-- Or via CSS property --&gt;<br/>  &lt;div style="background: url(image2.avif)"&gt;<br/>    some content<br/>  &lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="d732" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你也可以在这里看到演示<a class="ae ll" href="https://kagami.github.io/avif.js/" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl kb kc hc kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hn ho hp hq hr"><p id="3041" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我只对它的一点不满意:服务人员是复杂的、脆弱的和错误电话API。例如，有关服务人员更新机制的详细信息，请参见此处的<a class="ae ll" href="https://redfin.engineering/how-to-fix-the-refresh-button-when-using-service-workers-a8e27af6df68" rel="noopener ugc nofollow" target="_blank"/>。你很容易搞乱和破坏整个网站。否则将无法获得更新版本。否则获取请求将永远挂起。不用说，所有这些事情都发生在我开发<code class="eh mv mw mx my b">avif.js</code>的时候。希望不会再有类似的问题，因为代码已经稳定了。让我们也希望web标准的作者将在服务工作者API的下一次迭代中改善这种情况。</p><h1 id="350a" class="ki kj hu bd kk kl mp kn ko kp mq kr ks kt mr kv kw kx ms kz la lb mt ld le lf dt translated">未来的想法</h1><p id="69f6" class="pw-post-body-paragraph jc jd hu je b jf lg jh ji jj lh jl jm jn li jp jq jr lj jt ju jv lk jx jy jz hn dt translated">现在开始使用AVIF的大部分工作已经完成，但仍有许多地方需要改进:</p><ul class=""><li id="0df3" class="lm ln hu je b jf jg jj jk jn lo jr lp jv lq jz lr ls lt lu dt translated">更好的压缩是很好的，但是我们如何知道当我们重新编码时原始图像的质量被保留？有各种各样的客观指标，如PSNR、SSIM或现代VMAF，但它们根本没有定义我们应该瞄准的“视觉识别”分数。即使他们会，我们应该如何映射编码器的QP到分数？</li><li id="2e31" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">我将在我的网站上收集一些关于AVIF使用率的统计数据，也许会在下一篇文章中分享。</li><li id="96eb" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">让我们期待Chrome、Firefox、Edge甚至Safari能很快增加对AVIF的原生支持。<code class="eh mv mw mx my b">avif.js</code>应该对支持旧版本仍然有用。</li><li id="100a" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">AVIF的工具可能会好得多。现在我们仅限于<a class="ae ll" href="https://github.com/AOMediaCodec/av1-avif/wiki" rel="noopener ugc nofollow" target="_blank">这一小部分AVIF感知软件。如果能在流行的图像查看器和转换器中得到支持，那就太好了。</a></li><li id="875e" class="lm ln hu je b jf lv jj lw jn lx jr ly jv lz jz lr ls lt lu dt translated">AV1解码器polyfill ( <code class="eh mv mw mx my b">dav1d.js</code>)可能<a class="ae ll" href="https://github.com/Kagami/dav1d.js/issues/1" rel="noopener ugc nofollow" target="_blank">更小更快</a>，它还没有调到最大。但是由于polyfill只是老浏览器才需要，所以没那么重要。</li></ul><figure class="mb mc md me fq iv"><div class="bz el l di"><div class="nm nn l"/></div></figure></div></div>    
</body>
</html>