# OpenAPI 规范中的安全性

> 原文：<https://medium.com/hackernoon/security-in-your-openapi-specification-94d081603950>

![](img/0c70f6c294f031234e212797120c179b.png)

## 了解 OpenAPI 2.0 和 3.0 如何在 API 开发的设计阶段将 API 安全性作为头等大事来宣传和强调。

这已经不是什么秘密了，原料药正在吞噬世界。今天有许多公司提供他们的 API 作为与系统交互的主要媒介，用户界面只是副产品，或者，无论如何，不是销售的主要产品。Stripe 和 Twilio 等公司在 2012 年引领了这场运动。

鉴于这种转变(顺便说一下，这种转变仍在发生)，API 已经开始变得越来越复杂，因此 API 开发过程也需要发展。API 已经成为一个产品，因此所有典型的团队成员和方法都被用来使产品成功。

基于 API 的产品相关性的增加需要新的工具来支持用于实现产品的人员和方法。你将如何设计一个 API，以便你可以在真正构建它之前回顾和迭代设计？设计移动应用程序时，您可以使用工具轻松创建模型，以确保在投入资源创建真正的应用程序之前，组织中的每个人都在同一页面上。

多年来，这不是 API 的事情。直到 OpenAPI 规范(以及一堆其他标准)问世。

在本文中，我们将从安全的角度回顾 OpenAPI 可以提供什么，您今天如何能够接受这些特性，并展示一些在这个领域做得非常酷的公司！

# OpenAPI 历史:什么，为什么，什么时候

open API——以前称为 Swagger——在 2010 年开始时是一个简单的开源规范，用于设计 RESTful APIs，尽管在接下来的几年里出现了其他 API 规范格式(如 RAML 和 APIBlueprint ),但 Swagger 项目成为了最受欢迎的一个。

2015 年，Swagger 项目被捐赠给 Linux 基金会，并更名为 OpenAPI 规范，微软和 IBM 加入该基金会，帮助推动该格式向前发展。他们的第一个版本是 OpenAPI 2.0，只不过是将原来的 Swagger 格式改头换面；几年后，OpenAPI 3.0 发布了一些重要的更新。

今天，OpenAPI 倡议包括了 10 多家公司，他们认识到共同努力产生一个描述 API 的标准化文档的高价值和重要性。

# OpenAPI 2.0

# 格式概述

OpenAPI 2.0 只不过是旧的 Swagger 格式，在捐赠给 Linux 基金会后更名。

OpenAPI 2.0 文档可以编写为 JSON 或 YAML 文件，它们允许您根据端点、接受和返回的有效负载、媒体类型、返回的状态代码以及可以访问 API 的服务器来定义公开的 API。

我们不会在这里查看所有这些部分。相反，我们将关注规范提供的安全特性。

# OpenAPI 2.0 的安全特性

OpenAPI 2.0 提供了一个专门的部分来声明 API 的安全特性和要求，然后在路径和操作中适当的地方使用它们。

[https://gist.github.com/01e78b4c3e70102063a8ce3ca1f70459](https://gist.github.com/01e78b4c3e70102063a8ce3ca1f70459)

在这个例子中，我们声明了两个安全定义:第一个将在指定的头中寻找 API 键(在这个例子中是 api_key)，而第二个声明了一个隐式的 oAuth2 流，需要一些特定的作用域。

OpenAPI 2.0 支持另一种称为 basic 的安全定义类型，它本质上是旧的普通 HTTP 认证格式。

OpenAPI 2.0 没有其他内置的安全定义，如果不使用供应商提供的扩展，就不可能定义自定义的安全定义。虽然这三个选项涵盖了现实世界中的大部分用例，但对于特殊情况来说，它们可能还不够。

# OpenAPI 3.0

# OpenAPI 2.0 的格式概述和改进

OpenAPI 3.0 于 2017 年发布，旨在解决 2.0 版面临的一些缺点和限制。

我们不打算把重点放在 OpenAPI 3.0 规范上，也不打算强调这两种格式之间的所有差异:互联网上有很多详细介绍这些变化的链接。相反，我们将把重点放在新版本规范中引入的安全性变化上。

# OpenAPI 3.0 的安全特性

同样，OpenAPI 2.0 在文档中有一个专用部分来声明安全定义，OpenAPI 3.0 也有一个。不同之处在于，OpenAPI 3.0 将术语改为了“安全方案”。该规范还标准化了声明规范中可以跨多条路径重用的所有部分的方式。虽然以前共享组件是开发人员的常识，但现在它们都被分组到组件键下。

此外，还添加了 OpenID Connect 支持，以及安全定义包含多个 oAuth2 流的能力(这是目前常用的功能)。

为了让大家了解安全声明是如何从 OAS2.0 变为 OAS 3.0 的，我们在前面提到过这个例子，它是为 OAS 3 编写的:

https://gist.github.com/728cfd90abf698b9b62f774ed3954831

您可以看到，现在 oAuth2 定义支持多个流，这是由 security 部分中的一个新键定义的。

# 实践:设计安全的 API

现在，让我们动手创建一个表示将在公共互联网上公开的 API 的文档。我们将经历设计阶段，以及实现代码和合同测试。

由于大多数围绕 OpenAPI 的工具仍然坚持使用 2.0 版本，这就是我们将要使用的版本。然而，我们今天将在这里展示的所有概念仍然有效。

# 创建一个 OpenAPI 规范

OpenAPI 规范文档无非是 YAML 或 JSON 文件。尽管这有效地降低了愿意写文档的新手的门槛(每个人都可以写 JSON 或 YAML 文档)，但这隐藏了规范本身的复杂性。这就是视觉设计师或其他工具真正有用的地方。

市场上有很多这样的东西。即[红绿灯](https://stoplight.io/)、[蜂场](https://apiary.io/)、[转运站](https://swagger.io/tools/swaggerhub/)。选择哪一个真的取决于你和你的需求。在任何情况下，他们都提供一个免费的计划，所以你不必支付开始。

我们将只编写一个简单的 API，它是众所周知的 PetStore 示例的精简版本。该 API 是[OAS 2](https://github.com/OAI/OpenAPI-Specification/blob/master/examples/v2.0/yaml/petstore.yaml)0 和 [3.0](https://github.com/OAI/OpenAPI-Specification/blob/master/examples/v3.0/petstore.yaml) 中官方示例的一部分。我选择这一个是因为内容本身的简单性。

# 写代码

在 API 的世界里，编写代码确实是最琐碎的部分。构建一个 API 更多的是一个概念性的工作和协作努力，而不是在你的存储库上提交东西。

出于这个原因，我们将坚持一个非常基本的例子，其代码托管在 [Glitch](https://glitch.com/edit/#!/petstore-backend) 上。对于那些不知道的人来说，Glitch 是 NodeJS 应用程序的免费托管服务。它非常适合以非常快的方式构建和发布小型应用程序。

# 测试您的 API

现在，我们真正想做的是，在开发服务器时，不断检查我们刚刚编写的实现是否与我们存储库中的规范文档同步。这就是契约测试工具发挥作用的地方；它们启动服务器的一个实例，通过浏览 OpenAPI 文档，它们向服务器发送 HTTP 请求，服务器检查状态代码和返回的有效负载。如果其中任何一项不匹配，就会导致 CI/CD 步骤失败，并且不会部署 API。你也可以把这看作 TDD 开发，最初你只有一个 OpenAPI 文档，所有的测试都失败了，因为你没有任何代码。

随着您开发 API 并添加越来越多的端点，您将开始看到测试的更多部分通过，直到您处于绿色(这意味着您覆盖了 OpenAPI 文档中声明的整个 API 表面)。

在我们刚刚做的例子中，我决定使用[棱镜](https://github.com/stoplightio/prism)，但是[德雷德](https://dredd.com/en/latest)是另一个你可以使用的棱镜。它们都支持 OpenAPI 2.0，但不幸的是，它们都不支持 OpenAPI 3.0。

这些工具的设置通常很简单，不需要任何特别的努力。

我们要做的第一件事是在机器上下载 Prism 服务器:

`curl -L https://github.com/stoplightio/prism/releases/download/v2.0.16/prism_linux_amd64 -o prism && chmod +x ./prism`

完成后，我们需要在本地启动我们的应用服务器，然后运行 Prism，提供用于发送请求的监听 URL 和用作事实来源的 OpenAPI 文档:

[https://gist.github.com/c62745e77453b74ef6b40150f1a7737c](https://gist.github.com/c62745e77453b74ef6b40150f1a7737c)

Prism 现在将读取 OpenAPI 规范文件，遍历所有路径，并按照提供的示例开始创建 HTTP 请求，或者使用 JSON 模式作为参考创建有效负载，并将它们发送到您的应用服务器。一旦响应到来，Prism 将验证状态代码以及响应的形状是否与声明的一致。如果其中任何一项不匹配，服务器将报告错误并将测试标记为失败。

注意:这些命令也应该适用于 CI/CD 环境。

# 在 Auth0 中集成您的 OpenAPI 安全规范

现在我们有了一个设计规范与实现相匹配的 API，是时候部署它了。很可能我们想要保护 API，Auth0 显然是选择之一。

Auth0 当前并不支持所有的流。以下是目前情况的分类:

*   **oAuth2** :所有的流都被支持，这是处理认证/授权的推荐方式。也可以发出基于 JSON 的令牌，而不是不透明的令牌，从而支持其他场景(比如在 web 应用程序之间传递令牌)
*   **openIdConnect** :由 Auth0 支持所有标准声明
*   **basic/http** :作为 oAuth 2.0 流的一种特殊类型得到支持。任何拥有客户端密码的客户端都可以使用 HTTP 基本身份验证方案发送此消息。公平地说，这是一种发送客户端密码的方式，而不是对该方案的完全支持；因为当你试图找到目标路径时，你的浏览器不会有任何提示
*   **apiKey** :不支持。这本身并没有正式的标准，但是这是一种通过网络发送预共享凭证的常见方式。最接近 API 密钥的身份验证方法是使用客户端凭据授予请求。

你可以看到，只要你使用的是 oAuth2.0 或者 openIdConnect，就没什么好担心的。如果你想坚持使用一些“旧”的方法，你可能会遇到麻烦，这些方法在一定程度上可以被模仿。

# 运行时集成

在这个阶段，[我们有一个后端服务器实现我们的 API，还有一个身份提供者](https://glitch.com/edit/#!/petstore-backend)(在这个例子中是 Auth0)存储我们所有的用户，并提供必要的基础设施在我们的平台上对他们进行认证和授权。我们遗漏了两个部分之间的粘合剂:一个愿意在我的应用程序中进行身份验证的用户如何被重定向到 Auth0 的服务？

您可以在您的应用程序代码中做到这一点，但是在这种情况下，它不再是声明性的，并且您的 OpenAPI 文档中关于安全性需求的更改也需要您的代码进行更改。

在 API 网关的帮助下，有可能自动化这个阶段。考虑到这个软件通常是以声明的方式配置的，并且事实上大多数时候你的 OpenAPI 文档与公开的 API 相匹配，所以在规范和 API 网关配置之间几乎有一个完美的匹配。不幸的是，到目前为止，市场上没有一个网关达到这样的集成水平。

对于对这个话题感兴趣的人，我去年 12 月做了一个演示，他的[视频发布在网上](http://youtube.com/watch?v=_bt1r_SHfaU)

# 结论

我们已经了解了作为 OpenAPI 2.0 和 3.0 规范一部分的安全特性，它们可以帮助 API 用户和开发人员在使用和构建 API 时清楚地设定期望。然后我们稍微了解了一下 API 的生命周期，正如你可能注意到的，它更多的是关于沟通，在同一页面上，关于你想要公开什么，而不是简单地写代码。这只是整个过程中的一个步骤。最后，我们探索了与身份提供者进行运行时集成的机会，现在还没有。