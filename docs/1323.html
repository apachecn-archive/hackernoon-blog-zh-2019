<html>
<head>
<title>Finding High-impact Performance Bottlenecks — Django Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">寻找高影响性能瓶颈— Django提示</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/finding-high-impact-performance-bottlenecks-django-tips-237a896e0f91?source=collection_archive---------11-----------------------#2019-02-24">https://medium.com/hackernoon/finding-high-impact-performance-bottlenecks-django-tips-237a896e0f91?source=collection_archive---------11-----------------------#2019-02-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8b99fdf1cae044ff052d4ecc44e1992a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cqQNwq67wsXFyu5B"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo from Pexels.com</figcaption></figure><h2 id="a2f7" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">如何在Django中找到对应用程序性能有很大影响的瓶颈？</h2><p id="84b3" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky hn dt translated">原载于<a class="ae kz" href="https://avilpage.com/2018/12/django-bottleneck-performance-scaling.html" rel="noopener ugc nofollow" target="_blank">https://avilpage . com/2018/12/django-through-performance-scaling . html</a></p><h2 id="6792" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">介绍</h2><p id="314a" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky hn dt translated">在优化web应用程序的性能时，一个常见的错误是从优化最慢的页面(或API)开始。除了考虑响应时间，我们还应该考虑它正在接收的流量，以确定优化顺序的优先级。</p><p id="1112" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">在本文中，我们将分析一个Django web应用程序，找到影响较大的性能瓶颈，然后开始优化它们以获得更好的性能。</p><h2 id="aca4" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">压型</h2><p id="610d" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky hn dt translated">django-silk是一个开源的分析工具，它拦截并存储HTTP请求数据。用pip安装。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="5923" class="jg jh hu lk b fv lo lp l lq lr">pip install django-silk</span></pre><p id="d61d" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">将<code class="eh ls lt lu lk b">silk</code>添加到已安装的应用程序中，并将silk中间件包含在django设置中。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="ebc8" class="jg jh hu lk b fv lo lp l lq lr">MIDDLEWARE = [<br/>    ...<br/>    'silk.middleware.SilkyMiddleware',<br/>    ...<br/>]</span><span id="8da5" class="jg jh hu lk b fv lv lp l lq lr">INSTALLED_APPS = (<br/>    ...<br/>    'silk'<br/>)</span></pre><p id="6c73" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">运行迁移，以便Silk可以创建所需的数据库表来存储配置文件数据。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="00ff" class="jg jh hu lk b fv lo lp l lq lr">$ python manage.py makemigrations<br/>$ python manage.py migrate<br/>$ python manage.py collectstatic</span></pre><p id="57fe" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">在根urlconf中包含silk urls以查看配置文件数据。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="71a1" class="jg jh hu lk b fv lo lp l lq lr">urlpatterns += [url(r'^silk/', include('silk.urls', namespace='silk'))]</span></pre><p id="82ff" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">在silk requests页面上(<a class="ae kz" href="https://avilpage.com/2018/12/django-bottleneck-performance-scaling.html#" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/silk/requests/</a>)，我们可以看到所有的请求，并按照总时间或在数据库中花费的时间对它们进行排序。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lw"><img src="../Images/48ad4a2d98fc680eaec63ff59f25dbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PmltBbP-j81rrxvf.png"/></div></div></figure><h2 id="517e" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">高影响瓶颈</h2><p id="eac8" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky hn dt translated">Silk创建了一个<code class="eh ls lt lu lk b">silk_request</code>表，其中包含了Django处理的请求的信息。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="0283" class="jg jh hu lk b fv lo lp l lq lr">$ pgcli</span><span id="e33d" class="jg jh hu lk b fv lv lp l lq lr">library&gt; \d silk_request;</span><span id="459d" class="jg jh hu lk b fv lv lp l lq lr">+--------------------+--------------------------+-------------+<br/>| Column             | Type                     | Modifiers   |<br/>|--------------------+--------------------------+-------------|<br/>| id                 | character varying(36)    |  not null   |<br/>| path               | character varying(190)   |  not null   |<br/>| time_taken         | double precision         |  not null   |<br/>...</span></pre><p id="9403" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">我们可以通过<code class="eh ls lt lu lk b">path</code>对这些请求数据进行分组，计算每条路径的请求数量、平均耗时和影响因子。由于我们考虑的是响应时间和流量，影响因子将是该路径的平均响应时间和请求数量的乘积。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="a910" class="jg jh hu lk b fv lo lp l lq lr">library&gt; SELECT<br/>     s.*, round((s.avg_time * s.count)/max(s.avg_time*s.count) over ()::NUMERIC,2) as impact<br/> FROM<br/>     (select path, round(avg(time_taken)::numeric,2) as avg_time, count(path) as count from silk_request group by PATH)<br/>     s<br/> ORDER BY impact DESC;</span><span id="8197" class="jg jh hu lk b fv lv lp l lq lr">+-------------------------+------------+---------+----------+<br/>| path                    | avg_time   | count   | impact   |<br/>|-------------------------+------------+---------+----------|<br/>| /point/book/book/       | 239.90     | 1400    | 1.00     |<br/>| /point/book/data/       | 94.81      | 1900    | 0.54     |<br/>| /point/                 | 152.49     | 900     | 0.41     |<br/>| /point/login/           | 307.03     | 400     | 0.37     |<br/>| /                       | 106.51     | 1000    | 0.32     |<br/>| /point/auth/user/       | 494.11     | 200     | 0.29     |<br/>...</span></pre><p id="cdea" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">我们可以看到<code class="eh ls lt lu lk b">/point/book/book/</code>具有最高的影响力，尽管它既不是访问量最大的视图，也不是最慢的视图。优化这个视图首先会提高web应用程序的整体性能。</p><h2 id="6e5e" class="jg jh hu bd ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd dt translated">结论</h2><p id="3cf2" class="pw-post-body-paragraph ke kf hu kg b kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky hn dt translated">在本文中，我们学习了如何分析Django web应用程序并识别瓶颈以提高性能。在下一篇文章中，我们将深入了解如何优化这些瓶颈。</p><p id="b45f" class="pw-post-body-paragraph ke kf hu kg b kh la kj kk kl lb kn ko jr lc kq kr jv ld kt ku jz le kw kx ky hn dt translated">更多关于Django的提示和技巧可以在https://avilpage.com/tags/django-tips-tricks.html<a class="ae kz" href="https://avilpage.com/tags/django-tips-tricks.html" rel="noopener ugc nofollow" target="_blank">找到</a></p></div></div>    
</body>
</html>