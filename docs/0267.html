<html>
<head>
<title>Text summarizer using deep learning made easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习的文本摘要器变得简单</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/text-summarizer-using-deep-learning-made-easy-490880df6cd?source=collection_archive---------2-----------------------#2019-01-11">https://medium.com/hackernoon/text-summarizer-using-deep-learning-made-easy-490880df6cd?source=collection_archive---------2-----------------------#2019-01-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3198b1ff066ff47b8b91bec3560b4663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kQA4ssu1AqYyoSGFDpJtig.jpeg"/></div></div></figure><p id="5218" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个系列中，我们将讨论一个真正令人兴奋的自然语言处理主题，即使用<strong class="je hv">深度学习技术来总结文本</strong>，t <a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods" rel="noopener ugc nofollow" target="_blank">这个系列的代码是开源的</a>，并且以jupyter笔记本格式存在，允许它在google colab上运行，而不需要强大的gpu，此外所有数据都是开源的，您不必下载它。 由于你可以将google colab与google drive连接，并将你的数据直接放到google drive上，而不需要下载到本地，阅读<a class="ae ka" href="https://hackernoon.com/begin-your-deep-learning-project-for-free-free-gpu-processing-free-storage-free-easy-upload-b4dba18abebc" rel="noopener ugc nofollow" target="_blank">这篇博客</a>来了解更多关于google colab与google drive的信息。</p><p id="5831" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">总结文章有两种主要方法(我真的很喜欢这篇博客中的解释)</p><ol class=""><li id="eda7" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je hv">提取方法</strong>，即从输入中选择特定的主要单词来生成输出，这种模型往往是可行的，但不会输出结构正确的句子，因为它只是从输入中选择单词并将其复制到输出中，而没有真正理解句子，请将其视为一个高亮器。</li></ol><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/cb40cde2f186d252675d32dd2981cd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*X1B2i1ctBh2KYO9m-a8paA.jpeg"/></div></figure><p id="b155" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> 2。抽象方法</strong>，这是建立一个神经网络，以真正解决输入和输出之间的关系，而不仅仅是复制单词，本系列将通过这种方法，把它想象成一支笔。</p><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff kk"><img src="../Images/d9bb9665bfb84f46b8577fe3771f3a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:200/format:webp/1*k1nQKUG8r34Esyd78aDSlA.jpeg"/></div></figure><p id="17dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个系列是为那些对学习建立一个有能力的深层网络的力量感到兴奋的人制作的</p><ul class=""><li id="9495" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kp kh ki kj dt translated">分析输入序列</li><li id="98d7" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated">理解文本</li><li id="ffe2" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated">以摘要形式输出输出序列</li></ul><p id="7e00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此命名为seq2seq，输入序列到输出序列，这是这里使用的主要算法。</p><p id="eee8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">本系列将详细介绍如何</p><ol class=""><li id="8d9e" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">在线构建你的深度学习网络，而不需要一台功能强大的计算机</li><li id="4421" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated">在线访问数据集，无需将数据集下载到您的计算机上。</li><li id="243b" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated">建立一个张量流网络来解决这个问题</li></ol><p id="f2ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在过去的几年中，已经进行了多项研究，我目前正在研究这些新方法，在这个系列中，我们将介绍其中的一些方法。</p><p id="f356" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个系列使用google colab实现它的代码，所以不需要强大的计算机来实现这些想法，我目前正在将最新的研究转换到google colab笔记本上进行研究，不需要强大的GPU就可以尝试它们，而且所有的数据都可以使用，不需要下载它们，因为我们将使用google drive和google colab，阅读<a class="ae ka" href="https://hackernoon.com/begin-your-deep-learning-project-for-free-free-gpu-processing-free-storage-free-easy-upload-b4dba18abebc" rel="noopener ugc nofollow" target="_blank">这篇博客以了解更多关于如何在google生态系统上进行深度学习的信息</a></p><p id="ce87" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有的代码都可以在<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods" rel="noopener ugc nofollow" target="_blank">的github repo </a>上获得，它包含了对一些文本污名化的开源实现的修改</p><p id="03e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些研究主要包括</p><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="fe ff kv"><img src="../Images/c1bfa4a34c95dfb5be53dba9f3473cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*1BwMlWYa5ewAt96Z-gJ8Yg.png"/></div></figure><ol class=""><li id="ea63" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">使用<strong class="je hv"> seq2seq编码器(双向lstm)解码器的实现(注意)</strong></li></ol><p id="879b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个至关重要的实现，因为它是任何近期研究的基石，现在我已经收集了实现这个概念的不同方法</p><p id="68e3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.我发现的另一个真正有趣的实现是为摘要创建新句子，并从源输入中复制，这种方法被称为<strong class="je hv">指针生成器</strong>，这里是我在google colab中对<a class="ae ka" href="https://github.com/abisee/pointer-generator" rel="noopener ugc nofollow" target="_blank">原始实现</a>的修改<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods/tree/master/Implementation%20B%20(Pointer%20Generator%20seq2seq%20network)" rel="noopener ugc nofollow" target="_blank"/></p><p id="11d0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3.我目前仍在研究的其他实现是将<a class="ae ka" href="https://github.com/yaserkl/RLSeq2Seq" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv">强化学习</strong>与深度学习</a>结合使用</p><p id="7815" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个系列的构建是为了让像我这样的新手容易理解，因为您可能是介绍最新架构的人，这些架构将被用作文本摘要的最新标准，所以让我们开始吧！！</p><p id="1082" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是对该系列的一个快速概述，我希望你喜欢它</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><figure class="kl km kn ko fq iv fe ff paragraph-image"><div class="ab fr cl ld"><img src="../Images/16577fbdd2beff9f3d1dcb3f38417358.png" data-original-src="https://miro.medium.com/v2/format:webp/1*f1B-cGJMsFxL1gZ51ZPGlA.jpeg"/></div><figcaption class="le lf fg fe ff lg lh bd b be z ek">EazyMind free Ai-As-a-service for text summarization</figcaption></figure><p id="8b81" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我在一个网站上添加了一个文本摘要模型<a class="ae ka" href="http://bit.ly/2VxhPqU" rel="noopener ugc nofollow" target="_blank"> eazymind </a>，这样你就可以实际尝试自己生成摘要(<strong class="je hv">，看看你能构建什么</strong>，它可以通过简单的api调用来调用，并且通过<a class="ae ka" href="http://bit.ly/2Ef5XnS" rel="noopener ugc nofollow" target="_blank"> python包</a>，这样文本摘要就可以很容易地集成到你的应用程序中，而不需要设置tensorflow环境的麻烦，你可以<a class="ae ka" href="http://bit.ly/2VxhPqU" rel="noopener ugc nofollow" target="_blank">免费注册</a>，并享受免费使用这个api的乐趣。</p></div><div class="ab cl kw kx hc ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="hn ho hp hq hr"><h1 id="cbe6" class="li lj hu bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf dt translated">1 -在网上建立你的深度作品</h1><figure class="kl km kn ko fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mg"><img src="../Images/09e54fbbcee94ec90a004a0c7b85be04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96ZwRlUiGylIpbsgz0m5Wg.jpeg"/></div></div></figure><p id="b094" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将使用google colab进行工作，这将使我们能够使用他们的免费gpu时间来构建我们的网络，(<a class="ae ka" href="https://hackernoon.com/begin-your-deep-learning-project-for-free-free-gpu-processing-free-storage-free-easy-upload-b4dba18abebc" rel="noopener ugc nofollow" target="_blank">这个</a>博客将为您的深度项目提供关于免费生态系统的更多见解)</p><p id="1f23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你有两个主要的选择来建立你的谷歌实验室</p><ol class=""><li id="decb" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">建立一个新的空实验室</li><li id="fd20" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated">从github构建，您可以使用这个repo，它是不同</li></ol><p id="93f8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在<a class="ae ka" href="https://hackernoon.com/begin-your-deep-learning-project-for-free-free-gpu-processing-free-storage-free-easy-upload-b4dba18abebc" rel="noopener ugc nofollow" target="_blank">这个博客</a>中找到如何做到这一点的细节</p><p id="ca23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将您的代码放在google colab上可以让您</p><ol class=""><li id="84e6" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">连接到google drive(将您的数据集放入google drive)</li><li id="b5d7" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated">自由gpu时间</li></ol><p id="b657" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在这个博客中找到如何连接google drive</p><h1 id="2eae" class="li lj hu bd lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf dt translated">2-让我们代表单词</h1><p id="8f6b" class="pw-post-body-paragraph jc jd hu je b jf mm jh ji jj mn jl jm jn mo jp jq jr mp jt ju jv mq jx jy jz hn dt translated">由于我们的任务是nlp任务，我们需要一种方法来表示单词，我们将讨论两种主要方法，</p><ol class=""><li id="eda9" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">要么为网络提供每个单词的表示，这被称为单词嵌入，它只是通过一组数字来表示某个单词，在线上有多个已经训练好的单词嵌入，其中一个是<strong class="je hv">手套向量</strong></li><li id="a432" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated">或者让网络自己理解这些表达</li></ol><h1 id="44b1" class="li lj hu bd lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf dt translated">3-使用的数据集</h1><p id="4364" class="pw-post-body-paragraph jc jd hu je b jf mm jh ji jj mn jl jm jn mo jp jq jr mp jt ju jv mq jx jy jz hn dt translated">对于此任务，我们将使用新闻及其标题形式的数据集，最流行的是使用CNN/Daily Mail数据集，新闻正文用作模型的输入，而标题将用作摘要目标输出。</p><p id="860b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些数据集可以很容易地在网上找到，我们将使用2种主要方法来使用这些数据集</p><ol class=""><li id="3b90" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">使用原始数据，并手动对其进行处理</li><li id="1535" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated">对数据使用一个<a class="ae ka" href="https://github.com/abisee/cnn-dailymail" rel="noopener ugc nofollow" target="_blank">前置版本</a>,它目前用于最近的研究</li></ol><h1 id="83ed" class="li lj hu bd lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf dt translated">4 -使用的型号</h1><p id="638e" class="pw-post-body-paragraph jc jd hu je b jf mm jh ji jj mn jl jm jn mo jp jq jr mp jt ju jv mq jx jy jz hn dt translated">在这里，我将简单地谈谈模型，如果上帝愿意，将包括在未来的系列，希望你喜欢</p><p id="9dac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods/tree/master/Implementation%20A%20(seq2seq%20with%20attention%20and%20feature%20rich%20representation)" rel="noopener ugc nofollow" target="_blank">T3 . A .角石模型T5</a></p><p id="49cf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了实现这项任务，研究人员使用了一个深度学习模型，该模型由两部分组成，一个编码器，它理解输入，并以内部表示形式表示它，并将它馈送到网络的另一部分，即解码器，</p><p id="c316" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">用于LSTM中这两个部分的主要深度学习网络，代表长短期记忆，是对rnn的修改</p><p id="575d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在编码器中，我们主要使用多层双向LSTM，而在解码器中，我们使用一种注意机制，稍后会详细介绍</p><p id="55e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods/tree/master/Implementation%20B%20(Pointer%20Generator%20seq2seq%20network)" rel="noopener ugc nofollow" target="_blank"> <strong class="je hv"> B .指针生成器</strong> </a></p><p id="67ac" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是研究人员发现了上述实现的两个主要问题，就像ACL 2017论文中讨论的那样<a class="ae ka" href="https://arxiv.org/pdf/1704.04368.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="mr">抓住重点:用指针生成器网络</em> </a>进行总结，他们有一个真正<a class="ae ka" href="http://www.abigailsee.com/2017/04/16/taming-rnns-for-better-summarization.html" rel="noopener ugc nofollow" target="_blank">令人惊叹的博客</a>你需要看看</p><p id="29fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">哪个是</p><ol class=""><li id="5f2f" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated"><strong class="je hv">网络无法复制事实</strong>(如姓名和比赛分数)因为它不复制单词，而是生成单词，所以它有时无法正确生成事实</li><li id="67a5" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated"><strong class="je hv">词语重复</strong></li></ol><p id="f608" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这项研究建立在这两个主要问题的基础上，并试图解决它们，我已经修改了它们的回购协议，以便在google colab上的jupyter笔记本中工作</p><ul class=""><li id="4a34" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kp kh ki kj dt translated"><a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods/tree/master/Implementation%20B%20(Pointer%20Generator%20seq2seq%20network)" rel="noopener ugc nofollow" target="_blank">我的修改</a></li><li id="5695" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated"><a class="ae ka" href="https://github.com/abisee/pointer-generator" rel="noopener ugc nofollow" target="_blank">他们的回购</a></li></ul><p id="e755" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> C .利用强化学习配合深度学习</strong></p><p id="3fd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我仍在研究这项工作，但这是一项真正有趣的研究，它是关于将两个字段结合在一起，它实际上在工作中使用指针生成器(像在实现B中一样)，并使用相同的数据前置版本。</p><p id="7317" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个<a class="ae ka" href="https://arxiv.org/pdf/1805.09461.pdf" rel="noopener ugc nofollow" target="_blank">是研究</a>，它使用<a class="ae ka" href="https://github.com/yaserkl/RLSeq2Seq" rel="noopener ugc nofollow" target="_blank">这个回购</a>作为它的代码</p><p id="2a1a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">他们实际上正在尝试解决基石实施的两个主要问题，即</p><ol class=""><li id="a4a2" class="kb kc hu je b jf jg jj jk jn kd jr ke jv kf jz kg kh ki kj dt translated">解码器在训练中使用(1来自编码器的输出)，(2实际汇总)，(3然后使用其当前输出用于下一个动作)，而在测试中它没有地面真实，因为我们实际上需要生成它，所以它只使用(1来自编码器的输出)(2然后使用其当前输出用于下一个动作)，这导致了<strong class="je hv">曝光问题</strong></li><li id="93b0" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kg kh ki kj dt translated">网络的训练依赖于用于测量损失的度量，该度量不同于测试中使用的度量，因为训练中使用的度量是交叉熵损失，而测试的度量(如下所述)是不可微分的度量，例如BLEU和ROUGE</li></ol><p id="53e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我目前正在一个jupyter笔记本上实现这个方法，所以如果上帝愿意，你会在不久的将来看到更多关于这个的更新。</p><h1 id="86ff" class="li lj hu bd lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf dt translated">4 —总结评估</h1><p id="db05" class="pw-post-body-paragraph jc jd hu je b jf mm jh ji jj mn jl jm jn mo jp jq jr mp jt ju jv mq jx jy jz hn dt translated">为了评估一个摘要，我们使用了一个不可微的衡量标准，如BLEU和ROUGE，他们只是试图找到输入和输出之间的共同词汇，越多越好，大多数上述方法的分数从32到38不等</p><p id="2bd7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望你喜欢这个系列的快速概述，我在这些博客中的主要重点是以简单实用的方式介绍文本摘要的主题，为你提供一个可以在任何计算机上运行的实际代码，而不需要有一个强大的GPU，并且将你连接到关于这个主题的最新研究，请通过鼓掌支持这个博客，并且不要忘记查看这些博客的<a class="ae ka" href="https://github.com/theamrzaki/text_summurization_abstractive_methods" rel="noopener ugc nofollow" target="_blank">代码</a></p><p id="2467" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在接下来的博客中，如果上帝愿意的话，我将详细介绍构建基石的实现，实际上所有的现代研究都基于它，我们将使用单词嵌入方法，我们将使用原始数据，并手动应用预处理</p><p id="64db" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">而在后来的博客中，如果上帝愿意，我们将通过现代方法，如如何能够创建一个指针生成器模型，以解决上述问题，并使用强化学习和深度学习。</p><h1 id="09e5" class="li lj hu bd lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb ml md me mf dt translated">后续教程</h1><ul class=""><li id="5b19" class="kb kc hu je b jf mm jj mn jn ms jr mt jv mu jz kp kh ki kj dt translated"><a class="ae ka" href="https://hackernoon.com/abstractive-text-summarization-tutorial-2-text-representation-made-very-easy-ef4511a1a46" rel="noopener ugc nofollow" target="_blank">文本摘要变得简单，文本表示(教程2) </a></li><li id="aa3d" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated"><a class="ae ka" href="https://hackernoon.com/tutorial-3-what-is-seq2seq-for-text-summarization-and-why-68ebaa644db0" rel="noopener ugc nofollow" target="_blank">什么是seq2seq用于文本摘要，为什么(教程3) </a></li><li id="e4bd" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/eazysum_tu4" rel="noopener ugc nofollow" target="_blank">多层双向LSTM/GRU使文本摘要变得简单(教程4) </a></li><li id="1a9b" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/2G4XCo3" rel="noopener ugc nofollow" target="_blank">波束搜索&amp;注意让文本摘要变得简单(教程5) </a></li><li id="4b66" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/2ZeEmvO" rel="noopener ugc nofollow" target="_blank">在Tensorflow的94行中构建一个抽象的文本摘要器！！(教程6) </a></li><li id="7e8a" class="kb kc hu je b jf kq jj kr jn ks jr kt jv ku jz kp kh ki kj dt translated"><a class="ae ka" href="http://bit.ly/2EhcRIZ" rel="noopener ugc nofollow" target="_blank">用于文本摘要的抽象提取方法的组合&amp;(教程7) </a></li></ul></div></div>    
</body>
</html>