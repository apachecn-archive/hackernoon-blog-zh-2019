<html>
<head>
<title>Avoiding Race Conditions when Fetching Data with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩提取数据时避免竞争情况</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/avoiding-race-conditions-when-fetching-data-with-react-hooks-220d6fd0f663?source=collection_archive---------0-----------------------#2019-04-15">https://medium.com/hackernoon/avoiding-race-conditions-when-fetching-data-with-react-hooks-220d6fd0f663?source=collection_archive---------0-----------------------#2019-04-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/61ee01831bad85ad4644517bd3a6b418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okLGlm1oBbTkR9OIm--MYA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Man jumping over clock</figcaption></figure><p id="c572" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">大约一个月前，我在Twitter上发布了一个使用React Hooks获取数据的例子。虽然本意是好的，但是Dan abro mov(React核心团队的)让我知道我的实现包含了一个竞争条件。因此，我答应写一篇博文来纠正我的实现。这就是那个帖子！</p><p id="b5e6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">注:</strong>如果这篇文章对你有帮助，请借一个拍手(或50)帮忙传播一下！👏👏</p><p id="7597" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt">***</p><h2 id="5b33" class="ke kf hu bd kg kh ki kj kk kl km kn ko jr kp kq kr jv ks kt ku jz kv kw kx ky dt translated">通过注册我的免费时事通讯，在您的收件箱中获得快速JavaScript技巧！</h2><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="8355" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt">***</p><h1 id="a10c" class="lf kf hu bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv dt translated">设置</h1><p id="672e" class="pw-post-body-paragraph jg jh hu ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">在我们的示例应用程序中，当人们的名字被点击时，我们将虚假加载他们的个人资料数据。为了帮助可视化竞争条件，我们将创建一个<code class="eh mb mc md me b">fakeFetch</code>函数，实现0到5秒之间的随机延迟。</p><pre class="kz la lb lc fq mf me mg mh aw mi dt"><span id="170c" class="ke kf hu me b fv mj mk l ml mm">const fakeFetch = person =&gt; {<br/>  return new Promise(res =&gt; {<br/>    setTimeout(() =&gt; res(`${person}'s data`), Math.random() * 5000);<br/>  });<br/>};</span></pre><h1 id="aff9" class="lf kf hu bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv dt translated">初始实施</h1><p id="9728" class="pw-post-body-paragraph jg jh hu ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">我们最初的实现将使用按钮来设置当前配置文件。我们使用<code class="eh mb mc md me b">useState</code>钩子来实现它，维护以下状态:</p><ul class=""><li id="a754" class="mn mo hu ji b jj jk jn jo jr mp jv mq jz mr kd ms mt mu mv dt translated"><code class="eh mb mc md me b">person</code>，用户选择的人</li><li id="706a" class="mn mo hu ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated"><code class="eh mb mc md me b">data</code>，根据所选人员从我们的假获取中加载的数据</li><li id="d09d" class="mn mo hu ji b jj mw jn mx jr my jv mz jz na kd ms mt mu mv dt translated"><code class="eh mb mc md me b">loading</code>，当前是否正在加载数据</li></ul><p id="c11d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们额外使用了<code class="eh mb mc md me b">useEffect</code>钩子，每当<code class="eh mb mc md me b">person</code>改变时，它执行我们的假获取。</p><pre class="kz la lb lc fq mf me mg mh aw mi dt"><span id="4948" class="ke kf hu me b fv mj mk l ml mm">import React, { Fragment, useState, useEffect } from 'react';</span><span id="8aca" class="ke kf hu me b fv nb mk l ml mm">const fakeFetch = person =&gt; {<br/>  return new Promise(res =&gt; {<br/>    setTimeout(() =&gt; res(`${person}'s data`), Math.random() * 5000);<br/>  });<br/>};</span><span id="018c" class="ke kf hu me b fv nb mk l ml mm">const App = () =&gt; {<br/>  const [data, setData] = useState('');<br/>  const [loading, setLoading] = useState(false);<br/>  const [person, setPerson] = useState(null);</span><span id="059f" class="ke kf hu me b fv nb mk l ml mm">  useEffect(() =&gt; {<br/>    setLoading(true);<br/>    fakeFetch(person).then(data =&gt; {<br/>      setData(data);<br/>      setLoading(false);<br/>    });<br/>  }, [person]);</span><span id="3a4e" class="ke kf hu me b fv nb mk l ml mm">  return (<br/>    &lt;Fragment&gt;<br/>      &lt;button onClick={() =&gt; setPerson('Nick')}&gt;Nick's Profile&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setPerson('Deb')}&gt;Deb's Profile&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setPerson('Joe')}&gt;Joe's Profile&lt;/button&gt;<br/>      {person &amp;&amp; (<br/>        &lt;Fragment&gt;<br/>          &lt;h1&gt;{person}&lt;/h1&gt;<br/>          &lt;p&gt;{loading ? 'Loading...' : data}&lt;/p&gt;<br/>        &lt;/Fragment&gt;<br/>      )}<br/>    &lt;/Fragment&gt;<br/>  );<br/>};<br/>export default App;</span></pre><p id="4e73" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果我们运行我们的应用程序并单击其中一个按钮，我们的伪fetch将按预期加载数据。</p><h1 id="3103" class="lf kf hu bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv dt translated">达到比赛条件</h1><p id="5493" class="pw-post-body-paragraph jg jh hu ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">当我们开始在人与人之间快速转换时，麻烦就来了。假设我们的假提取有一个随机延迟，我们很快就会发现我们的提取结果可能会乱序返回。此外，我们选择的配置文件和加载的数据可能不同步。那是一副糟糕的表情！</p><figure class="kz la lb lc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/5836691ae8548a1a9edd247044330bd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/0*odL0POtVf8EHjqQi.gif"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Clicking buttons quickly and hitting the race condition</figcaption></figure><p id="3a99" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这里发生的事情相对直观:<code class="eh mb mc md me b">useEffect</code>钩子内的<code class="eh mb mc md me b">setData(data)</code>只有在<code class="eh mb mc md me b">fakeFetch</code>承诺被解析后才被调用。无论哪个承诺最后解决，都将最后调用<code class="eh mb mc md me b">setData</code>，而不管哪个按钮实际上是最后调用的。</p><h1 id="4361" class="lf kf hu bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv dt translated">取消以前的提取</h1><p id="1518" class="pw-post-body-paragraph jg jh hu ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">我们可以通过“取消”任何非最新点击的<code class="eh mb mc md me b">setData</code>调用来修复这种竞争情况。我们通过在<code class="eh mb mc md me b">useEffect</code>钩子内创建一个布尔变量，并从<code class="eh mb mc md me b">useEffect</code>钩子返回一个清理函数，将这个布尔“取消”变量设置为<code class="eh mb mc md me b">true</code>来实现。当承诺解析时，只有当“取消”变量为假时，<code class="eh mb mc md me b">setData</code>才会被调用。</p><p id="b42c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果这个描述有点混乱，下面的代码示例应该会有所帮助。</p><pre class="kz la lb lc fq mf me mg mh aw mi dt"><span id="6b5b" class="ke kf hu me b fv mj mk l ml mm">useEffect(() =&gt; {<br/>  let canceled = false;</span><span id="4f65" class="ke kf hu me b fv nb mk l ml mm">  setLoading(true);<br/>  fakeFetch(person).then(data =&gt; {<br/>    if (!canceled) {<br/>      setData(data);<br/>      setLoading(false);<br/>    }<br/>  });</span><span id="6a4e" class="ke kf hu me b fv nb mk l ml mm">  return () =&gt; (canceled = true);<br/>}, [person]);</span></pre><p id="4f19" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">即使前一次按钮点击的<code class="eh mb mc md me b">fakeFetch</code>承诺稍后解决，它的<code class="eh mb mc md me b">canceled</code>变量将被设置为<code class="eh mb mc md me b">true</code>并且<code class="eh mb mc md me b">setData(data)</code>将不会被执行！</p><p id="6117" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们来看看我们的新应用程序是如何运行的:</p><figure class="kz la lb lc fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nc"><img src="../Images/fe5e368a11ef7d07f04771704dc2ddbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/0*rX3F44hi5ppWivEV.gif"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Clicking buttons quickly and avoiding the race condition</figcaption></figure><p id="c22f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">完美——无论我们点击不同的按钮多少次，我们将总是只看到与最后一次按钮点击相关的数据。</p><h1 id="d1e1" class="lf kf hu bd kg lg lh li kk lj lk ll ko lm ln lo kr lp lq lr ku ls lt lu kx lv dt translated">完整代码</h1><p id="94e3" class="pw-post-body-paragraph jg jh hu ji b jj lw jl jm jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd hn dt translated">这篇博文的完整代码可以在下面找到:</p><pre class="kz la lb lc fq mf me mg mh aw mi dt"><span id="a561" class="ke kf hu me b fv mj mk l ml mm">import React, { Fragment, useState, useEffect } from 'react';</span><span id="3afb" class="ke kf hu me b fv nb mk l ml mm">const fakeFetch = person =&gt; {<br/>  return new Promise(res =&gt; {<br/>    setTimeout(() =&gt; res(`${person}'s data`), Math.random() * 5000);<br/>  });<br/>};</span><span id="ea1e" class="ke kf hu me b fv nb mk l ml mm">const App = () =&gt; {<br/>  const [data, setData] = useState('');<br/>  const [loading, setLoading] = useState(false);<br/>  const [person, setPerson] = useState(null);</span><span id="e4d8" class="ke kf hu me b fv nb mk l ml mm">  useEffect(() =&gt; {<br/>    let canceled = false;</span><span id="ce80" class="ke kf hu me b fv nb mk l ml mm">    setLoading(true);<br/>    fakeFetch(person).then(data =&gt; {<br/>      if (!canceled) {<br/>        setData(data);<br/>        setLoading(false);<br/>      }<br/>    });</span><span id="377f" class="ke kf hu me b fv nb mk l ml mm">    return () =&gt; (canceled = true);<br/>  }, [person]);</span><span id="f9b6" class="ke kf hu me b fv nb mk l ml mm">  return (<br/>    &lt;Fragment&gt;<br/>      &lt;button onClick={() =&gt; setPerson('Nick')}&gt;Nick's Profile&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setPerson('Deb')}&gt;Deb's Profile&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; setPerson('Joe')}&gt;Joe's Profile&lt;/button&gt;<br/>      {person &amp;&amp; (<br/>        &lt;Fragment&gt;<br/>          &lt;h1&gt;{person}&lt;/h1&gt;<br/>          &lt;p&gt;{loading ? 'Loading...' : data}&lt;/p&gt;<br/>        &lt;/Fragment&gt;<br/>      )}<br/>    &lt;/Fragment&gt;<br/>  );<br/>};<br/>export default App;</span></pre><figure class="kz la lb lc fq iv"><div class="bz el l di"><div class="nd le l"/></div></figure></div></div>    
</body>
</html>