<html>
<head>
<title>Add Flutter to your Production Android App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Flutter添加到您的生产Android应用程序中</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-add-flutter-to-your-production-android-app-4b5150de9e44?source=collection_archive---------1-----------------------#2019-04-16">https://medium.com/hackernoon/how-to-add-flutter-to-your-production-android-app-4b5150de9e44?source=collection_archive---------1-----------------------#2019-04-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="2f2a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有几个关于如何将Flutter添加到您现有的Andriod应用程序的说明，包括官方维基，但没有一个是在真正的生产应用程序上完成的，因此当我们这样做时，有比我们预期的更多的挑战，例如子模块的代码组织(以便我们可以在以后重用iOS应用程序)，对AndroidX和产品风格的支持，类似于使用<code class="eh jp jq jr js b">intent#putExtra</code>和<code class="eh jp jq jr js b">startActivityForResult</code>来回传递数据，支持该模块所依赖的<code class="eh jp jq jr js b">plugins</code>，在缓存时支持不同的路线。我们已经将我们的经验提取到带有代码示例的分步指导中。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff jt"><img src="../Images/4a311ab716e1f43ee90d57b6d4366d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEe3A47phrRygkLopgnugQ.png"/></div></div></figure><h1 id="0924" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">0.准备旋舞和主机应用程序</h1><p id="8976" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">本教程是在颤振版本<code class="eh jp jq jr js b">1.5.2</code>上完成的。此时，<code class="eh jp jq jr js b">1.5.x</code>已经在<code class="eh jp jq jr js b">dev</code> <a class="ae li" href="https://flutter.dev/docs/development/tools/sdk/releases" rel="noopener ugc nofollow" target="_blank">频道</a>(不需要使用<code class="eh jp jq jr js b">master</code>频道)。由于Flutter每月发布<code class="eh jp jq jr js b">beta</code>，预计<code class="eh jp jq jr js b">1.5.x</code>将于五月初在<code class="eh jp jq jr js b">beta</code>上发布。</p><p id="2c4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更新:当你读到这里的时候，<code class="eh jp jq jr js b">1.5.4-hotfix-2</code> <a class="ae li" href="https://developers.googleblog.com/2019/05/Flutter-io19.html" rel="noopener ugc nofollow" target="_blank">已经被命名为</a> <code class="eh jp jq jr js b"><a class="ae li" href="https://developers.googleblog.com/2019/05/Flutter-io19.html" rel="noopener ugc nofollow" target="_blank">stable</a></code>。</p><p id="9514" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是你目前生产的安卓应用。出于本文的目的，创建一个新的应用程序来模拟您的生产应用程序，但实际上，它应该是您真正的应用程序。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lj"><img src="../Images/3966c177d7829e296f5feea614a9596b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xLV8PtNHE1otXABIst4AQ.png"/></div></div></figure><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lk"><img src="../Images/1cf1e18bf0070b2046c06ab3613bf9be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zCP9la0h1lLwicqAQPzs-Q.png"/></div></div></figure><p id="189f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">请注意，我们选择“使用AndroidX工件”，这反映了我们在这样做时遇到的一些真正的挑战，但你不需要担心，因为默认情况下，Flutter的“AddToApp”与<code class="eh jp jq jr js b">AppCompat</code>配合得很好。</p><p id="b187" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，为了使这个示例应用程序更接近生产应用程序，请确保您有构建风格</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/df8c79a1cbdaddfdf4460125beb8230e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*Iz3XubX_1yIfQnRJ3sZcgQ.png"/></div></figure><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff lm"><img src="../Images/6ff43412cbe2e1ee3386903765b03f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDgXsSZi9qLHO6b9h_mMHw.png"/></div></div></figure><p id="d0e9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我的<a class="ae li" href="https://github.com/truongsinh/android_flutter_host/tree/step/00" rel="noopener ugc nofollow" target="_blank"> Github </a>上可以找到这一步的示例主机应用程序代码。</p><h1 id="02a4" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">1.创建“颤振模块”</h1><p id="2b46" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">在本地系统的任何地方(包括主机应用程序内部)，运行命令</p><pre class="ju jv jw jx fq ln js lo lp aw lq dt"><span id="71b3" class="lr kg hu js b fv ls lt l lu lv">flutter create -t module -i swift -a kotlin --org [your org prefix] flutter_embedding</span></pre><ul class=""><li id="0d82" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">需要<code class="eh jp jq jr js b">-t module</code>以便该包是一个颤动<code class="eh jp jq jr js b">module</code>(而不是与<code class="eh jp jq jr js b">app</code>、<code class="eh jp jq jr js b">pakcage</code>或<code class="eh jp jq jr js b">plugin</code>)。</li><li id="b03e" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated"><code class="eh jp jq jr js b">-i swift</code>是可选的，但目前似乎没有生效。只是对于这个特定的模块，任何iOS相关的代码将在Swift中(这是我的偏好，如果你忽略这个选项，iOS相关的代码，截至目前，将在Objective C中)。对于Android和Kotlin的<code class="eh jp jq jr js b">-a kotlin</code>也是如此(只针对这个特定的<code class="eh jp jq jr js b">module</code>，与你的主机应用是Java、Kotlin还是两者的混合无关)。</li><li id="23f8" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated"><code class="eh jp jq jr js b">--org [your org prefix]</code>可选，但推荐使用，如果您有Android和/或iOS应用程序开发背景，应该直接使用。</li><li id="cdcc" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated"><code class="eh jp jq jr js b">flutter_embedded</code>是必需的，它是包名中<code class="eh jp jq jr js b">[your org prefix]</code>之后的名字，也是这个模板代码上生成的文件夹。</li></ul><p id="f24c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在git repo上提交和推送代码(比如您公司的私有自托管git repo，或Github)，并记住要在下面的步骤中使用的git URL。尽管也可以直接在你的主机应用程序代码下提交这个目录，但建议把它作为一个<code class="eh jp jq jr js b">git submodule</code>来提交，这样我们以后也可以和一个iOS应用程序共享这个flutter模块。</p><p id="58bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然后，为了支持<code class="eh jp jq jr js b">AndroidX</code>，您需要做出如下变通:将大多数文件包含在目录<code class="eh jp jq jr js b">.android</code>下，并将Java文件迁移到AndroidX</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="9e2d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一步嵌入模块代码在我的<a class="ae li" href="https://github.com/truongsinh/flutter_embedding/tree/step/01" rel="noopener ugc nofollow" target="_blank"> Github </a>上有。</p><h1 id="f2e2" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">2.让这个“颤动模块”成为你的主机应用程序的一个“git子模块”</h1><p id="237c" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">在您的主机应用程序中，运行命令将<code class="eh jp jq jr js b">flutter module</code>添加为<code class="eh jp jq jr js b">git submodule</code>:</p><pre class="ju jv jw jx fq ln js lo lp aw lq dt"><span id="f96d" class="lr kg hu js b fv ls lt l lu lv">git submodule add [your git URL of flutter embedding module in step 1] flutter_embedding</span></pre><p id="9ddd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">flutter_embedding</code>是这个子模块的目录名的推荐名称，以避免与<code class="eh jp jq jr js b">flutter</code>本身的名称空间冲突，同时也足够简单明了。请注意，如果此时您正在使用iOS，您将不得不部分重新生成模块，因为<code class="eh jp jq jr js b">.ios</code>目录被忽略。</p><p id="9888" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你在<code class="eh jp jq jr js b">flutter_embedded</code>下检查你的目录，你会看到一些文件，但是在<code class="eh jp jq jr js b">git diff</code>下，你只会看到子模块的git URL，以及这个子模块指向的当前hash commit。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="0781" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主机app这一步的代码在我的<a class="ae li" href="https://github.com/truongsinh/android_flutter_host/tree/step/02" rel="noopener ugc nofollow" target="_blank"> Github </a>上有。</p><h1 id="165e" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">3.从本机应用程序活动调用FlutterEmbeddingActivity</h1><p id="88fc" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">为了能够从本地应用活动中调用<code class="eh jp jq jr js b">FlutterEmbeddingActivity</code>，您需要向主机应用梯度脚本注册<code class="eh jp jq jr js b">flutter module</code></p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="27af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在存储所有活动的目录中，创建一个新的活动<code class="eh jp jq jr js b">FlutterEmbeddingActivity</code>。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="881b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个活动有一个静态方法<code class="eh jp jq jr js b">init</code>来初始化和创建一个缓存的flutter引擎以获得更好的性能，并在以后用于<code class="eh jp jq jr js b">flutter plugin</code>注册。注意，这个活动必须扩展<code class="eh jp jq jr js b">io.flutter.embedding.android.FlutterActivity</code>，而不是<code class="eh jp jq jr js b">io.flutter.app.FlutterActivity</code>，否则，我们无法覆盖<code class="eh jp jq jr js b">IntentBuilder</code>。当我们注册<code class="eh jp jq jr js b">flutter plugin</code>时，该注释对于后面的步骤也很重要。</p><p id="73eb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在我们有了新的活动，我们可以在AndroidManifest.xml中注册它，并从其他活动中调用它</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="b91d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是否/在哪里调用<code class="eh jp jq jr js b">FlutterEmbeddingActivity.init(this)</code>，是一个权衡的决定。你有三个选择</p><ul class=""><li id="3bc5" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">在你进入活动的<code class="eh jp jq jr js b">onCreate</code>中调用它。优点:从本机活动过渡到Flutter嵌入活动时性能更好(第一次)，缺点:应用启动时性能更差。</li><li id="5af9" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">在<code class="eh jp jq jr js b">onCreate</code>中调用它的活动会立即导致嵌入活动的颤动。优点:从本机活动转换到Flutter嵌入活动时性能更好(第一次)，缺点:从一个本机应用程序活动转换到另一个调用<code class="eh jp jq jr js b">init</code>的本机应用程序活动时性能更差(第一次)。</li><li id="c0c8" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">根本不要调用<code class="eh jp jq jr js b">FlutterEmbeddingActivity.init(this)</code>。优点:在应用程序启动时或在本地应用程序活动中有更好的性能，缺点:从本地活动过渡到Flutter嵌入活动时性能更差(第一次)</li></ul><p id="25b5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，您不能在另一个线程中调用<code class="eh jp jq jr js b">FlutterEmbeddingActivity.init(this)</code>,因为它会崩溃</p><pre class="ju jv jw jx fq ln js lo lp aw lq dt"><span id="26d3" class="lr kg hu js b fv ls lt l lu lv">java.lang.IllegalStateException: startInitialization must be called on the main thread</span></pre><p id="cf02" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您现在开始调试，您将看到应用程序在启动后立即崩溃，并显示以下日志</p><pre class="ju jv jw jx fq ln js lo lp aw lq dt"><span id="8576" class="lr kg hu js b fv ls lt l lu lv">E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.<br/>    [ERROR:flutter/runtime/dart_vm.cc(237)] Could not setup VM data to bootstrap the VM from.<br/>    [ERROR:flutter/runtime/dart_vm_lifecycle.cc(81)] Could not create Dart VM instance.<br/>A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.<br/>A/libc: Fatal signal 6 (SIGABRT), code -6 in tid 12928 (utter_host.free)</span></pre><p id="6e9c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是一个<a class="ae li" href="https://github.com/flutter/flutter/issues/30916" rel="noopener ugc nofollow" target="_blank">已知错误</a>，解决方法是在<code class="eh jp jq jr js b">app/build.gradle</code>中添加以下几行</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="dce0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上述解决方法将修复所有产品风格和构建类型(如<code class="eh jp jq jr js b">Debug</code>、<code class="eh jp jq jr js b">Profile</code>、<code class="eh jp jq jr js b">Release</code>)的问题。现在再次开始调试你的应用程序，点击fab按钮，你应该在日志中看到这些行(表明我们确实在使用缓存的Flutter引擎)</p><pre class="ju jv jw jx fq ln js lo lp aw lq dt"><span id="03a9" class="lr kg hu js b fv ls lt l lu lv">D/FlutterFragment: Deferring to attached Activity to provide a FlutterEngine.<br/>D/FlutterView: Initializing FlutterView<br/>    Internally creating a FlutterSurfaceView.</span></pre><p id="31e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">应用第一次从原生活动过渡到Flutter嵌入活动时，你会看到一个小的滞后，但后续的过渡要平滑得多。</p><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff mm"><img src="../Images/d5c455f14014a9cc66ff11837dc885be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atv_YYhG9WjELFQ4A-5-tQ.png"/></div></div></figure><figure class="ju jv jw jx fq jy fe ff paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="fe ff mm"><img src="../Images/327bf2a6372b5175f7e8165a6cc7f598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVNgp-Ql6U4lA19F0j84dA.png"/></div></div></figure><p id="e335" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，Flutter嵌入活动的内部状态是持久的，这意味着您点击“后退按钮”以返回到本机应用程序活动，然后点击FabButton，您将看到计数器编号保持不变(并且不会重置为0)。</p><p id="39af" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此时，您还可以将Android Studio附加到Flutter活动，以调试您的Dart代码，进行热重装和热重启。</p><p id="29d6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主机app这一步的代码在我的<a class="ae li" href="https://github.com/truongsinh/android_flutter_host/tree/step/03" rel="noopener ugc nofollow" target="_blank"> Github </a>上有。</p><h1 id="495a" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">4.打开不同的颤动屏幕</h1><p id="091d" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">当您的应用程序在Flutter端增长时，您将需要嵌入活动来显示多个屏幕/路径，在本例中，我们将有“counter”屏幕和另一个“hello world”屏幕。</p><p id="83fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据目前的官方维基，你可以用<code class="eh jp jq jr js b">createBuilder().initialRoute</code>和<code class="eh jp jq jr js b">createBuilder().dartEntrypoint</code>中的一个/两个来实现这个。然而，我们发现，一旦我们使用缓存的颤振引擎，这些方法不再工作。我们现在要做的就是把最顶层的小部件(<code class="eh jp jq jr js b">MyApp</code>)转换成有状态的小部件，监听平台通道(事件通道)并据此构建小部件。</p><p id="2747" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh jp jq jr js b">flutter_embedding/lib/main.dart</code>中，将最顶层的小部件转换成有状态的小部件，监听事件通道并相应地设置状态。注意，在第32行，我们还确定路线是否是<code class="eh jp jq jr js b">init</code>，我们将立即返回到原生Android活动。这样做只是为了缓存。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="b0d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh jp jq jr js b">FlutterEmbeddingActivity</code>中，每当这个活动是<code class="eh jp jq jr js b">onCreate</code>时，我们需要通过平台通道向Dart方发送消息。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="2207" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同样出于缓存的目的，如果不是从<code class="eh jp jq jr js b">FlutterEmbeddingActivity</code>调用<code class="eh jp jq jr js b">init</code>，我们将呈现Flutter视图(无论如何都会从Dart端立即<code class="eh jp jq jr js b">pop</code>调用)</p><p id="768a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，在任何其他活动中，用<code class="eh jp jq jr js b">initialRoute</code>创建一个颤振<code class="eh jp jq jr js b">Intent</code>，并开始该活动。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="6d57" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你会看到，点击不同的按钮会导致你不同的颤振屏幕。此外，“计数器”的状态将被保留，如果你只是来回到那个颤动的屏幕，但被重置(到0)，如果你访问另一个屏幕，并回到“计数器”屏幕。</p><p id="66c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一步的代码可以在我的<a class="ae li" href="https://github.com/truongsinh/android_flutter_host/tree/android_step/04" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到。</p><h1 id="0423" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">5.意图和返回意图附加内容</h1><p id="e791" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">有Android开发背景，毫无疑问，你至少曾经使用过<code class="eh jp jq jr js b">intent#putExtra</code>向下一个活动传递数据，使用<code class="eh jp jq jr js b">startActivityForResult</code>和<code class="eh jp jq jr js b">returnIntent#putExtra</code>向上一个活动传递数据。借助于平台通道(这次是事件通道和方法通道)，也可以用Flutter activity/screen来实现。在这样做的时候，你应该知道什么样的数据结构有资格通过Dart和Android之间的桥梁。</p><p id="b240" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在Dart端，我们从同一个事件中获得额外的数据</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="9f90" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在<code class="eh jp jq jr js b">FlutterEmbeddingActivity.kt</code>中，我们将从Dart端接收的数据转换为<code class="eh jp jq jr js b">Intent</code>的额外数据，并使用<code class="eh jp jq jr js b">setResult</code>和<code class="eh jp jq jr js b">finish</code>将数据传递回之前的活动</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="58c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在调用活动中，我们用<code class="eh jp jq jr js b">startActivityForResult</code>替换<code class="eh jp jq jr js b">startActivity</code>，用<code class="eh jp jq jr js b">onActivityResult</code>听结果</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="7a6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主机app这一步的代码在我的<a class="ae li" href="https://github.com/truongsinh/android_flutter_host/tree/android_step/05" rel="noopener ugc nofollow" target="_blank"> Github </a>上有。</p><h1 id="5880" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">6.使用颤振插件</h1><p id="bf82" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">发展您的生产应用程序，毫无疑问，在某些时候，您将需要您的Flutter活动来访问平台的特定数据，如相机、音频或传感器。你可以自己实现所有的平台通道来处理这些数据，或者你可以直接使用https://pub.dartlang.org/flutter上可用的Flutter插件。当然，我们建议您选择后一种方法，这样以后当Flutter activity超过本机应用程序并成为应用程序本身时，您就不需要维护Kotlin/Java代码库了。</p><p id="43f6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们以<a class="ae li" href="https://pub.dartlang.org/packages/path_provider" rel="noopener ugc nofollow" target="_blank"> path_provider </a>包为例，假设我们想要<code class="eh jp jq jr js b">getApplicationDocumentsDirectory</code>，并使用前面步骤中实现的<code class="eh jp jq jr js b">ReturnIntent extras</code>将数据传回。我们在<code class="eh jp jq jr js b">pubspec.yml</code>中定义依赖关系，并调用方法获取数据(字符串格式)</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="9d78" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，如果您现在运行并测试该应用程序，您将会得到以下错误</p><pre class="ju jv jw jx fq ln js lo lp aw lq dt"><span id="ad9d" class="lr kg hu js b fv ls lt l lu lv">E/flutter: [ERROR:flutter/lib/ui/ui_dart_state.cc(148)] Unhandled Exception: MissingPluginException(No implementation found for method getApplicationDocumentsDirectory on channel plugins.flutter.io/path_provider)</span></pre><p id="4f74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">是因为我们没有在Android这边注册<code class="eh jp jq jr js b">path_provider</code>插件的平台通道。这样做，通常在活动的<code class="eh jp jq jr js b">onCreate</code>我们称之为<code class="eh jp jq jr js b">GeneratedPluginRegistrant.registerWith(this)</code>。然而，我们痛苦地发现，我们不能在当前的<code class="eh jp jq jr js b">FlutterEmbeddingActivity</code>中使用该策略。原因是我们的活动从<code class="eh jp jq jr js b">io.flutter.embedding.android.FlutterActivity</code>延伸，而不是<code class="eh jp jq jr js b">io.flutter.app.FlutterActivity</code>。进一步研究<code class="eh jp jq jr js b">GeneratedPluginRegistrant</code>，看起来这段代码只需要2样东西，对当前活动的引用，以及<code class="eh jp jq jr js b">messenger</code>，在我们的例子中是<code class="eh jp jq jr js b">cachedFlutterEngine.dartExecutor</code>。了解到这一点后，我们可以有一个解决方法，尽管有点冗长。</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mk ml l"/></div></figure><p id="c840" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这一次，测试你的应用程序，我们可以看到它的工作预期</p><pre class="ju jv jw jx fq ln js lo lp aw lq dt"><span id="333f" class="lr kg hu js b fv ls lt l lu lv">D/Flutter example: requestCode: 42, resultCode: 24, data {returnArg1=/data/user/0/pro.truongsinh.flutter.android_flutter_host.free/app_flutter, returnArg2=2}</span></pre><p id="01c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">主机app这一步的代码在我的<a class="ae li" href="https://github.com/truongsinh/android_flutter_host/tree/android_step/06" rel="noopener ugc nofollow" target="_blank"> Github </a>上有。</p><h1 id="ac22" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="3476" class="pw-post-body-paragraph ir is hu it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hn dt translated">尽管Flutter的<a class="ae li" href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" rel="noopener ugc nofollow" target="_blank"> Add2App </a>还处于预览阶段，但它已经可以用在生产应用上了，只需稍微调整一下就可以支持一些常见的用例，比如</p><ul class=""><li id="e6e7" class="lw lx hu it b iu iv iy iz jc ly jg lz jk ma jo mb mc md me dt translated">安卓克斯</li><li id="a4dc" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">产品风味</li><li id="5cde" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">使用缓存颤振引擎时的不同路线</li><li id="eac9" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">像使用<code class="eh jp jq jr js b">intent#putExtra</code>和<code class="eh jp jq jr js b">startActivityForResult</code>一样来回传递数据</li><li id="6e0a" class="lw lx hu it b iu mf iy mg jc mh jg mi jk mj jo mb mc md me dt translated">该模块所依赖的颤振的<code class="eh jp jq jr js b">plugins</code></li></ul><p id="fc22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文中的<code class="eh jp jq jr js b">FlutterEmbeddingActivity</code>代码样本的设计使得它的一些代码最终会出现在Flutter引擎的代码中，从而减少了样板代码。同时，如果你想入门Flutter和你的制作app，建议将Flutter嵌入到你当前的app中，而不是重新构建整个Flutter app，减少风险和反馈回路。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="0a4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章是免费的，你的拍手也是免费的👏。你知道你可以按拍手键吗👏按钮50次？</p><figure class="ju jv jw jx fq jy"><div class="bz el l di"><div class="mv ml l"/></div></figure></div></div>    
</body>
</html>