<html>
<head>
<title>Understanding Express.js: Creating Your Own Node HTTP Request Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Express.js:创建自己的节点 HTTP 请求路由器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-express-js-creating-your-own-node-http-request-router-4190a9b6aad6#2019-03-04">https://medium.com/hackernoon/understanding-express-js-creating-your-own-node-http-request-router-4190a9b6aad6#2019-03-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/545be0b528e7be0183440c0b933e1c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJAskMnZuq3Wk2zVHhxYdQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Do-It-Yourself: Node HTTP Router</figcaption></figure><p id="7447" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Express 是一个非常棒的 JavaScript 框架，可以作为许多全栈 web 应用程序的后端。我们中的许多人每天都在使用它，并精通如何使用它，但可能对它的工作原理缺乏了解。今天，在不深入研究 Express 源代码的情况下，我们将重新创建一些路由功能，以便更好地理解框架运行的环境以及如何处理响应和请求。</p><p id="9aff" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你想看最终的源代码，你可以在 Github 上找到它。为了更好的学习体验，请继续和我一起编码！</p><p id="6d9d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">注意:</strong>如果这篇文章帮助您更好地理解了 Node 后端路由，请为它鼓掌👏(还是 50！)来帮助传播消息！</p><p id="be56" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt">***</p><h2 id="5b33" class="kg kh hu bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la dt translated">通过注册我的免费时事通讯，在您的收件箱中获得快速 JavaScript 技巧！</h2><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="8355" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt">***</p><h1 id="8057" class="lh kh hu bd ki li lj lk km ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx dt translated">入门指南</h1><p id="9279" class="pw-post-body-paragraph jg jh hu ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd hn dt translated">让我们从模仿快递应用开始。我们将对其稍作修改，因为我们不会引入<code class="eh md me mf mg b">express</code>，而是引入我们自己创建的模块。</p><p id="bf71" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">首先，创建一个新的项目文件夹，并使用默认配置启动一个 npm 项目。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="09db" class="kg kh hu mg b fv ml mm l mn mo">mkdir diy-node-router<br/>cd diy-node-router<br/>npm init -y</span></pre><p id="7910" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">验证您的<code class="eh md me mf mg b">package.json</code>文件如下所示:</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="3102" class="kg kh hu mg b fv ml mm l mn mo">{<br/>  "name": "diy-node-router",<br/>  "version": "1.0.0",<br/>  "description": "", <br/>  "main": "index.js",<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },<br/>  "author": "",<br/>  "license": "ISC"<br/>}</span></pre><p id="e4e3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将创建我们的<code class="eh md me mf mg b">index.js</code>文件。在这个文件中，我们将复制<code class="eh md me mf mg b">express</code>“Hello World”示例，但是引入我们自己的模块(我们将在短时间内创建这个模块)。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="55d5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这与<code class="eh md me mf mg b">express</code>“Hello World”的例子本质上是一样的。基于这段代码，我们知道我们的<code class="eh md me mf mg b">router</code>模块应该是一个在被调用时返回<code class="eh md me mf mg b">app</code>对象的函数。这个对象应该有一个<code class="eh md me mf mg b">listen</code>方法来开始监听端口上的请求，还有一个<code class="eh md me mf mg b">get</code>方法来设置<code class="eh md me mf mg b">get</code>请求处理。我们还将设置一个<code class="eh md me mf mg b">post</code>方法，因为我们最终希望我们的应用程序处理帖子。</p><h1 id="76e6" class="lh kh hu bd ki li lj lk km ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx dt translated">搭建<code class="eh md me mf mg b">diy-router</code>模块</h1><p id="5c73" class="pw-post-body-paragraph jg jh hu ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd hn dt translated">现在我们创建实际的路由器模块。在新的<code class="eh md me mf mg b">src</code>目录下创建<code class="eh md me mf mg b">diy-router.js</code>文件。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="2189" class="kg kh hu mg b fv ml mm l mn mo">mkdir src<br/>cd src<br/>touch diy-router.js</span></pre><p id="1b8a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们不想一次吃掉太多，所以让我们先创建一个模块，导出必要的方法。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="3011" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">希望到目前为止这些都有意义:我们创建了一个<code class="eh md me mf mg b">router</code>函数，当被调用时，它返回一个<code class="eh md me mf mg b">get</code>和一个<code class="eh md me mf mg b">listen</code>方法。此时，每个方法都忽略它的参数，只记录它被调用过。然后，这个函数被包装在一个立即调用的函数表达式(IIFE)中。如果你不知道我们为什么使用生命，我们这样做是为了数据隐私。当我们有不想暴露在模块本身之外的变量和函数时，下面的步骤会更加明显。</p><p id="7c39" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">此时，我们可以返回到根目录，使用 node 运行我们的应用程序。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="1a6c" class="kg kh hu mg b fv ml mm l mn mo">node .</span></pre><p id="ab8a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果一切正常，您将看到如下输出:</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="b0ea" class="kg kh hu mg b fv ml mm l mn mo">Get method called!<br/>Listen method called!</span></pre><p id="6a5e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">太好了，所有东西都连在一起了！现在，让我们开始响应 http 请求提供内容。</p><h1 id="b241" class="lh kh hu bd ki li lj lk km ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx dt translated">处理 HTTP 请求</h1><p id="f09a" class="pw-post-body-paragraph jg jh hu ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd hn dt translated">为了获得一些基本的 HTTP 请求处理功能，我们将节点的内置<code class="eh md me mf mg b">http</code>模块引入到我们的<code class="eh md me mf mg b">diy-router</code>中。<code class="eh md me mf mg b">http</code>模块有一个<code class="eh md me mf mg b">createServer</code>方法，该方法采用带有请求和响应参数的函数。每当一个 http 请求被发送到在<code class="eh md me mf mg b">listen</code>方法中指定的端口时，这个函数就会被执行。下面的示例代码显示了如何使用<code class="eh md me mf mg b">http</code>模块在端口<code class="eh md me mf mg b">8080</code>上返回文本“Hello World”。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="a472" class="kg kh hu mg b fv ml mm l mn mo">http.createServer((req, res) =&gt; {<br/>   res.write('Hello World!');<br/>   res.end();<br/>}).listen(8080);</span></pre><p id="0f52" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们希望在我们的模块中使用这种功能，但是我们需要让用户指定他们自己的端口。此外，我们希望执行一个用户提供的回调函数。让我们在<code class="eh md me mf mg b">diy-router</code>模块的<code class="eh md me mf mg b">listen</code>方法中使用这个示例功能，并确保更加灵活地使用端口和回调函数。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="ead1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们运行我们的应用程序，看看会发生什么。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="2505" class="kg kh hu mg b fv ml mm l mn mo">node .</span></pre><p id="3898" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们看到控制台中记录了以下内容:</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="b94d" class="kg kh hu mg b fv ml mm l mn mo">Get method called!<br/>Example app listening on port 3000!</span></pre><p id="800f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是一个好迹象。让我们打开我们最喜欢的网络浏览器，导航到<a class="ae kf" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>。</p><figure class="lb lc ld le fq iv fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/56c8a18f83ea927efa20ffb7c8f359c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*w2nO_2fwYaw0TsKU0--btQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Simple “Hello World!” App</figcaption></figure><p id="2ea2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">看起来不错！我们现在通过端口 3000 提供内容。这很好，但我们仍然不提供依赖路线的内容。例如，如果您导航到<a class="ae kf" href="http://localhost:3000/test-route" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/test-route</a>，您将看到同样的“Hello World！”消息。在任何真实的应用程序中，我们都希望提供给用户的内容依赖于所提供的 URL 中的内容。</p><h1 id="9e37" class="lh kh hu bd ki li lj lk km ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx dt translated">添加和查找路线</h1><p id="2c66" class="pw-post-body-paragraph jg jh hu ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd hn dt translated">我们需要能够向我们的应用程序添加任意数量的路由，并在调用该路由时执行正确的路由处理函数。为此，我们将在模块中添加一个<code class="eh md me mf mg b">routes</code>数组。此外，我们将创建<code class="eh md me mf mg b">addRoute</code>和<code class="eh md me mf mg b">findRoute</code>函数。名义上，代码可能看起来像这样:</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="73e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们将使用<code class="eh md me mf mg b">get</code>和<code class="eh md me mf mg b">post</code>方法中的<code class="eh md me mf mg b">addRoute</code>方法。<code class="eh md me mf mg b">findRoute</code>方法简单地返回<code class="eh md me mf mg b">routes</code>中匹配所提供的<code class="eh md me mf mg b">method</code>和<code class="eh md me mf mg b">url</code>的第一个元素。</p><p id="6657" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在下面的代码片段中，我们添加了数组和两个函数。此外，我们修改了我们的<code class="eh md me mf mg b">get</code>方法并添加了一个<code class="eh md me mf mg b">post</code>方法，这两个方法都使用<code class="eh md me mf mg b">addRoute</code>函数将用户指定的路线添加到<code class="eh md me mf mg b">routes</code>数组中。</p><p id="8d8f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">注意:</strong>由于<code class="eh md me mf mg b">routes</code>数组和<code class="eh md me mf mg b">addRoute</code>和<code class="eh md me mf mg b">findRoute</code>方法只能在模块内访问，我们可以使用我们的 IIFE“揭示模块”模式，不将它们暴露在模块外。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="a5aa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，让我们在传递给<code class="eh md me mf mg b">createServer</code>方法的函数中使用<code class="eh md me mf mg b">findRoute</code>函数。当成功找到一条路由时，我们应该调用与之关联的处理函数。如果没有找到路由，我们应该返回一个 404 错误，说明没有找到路由。该代码在概念上将如下所示:</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="af6f" class="kg kh hu mg b fv ml mm l mn mo">const method = req.method.toLowerCase();<br/>const url = req.url.toLowerCase();<br/>const found = findRoute(method, url);</span><span id="c18b" class="kg kh hu mg b fv mr mm l mn mo">if (found) {<br/>  return found.handler(req, res);<br/>}</span><span id="0de7" class="kg kh hu mg b fv mr mm l mn mo">res.writeHead(404, { 'Content-Type': 'text/plain' });<br/>res.end('Route not found.');</span></pre><p id="bbab" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，让我们将其纳入我们的模块。当我们这样做时，我们将添加一段额外的代码，为我们的响应对象创建一个<code class="eh md me mf mg b">send</code>方法。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="ebac" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们看看这是怎么回事！同样，从根目录运行您的应用程序。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="8e5b" class="kg kh hu mg b fv ml mm l mn mo">node .</span></pre><p id="6fcb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">您应该看到该应用程序正在端口 3000 上运行。在浏览器中，导航至<a class="ae kf" href="http://localhost3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>。你应该看看“你好，世界！”但是现在，如果你导航到<a class="ae kf" href="http://localhost:3000/test-route," rel="noopener ugc nofollow" target="_blank">http://localhost:3000/test-Route</a>，你应该得到一个“Route not found”的消息。成功！</p><figure class="lb lc ld le fq iv fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/ad443595326e542de2b9bc79f5b9c76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*S8_Fvcvq-t6wYeD-LfQLlA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Route not found</figcaption></figure><p id="7246" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们想确认我们确实可以在应用程序中添加<code class="eh md me mf mg b">/test-route</code>作为路线。在<code class="eh md me mf mg b">index.js</code>，设置了这条路线。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="b921" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">重启服务器并导航到<a class="ae kf" href="http://localhost:3000/test-route." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/test-route</a>。如果你看到“测试测试”，你已经成功地设置了路由！</p><p id="e07b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">注:</strong>如果玩够了，可以到此结束！这是一个很好的路由入门。如果你想更深入一点，并能够从我们的路线中提取参数，请继续阅读！</p><h1 id="0830" class="lh kh hu bd ki li lj lk km ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx dt translated">提取路线参数</h1><p id="d095" class="pw-post-body-paragraph jg jh hu ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd hn dt translated">在现实世界中，我们很可能在 url 字符串中有参数。例如，假设我们有一组用户，希望根据 url 字符串中的参数获取一个用户。我们的 url 字符串可能以类似于<code class="eh md me mf mg b">/user/:username</code>的形式结束，其中<code class="eh md me mf mg b">username</code>表示与用户相关联的唯一标识符。</p><p id="24e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了创建这个函数，我们可以开发一些正则表达式规则来匹配任何 url 参数。与其这样做，我建议我们引入一个叫做<code class="eh md me mf mg b">route-parser</code>的伟大模块来为我们做这件事。<code class="eh md me mf mg b">route-parser</code>模块为每条具有<code class="eh md me mf mg b">match</code>方法的路线创建一个新对象，所有的正则表达式都包含在其中。要在我们的模块中进行所需的更改，请执行以下操作:</p><p id="bc1b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从命令行安装模块:</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="37e4" class="kg kh hu mg b fv ml mm l mn mo">npm i route-parser</span></pre><p id="a56a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<code class="eh md me mf mg b">diy-router.js</code>文件的顶部，要求模块。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="a674" class="kg kh hu mg b fv ml mm l mn mo">const Route = require('route-parser');</span></pre><p id="595f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<code class="eh md me mf mg b">addRoute</code>函数中，不是添加计划 url 字符串，而是添加一个<code class="eh md me mf mg b">Route</code>类的新实例。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="16d3" class="kg kh hu mg b fv ml mm l mn mo">const addRoute = (method, url, handler) =&gt; {<br/>  routes.push({ method, url: new Route(url), handler });<br/>};</span></pre><p id="76b7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">接下来，我们将更新<code class="eh md me mf mg b">findRoute</code>函数。在这次更新中，我们使用<code class="eh md me mf mg b">Route</code>对象的<code class="eh md me mf mg b">match</code>方法来匹配提供的 url 和路由字符串。换句话说，导航到<code class="eh md me mf mg b">/user/johndoe</code>将匹配路线字符串<code class="eh md me mf mg b">/user/:username</code>。</p><p id="c276" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果我们找到了匹配，我们不仅要返回一个匹配，还要返回从 url 中提取的参数。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="d504" class="kg kh hu mg b fv ml mm l mn mo">const findRoute = (method, url) =&gt; {<br/>  const route = routes.find(route =&gt; {<br/>    return route.method === method &amp;&amp; route.url.match(url);<br/>  });</span><span id="05ed" class="kg kh hu mg b fv mr mm l mn mo">  if (!route) return null;</span><span id="c0e7" class="kg kh hu mg b fv mr mm l mn mo">  return { handler: route.handler, params: route.url.match(url) };<br/>};</span></pre><p id="8e4a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了处理这个新功能，我们需要重新访问在传递给<code class="eh md me mf mg b">http.createServer</code>的函数中调用<code class="eh md me mf mg b">findRoute</code>的地方。我们需要确保路由中的任何参数都作为请求对象的属性添加。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="96d4" class="kg kh hu mg b fv ml mm l mn mo">if (found) {<br/>  req.params = found.params;<br/>  res.send = content =&gt; {<br/>    res.writeHead(200, { 'Content-Type': 'text/plain' });<br/>    res.end(content);<br/>};</span></pre><p id="2371" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">因此，我们的最终模块将如下所示:</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="1ae1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们来测试一下！在我们的<code class="eh md me mf mg b">index.js</code>文件中，我们将添加一个新的用户端点，看看是否可以通过改变我们的 url 查询字符串来切换用户。如下更改您的<code class="eh md me mf mg b">index.js</code>文件。这将根据所提供请求的<code class="eh md me mf mg b">params</code>属性过滤我们的<code class="eh md me mf mg b">user</code>数组。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="mp lg l"/></div></figure><p id="d4d1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，重启你的应用。</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="80b1" class="kg kh hu mg b fv ml mm l mn mo">node .</span></pre><p id="3acb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">先导航到<a class="ae kf" href="http://localhost:3000/user/johndoe" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/user/John doe</a>，观察内容，再导航到<a class="ae kf" href="http://localhost:3000/user/janesmith." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/user/janes with</a>。您将分别收到以下响应:</p><pre class="lb lc ld le fq mh mg mi mj aw mk dt"><span id="6de4" class="kg kh hu mg b fv ml mm l mn mo">Hello, John Doe!</span><span id="1e99" class="kg kh hu mg b fv mr mm l mn mo">Hello, Jane Smith!</span></pre><h1 id="57cb" class="lh kh hu bd ki li lj lk km ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx dt translated">最终代码</h1><p id="c3bb" class="pw-post-body-paragraph jg jh hu ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd hn dt translated">这个项目的最终代码可以在<a class="ae kf" href="https://github.com/nas5w/diy-node-router" rel="noopener ugc nofollow" target="_blank"> Github 这里</a>找到。感谢您的参与！</p><h1 id="3ce8" class="lh kh hu bd ki li lj lk km ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx dt translated">结论</h1><p id="1b96" class="pw-post-body-paragraph jg jh hu ji b jj ly jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd hn dt translated">在本文中，我们观察到，虽然 Express 是一个不可思议的工具，但是我们可以通过实现我们自己的定制模块来复制它的路由功能。经历这种练习真的有助于拉开“帷幕”，让你意识到真的没有任何“魔法”在进行。也就是说，我绝对不建议为你的下一个节点项目开发你自己的框架！像 Express 这样的框架如此不可思议的一个原因是它们受到了许多优秀开发人员的关注。它们具有健壮的设计，并且比任何一个开发人员部署的解决方案都更加高效和安全。</p><p id="03c2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你觉得这个练习怎么样？这是否激励你尝试复制 Express 其他方面的功能？请在评论中告诉我！</p></div></div>    
</body>
</html>