<html>
<head>
<title>React Native Performance: Do and Don't</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本地性能:做与不做</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/react-native-performance-do-and-dont-1198e97b730a?source=collection_archive---------1-----------------------#2019-05-31">https://medium.com/hackernoon/react-native-performance-do-and-dont-1198e97b730a?source=collection_archive---------1-----------------------#2019-05-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="6bfa" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">t<!-- -->L；DR —一定要阅读React、React Native和每个库的文档，使用远程映像可能会很痛苦:使用库。有些模式可能是有害的，小心纯组件和HOCS。使您的库保持最新。给你的应用和你的用户一些爱。</p></blockquote><p id="c8a5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这篇文章是基于两年来构建<a class="ae jw" href="https://nelio.io" rel="noopener ugc nofollow" target="_blank">内利奥</a> React本地移动应用的经验，这些应用可以在<a class="ae jw" href="https://itunes.apple.com/fr/app/nelio/id1057392527?mt=8" rel="noopener ugc nofollow" target="_blank"> iOS </a>和<a class="ae jw" href="https://play.google.com/store/apps/details?id=io.nelio.hello&amp;hl=en" rel="noopener ugc nofollow" target="_blank"> Android </a>上使用。它假设您已经有一些使用React和/或React Native的经验。严格来说，React Native并不是专用的，因为下面的一些建议适用于常规的React应用程序。这也不是一个详尽的性能指南:你可以应用这里找到的所有建议，但仍然有一个落后的应用程序。不要责怪我们；-)</p><p id="b3d5" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">内利奥是一家专注于手工食品的食品配送初创公司，目前在巴黎运营。当交付高质量产品是你的业务时，它会影响到你公司的方方面面。从营销信息到代码库。基本上，这里的每个人都专注于提供最佳的用户体验。</p><p id="4446" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">绩效是可以改变对您提供的服务的整体看法的话题之一。老实说，在这个话题上，我们有时很难达到我们和客户的期望。这篇文章是基于我们在这次旅程中学到的东西。我们犯过的错误，不会再发生的错误，或者我们学到的东西和我们采取的应对措施。</p><h1 id="8f69" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">反应和反应-本机性能</h1><p id="bc17" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">作为一名过去4年的React开发人员，我能说的就是我喜欢它。当我加入React Native项目时，我非常高兴，就学习曲线而言，它符合我的预期:拥有相同的框架使开始开发您的第一个组件变得非常容易，但稍后您将需要更深入地了解React Native。正如成为一名高级React Web开发人员需要你了解浏览器中正在发生的事情一样；-)</p><p id="18ee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">关于React Native中的性能，这是相同的:</p><blockquote class="la"><p id="155b" class="lb lc hu bd ld le lf lg lh li lj js ek translated">您所知道的关于React性能的一切都将适用于React本机应用程序</p></blockquote><p id="1983" class="pw-post-body-paragraph iu iv hu ix b iy lk ja jb jc ll je jf jt lm ji jj ju ln jm jn jv lo jq jr js hn dt translated">也就是说，下一步很可能是跳转到<a class="ae jw" href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener ugc nofollow" target="_blank"> React性能文档</a>以及稍后的<a class="ae jw" href="https://facebook.github.io/react-native/docs/performance" rel="noopener ugc nofollow" target="_blank"> React原生性能文档</a>。这些都是很好的资源，我不会在这里花费任何时间复制粘贴或重写；-)我更倾向于关注我们为了提高性能而放置或决定避免的特定模式。</p><p id="03d8" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我也不会花任何时间争论反应自然是否足够快，你是否应该移动到颤动或完全自然。有一些很棒的React本地应用。以下是我们如何努力成为他们中的一员。</p><h1 id="0057" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">一定要提供用户界面反馈</h1><p id="63cb" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">性能主要是关于感知，而不是精确测量一个功能完成需要多长时间。更重要的是<em class="iw">还有多久？</em>，你应该问问自己<em class="iw">为什么？</em>和<em class="iw">什么时候？。</em></p><p id="db5f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">人们普遍认为，在用户互动之后，你应该在100毫秒内给出反馈。请记住，这个门槛是你不应该跨越的障碍。还要记住<strong class="ix hv">给予反馈永远不会太早</strong>。</p><p id="1ddb" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">有不同的方式向用户提供反馈。在React Native中，一个伟大而简单的解决方案是在所有接受用户交互的组件上使用<a class="ae jw" href="https://facebook.github.io/react-native/docs/touchableopacity" rel="noopener ugc nofollow" target="_blank"> TouchableOpacity </a>组件。这将在交互过程中向用户提供反馈，并且是一种很好的方式来表明交互后将发生的事情。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/2eaa4178e0ca34018975b8d1e8518714.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*VyQsZkHhMwtASBU8guUfxA.png"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">A skeleton product card in Nelio App</figcaption></figure><p id="9887" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果点击导致打开一个新的屏幕，那么你应该<strong class="ix hv">花一些时间考虑你的数据加载</strong>。通常一个好的方法是尽快打开新屏幕，呈现已经有的内容，并在内容加载时显示加载器和/或一些占位符组件。这是一种也被称为<a class="ae jw" href="https://uxdesign.cc/what-you-should-know-about-skeleton-screens-a820c45a571a" rel="noopener" target="_blank"> <em class="iw">骨架筛</em> </a> <em class="iw">的技术。</em></p><p id="69e9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果您单击导致其他操作，比如将一个项目添加到您的购物车、收藏夹或发布聊天消息，这通常会包括远程API调用。在这种情况下，您应该尽可能——大多数时候— <strong class="ix hv">表现得好像端点已经成功响应了一样</strong>。这种模式被称为<a class="ae jw" href="https://uxplanet.org/optimistic-1000-34d9eefe4c05" rel="noopener ugc nofollow" target="_blank">乐观用户界面</a>，在整个行业中也非常普遍。</p><p id="95c4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在内利奥，我们使用GraphQL和ReactApollo。带有<a class="ae jw" href="https://www.apollographql.com/docs/react/features/optimistic-ui" rel="noopener ugc nofollow" target="_blank"> optimisticResponse </a>参数的ReactApollo有一个很好的解决方案来实现这种模式。在使用redux时，这也可以通过不同的方式来完成。</p><h1 id="4dc9" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">形象</h1><p id="6ed1" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">关于React原生应用的性能和可用性的一个大话题是图像。来自网络背景，对我来说有点意外。想想看，浏览器在处理图像方面做了大量工作，比如下载、缓存、解码、缩放和显示图像:所有这些都是以流式方式进行的。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/782299b7b7fee2c18cc7a7c245211fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*7aPSypInSHdfEUpqW045Ig.gif"/></div></figure><h2 id="6eee" class="mc jy hu bd jz md me mf kd mg mh mi kh jt mj mk kl ju ml mm kp jv mn mo kt mp dt translated">务必使用图像缓存解决方案</h2><p id="820a" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">React本机代码提供了一个<a class="ae jw" href="https://facebook.github.io/react-native/docs/image" rel="noopener ugc nofollow" target="_blank">图像</a>组件，它在显示单个图像方面做得很好，但在处理大量图像时会有一些问题。具体来说，我们有一些闪烁的问题，而且当太多的图像加载到我们的应用程序中时，在某些时候，它们会停止加载。</p><p id="0081" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们切换到<a class="ae jw" href="https://github.com/DylanVann/react-native-fast-image" rel="noopener ugc nofollow" target="_blank"> react-native-fast-image </a>，似乎我们不是唯一的一个。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mq"><img src="../Images/a8fd8595302e366a26f1156eb28af409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kW8vh_xG5phNxpE_8ucJ_g.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Recently react-native-fast-image was downloaded 12% as often a react-native on NPM registry which is almost as Expo</figcaption></figure><h2 id="5358" class="mc jy hu bd jz md me mf kd mg mh mi kh jt mj mk kl ju ml mm kp jv mn mo kt mp dt translated">请按照您需要的大小加载图像</h2><p id="a297" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">React-native-fast-image解决了我们遇到的许多问题，但我们仍然注意到我们的应用程序中有一些随机崩溃与一些图像有关。快速检查后，我们注意到我们要求我们的应用程序下载、缓存和缩放数十张图片，每张图片都有几百千字节。我们最初试图通过对图片上传设置一些硬性限制来解决这个问题，但我们对这个解决方案并不满意。在任何情况下，<strong class="ix hv">小心你正在加载的图像的数量和大小</strong>，因为这会给设备带来很大压力。一个好的解决方案是不在设备上而是在之前完成大部分工作。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/58ba233e64801ab020b184ddab011757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*qp4sp_nxFk3uyAnU2Q9W8Q.jpeg"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">An image resized to specific dimensions with cloudImg with the following URL <a class="ae jw" href="https://acoigzuuen.cloudimg.io/crop/640x360/q95/_s3_nelio_/kaviari-3384d944c6f8418679baee23-1523374450958.jpeg" rel="noopener ugc nofollow" target="_blank">https://acoigzuuen.cloudimg.io/crop/640x360/q95/_s3_nelio_/kaviari-3384d944c6f8418679baee23-1523374450958.jpeg</a></figcaption></figure><p id="e7ae" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">即使你对图片没有记忆问题，按照你要显示的尺寸来调整图片的大小仍然是一个好主意。这将减轻用户设备的压力。</p><p id="b69c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们最近转而使用图像缩放CDN解决方案，该解决方案允许我们下载图像，并将其精确缩放到我们想要显示的大小。对于记录，我们选择了<a class="ae jw" href="https://www.cloudimage.io" rel="noopener ugc nofollow" target="_blank">云图像</a>，目前非常满意。它允许我们请求一个特定尺寸的图像。为了快速实现，我们选择更改GraphQL解析器，将其转换为cloudImage one的图像URL。这种改变也可以在客户端完成。CloudImage是我们寻求的解决方案，因为我们可以使用<a class="ae jw" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>或托管开源解决方案，如<a class="ae jw" href="https://github.com/imgproxy/imgproxy" rel="noopener ugc nofollow" target="_blank"> imgProxy </a>或<a class="ae jw" href="https://github.com/thumbor/thumbor" rel="noopener ugc nofollow" target="_blank"> Thumbor </a>。</p><h1 id="73bb" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">务必明智地使用纯组件</h1><p id="a9b4" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">如前所述，React原生应用在所有React应用之前和之后。大多数对React应用有益的建议也适用于React本地应用。</p><p id="6672" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">可能关于React性能最流行的建议是关于是否使用PureComponent(和/或<a class="ae jw" href="https://reactjs.org/docs/react-api.html#reactmemo" rel="noopener ugc nofollow" target="_blank"> React.memo() </a>)。长话短说，React中无用的重新渲染通常不是问题，但在复杂的应用程序中可能会成为问题。PureComponent是一种防止组件在道具不变的情况下重新渲染的方法。更准确地说，它通过对props进行浅层比较来实现<a class="ae jw" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank"> shouldComponentUpdate </a>。</p><p id="9b2f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">有些人认为在实现新组件时默认使用PureComponent是一个好模式。我的建议是永远记住，它可能弊大于利。这是邪恶的过早优化的一个很好的例子<a class="ae jw" href="http://wiki.c2.com/?PrematureOptimization" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="9e74" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你需要/真的想减少重新渲染，请记住，在这种情况下，当实例化一个组件时，你不应该在你的父渲染方法中创建这个纯组件的任何道具。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mw"><img src="../Images/47de9da88857ad294f23343f84356522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mna5onBl0ntyQau3ngybLg.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Don't create any new props at render time when using a pure component</figcaption></figure><p id="6e10" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">提供道具的两个主要用例是提供新的对象和新的功能。上面的例子也显示了提供一个子组件作为子道具，但是如果你超越了JSX，最后，它只是一个普通的JS对象。</p><p id="eb49" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">关于对象，也要记住数组是对象。当把你的组件切换到一个更加函数化的风格时，要时刻注意大多数函数，它们本身是纯粹的，会创建新的引用。同样，不要在渲染时调用这些函数。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff mx"><img src="../Images/163f0f969a0ea1f90c15c7e1b0ca465d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptTNNQnBwm7JTRtZ8hzmUQ.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Also avoid pitfalls when going functional</figcaption></figure><p id="24dd" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在使用React-Native时，您可能会经常用到的另一种模式是<a class="ae jw" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> renderProps </a>:提供一个返回组件的函数作为道具。从道具的角度来看，渲染道具只是一个作为道具提供的常规函数，因此一般的建议是适用的:不要在运行时创建渲染道具。</p><p id="6e06" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在内利奥这里，我们还没有使用反应钩，如果你还没有，你需要检查一下。React Native 0.59中自带的钩子，下面会有专门的一节介绍它。我们用的反而是<a class="ae jw" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank">重新作曲</a>，从中钩子得到了很大的启发。</p><p id="e24b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">多亏了<code class="eh my mz na nb b">Pure</code>、<code class="eh my mz na nb b">withHandlers</code>和<code class="eh my mz na nb b">withPropsOnChange</code>，重新组合已经证明了它是一个非常有用的工具，可以帮助我们保持代码库的整洁并提高性能。</p><h1 id="66f0" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">不要匆忙使用hoc</h1><p id="3f7d" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">当你的应用程序变得复杂，你想在你的组件间共享一些公共模式时，使用<a class="ae jw" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>并不罕见。</p><p id="5238" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">使用高阶组件是一个相当好的实践，即使这有时是有争议的，因为它增加了间接性。但是它会增加你理解代码的复杂性。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff nc"><img src="../Images/22faa2e54c27f82bfc182ee4e2bd8a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qT0AJGIrNJjRslfNe719bg.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Don't instance HOC at render</figcaption></figure><p id="9963" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">你真正应该小心的是<strong class="ix hv">不要在运行中实例化任何高阶组件，特别是在渲染方法</strong> 期间 <a class="ae jw" href="https://reactjs.org/docs/higher-order-components.html#dont-use-hocs-inside-the-render-method" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">。您不想这样做的原因是，您实际上是在创建一个新的组件。React无法知道这实际上是与之前相同的组件(因为这确实不是)。这给协调算法带来了很大的压力。不仅如此，它还强制React在整个树上运行所有的生命周期方法。</strong></a></p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff nd"><img src="../Images/9e01c9d609ef00865fda1f1cb86701e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YnM4jOczsFVVhRygSzTWw.png"/></div></div></figure><p id="2c43" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我记得有一个案例，我们发现了这个不好的模式，并解决了它。基本上这发生在我们混合使用<em class="iw"> RenderProps </em>和<em class="iw">高阶组件</em>的时候。作为Apollo用户，我们在大多数地方使用<a class="ae jw" href="https://www.apollographql.com/docs/react/essentials/queries/#basic" rel="noopener ugc nofollow" target="_blank"> Apollo查询组件</a>从我们的端点获取数据。因为我们的代码风格是尽可能使用重新组合，所以最初的实现是将Apollo查询组件包装在一个<em class="iw"> fromRenderProps </em> HOC中。这对于所有不需要动态变量的查询都很有效，但如果不需要，就会失败，因为<a class="ae jw" href="https://github.com/acdlite/recompose/issues/702" rel="noopener ugc nofollow" target="_blank">没有办法给你的渲染道具组件</a>提供特定的道具。我们最初实现的方式是错误的。我们后来确定了两种方法来改善这种情况。第一个是接受在这里不使用Recompose HOC，只使用一个更经典的实现来做一个常规的组件。第二个，我们选择的，是切换到<a class="ae jw" href="https://www.apollographql.com/docs/react/api/react-apollo#graphql" rel="noopener ugc nofollow" target="_blank"> Apollo graphQL HOC </a>，这是<a class="ae jw" href="https://www.apollographql.com/docs/react/recipes/recompose" rel="noopener ugc nofollow" target="_blank">记录的</a>来匹配我们的使用。</p><p id="ac9f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我可以想象的另一种用法是，如果你需要基于你收到的道具实例化一个高阶组件。我创建了一个<a class="ae jw" href="https://repl.it/repls/VividOrangePipeline" rel="noopener ugc nofollow" target="_blank">小例子</a>来展示这种情况。我们的代码库中有一些与这种模式相近的东西。经过一番思考后，我们通过在这些地方不使用HOC，而用renderProps替换它，或者直接提供组件作为道具，来摆脱它。</p><figure class="lq lr ls lt fq lu fe ff paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="fe ff nc"><img src="../Images/dfe41d039d91ab36a4a0ee750eb300ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WmtKK-YxJxxbRTViDnX08A.png"/></div></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Do use another pattern such as Children, renderProps, or Component as Props</figcaption></figure><h1 id="eab0" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">不要实现大容量缩减器</h1><p id="fe9d" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">如果您没有使用GraphQL，那么您可能正在使用<a class="ae jw" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> redux </a>。这里我们两者都用，但是我不建议在大多数情况下使用。</p><p id="1cac" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你没有使用redux和<a class="ae jw" href="https://github.com/paularmstrong/normalizr" rel="noopener ugc nofollow" target="_blank"> normalizr </a>和/或<a class="ae jw" href="https://rematch.gitbooks.io/rematch/#getting-started" rel="noopener ugc nofollow" target="_blank"> rematch </a>，或者在某个时候编写你自己的reducers，请注意<strong class="ix hv">总是只变异你需要的对象</strong>。如果你用心的跟随<a class="ae jw" href="https://redux.js.org/basics/reducers#designing-the-state-shape" rel="noopener ugc nofollow" target="_blank"> Redux基础教程</a>你已经意识到了这一点，但是如果你不是，那就再读一遍；-)</p><p id="f5f1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果你像我们一样，有时太急于编码，那么当你从网络上重新获取一个条目列表，并保存到你的reducer中时——即使是以一种规范化的方式——你可能会天真地这样做:</p><figure class="lq lr ls lt fq lu"><div class="bz el l di"><div class="ne nf l"/></div><figcaption class="lx ly fg fe ff lz ma bd b be z ek">Bad pattern in your reducer — maybe you are updating objects which don't need to be</figcaption></figure><p id="f3a6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">如果这样做并且在呈现可以在后台刷新的项目列表时有一些性能问题，那么您需要做的是仅在需要时更新您的商店。更准确地说，<strong class="ix hv">只更新需要成为</strong>的引用:如果一个条目的值和以前一样，那么你可能不需要在redux中为它保存一个新的引用。更新你的商店中的引用，将创建无用的渲染，最终将产生相同的组件。</p><h1 id="f954" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">不要天真地分享选择器</h1><p id="1e4f" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">如果使用redux，那么在您的<code class="eh my mz na nb b">connect()</code>调用中使用mapStateToProps函数。</p><p id="e387" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">随着应用程序的增长，mapStateToProps的复杂性增加，您可能会注意到在mapStateToProps中进行的一些计算变得很繁重。你可能还会注意到，你有时会过度渲染，这可能看起来违背直觉，因为connect实现了他自己的<a class="ae jw" href="https://redux.js.org/faq/react-redux#why-isn-t-my-component-re-rendering-or-my-mapstatetoprops-running" rel="noopener ugc nofollow" target="_blank">道具浅层比较</a>。</p><p id="5d9c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">这里的问题基本上与pureComponent相同。如果每次你渲染你的父组件的时候，你给了一个pureComponent新的道具，它将需要重新渲染。<strong class="ix hv">如果你的组件的行为是相同的，你需要做的是保持先前的属性。</strong></p><p id="de0f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">一旦正确理解了这一点，那么<a class="ae jw" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank">重新选择</a>是克服这个问题的一个很好的解决方案。这又一次引入了一些样板文件，但这绝对是值得的。</p><p id="032c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">但是要小心，<strong class="ix hv">对重选的不良使用也会引入新的性能问题</strong>。当您在应用程序的不同位置共享您的reducers，或者在同一组件的不同实例之间共享时，情况尤其如此。这里问题是重选选择器基本上是内存化的方法，其缓存限制为一个。重新选择文档有一个关于共享选择器的章节，并提供了一个模式来克服它。基本上，它包括为组件的每个实例创建新的选择器。其他库，如<a class="ae jw" href="https://github.com/toomuchdesign/re-reselect" rel="noopener ugc nofollow" target="_blank"> re-reselect </a>以不同的方式解决了这个问题。</p><p id="d157" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">在任何情况下，当您开始跨组件或同一组件的不同实例共享选择器时，您都应该非常小心。</p><h1 id="3d6a" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">更进一步</h1><p id="bc05" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">在所有智能手机上提供无延迟的体验不是一次性的任务，而是一个持续的追求，软件开发也是如此。你会发现下面一些我们正在考虑的改进。</p><h2 id="8b81" class="mc jy hu bd jz md me mf kd mg mh mi kh jt mj mk kl ju ml mm kp jv mn mo kt mp dt translated">使用React Native 0.59</h2><p id="04d6" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">如前所述，RN0.59带React钩子到React Native。使用钩子应该允许我们从重新组合中切换出来，重新组合已经不再被开发了。</p><p id="c7d1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">而且React Native 0.59给Android设备带来了升级版的<a class="ae jw" href="https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059#updated-jsc-means-performance-gains-and-64-bit-support-on-android" rel="noopener ugc nofollow" target="_blank"> JavaScriptCore </a>，已经有一段时间没有更新了。此次更新带来了约25%的性能提升，<a class="ae jw" href="https://developer.android.com/distribute/best-practices/develop/64-bit" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv"> 64位支持将于2019年8月1日起在Google Play商店强制执行</strong> </a> <strong class="ix hv">。</strong></p><h2 id="fcac" class="mc jy hu bd jz md me mf kd mg mh mi kh jt mj mk kl ju ml mm kp jv mn mo kt mp dt translated">尝试平面列表选项</h2><p id="1cbb" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">当呈现元素列表时，您应该始终使用基于<a class="ae jw" href="https://facebook.github.io/react-native/docs/virtualizedlist" rel="noopener ugc nofollow" target="_blank">虚拟化列表</a>的组件，例如<a class="ae jw" href="https://facebook.github.io/react-native/docs/flatlist" rel="noopener ugc nofollow" target="_blank">平面列表</a>或<a class="ae jw" href="https://facebook.github.io/react-native/docs/sectionlist" rel="noopener ugc nofollow" target="_blank">部分列表</a>。根据你的列表中的项目数量，组件的复杂程度和它们的尺寸，你可能需要花一些时间来调整它们的道具，因为它们中的很多会对性能产生直接影响。</p><h2 id="ea41" class="mc jy hu bd jz md me mf kd mg mh mi kh jt mj mk kl ju ml mm kp jv mn mo kt mp dt translated">使用工具检测您的性能问题</h2><p id="3ab2" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">当试图了解性能问题时，您需要了解组件装载或渲染的时间。<a class="ae jw" href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" rel="noopener ugc nofollow" target="_blank"> React Profiler </a>对于理解延迟的来源有很大的帮助。</p><p id="5766" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">我们还没有使用过，但是在你的应用程序中寻找响应源时可能有用的东西是<a class="ae jw" href="https://github.com/facebook/react-native/blob/0ee5f68929610106ee6864baa04ea90be0fc5160/Libraries/BatchedBridge/MessageQueue.js#L88" rel="noopener ugc nofollow" target="_blank">监视队列</a>，正如这里的<a class="ae jw" href="https://blog.callstack.io/reactnative-how-to-check-what-passes-through-your-bridge-e435571ffd85" rel="noopener ugc nofollow" target="_blank">所解释的</a>。队列是应用程序的JS部分和本机部分之间的通信代理通道。</p><p id="4cf3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf jt jh ji jj ju jl jm jn jv jp jq jr js hn dt translated">你的界面可能是半反应性的:例如滚动视图或可触摸的不透明度工作，但是你写的JS处理程序不会被触发。在这种情况下，这意味着执行本机代码，而不是JS。监视队列是否超级繁忙可能是了解问题来源的好方法。</p><h1 id="4c94" class="jx jy hu bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dt translated">谢谢</h1><p id="9239" class="pw-post-body-paragraph iu iv hu ix b iy kv ja jb jc kw je jf jt kx ji jj ju ky jm jn jv kz jq jr js hn dt translated">喔，恭喜你读到这里。有什么个人小贴士可以分享吗？不要害羞，评论；-)你还有什么问题吗？请放在那里，我会尽力回答。</p></div></div>    
</body>
</html>