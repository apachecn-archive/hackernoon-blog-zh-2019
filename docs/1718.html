<html>
<head>
<title>Easily Impossible: One approach to designing a great API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不可能的事情:设计优秀API的一种方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/easily-impossible-one-approach-to-designing-a-great-api-16fc02e42d?source=collection_archive---------2-----------------------#2019-03-13">https://medium.com/hackernoon/easily-impossible-one-approach-to-designing-a-great-api-16fc02e42d?source=collection_archive---------2-----------------------#2019-03-13</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="add8" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">为什么构建图形用户界面很难？</h2></div><p id="31ab" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么编写和维护UI代码这么难？原因之一是糟糕的API设计。特别是在一组用例中<em class="kf">控制</em>与<em class="kf">工作</em>之间的不均衡。努力是使用API实现一个用例所花费的时间。控制是我们发送给API的命令可以有多细粒度。</p><p id="f06d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个平衡问题不是GUI特有的，而是API设计中的一个普遍问题。这篇文章是我试图用前端开发的例子来理解控制和努力之间的动态关系。</p><h1 id="11f0" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">失落的几何艺术</h1><p id="7335" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">这里有一个谜题。假设我们有两个矩形。一个比另一个更高更宽。我们希望将较小的矩形放置在较大的矩形内并垂直居中。</p><p id="1d29" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">较大矩形的高度为<code class="eh ld le lf lg b">h1</code>。小一号的高度是<code class="eh ld le lf lg b">h2</code>。我们如何求解<code class="eh ld le lf lg b">x</code>，其中<code class="eh ld le lf lg b">x</code>是一个矩形相对于另一个矩形的垂直偏移？</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/5b5a9912661647e9555fd915cca53317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvVRZ3-X_HtASnsR29wmYA.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Puzzle: center a rectangle</figcaption></figure><p id="0979" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想尝试一下，这里有几个选择:</p><pre class="li lj lk ll fq lx lg ly lz aw ma dt"><span id="8c28" class="mb kh hu lg b fv mc md l me mf">1. x = h1 / 2<br/>2. x = (h1 - h2) / 2<br/>3. x = (h1 + h2) / 2</span></pre><p id="b17e" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae mg" href="https://gist.github.com/flpvsk/92e99d5400ffb27e671c531d2129c424" rel="noopener ugc nofollow" target="_blank">见正确答案</a></p><p id="352c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你看，这只是一行数学——电子表格的老的不性感的编程语言。</p><p id="180c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们把这个问题从表单领域转移到HTML文档领域，它仍然是可以解决的。这一次是用CSS——浏览器的新的很酷的风格语言。</p><pre class="li lj lk ll fq lx lg ly lz aw ma dt"><span id="4c17" class="mb kh hu lg b fv mc md l me mf">.container {<br/>  display: flex;<br/>  align-items: center;<br/>}</span></pre><h2 id="5121" class="mb kh hu bd ki mh mi mj km mk ml mm kq js mn mo ks jw mp mq ku ka mr ms kw mt dt translated">稍微难一点的谜题</h2><p id="5b6b" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">让我们把它变得难一点。现在我们想把小矩形的上边和一个网格联系起来。其余都一样。我们仍然将较小的盒子放在较大的盒子的中心，只是这次将<code class="eh ld le lf lg b">x</code>的值四舍五入到最近的网格行。</p><p id="0c11" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个网格行的高度是<code class="eh ld le lf lg b">h3</code>。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/0bff1d6273b67e8b922ea8102e366439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2nRIPxPeSKJ8CgvOudIqQ.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Puzzle: center a rectangle within a grid</figcaption></figure><pre class="li lj lk ll fq lx lg ly lz aw ma dt"><span id="8a81" class="mb kh hu lg b fv mc md l me mf">1. x = h3 * round((h1 - h2) / (2 * h3))<br/>2. x = h3 * (h1 - h2) / 2<br/>3. x = h3 * floor((h1 + h2) / 2)</span></pre><p id="fa42" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae mg" href="https://gist.github.com/flpvsk/e33a78a67a06ccbd9f80498140acd79d" rel="noopener ugc nofollow" target="_blank">见正确答案</a></p><p id="d205" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这次的解决方案更复杂，但它仍然是数学，仍然只有一行。我们如何用CSS做到这一点？用iOS自动布局？安卓布局？</p><p id="9005" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可悲的是，没有办法。</p><h2 id="7f46" class="mb kh hu bd ki mh mi mj km mk ml mm kq js mn mo ks jw mp mq ku ka mr ms kw mt dt translated">谁掌握了节奏？</h2><p id="4e29" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">这些谜题的灵感来自GUI的真实使用案例。最后一个是<a class="ae mg" href="https://zellwk.com/blog/why-vertical-rhythms/" rel="noopener ugc nofollow" target="_blank">垂直节奏的模型，</a>一个来自印刷术的概念。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/ea3469ceec840e129e7a84aa2ff4d579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQzAXmBUaksaKy-rnK9j4w.png"/></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Vertical rhythm</figcaption></figure><p id="ba30" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为什么执行起来这么难？毕竟，我们只是在屏幕上排列像素。像素是正方形。正方形是我们应该能够轻松操作的几何形状。但是我们不能。</p><h2 id="eddf" class="mb kh hu bd ki mh mi mj km mk ml mm kq js mn mo ks jw mp mq ku ka mr ms kw mt dt translated">像素不是像素</h2><p id="d94d" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">问题是屏幕上的一个像素是由系统中的其他东西来表示的。它是一个DOM元素，一个视图，一个对象。它是一千种不同的东西。一个像素<em class="kf">实际上是什么</em>对开发者是隐藏的。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff mv"><img src="../Images/6c25b5915648463b145faab3a9b1454c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mHC96-0N_N6lTz9V6TrZQ.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Browser’s render pipeline</figcaption></figure><p id="19d8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在浏览器的情况下，这会导致各种不便:</p><ul class=""><li id="7cb4" class="mw mx hu jl b jm jn jp jq js my jw mz ka na ke nb nc nd ne dt translated">我们仅限于浏览器厂商认为常见的用例；</li><li id="153e" class="mw mx hu jl b jm nf jp ng js nh jw ni ka nj ke nb nc nd ne dt translated">我们不能为布局或绘制阶段的渲染编写测试；</li><li id="1c5e" class="mw mx hu jl b jm nf jp ng js nh jw ni ka nj ke nb nc nd ne dt translated">测试任何与用户界面相关的东西都需要<em class="kf">开发一个浏览器。</em>这就像乘坐私人飞机去杂货店购物一样。</li></ul><h1 id="48ba" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">错误的权衡</h1><p id="0ca1" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">我在文章的开头说过，这里的核心问题是:</p><blockquote class="nk nl nm"><p id="a2eb" class="jj jk kf jl b jm jn iv jo jp jq iy jr nn jt ju jv no jx jy jz np kb kc kd ke hn dt translated">在一组用例中，控制与努力之间的平衡不佳。</p></blockquote><p id="46d8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我们来解释一下这句话。</p><p id="7106" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">API的用例集是开发人员可能想要实现的所有东西。浏览器供应商给了我们制作图形用户界面的能力。我们可能想要构建的任何接口都包含在用例集中。这是一大套。</p><p id="7802" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">努力是使用API实现一个用例所花费的时间。花费的时间越多(对于已经知道API如何工作的人来说)就越难使用。</p><p id="91ce" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我所说的“控制”是指我们发送给API的命令可以有多细粒度。在图形API中，控制的级别可以不同，从改变组件的属性到改变形状的属性，再到操纵像素。</p><p id="fc9a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们所拥有的控制力通常是由我们所使用的抽象层次决定的。抽象程度越低，越接近硬件，我们就越有控制力。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/72f8ab3d4136145b9d19fa5ea89362b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0JBCnS8HjeP_3lkrLa1uQ.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Level of Abstraction vs Effort relationship for different kinds of use cases</figcaption></figure><p id="c179" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">努力和控制这两个参数似乎是直接冲突的。我们控制得越多，我们要做的工作就越多。那是真的，但是它不是全部事实。</p><p id="1263" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们通过用例集时，工作/控制关系会发生变化。使用高级浏览器API，在屏幕上显示一段文本很容易做到。随着我们使用更低层次的抽象，这变得越来越困难。想象一下，编写一个着色器来绘制给定字体的字符。😱</p><p id="70ea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在让我们记住文章开头的网格的例子。一些用例对于高层抽象来说是不可能的。除非API供应商认为这样的用例足够普遍，否则我们无法实现它。同时，使用OpenGL这样的高控制低级API也不难做到。</p><p id="08aa" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们正在慢慢接近API设计的主题。当我们面临这些权衡时，作为系统设计师，我们有什么选择？一个显而易见的选择是优先考虑等式的一部分。</p><h1 id="eb9a" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">#使用平台</h1><p id="1a23" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">历史上，浏览器供应商优先考虑最小化一组常见用例的工作量。浏览器在桌面屏幕上显示带有文本和图像的文档时表现不错。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/c1c10a24a490e87559f1f0b09298f517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWlbJdE3lKNgUXZTeK2Skw.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Browser API as a flat surface</figcaption></figure><p id="c237" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当出版商和开发商开始要求更多时，问题就出现了。支持多种平台，不同的屏幕分辨率和密度。构建应用程序、游戏和其他交互式媒体。这一切都需要给制造商更多的机会，更多的控制力(T2)。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/2e2f9318ee146e1e11567f5442cca9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAS8QPYEwyZhDzqM3Iwcgg.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Browser API as a cheese</figcaption></figure><p id="1b68" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">导致了我们今天的处境。有一个普通情况下的平面API，上面钻了一堆“洞”来访问浏览器所具有的低级功能(已经有一段时间了)。</p><p id="d783" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这就是为什么我们可以在HTML画布上绘制任意形状，但我们不能让这些形状成为DOM、CSSOM或AOM(可访问性对象模型)的一部分。</p><p id="2dd4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以使用不同的布局模型，如flexbox或grid。但是我们没有办法对布局阶段的结果进行单元测试。</p><p id="619d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们可以在某种程度上控制浏览器在缓存中存储什么，但是我们不能在代码中保存、检索和操作文件内容。在某种程度上，由于文件API，我们将能够做到这一点。但它将是一个独立的构造，与缓存、服务工作者、应用程序缓存和其他API无关。即使所有这些<em class="kf">都有相同的基础。</em></p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff lh"><img src="../Images/99c9efb09af6b53e90deddad5c343758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUOJbsnivOXGGeN3q8BQnA.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Browser API vs Browser insides</figcaption></figure><h1 id="7fd0" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">通过痛苦的经历</h1><p id="7192" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">区分努力和控制的优先顺序是解决这个冲突的一个方法。还有一个办法。更难的方法。</p><p id="70e6" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">作为API的设计者，我们可以决定在层中公开它。以提供对低级和高级原语的访问。棘手的部分是以这样一种方式来做，即开发人员可以乱搞低级别的API，而结果不会被系统的其余部分“排除”。</p><p id="93e4" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">颤振是这种方法的一个很好的例子。Flutter是Google做的跨平台移动开发平台。</p><figure class="li lj lk ll fq lm fe ff paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="fe ff nq"><img src="../Images/462273aa9666133cf8c22934fdd33ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sv89bCFTFYlsDcDMGj_rkg.png"/></div></div><figcaption class="lt lu fg fe ff lv lw bd b be z ek">Flutter architecture</figcaption></figure><p id="1b3c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于Flutter API的分层结构，我们能够:</p><ul class=""><li id="e377" class="mw mx hu jl b jm jn jp jq js my jw mz ka na ke nb nc nd ne dt translated">制作一个负责布局其子级的小部件；</li><li id="6052" class="mw mx hu jl b jm nf jp ng js nh jw ni ka nj ke nb nc nd ne dt translated">在不启动仿真器的情况下，对我们的定制布局小部件<em class="kf">进行单元测试；</em></li><li id="29d1" class="mw mx hu jl b jm nf jp ng js nh jw ni ka nj ke nb nc nd ne dt translated">使用自定义绘制方法制作一个小部件。例如，我们可以制作一个自定义形状、有趣的阴影或着色效果的按钮；</li><li id="070f" class="mw mx hu jl b jm nf jp ng js nh jw ni ka nj ke nb nc nd ne dt translated">这个自定义小部件在它接受的手势、可访问性和其他属性方面仍然是一个按钮；</li><li id="65e7" class="mw mx hu jl b jm nf jp ng js nh jw ni ka nj ke nb nc nd ne dt translated">我们也可以对油漆操作进行单元测试。同样，只需在Dart VM中运行代码，不需要仿真器。</li></ul><p id="9974" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">回到本文开头的网格示例。下面是垂直居中其子部件的代码，将它们绑定到一个网格:</p><pre class="li lj lk ll fq lx lg ly lz aw ma dt"><span id="14a1" class="mb kh hu lg b fv mc md l me mf">Offset getPositionForChild(<br/>  Size containerSize,<br/>  Size childSize<br/>) {<br/>  final h1 = containerSize.height;<br/>  final h2 = childSize.height;<br/>  final h3 = rowHeight;<br/>  final rowsCount = ((h1 - h2) / (2 * h3)).round();<br/>  return Offset(0, rowsCount * h3);<br/>}</span></pre><p id="e909" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如你所看到的，Flutter中的代码看起来非常类似于我们使用数学得出的结果:<code class="eh ld le lf lg b">x = h3 * round((h1 - h2) / (2 * h3)).</code>这是在正确的抽象层次上工作的另一个好处:我们表达意图的方式是直接的。</p><p id="7863" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是Flutter中最终应用的外观:</p><figure class="li lj lk ll fq lm"><div class="bz el l di"><div class="nr ns l"/></div></figure><h1 id="49ca" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">结束语</h1><p id="e801" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">这些努力与冲突、分层与扁平化的原则帮助我解决了工作中一些反复出现的问题。这是一个有用的视角。</p><p id="e6ea" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有时，我们会陷入“钻取”扁平的高级API来提取隐藏在下面的功能。这表明我们可能需要改变我们的方法。请记住，有一个更大的用例集，我们可以用一个更低级的API来支持它。逐一提取每个用例会导致臃肿的设计和作为API设计者的<em class="kf">更多的工作</em>。</p></div><div class="ab cl nt nu hc nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="hn ho hp hq hr"><p id="2960" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章是<a class="ae mg" href="https://flpvsk.com/blog/2019-03-08-control-effort-in-api-design/" rel="noopener ugc nofollow" target="_blank">最初发表在我的博客上。</a></p><p id="2ca8" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想了解更多关于GUI开发的不同方法，请查看<a class="ae mg" href="https://codepodcast.com/posts/2017-04-28-episode-6-dont-make-me-write-ui/" rel="noopener ugc nofollow" target="_blank">本期代码播客。</a></p><p id="a000" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章是基于我做的一个API设计演讲。你可以在这里找到这次演讲的视频。</p></div></div>    
</body>
</html>