<html>
<head>
<title>Debugging Serverless Applications with Dashbird</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Dashbird 调试无服务器应用程序</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/debugging-serverless-applications-with-dashbird-82a2ed86d757#2019-01-25">https://medium.com/hackernoon/debugging-serverless-applications-with-dashbird-82a2ed86d757#2019-01-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="8d71" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">借助 AWS Lambda，我们获得了开箱即用的可伸缩性和弹性。更重要的是，AWS 还通过 CloudWatch 和 X-Ray 提供内置的监控、日志和跟踪支持。这些内置工具提供了一个很好的起点，但是随着他们的无服务器应用程序变得越来越复杂，许多开发人员最终会放弃它们。</p><p id="3ab4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我们来看一个无服务器的应用程序，看看<a class="ae jp" href="https://dashbird.io/" rel="noopener ugc nofollow" target="_blank"> Dashbird </a>如何帮助你调试这个应用程序。</p><h1 id="6264" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">无服务器可观测性的挑战</h1><p id="5db1" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">谈到可观察性，无服务器引入了一些有趣的挑战。长期以来，我们一直依赖于使用代理和守护进程来收集指标和日志。它们在后台静默运行，远离我们的关键路径，我们关心的是最大限度地减少面向用户的延迟。他们批量收集、缓冲、发布这些可观测性数据，提高效率。作为一种实践，它们是如此根深蒂固地融入到我们如何监控我们的应用程序中，直到现在。</p><p id="f232" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">说到无服务器，特别是 AWS Lambda 这样的托管平台，我们根本没有地方安装这些代理！</p><p id="8fed" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">收集度量和日志作为函数调用的一部分会增加调用时间的开销，这是可以理解的。因为 AWS 已经异步地从您的函数中收集日志，并将它们发布到 CloudWatch 日志中。一种常见的解决方法是订阅这些日志并对其执行后处理。</p><p id="d5b0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">事实上，这就是 Dashbird 收集函数执行数据的方式。它将 CloudWatch 日志组订阅到一个 Kinesis 流，然后从那里处理事件。你可以在<a class="ae jp" href="https://theburningmonk.com/2018/07/centralised-logging-for-aws-lambda-revised-2018/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中了解这种方法的优势。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff kt"><img src="../Images/0d998e73abf7101533aae9b709412166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MU2JAw5c2Pkrb6Bn.png"/></div></div></figure><p id="6d94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">随着我们的无服务器应用程序变得越来越复杂，能够跨多个函数跟踪执行对我们来说很重要。正如演示应用程序所演示的，即使一个简单的用户事务也可以跨越多个事件源和 Lambda 函数。</p><h1 id="80be" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">演示应用程序</h1><p id="b1d9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">想象你正在构建一个 Twitter 的克隆体。该系统的核心特性之一是将用户的帖子分发给其追随者。为了实现这个特性，假设我们有两个独立的 API 端点:</p><ul class=""><li id="cc7b" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">发布帖子/创建:为当前用户创建新帖子</li><li id="f3d6" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">获取关注者/{userId}:获取用户的关注者</li></ul><p id="6b85" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每个端点分别由一个单独的 Lambda 函数处理— <strong class="it hv"> <em class="lt"> create-post </em> </strong>和<strong class="it hv"> <em class="lt"> get-followers </em> </strong>。</p><p id="1fd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当用户发布新的帖子时，<strong class="it hv"> <em class="lt"> create-post </em> </strong>函数会将帖子保存在<strong class="it hv"> <em class="lt"> posts </em> </strong> DynamoDB 表中，并且还会将<strong class="it hv"><em class="lt">post-create</em></strong>事件发布到 Kinesis 流中。该事件然后触发一个<strong class="it hv"> <em class="lt">分发-发布</em> </strong>功能。该函数将查询<em class="lt"> GET followers/{userId} </em>端点，然后将帖子添加到追随者的提要中。<strong class="it hv"><em class="lt">get-followers</em></strong>函数将查询<strong class="it hv"><em class="lt">followers</em></strong>DynamoDB 表以返回用户的关注者的 id。</p><p id="f57c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了简洁起见，我省略了实际发布帖子的逻辑。因此，我们的演示应用程序的整体架构如下所示。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lu"><img src="../Images/d8ef75bacd1b39cce88984da9c4c008e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NoHAE22yc7RxaT9V.png"/></div></div></figure><p id="f209" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更有趣的是，每个 Lambda 函数都基于可配置的概率被硬连线到错误或超时。演示应用的源代码在 Github 上可以找到<a class="ae jp" href="https://github.com/theburningmonk/dashbird-demo" rel="noopener ugc nofollow" target="_blank">，所以你可以自己尝试一下。</a></p><h1 id="969b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">介绍 Dashbird</h1><p id="8a57" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">即使是一个简单的无服务器应用程序，就像上面概述的那样，我们也有相当多的函数要处理。让我们看看如何使用 Dashbird 来帮助我们监控这个应用程序和调试问题。</p><p id="3c9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我一登录，我的帐户就有了一个高级仪表板。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/bae4a11c826dbcfedb266378d73f8e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3wx05u1keXGMJAij.png"/></div></div></figure><p id="0baf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了我在 AWS Lambda 控制台中获得的数据(见下文)，Dashbird 仪表盘还有两个有用的数据点:</p><ul class=""><li id="3241" class="lf lg hu it b iu iv iy iz jc lh jg li jk lj jo lk ll lm ln dt translated">函数的平均内存利用率</li><li id="261e" class="lf lg hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">Lambda 调用的成本</li></ul><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/59d472120be4abc60ae237378f8e262d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-RRtkvYI3B7LvFeT.png"/></div></div></figure><p id="36f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">接下来，在 Dashbird 的 Lambda 控制台中，我可以看到我的功能及其在过去 24 小时内的活动的高级摘要。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/3530879851c7fe444066f1ca16ee40b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z21gtl_jfN-kE-nn.png"/></div></div></figure><p id="19a8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我发现这里非常有用的一个事实是，它将空闲 10 天的函数突出显示为非活动的。随着您的无服务器架构的扩展，您最终拥有由不同团队维护的数百个功能，很难跟踪哪些功能不再需要。拥有冗余功能是一种安全风险，因为它们仍然是可以被利用的攻击面。</p><p id="f3c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然这个视图不能明确地告诉您哪些功能不再使用。许多功能不会定期运行。也许它们是一个月只运行一次的 cron 作业的一部分。或者，它们可能只在灾难恢复场景中使用。尽管如此，知道哪些功能是不活动的会鼓励团队问这样的问题“这个功能还需要吗？”。从这里开始，也许会出现更好的实践。例如，使用标记来标记预计很少使用的函数，这样它们就不会被这些检查标记出来。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/a4bc1a6c868cc720dd1092f77e606c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CsuMFbXUfo4gUeLy.png"/></div></div></figure><p id="8a5f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我导航到其中一个函数，那么我就有一个以函数为中心的视图，显示调用时间、错误、成本和内存利用率。此外，我还可以看到最近调用的列表。这里真正有用的是冷启动和重试都有明确的标签。在调试实时问题时，这让我可以快速缩小需要注意的调用范围。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/ce373ae9a036d93f779848fb969c9358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8_jid1Y_sG_cbTJn.png"/></div></div></figure><p id="bc3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">很快，我可以看到 6 秒后有 3 个调用超时了。更何况原来的 Kinesis 事件重试了 3 次，终于在第三次重试时成功了。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/96ae2c47498d1522539084aae98c5614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J7SEZ_EK1aWK6o3A.png"/></div></div></figure><p id="ea9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我单击某个调用旁边的“+”按钮，就可以深入到调用本身。在这里，我可以在一个屏幕上看到这个调用的日志和 X 射线跟踪。这很棒，因为它让我不必经常在不同的 AWS 控制台之间切换。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/c67471c345c5e299b9c3d58796b983b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9-VOw-xsrF3mB5nQ.png"/></div></div></figure><h1 id="2750" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">使用 Dashbird 调试</h1><p id="e4b9" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">如前所述，演示应用程序是硬连线到错误和超时。果然，当这些故障案例发生时，Dashbird 的内置警报功能启动了，我立即收到了通知我出现问题的电子邮件。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lw"><img src="../Images/d36f3330db79204ddfdd36c4c13e6e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TDIcxxsnG-n_eap0.png"/></div></div></figure><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lx"><img src="../Images/718849122d35731f3c1563ec0a337672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*unPiVL0E6QC057iS.png"/></div></div></figure><p id="5d98" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">虽然这个内置的警报很棒，但我看不到任何调整警报灵敏度的设置。</p><p id="c5b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我按照电子邮件中的链接，找到了函数，然后是失败的调用。Dashbird 将相关的调用(初始超时和后续重试)整齐地分组在一起。我可以很快看到失败的 Kinesis 事件在第 3 次重试时被成功处理。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff ly"><img src="../Images/17d4e42945f726db2c8a92e05dc586d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P8P9xvKvn_-IdQzv.png"/></div></div></figure><p id="428e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Dashbird 还在错误控制台中跟踪未解决的问题。现在我知道问题已经自行解决，我可以继续解决错误。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/b44f9461f93105b273ed00fc62eeecdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OKovmxFYKL4pGPmG.png"/></div></div></figure><h1 id="660b" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">拖尾函数日志</h1><p id="374b" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">Dashbird 的另一个很好的特性是它能够同时跟踪多个函数的日志。对于演示应用程序，当我卷曲<em class="lt">POST POST/create</em>端点时，我希望看到<em class="lt"> create-post </em>和<em class="lt"> distribute-post </em>函数的日志。</p><p id="7444" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这样，我可以看到事件被成功发布到 Kinesis 流中，并随后被<em class="lt"> distribute-post </em>函数接收。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lv"><img src="../Images/86ed9fe4c063390b7613f623599b842c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nq_eP-14T_YcL3ps.png"/></div></div></figure><h1 id="8781" class="jq jr hu bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dt translated">结论</h1><p id="fbf5" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">总的来说，Dashbird 提供的东西给我留下了深刻的印象，很明显，在这个产品上花了很多心思。它有许多不错的地方，使调试变得更加容易。例如，将重试分组在一起，并将 X 射线跟踪和日志集成在一个屏幕中。这些可能看起来微不足道，但在处理一个现实问题的高压场景下，它们可以产生很大的影响。</p><p id="ed26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就我所见，我认为 Dashbird 是一个非常棒的工具。我缺少的主要东西是端到端跟踪执行的能力。就我个人而言，我真的希望看到从创建 post 的 API 调用开始的整个执行过程，一直到对<strong class="it hv"><em class="lt">followers</em></strong>DynamoDB 表执行查询的<strong class="it hv"> <em class="lt"> get-followers </em> </strong>函数。</p><figure class="ku kv kw kx fq ky fe ff paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="fe ff lz"><img src="../Images/793ccca17e80549c0351128f60eb47f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tjx1XgwC9lZZgtCP.png"/></div></div></figure><p id="ff59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你仅仅依赖内置的 AWS 工具(CloudWatch、CloudWatch Logs 和 X-Ray ),那么你应该试试 Dashbird。为什么不注册免费试用，并将演示应用程序部署到您的环境中，以便您可以了解 Dashbird 如何帮助您调试无服务器应用程序？</p></div><div class="ab cl ma mb hc mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="hn ho hp hq hr"><p id="e565" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lt">原载于 2019 年 1 月 25 日</em><a class="ae jp" href="https://dashbird.io/blog/debugging-serverless-apps-with-dashbird/" rel="noopener ugc nofollow" target="_blank"><em class="lt">dash bird . io</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>