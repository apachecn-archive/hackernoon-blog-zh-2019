<html>
<head>
<title>Class delegation in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林的班级代表团</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/kotlin-what-is-class-delegation-all-about-683eb543e391#2019-04-29">https://medium.com/hackernoon/kotlin-what-is-class-delegation-all-about-683eb543e391#2019-04-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2b79b330e02558acfabcb6c5cc071655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DrRo5oEq8j4VJphByZYekA.png"/></div></div></figure><p id="a789" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">TL；你现在这样很好，你可以跳过这篇文章。</strong></p><p id="4f14" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们开始之前，让我们看看 Kotlin 中的班级代表是什么样的:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="8ed1" class="kj kk hu kf b fv kl km l kn ko">interface Flyable {<br/>    fun fly()<br/>}</span><span id="27aa" class="kj kk hu kf b fv kp km l kn ko">interface Movable {<br/>    fun move()<br/>}</span><span id="5083" class="kj kk hu kf b fv kp km l kn ko">class Aircraft(<br/>    liftMechanism: Flyable, <br/>    propulsion: Movable<br/>): Flyable by liftMechanism, Movable by propulsion</span></pre><p id="044c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么这段代码是做什么的呢？这个类别代表一种能够移动和飞行的飞行器。这可以通过层级来实现，对吗？那么，为什么要大费周章，用委托来定义它呢？做好准备，因为这是我们在这篇文章中要讨论的全部内容。</p><h2 id="b417" class="kj kk hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">等级制度</h2><p id="77c3" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">如果您来自 Java 或其他早期语言，您可能对继承有很好的了解。<strong class="je hv">为了定义模型，我们通常找到它们之间的共性来定义一个基类，然后我们基于差异来定义派生类，创建一个类层次结构。</strong></p><p id="f9da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">简而言之，我们试图根据模型定义一个家谱。例如，飞机是一种移动和飞行的交通工具，而滑翔机则是一种不用任何引擎就能移动的飞机。所以你这样定义你的模型:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="7a6e" class="kj kk hu kf b fv kl km l kn ko">interface Aircraft {<br/>    fun fly()<br/>    fun move ()<br/>}</span><span id="ade2" class="kj kk hu kf b fv kp km l kn ko">interface WingedAircraft: Aircraft {<br/>    override fun fly() = <em class="lo">print</em>("Adjust wing angle..")<br/>}</span><span id="8e95" class="kj kk hu kf b fv kp km l kn ko">interface RotorCraft: Aircraft {<br/>    override fun fly() = <em class="lo">print</em>("Start spinning the blades..")<br/>}</span><span id="edcd" class="kj kk hu kf b fv kp km l kn ko">interface UnpoweredVehicle: Aircraft {<br/>    override fun move() = <em class="lo">print</em>("Just hanging up here..")<br/>}</span><span id="765f" class="kj kk hu kf b fv kp km l kn ko">interface PropelledVehicle: Aircraft {<br/>    override fun move() = <em class="lo">print</em>("Starting engine..")<br/>}</span></pre><p id="4ae4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们可以派生出这样的类:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="147c" class="kj kk hu kf b fv kl km l kn ko">class Glider: WingedAircraft, UnpoweredVehicle<br/>class Jet: WingedAircraft, PropelledVehicle<br/>class Gyroglider: RotorCraft, UnpoweredVehicle<br/>class Helicopter: RotorCraft, PropelledVehicle</span></pre><p id="6231" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如此熟悉，对吗？借助默认实现的<strong class="je hv">接口，</strong>我们可以在 Kotlin 中创建类似多重继承的东西。的确是好的；那么真的还有什么问题需要班级委托来解决吗？还有改进的空间吗？要看到这一点，首先我们必须深入到层次结构中。</p><h2 id="99b6" class="kj kk hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">遗传多态性</h2><p id="5b91" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">那么遗传是怎么回事呢？它是多态的，它使你能够定义一个类，通过它是什么或者它是从什么派生的。所以如果一个职业是从 jet 衍生出来的，那么它就是 jet，现在根据它是什么，它可以从 Jet 进化成战斗机或者无人机。这很好，但是你打算在哪个层次上添加这个新特性呢？哪些实体会是你的父母？杰特？有翼推进？</p><p id="9da3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能会得到这样一个类:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="924e" class="kj kk hu kf b fv kl km l kn ko">class Fighter: WingedAircraft, PropelledVehicle, CombatAircraft</span></pre><p id="6c77" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">，而其他人也会这样结束</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="738d" class="kj kk hu kf b fv kl km l kn ko">class Fighter: Jet()</span></pre><p id="4925" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">，而其他人(肯定不是我)可能会这样结束</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="2647" class="kj kk hu kf b fv kl km l kn ko">class Fighter: Aircraft</span></pre><p id="21d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如你所见，我们已经在看家谱了。</p><h2 id="e399" class="kj kk hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">问题是</h2><p id="c927" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">所以让我们引入一个问题，让我们的生活变得更艰难。比方说，我们想要添加一种新的飞行机制。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="6cea" class="kj kk hu kf b fv kl km l kn ko">interface AerostatsAircraft: Aircraft {<br/>    override fun fly() = <em class="lo">print</em>("Start floating..")<br/>}</span></pre><p id="944e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以拥有像气球一样利用热空气飞行的飞机。当然，这些飞机如何移动决定了它们的父母:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="ad10" class="kj kk hu kf b fv kl km l kn ko">class Balloon: AerostatsAircraft, UnpoweredVehicle<br/>class Zeppelin: AerostatsAircraft, PropelledVehicle</span></pre><p id="59b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，通过引入一种新的类型，子类的数量从 4 个增加到 6 个，这对于一个简单的变化来说不是一个合理的复杂性，另一种推进类型会将子类的数量从 6 个增加到 9 个，之后只会变得更糟，单独引入一个新的特性，比如飞机如何驾驶会使复杂性增加两倍。因此，这里我们需要另一种方式来模拟我们的系统。</p><h2 id="8fab" class="kj kk hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">通过合成的多态性</h2><p id="2a47" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">简单地说，组合就是通过行为来定义实体的行为。这确实变得更加容易，因为您通过查看它有什么组件来创建一个类，而不是考虑它是什么(不管上下文是什么，这都是一个困难的问题)。例如，您可以根据飞机的飞行方式来定义飞机:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="2775" class="kj kk hu kf b fv kl km l kn ko">interface Flyable {<br/>    fun fly()<br/>}</span><span id="3b60" class="kj kk hu kf b fv kp km l kn ko">class FixedWing: Flyable {<br/>    override fun fly() = <em class="lo">print</em>("Adjust wing angle..")<br/>}</span><span id="8e7f" class="kj kk hu kf b fv kp km l kn ko">class RotaryWing: Flyable {<br/>    override fun fly() = <em class="lo">print</em>("Start spinning the blades..")<br/>}</span><span id="07d5" class="kj kk hu kf b fv kp km l kn ko">class Aircraft(private val liftMechanism: Flyable): Flyable {<br/>    override fun fly() {<br/>        liftMechanism.fly()<br/>    }<br/>}</span></pre><p id="980d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">或者你可以根据它的运动方式来定义它:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="c6fe" class="kj kk hu kf b fv kl km l kn ko">interface Movable {<br/>    fun move()<br/>}</span><span id="c527" class="kj kk hu kf b fv kp km l kn ko">class Unpowered: Movable {<br/>    override fun move() = <em class="lo">print</em>("Just hanging up here..")<br/>}</span><span id="aefd" class="kj kk hu kf b fv kp km l kn ko">class Propelled: Movable {<br/>    override fun move() = <em class="lo">print</em>("Starting engine..")<br/>}</span><span id="c8db" class="kj kk hu kf b fv kp km l kn ko">class Aircraft(private val propulsion: Movable): Movable {<br/>    override fun move() {<br/>        propulsion.move()<br/>    }<br/>}</span></pre><p id="636f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在要把它推广到每一架飞机，你只需说:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="3ff5" class="kj kk hu kf b fv kl km l kn ko">class Aircraft(<br/>    private val liftMechanism: Flyable,<br/>    private val propulsion: Movable<br/>): Flyable, Movable {<br/>    <br/>    override fun fly() {<br/>        liftMechanism.fly()<br/>    }<br/>    <br/>    override fun move() {<br/>        propulsion.move()<br/>    }<br/>}</span></pre><p id="7719" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们已经建立了我们的飞机，让我们看看如何添加新类型的飞行机制影响我们的类:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="4d43" class="kj kk hu kf b fv kl km l kn ko">class HotAir: Flyable {<br/>    override fun fly() = <em class="lo">print</em>("Start floating..")<br/>}</span><span id="cade" class="kj kk hu kf b fv kp km l kn ko">val balloon = Aircraft(HotAir(), Unpowered())<br/>val zeppelin = Aircraft(HotAir(), Propelled())</span></pre><p id="3867" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">没那么多吧。我们在这里所做的是通过定义类的特性来组成类，从而拉平层次树。毕竟是相同的多态性和接口；改变的不是我们使用的技术，而是我们的思维方式。</p><h2 id="6867" class="kj kk hu bd kq kr ks kt ku kv kw kx ky jn kz la lb jr lc ld le jv lf lg lh li dt translated">科特林级代表团</h2><p id="1e3b" class="pw-post-body-paragraph jc jd hu je b jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ln jx jy jz hn dt translated">那么科特林是做什么的呢？它提供了一个语言关键字，所以你可以跳过所有无聊的部分:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="9c9c" class="kj kk hu kf b fv kl km l kn ko">class Aircraft(<br/>    liftMechanism: Flyable,<br/>    propulsion: Movable<br/>): Flyable by liftMechanism, Movable by propulsion</span></pre><p id="0d2e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">科特林班委绝不是魔术，它只是作文上面的一个合成糖(我很欣赏)，让作文更快更容易。如果有什么可以称之为魔术的话，那就是让生活和编程变得更容易的合成本身。</p><p id="0d6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">免责声明:</strong>本文不是在比较继承和合成，因为有很多关于合成优于继承的好资源，但这不是其中之一。</p></div></div>    
</body>
</html>