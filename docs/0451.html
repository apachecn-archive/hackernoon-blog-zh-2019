<html>
<head>
<title>How to Move Code into a Docker Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将代码移动到 Docker 容器中</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-move-code-into-a-docker-container-ab28edcc2901#2019-01-18">https://medium.com/hackernoon/how-to-move-code-into-a-docker-container-ab28edcc2901#2019-01-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="b5bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>提供了两个很好的选项来将你的代码移动到一个映像或者容器中:<a class="ae jp" href="https://docs.docker.com/storage/bind-mounts/" rel="noopener ugc nofollow" target="_blank">绑定挂载</a>和<a class="ae jp" href="https://docs.docker.com/engine/reference/builder/#copy" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a> <code class="eh jq jr js jt b"><a class="ae jp" href="https://docs.docker.com/engine/reference/builder/#copy" rel="noopener ugc nofollow" target="_blank">COPY</a></code> <a class="ae jp" href="https://docs.docker.com/engine/reference/builder/#copy" rel="noopener ugc nofollow" target="_blank">指令</a>。在这篇文章中，我将解释为什么在生产中图像应该总是使用<code class="eh jq jr js jt b">COPY</code>指令，以及为什么在开发中使用绑定挂载可能更方便。</p><h1 id="b98d" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">Dockerfile <code class="eh jq jr js jt b">COPY</code>指令</h1><p id="cebc" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">Dockerfile 中的<code class="eh jq jr js jt b">COPY</code>指令用于将文件或目录从主机文件系统复制到映像中。例如，下面的 Dockerfile 设置了一个在生产模式下运行的 NodeJS 应用程序。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="c40d" class="lf jv hu jt b fv lg lh l li lj"># Dockerfile<br/>FROM node:carbon</span><span id="4a56" class="lf jv hu jt b fv lk lh l li lj">WORKDIR /app<br/>ENV NODE_ENV=production</span><span id="edec" class="lf jv hu jt b fv lk lh l li lj"># Install dependencies first to take advantage of Docker layer caching. <br/>COPY package.json yarn.lock ./<br/>RUN yarn install --frozen-lockfile --no-cache --production</span><span id="90c2" class="lf jv hu jt b fv lk lh l li lj"># Copy the application files into the image. <br/>COPY . .</span><span id="2bef" class="lf jv hu jt b fv lk lh l li lj">EXPOSE 3000<br/>CMD [ "node", "app.js" ]</span></pre><p id="ae54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建并运行:</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="937a" class="lf jv hu jt b fv lg lh l li lj">$ docker build -t myapp .<br/>$ docker run -d -p 3000:3000 myapp</span></pre><p id="e7ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">COPY</code>指令递归地将文件和目录从主机复制到映像中，这意味着敏感文件也可能被复制进来。与 Git 的<code class="eh jq jr js jt b">.gitignore</code>类似，Docker 的<code class="eh jq jr js jt b"><a class="ae jp" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">.dockerignore</a></code> <a class="ae jp" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">文件</a>允许你阻止某些文件被复制到镜像中。使用 <code class="eh jq jr js jt b"><strong class="it hv">COPY</strong></code> <strong class="it hv">指令</strong>时，您应该<strong class="it hv">始终包含一个</strong> <code class="eh jq jr js jt b"><strong class="it hv">.dockerignore</strong></code> <strong class="it hv">文件。至少，它应该包括与您的版本控制系统和本地安装的依赖项相关的文件。例如，一个典型的 NodeJS 应用程序可能使用以下代码。</strong></p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="3754" class="lf jv hu jt b fv lg lh l li lj"># .dockerignore<br/>.git<br/>Dockerfile<br/>.dockerignore<br/>node_modules<br/>npm-debug.log</span></pre><h1 id="2637" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">绑定安装</h1><p id="5f68" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">绑定挂载允许您将文件或目录从主机挂载到容器中。在下面的代码片段中，工作目录被挂载并可以从容器中的<code class="eh jq jr js jt b">/app</code>访问。一旦容器开始运行，您就可以通过 shell 与它进行交互。</p><pre class="kx ky kz la fq lb jt lc ld aw le dt"><span id="64f0" class="lf jv hu jt b fv lg lh l li lj">$ docker run --rm -it -p 3000:3000 -v $(pwd):/app myapp bash<br/>root@id:/app# yarn global add nodemon<br/>root@id:/app# nodemon app.js</span></pre><p id="af1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">nodemon</code>是一个工具，用于监视文件更改，并在检测到更改时自动重启应用程序。在上面的例子中，当您更改主机上的文件时，这些更改通过绑定挂载在容器中自动可见，并且您的应用程序将在<code class="eh jq jr js jt b">nodemon</code>前自动重启。</p><h1 id="fda6" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">在<code class="eh jq jr js jt b">COPY</code>指令和绑定支架之间选择</h1><p id="022f" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">什么时候应该使用<code class="eh jq jr js jt b">COPY</code>指令，什么时候适合使用绑定挂载？</p><p id="09bb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">绑定坐骑非常适合本地开发。它们提供了便利，因为对宿主开发环境和代码的更改会立即反映在容器中，并且应用程序在容器中创建的文件(如构建工件或日志文件)可以从宿主获得。</p><p id="5b54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，绑定挂载确实带来了一些安全问题。来自<a class="ae jp" href="https://docs.docker.com/storage/" rel="noopener ugc nofollow" target="_blank"> Docker 存储文档</a>:</p><blockquote class="ll lm ln"><p id="91e3" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><em class="hu">使用绑定挂载的一个副作用，不管是好是坏，是您可以通过在容器中运行的进程来更改主机文件系统，包括创建、修改或删除重要的系统文件或目录。这是一项强大的功能，可能会带来安全隐患，包括影响主机系统上的非 Docker 进程。</em></p><p id="93d1" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><em class="hu"> […] </em></p><p id="0d32" class="ir is lo it b iu iv iw ix iy iz ja jb lp jd je jf lq jh ji jj lr jl jm jn jo hn dt translated"><em class="hu">如果您以这种方式使用 Docker 进行开发，您的生产 Docker 文件会将生产就绪的工件直接复制到映像中，而不是依赖于绑定挂载。</em></p></blockquote><p id="e32a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">绑定挂载将主机系统暴露给容器，并降低了容器的安全性和隔离性。即使是一个只读绑定挂载<a class="ae jp" href="https://docs.docker.com/storage/bind-mounts/#use-a-read-only-bind-mount" rel="noopener ugc nofollow" target="_blank">也可以暴露那些被<code class="eh jq jr js jt b">.dockerignore</code>从映像中排除的文件。为了在生产中避免这些问题<strong class="it hv">，应该使用</strong> <code class="eh jq jr js jt b"><strong class="it hv">COPY</strong></code> <strong class="it hv">命令将代码</strong>传输到映像中，而不是绑定挂载。</a></p><h1 id="7f28" class="ju jv hu bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">进一步阅读</h1><p id="291f" class="pw-post-body-paragraph ir is hu it b iu ks iw ix iy kt ja jb jc ku je jf jg kv ji jj jk kw jm jn jo hn dt translated">Docker 文档提供了其他挂载类型的详细信息，并给出了它们可能的用例的更多细节。特别是，在某些用例中，对配置文件使用绑定挂载可能是有利的。</p><p id="0619" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">而且真的，<a class="ae jp" href="https://codefresh.io/docker-tutorial/not-ignore-dockerignore/" rel="noopener ugc nofollow" target="_blank">不要忽略</a> <code class="eh jq jr js jt b"><a class="ae jp" href="https://codefresh.io/docker-tutorial/not-ignore-dockerignore/" rel="noopener ugc nofollow" target="_blank">.dockerignore</a></code>。</p></div></div>    
</body>
</html>