<html>
<head>
<title>Implementing The Perceptron Algorithm From Scratch In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python从头开始实现感知器算法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/implementing-the-perceptron-algorithm-from-scratch-in-python-48be2d07b1c0?source=collection_archive---------0-----------------------#2019-02-26">https://medium.com/hackernoon/implementing-the-perceptron-algorithm-from-scratch-in-python-48be2d07b1c0?source=collection_archive---------0-----------------------#2019-02-26</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0e95" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在本帖中，我们将看到如何使用python中的乳腺癌数据集实现感知器模型。</p><p id="afb4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感知器是神经网络的基本单元，它接受加权输入，对其进行处理，并能够执行二元分类。这是我之前关于<a class="ae jp" href="https://hackernoon.com/perceptron-deep-learning-basics-3a938c5f84b6" rel="noopener ugc nofollow" target="_blank">感知器模型</a>的帖子的后续。</p><p id="3e92" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你想跳过理论直接跳到代码，点击<a class="ae jp" href="https://github.com/Niranjankumar-c/Perceptron_Model" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="8ab2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">声明:本文的内容和结构基于四分之一实验室的深度学习讲座——</em><a class="ae jp" href="https://padhai.onefourthlabs.in" rel="noopener ugc nofollow" target="_blank"><em class="jq">pad hai</em></a><em class="jq">。</em></p><h1 id="3440" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">感知器概述</h1><p id="692f" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">与MP神经元模型中的布尔输入不同，感知器模型中的输入可以是实数。模型的输出仍然是二进制的{0，1}。感知器模型接受输入<strong class="it hv"> x </strong>如果输入的加权和大于阈值<strong class="it hv"> b </strong>输出将为1，否则输出将为0。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/56f12d961ef283f54e6e3641d3741587.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*xu7SqshfOOb3en-biidPaw.png"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Fig 1— Mathematical Representation</figcaption></figure><h1 id="4f2b" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">学习算法</h1><p id="43ad" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">学习算法的主要目标是找到能够绝对分离正的<strong class="it hv"> P </strong> (y = 1) <strong class="it hv"> </strong>和负的<strong class="it hv"/>N(y = 0)组数据的向量<strong class="it hv"> w </strong>。感知器学习算法是这样的，</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff lg"><img src="../Images/88f5e6baa8b656f4379824e27448aac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*eAAS-yZgJvyQXhRmI8Lq-A.png"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Fig 2— Perceptron Algorithm</figcaption></figure><p id="12a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要详细了解学习算法以及为什么更新权重的概念在对正负数据集进行完美分类方面起作用的直觉，请参考我以前关于<a class="ae jp" href="https://hackernoon.com/perceptron-deep-learning-basics-3a938c5f84b6" rel="noopener ugc nofollow" target="_blank">感知器模型</a>的帖子。</p></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><h1 id="3dc7" class="jr js hu bd jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko dt translated">让我们编码</h1><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/723cf8b5bd974a587e926d0a1db96ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*OHLG7rdn27squaWGxiPOAQ.png"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek"><a class="ae jp" href="https://memegenerator.net/instance/42970028/frank-costanza-enough-talk-lets-code" rel="noopener ugc nofollow" target="_blank">Image Source</a></figcaption></figure><p id="c2ea" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将使用的数据集是来自<a class="ae jp" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html" rel="noopener ugc nofollow" target="_blank"> sklearn </a>的乳腺癌数据集。数据集有569个观察值和30个变量，不包括类变量。乳腺癌数据是一个不平衡的数据集，这意味着类“0”和“1”没有被平等地表示。在这个例子中，我们不打算执行任何采样技术来平衡数据，因为这是感知器模型的简单实现。</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/1b1819ac538444ba01d97d8af468000b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*VuxcHcpCb5-EtjQUFlxsQA.png"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Class Imbalance</figcaption></figure><p id="880f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开始构建感知器模型之前，首先我们需要加载所需的包和数据集。数据集存在于sklearn数据集模块中。一旦我们加载了数据，我们需要使用<code class="eh lv lw lx ly b">breast_cancer.data</code>和<code class="eh lv lw lx ly b">breast_cancer.target</code>命令获取特性和响应变量。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lz ma l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Perceptron Preprocessing</figcaption></figure><p id="bd4f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">获取X和Y变量后，我们将执行最小-最大缩放，以显示范围0-1内的所有要素。在建立模型之前，我们将拆分数据，以便我们可以根据训练数据训练模型，并根据测试数据测试模型的性能。我们将使用sklearn的<code class="eh lv lw lx ly b">train_test_split</code>函数将数据按照90:10的比例拆分，分别用于训练和测试。现在我们已经完成了预处理步骤，可以开始构建模型了。我们将在一个名为<em class="jq">感知器</em>的类中构建我们的模型。</p><p id="99c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在感知器类中，我们将创建一个构造函数<code class="eh lv lw lx ly b">def__init__</code>。构造器将权重向量<strong class="it hv"> w </strong>和阈值<strong class="it hv"> b </strong>初始化为无。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lz ma l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Perceptron Model</figcaption></figure><p id="5e1b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">函数<code class="eh lv lw lx ly b">model</code>将输入值<strong class="it hv"> x </strong>作为参数，并执行输入的加权聚合(在<strong class="it hv"> w.x </strong>之间的点积)，如果聚合大于阈值<strong class="it hv"> b </strong>否则返回值1。接下来，我们有一个<code class="eh lv lw lx ly b">predict</code>函数，它将输入值<strong class="it hv"> x </strong>作为参数，对于<strong class="it hv"> x </strong>中出现的每个观察值，该函数计算预测结果并返回一个预测列表。</p><p id="5325" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，我们将实现<code class="eh lv lw lx ly b">fit</code>函数来学习给定数据的最佳可能权重向量<strong class="it hv"> w </strong>和阈值<strong class="it hv"> b </strong>。该函数以输入数据(<strong class="it hv"> x </strong> &amp; <strong class="it hv"> y </strong>)、学习率和历元数为自变量。</p><figure class="kv kw kx ky fq kz"><div class="bz el l di"><div class="lz ma l"/></div><figcaption class="lc ld fg fe ff le lf bd b be z ek">Perceptron Model Execution</figcaption></figure><p id="27c4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦我们准备好我们的类，我们初始化一个新的感知器类对象，并使用该对象，我们将在我们的训练数据上调用<code class="eh lv lw lx ly b">fit</code>方法来学习最好的可能参数。我们将通过计算测试精度来评估模型在测试数据上的性能。</p><p id="0c17" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本文中讨论的全部代码都在这个GitHub <a class="ae jp" href="https://github.com/Niranjankumar-c/Perceptron_Model/blob/master/PerceptronModel.ipynb" rel="noopener ugc nofollow" target="_blank">库</a>中。随意叉或者下载。</p><h1 id="6f5b" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">进一步的改进</h1><p id="5bb9" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">您可以尝试一些可能的改进来提高模型的准确性，</p><ul class=""><li id="f759" class="mb mc hu it b iu iv iy iz jc md jg me jk mf jo mg mh mi mj dt translated">改变训练-测试大小分割，并查看准确性是否有任何变化。</li><li id="7a93" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">选择更大的历元值、学习率，在感知器模型上测试，并可视化准确度的变化。</li><li id="3242" class="mb mc hu it b iu mk iy ml jc mm jg mn jk mo jo mg mh mi mj dt translated">在感知器模型中采用随机权重并进行实验。</li></ul><h1 id="8945" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">继续学习</h1><p id="075c" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">如果你想让你的学习从感知器模型更上一层楼。查看来自<a class="ae jp" href="https://courses.starttechacademy.com/full-site-access/?coupon=NKSTACAD" rel="noopener ugc nofollow" target="_blank"> Starttechacademy </a>的Abhishek和Pukhraj的<a class="ae jp" href="https://courses.starttechacademy.com/full-site-access/?coupon=NKSTACAD" rel="noopener ugc nofollow" target="_blank">人工神经网络</a>。还有，课程是用最新版本的Tensorflow 2.0 (Keras后端)讲授的。他们还有一个非常好的包，关于Python和R语言的<a class="ae jp" href="https://courses.starttechacademy.com/full-site-access/?coupon=NKSTACAD" rel="noopener ugc nofollow" target="_blank">机器学习(基础+高级)</a>。</p><h1 id="c55f" class="jr js hu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko dt translated">结论</h1><p id="5b7f" class="pw-post-body-paragraph ir is hu it b iu kp iw ix iy kq ja jb jc kr je jf jg ks ji jj jk kt jm jn jo hn dt translated">在本文中，我们看到了如何使用python从头开始实现感知器算法。</p><blockquote class="mp mq mr"><p id="5431" class="ir is jq it b iu iv iw ix iy iz ja jb ms jd je jf mt jh ji jj mu jl jm jn jo hn dt translated">联系我<br/>GitHub:<a class="ae jp" href="https://github.com/Niranjankumar-c" rel="noopener ugc nofollow" target="_blank">https://github.com/Niranjankumar-c</a>T9】LinkedIn:<a class="ae jp" href="https://www.linkedin.com/in/niranjankumar-c/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/niranjankumar-c/</a></p></blockquote><p id="9e65" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">免责声明</strong> —这篇文章中可能有一些相关资源的附属链接。你可以以尽可能低的价格购买捆绑包。如果你购买这门课程，我会收到一小笔佣金。</p></div></div>    
</body>
</html>