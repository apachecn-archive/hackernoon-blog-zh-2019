<html>
<head>
<title>My experience in publishing an AAR Artifact</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我发布 AAR 工件的经历</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/my-experience-in-publishing-an-aar-artifact-f7d554138230#2019-07-02">https://medium.com/hackernoon/my-experience-in-publishing-an-aar-artifact-f7d554138230#2019-07-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/1656282dea19c17eaaa8ca56ca4cfc73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42F_DXJnp9SzcUR3pZSrYQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">source:unsplash.com</figcaption></figure><p id="d1fc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">几个月前，我开始开发一个 SDK，它基本上是一个 AAR(Android 存档文件)。该 SDK 包含 java 和 kotlin 文件中的业务逻辑以及资源文件，如清单、布局等。这个 SDK 将被另一个想要使用我们服务的应用程序使用。所以我们需要提供一种方便的方法来共享这个 AAR 文件。</p><p id="e311" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在初始状态，我们考虑共享模块本身，这是 SDK 的源代码，但这将增加实施它的项目的编译时间，当然，我们不想公开我们的代码，即使使用代码的团队在我们公司。因此，我们转向提供 aar 文件的其他选项，这一选项显然比第一个选项好，但它仍然有缺陷，这将使手动导入 aar 文件到项目的大量工作，更不用说如果有新版本的 SDK，您将需要手动下载和删除以前的版本并导入新版本，这至少对我来说很麻烦。</p><p id="5ecc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我可以使用 jitpack 或任何其他工件托管平台，这非常容易实现，如果 SDK 有公共代码，因为我的项目是私有的，那么我需要支付在 jitpack 中托管它的费用，我不想这样做。</p><p id="c4f0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们确实有自托管的 jfrog artifactory，我可以用它来托管工件，但不幸的是 artifactory 仅用于一个专用服务，所以我仍然不能在那里托管它。</p><p id="4442" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">显然，gitlab 有一个 maven 资源库包<a class="ae ke" href="https://about.gitlab.com/2018/09/22/gitlab-11-3-released/" rel="noopener ugc nofollow" target="_blank">支持</a>(如果你使用高级版本的话)。所以没有进一步考虑，我找到了合适的地方来存放我的艺术品。</p><p id="0b1f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一开始，我试图遵循官方文档，但我发现没有运气，说明太笼统，对我来说一点帮助都没有。经过反复试验，我放弃了跟随官方文档(官方文档也可以是无用的 xD)。所以我去了谷歌，发现我们可以使用<a class="ae ke" href="https://docs.gradle.org/current/userguide/publishing_maven.html" rel="noopener ugc nofollow" target="_blank"> maven-publish </a> gradle 插件直接从 gradle 文件中发布工件，或者简单地创建一个任务来完成这项工作。</p><p id="3368" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用 maven-publish gradle 插件对我来说真是救命稻草。这真的很简单，也很容易实现。</p><p id="01ee" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要发布您的工件，您只需遵循以下步骤:</p><ol class=""><li id="dbf5" class="kf kg hu ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated">在 build.gradle 文件中应用 maven-publish 插件</li></ol><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="0692" class="kx ky hu kt b fv kz la l lb lc">apply plugin: 'maven-publish'</span></pre><p id="c302" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">2.给你的神器一个信息</p><p id="7df7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可以简单地只提供必要的信息，就像我在这里做的那样，要了解更多关于元数据或信息，你可以去这个<a class="ae ke" href="http://maven.apache.org/ref/3.6.1/maven-repository-metadata/project-info.html" rel="noopener ugc nofollow" target="_blank">链接</a></p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="7f74" class="kx ky hu kt b fv kz la l lb lc">def libraryGroupId = 'io.rahmatt.artifact'<br/>def libraryArtifactId = 'coollib'<br/>def libraryVersion = '0.0.1'</span></pre><p id="4ff6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">3.为发布做准备</p><figure class="ko kp kq kr fq iv"><div class="bz el l di"><div class="ld le l"/></div></figure><p id="9a9d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在上面的要点中，请注意，我指定了将发布到 maven 的唯一发布版本。这也是棘手的部分，起初我没有<strong class="ji hv"> pom.withXml </strong>配置，工件仍然被发布，但当我试图构建实现我的 SDK 的项目时，它给了我一个错误，它说一些依赖项丢失了，这是因为我的 SDK 也有一个不包括在项目中的第三方库的依赖项。因此，我需要指定使用我的 SDK 所需的依赖项，一旦项目实现了 SDK，它现在将自动下载所有所需的依赖项，这里<strong class="ji hv">POM . with XML</strong>configuration 来拯救我们，基本上，它创建一个 pom.xml 文件(项目对象模型)来提供我们需要的解决方案，该解决方案提供所需依赖项的信息，以便使用我们的 SDK。</p><p id="b0db" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，我们设置了存储库配置，其中我们指定了发布工件/SDK 所需的 URL 和凭证(上面是伪 URL)。这里的私有令牌是 gitlab 访问<a class="ae ke" href="https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html" rel="noopener ugc nofollow" target="_blank">令牌</a>。</p><p id="6915" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们可以通过简单地调用任务来发布工件，如下所示:</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="946c" class="kx ky hu kt b fv kz la l lb lc">./gradlew assembleRelease publish</span></pre><p id="4787" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">但在此之前，我建议你先清理项目，以防有一些生成的文件，或者只是我们想在发布之前清理项目。</p><p id="81f7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这样，我就可以用这个来下载我的工件了:</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="35d6" class="kx ky hu kt b fv kz la l lb lc">//build.gradle project level<br/>...<br/>repositories {<br/>....<br/>maven { url "<a class="ae ke" href="https://rahmatt.io/coollib" rel="noopener ugc nofollow" target="_blank">https://rahmatt.io/coollib</a>" }<br/>...<br/>}</span><span id="85b7" class="kx ky hu kt b fv lf la l lb lc">//build.gradle module level<br/>implementation "io.rahmat.artifact:coollib:0.0.1"</span></pre><p id="b810" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">还有一个用例，如果您的项目有内部或私有的可见性来下载您的工件，您也需要像这样放置认证过程的凭证</p><pre class="ko kp kq kr fq ks kt ku kv aw kw dt"><span id="82f0" class="kx ky hu kt b fv kz la l lb lc">//build.gradle project level<br/>...<br/>repositories {<br/>....<br/>maven { url "<a class="ae ke" href="https://rahmatt.io/coollib" rel="noopener ugc nofollow" target="_blank">https://rahmatt.io/coollib</a>" <br/>  credentials(HttpHeaderCredentials) {<br/>       name = "Private-Token"<br/>       value = "${private_token}"<br/>    }<br/>   authentication {<br/>       header(HttpHeaderAuthentication)<br/>  }<br/>}<br/>...<br/>}</span></pre><p id="21dd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">那就是，神器现在是活的，你可以分享它！</p><figure class="ko kp kq kr fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lg"><img src="../Images/fc2d154ee3cf708374293941b8eac64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_wNIiHukq0yeryeQZCe1A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">the information will be displayed like this once you enter the tab package in your gitlab project</figcaption></figure></div><div class="ab cl lh li hc lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hn ho hp hq hr"><p id="6eb7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">感谢你阅读这篇文章，我希望我的经历和发现可以帮助你不要像我以前一样挣扎。如果你觉得这个帖子有帮助，请鼓掌并分享到你的圈子。祝您愉快！</p></div></div>    
</body>
</html>