<html>
<head>
<title>Three Ways to Structure GraphQL Code with Apollo Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Apollo服务器构建GraphQL代码的三种方法</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/three-ways-to-structure-your-graphql-code-with-apollo-server-4788beed89db?source=collection_archive---------3-----------------------#2019-01-23">https://medium.com/hackernoon/three-ways-to-structure-your-graphql-code-with-apollo-server-4788beed89db?source=collection_archive---------3-----------------------#2019-01-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="1c0a" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在本文中，我们将使用Apollo服务器，并在没有任何额外依赖的情况下开始。我们必须为我们的项目选择文件夹结构，我们将探索三种不同的结构以及它们的优缺点。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/b2bd763b03941ac63f30a2c99f6ae3ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pD7qiEf4Z5GtP6H8ZiU1mg.jpeg"/></div></div></figure><p id="ae1f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">开始一个新项目时，构建代码可能是你必须做的第一件事。当然，如果你使用一个框架，你可能会得到一个默认的结构。这是因为“约定优于配置”原则通常有助于更快地开始。然而，当在Node.js中编写微型/小型服务时，我发现框架过于臃肿，因为它们附带了许多我们不需要的东西(例如:路由)，或者我们会在某个时候与另一个库交换(例如:安全)。这也是很好的开始你的新应用程序的基础，没有膨胀，并精选每一个我们要添加的依赖。这样，如果我们用同一个库编写多个服务，我们就能得到完全适合自己的框架。多美的东西啊！</p><p id="baa6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">阿波罗服务器通常与T2快捷网络服务器配对，但也包括自己的生产就绪服务器(这只是Node的T4 http。服务器。这对我们来说是完美的，考虑到我们可以添加一个不同的web服务器，如express或koa，如果我们以后需要它的话。然而，开始香草也意味着我们面对没有强制模式来构建我们的代码。对于没有经验的开发人员来说，这可能令人望而生畏。我们如何决定代码的结构？好了，不要再流汗了，我们将探索三种不同的架构，这样我们就可以选择最适合我们的架构。</p><p id="f67d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本文中，每个例子都来自于<a class="ae kr" href="https://github.com/betaflag/graphql-server-scaffolding" rel="noopener ugc nofollow" target="_blank">beta flag/graph QL-server-scaffolding</a>Github仓库，在这里我们可以找到实现每个结构的工作应用程序。</p><p id="1c53" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">从这个repo中，惟一的依赖项是Apollo Server和GraphQL。</p><pre class="jk jl jm jn fq ks kt ku kv aw kw dt"><span id="bc53" class="kx ky hu kt b fv kz la l lb lc">npm install apollo-server graphql</span></pre><h1 id="fd3d" class="ld ky hu bd le lf lg lh li lj lk ll lm ja ln jb lo jd lp je lq jg lr jh ls lt dt translated">极简派</h1><p id="9d00" class="pw-post-body-paragraph jv jw hu jx b jy lu iv ka kb lv iy kd ke lw kg kh ki lx kk kl km ly ko kp kq hn dt translated">这种结构反映了在单个文件中编写一个服务器的纯粹的架构简单性。当然，这不适合大型项目，但我可以证明它在微型或小型服务中的使用是合理的。首先，并不是所有的API都需要大量的服务器代码。</p><p id="89a6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">考虑这个例子:你想在你的聊天应用程序中集成情感分析到你的消息中。您决定这不应该是您的核心应用程序的一部分，而应该外化到一个单独的服务中。它就像一个黑匣子:一个信息进来，一个分析出来。你可以立即开始使用一个名为“情绪”的开源库，它为你提供了一个简单的接口“<em class="lz">情绪.分析(消息)</em>”。编写您的情感分析微服务只需要将其包装在解析器中，并且可以很好地放入单个文件中。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ma mb l"/></div></figure><pre class="jk jl jm jn fq ks kt ku kv aw kw dt"><span id="bb23" class="kx ky hu kt b fv kz la l lb lc">.<br/>├── package.json<br/>└── src<br/>    └── index.js</span></pre><p id="5265" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">优点</strong></p><ul class=""><li id="e9b1" class="mc md hu jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">您可以立即看到API的所有代码</li><li id="5597" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">你可以立即开始</li><li id="4c04" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">当你使你的应用适应真实世界的使用时，重构和进化成一个更结构化的应用是很容易的。</li></ul><p id="9840" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">缺点</strong></p><ul class=""><li id="98c6" class="mc md hu jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">只适合小的应用程序，否则会很快变得一团糟</li><li id="9035" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">它可能会在某个时候演变成另一种结构</li><li id="ba0e" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">如果每个人都在处理同一个文件，可能很难与其他开发人员协作。</li></ul><h1 id="24d6" class="ld ky hu bd le lf lg lh li lj lk ll lm ja ln jb lo jd lp je lq jg lr jh ls lt dt translated">角色扮演者</h1><p id="0e19" class="pw-post-body-paragraph jv jw hu jx b jy lu iv ka kb lv iy kd ke lw kg kh ki lx kk kl km ly ko kp kq hn dt translated">这是您在使用框架创建或搭建项目时通常会得到的结果。这是一个易于上手的结构，适合各种规模的应用。这种结构是根据文件各自的角色将文件放在它们所属的位置。GraphQL类型定义位于"<em class="lz"> typeDefs </em>"文件夹中，解析器位于(您猜对了)"<em class="lz">解析器</em>"文件夹中。</p><p id="67bd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这里有一个在GraphQL API中可以找到的角色的详尽列表:<em class="lz">数据、模型、迁移、验证器、类型定义、解析器、服务、路由、配置、实用程序等。</em></p><pre class="jk jl jm jn fq ks kt ku kv aw kw dt"><span id="554a" class="kx ky hu kt b fv kz la l lb lc">.<br/>├── package.json<br/>└── src<br/>    ├── data<br/>    │   └── index.js<br/>    ├── models<br/>    │   ├── Book.js<br/>    │   └── index.js<br/>    ├── resolvers<br/>    │   ├── booksResolvers.js<br/>    │   └── index.js<br/>    └── typeDefs<br/>        ├── index.js<br/>        ├── query.js<br/>        └── types<br/>            ├── bookType.js<br/>            └── index.js</span></pre><p id="7233" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">摘自Github上的<a class="ae kr" href="https://github.com/betaflag/graphql-server-scaffolding" rel="noopener ugc nofollow" target="_blank">beta flag/graph QL-server-scaffolding</a></p><p id="eb96" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">优点:</strong></p><ul class=""><li id="3ad6" class="mc md hu jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">适合所有种类和所有规模的应用</li><li id="d63d" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">新来的人可以很容易地四处走动</li><li id="2ee3" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">每个文件代表一个关注点，比如一个类或者一个对象</li></ul><p id="4c38" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">缺点:</strong></p><ul class=""><li id="1635" class="mc md hu jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">随着应用程序的增长，这些顶级目录变得杂乱无章</li><li id="eaae" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">这种架构不是模块化的，可能会发展成一个整体</li><li id="59ca" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">对于非常小的应用程序来说是过度的</li></ul><h1 id="734f" class="ld ky hu bd le lf lg lh li lj lk ll lm ja ln jb lo jd lp je lq jg lr jh ls lt dt translated">领域专家</h1><p id="48d0" class="pw-post-body-paragraph jv jw hu jx b jy lu iv ka kb lv iy kd ke lw kg kh ki lx kk kl km ly ko kp kq hn dt translated">如果你想给你的应用增加额外的模块化风格，这种结构正适合你。在这种结构中，顶级文件夹代表域区域。它是模块化的，因为它们之间有自然的界限。我们甚至可以通过将域外部化到它们自己的NPM模块中来实现极端的模块化，这些模块可以在应用程序之间共享。然而，并不是因为你能，所以做这件事总是有意义的。</p><p id="4a4a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当开始一个新的应用程序时，定义你的域并不总是容易的。像用户、权限和配置文件这样的域是很自然的，但是，在某些时候你可能会有一些重叠的子域，这就是困难所在。</p><p id="dcbc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">另一方面，用一个清晰的界面将你的域分开，并且一劳永逸地决定一个子域在哪里，这很棒。在大型应用程序中，团队通常围绕领域领域有机地形成。想想数据、报告、安全等。</p><pre class="jk jl jm jn fq ks kt ku kv aw kw dt"><span id="4cf5" class="kx ky hu kt b fv kz la l lb lc">.<br/>├── package.json<br/>└── src<br/>    ├── books<br/>    │   ├── Book.js<br/>    │   ├── data.js<br/>    │   ├── index.js<br/>    │   ├── resolvers.js<br/>    │   └── typeDef.js<br/>    └── index.js</span></pre><p id="ec3c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">优点:</strong></p><ul class=""><li id="f184" class="mc md hu jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">模块化；一个域可以在它自己的模块中具体化</li><li id="b244" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">可扩展；这种结构非常适合非常大应用程序</li><li id="194f" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">干净；强制子域成为父域确保没有重叠</li></ul><p id="c1ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><strong class="jx hv">缺点</strong></p><ul class=""><li id="9a5a" class="mc md hu jx b jy jz kb kc ke me ki mf km mg kq mh mi mj mk dt translated">对于较小的应用程序来说也是多余的</li><li id="4b44" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">建立子域所有权时可能会出现冲突(但是解决它们确实是一件好事)</li><li id="0605" class="mc md hu jx b jy ml kb mm ke mn ki mo km mp kq mh mi mj mk dt translated">域边界可能从一开始就不清楚</li></ul><h1 id="c462" class="ld ky hu bd le lf lg lh li lj lk ll lm ja ln jb lo jd lp je lq jg lr jh ls lt dt translated">结论</h1><p id="7a4c" class="pw-post-body-paragraph jv jw hu jx b jy lu iv ka kb lv iy kd ke lw kg kh ki lx kk kl km ly ko kp kq hn dt translated">选择适合你的结构是你自己的选择，以后还可以改变。然而，从一开始就选择正确的方法是避免未来头痛的好方法。</p><p id="6a92" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果你知道我没有提到的其他结构，我正在寻求帮助，将它们添加到我在<a class="ae kr" href="https://github.com/betaflag/graphql-server-scaffolding" rel="noopener ugc nofollow" target="_blank">beta flag/graph QL-server-scaffolding</a>的存储库中。也可以在下面的评论里添加。在推特上跟我讨论<a class="ae kr" href="https://twitter.com/betaflag" rel="noopener ugc nofollow" target="_blank"> @betaflag </a></p><p id="ab92" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">照片由<a class="ae kr" href="https://unsplash.com/photos/gYNw3N1vJto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Nicolas I. </a>在<a class="ae kr" href="https://unsplash.com/t/architecture?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></div></div>    
</body>
</html>