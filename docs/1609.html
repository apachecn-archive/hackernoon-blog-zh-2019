<html>
<head>
<title>The Coder’s Axiom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码者的公理</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-coders-axiom-7881e88d495d?source=collection_archive---------21-----------------------#2019-03-07">https://medium.com/hackernoon/the-coders-axiom-7881e88d495d?source=collection_archive---------21-----------------------#2019-03-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="0b51" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果有一种方法可以从等式中去除观点和个人偏好，并明确地确定给定两个竞争的解决方案时哪种代码更好呢？</p><ul class=""><li id="fd54" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo ju jv jw jx dt translated">开发人员必须同意的唯一事情是公理本身。在这一点上达成了一致，堆积如山的主观讨论突然变得无关紧要，宝贵的时间被收回了。</li><li id="5147" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">当我们向一个去中心化的世界前进时，遵从不必要的权威是不必要的。</li><li id="47e5" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo ju jv jw jx dt translated">开发人员可以使用扶手来帮助他们在一生中做出无数的决定。挥之不去的不确定感被可喜的信心所取代。</li></ul><p id="54a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">大约5年前，我提出了这个想法，从那以后，它经受住了来自不同公司的开发者和架构师的严格审查。当我写下极难批评的原始代码时，我一整天都在无数次地思考这个问题。</p><p id="1d68" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">没有进一步的拖延，这是…</p><blockquote class="ke"><p id="292c" class="kf kg hu bd kh ki kj kk kl km kn jo ek translated">暴露出任何与目标相矛盾的方法，最小文件大小的后编译胜过任何选择。</p></blockquote><p id="d7ce" class="pw-post-body-paragraph ir is hu it b iu ko iw ix iy kp ja jb jc kq je jf jg kr ji jj jk ks jm jn jo hn dt translated">这句话里有两个相反的东西。</p><ol class=""><li id="3239" class="jp jq hu it b iu iv iy iz jc jr jg js jk jt jo kt jv jw jx dt translated"><strong class="it hv">目标</strong>:当然这可能意味着很多不同的事情。也许您需要添加更多的代码，因为目标需要一定水平的性能、安全性、特性，或者项目必须在截止日期前完成。</li><li id="eab5" class="jp jq hu it b iu jy iy jz jc ka jg kb jk kc jo kt jv jw jx dt translated"><strong class="it hv">编译后</strong>:因为公理以编译后(或最小化后)的代码为中心，所以它避开了任何关于代码注释、变量命名或语法糖的讨论。编译器可以保持理论性，这提供了相当多的余地。</li></ol><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff ku"><img src="../Images/72f8cc7799ce4c73cb5e880f637eda16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*G1pjV7pxXBJcTOymKyCXZg.jpeg"/></div></figure><h2 id="a541" class="lc ld hu bd le lf lg lh li lj lk ll lm jc ln lo lp jg lq lr ls jk lt lu lv lw dt translated">判断预编译代码呢？</h2><p id="fb81" class="pw-post-body-paragraph ir is hu it b iu lx iw ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">如何确定什么代码是更好的“预编译”需要不同的讨论，这是在考虑“后编译”解决方案后做出的判断。话虽如此，但很难说排在之后的<strong class="it hv">不是首要考虑因素。</strong></p><h1 id="43e0" class="mc ld hu bd le md me mf li mg mh mi lm mj mk ml lp mm mn mo ls mp mq mr lv ms dt translated">依赖怎么办？</h1><p id="1ef6" class="pw-post-body-paragraph ir is hu it b iu lx iw ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">不言而喻，依赖关系会扩大编译后代码库的大小。作为一个生活中的总校长，谁愿意去争论依赖比独立好？还记得<a class="ae kd" href="https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/" rel="noopener ugc nofollow" target="_blank">左垫溃败</a>吗？在一个完美的世界里，没有截止日期，代码库应该独立存在…简约、优雅、一致。</p><p id="11bf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当然<strong class="it hv">目标</strong>会在某个时候出现，并给项目设定时间限制。这时，就有必要伸手到架子上拉一个依赖项，其中不可避免地包含更多您需要的代码。</p><h2 id="720f" class="lc ld hu bd le lf lg lh li lj lk ll lm jc ln lo lp jg lq lr ls jk lt lu lv lw dt translated">在平台和它的代码库之间画一条线</h2><p id="bee4" class="pw-post-body-paragraph ir is hu it b iu lx iw ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">实际上，开发人员/团队必须站在他人的肩膀上。然而，在划分代码库和它的基础设施时，还是有余地的。如果我在AWS上构建一个项目，这并不意味着在评估某个编译后的解决方案时，必须考虑亚马逊的任何代码。</p><p id="9b7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">软件堆栈(即React、Node、Java、Linux等)如何？).什么是基础设施/平台，什么是依赖性，这可能是一个争论的问题。然而，一般来说，我认为像React和Typescript这样的东西是一种依赖，它涉及一个编译例程，并产生一个最终的构建文件(后编译)。Java和Node.js不会出现在构建文件中(忽略Docker之类的东西)，所以我不认为这些平台/语言对利用编码者公理的辩论有任何影响。</p><p id="c905" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在许多情况下，当评估两个竞争解决方案时，它们都运行在同一堆栈上，因此考虑平台/基础架构的规模变得无关紧要。</p><h1 id="1d81" class="mc ld hu bd le md me mf li mg mh mi lm mj mk ml lp mm mn mo ls mp mq mr lv ms dt translated">性能呢？</h1><p id="f87e" class="pw-post-body-paragraph ir is hu it b iu lx iw ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">我听到的一个常见论点是，一个版本的代码可能更大，但因为它更有效，所以它“更好”。好吧，除非目标是这样！你听过<a class="ae kd" href="http://wiki.c2.com/?PrematureOptimization" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">过早优化是万恶之源</strong> </a> <strong class="it hv">的口头禅吗？</strong>换句话说，如果一个更小/更简单的替代方案被证明是足够的，就不要花时间(或代码)让事情变得更有效率。</p><h1 id="67fd" class="mc ld hu bd le md me mf li mg mh mi lm mj mk ml lp mm mn mo ls mp mq mr lv ms dt translated">抽象还是不抽象</h1><p id="57e2" class="pw-post-body-paragraph ir is hu it b iu lx iw ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">这就是编码者的公理真正发挥作用的地方。我经常看到过度设计的系统，在需求出现之前结构就被抽象了。显然，这不必要地增加了编译后的大小。</p><p id="369e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当需要时，不寻找重复和抽象的迹象？与过度设计系统相反，欠设计包括复制模式/例程，在编译后增加文件大小。</p><p id="e3b8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除非你绝对确定在不久的将来你会需要多次使用功能，否则选择monolith。随着系统的发展，当需要拆分某些东西时，不要偷懒。这样，你就能不断地为你的瞬时上下文找到最好的(我的意思是错误最少的)代码。</p><h2 id="f51c" class="lc ld hu bd le lf lg lh li lj lk ll lm jc ln lo lp jg lq lr ls jk lt lu lv lw dt translated">巨石柱</h2><p id="2390" class="pw-post-body-paragraph ir is hu it b iu lx iw ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">亚马逊和网飞<a class="ae kd" href="https://smartbear.com/blog/develop/why-you-cant-talk-about-microservices-without-ment/" rel="noopener ugc nofollow" target="_blank">都是作为一个整体开始的，因为那是你刚开始做的事情。<strong class="it hv">目标</strong>随着流量的增加和功能的增加而改变。</a></p><p id="6278" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是亚马逊AWS产品管理高级经理Rob Brigham在2015年的一次会议上所说的话。</p><blockquote class="mt mu mv"><p id="1551" class="ir is mw it b iu iv iw ix iy iz ja jb mx jd je jf my jh ji jj mz jl jm jn jo hn dt translated">别误会我的意思。它采用多层架构，这些层中有许多组件。但是它们都紧密地结合在一起，就像一块巨大的石头。现在，很多创业公司，甚至大公司内部的项目，都是这样开始的。他们采取整体先行的方法，因为这样很快，可以快速行动。但是随着时间的推移，随着项目的成熟，随着你在上面添加更多的开发人员，随着它的增长，代码库变得更大，架构变得更复杂，这个庞然大物将会增加你的过程的开销，软件开发生命周期将会开始变慢。</p></blockquote><h1 id="856b" class="mc ld hu bd le md me mf li mg mh mi lm mj mk ml lp mm mn mo ls mp mq mr lv ms dt translated">少即是多</h1><p id="8325" class="pw-post-body-paragraph ir is hu it b iu lx iw ix iy ly ja jb jc lz je jf jg ma ji jj jk mb jm jn jo hn dt translated">想反驳奥卡姆剃刀吗？</p><figure class="kv kw kx ky fq kz fe ff paragraph-image"><div class="fe ff na"><img src="../Images/34544bff88de3db71b96d1e67d47ab0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*XAz4m9bn2bJNKG8MZ2rQgQ.jpeg"/></div></figure><p id="2b63" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我有一个满足目标的工作解决方案，谁愿意站在“增加更多”的一边，只是为了满足一些正义的原则或遥远的预测？“保持简单，傻傻的”，选择优雅。毕竟，因为没有人<a class="ae kd" href="https://www.youtube.com/watch?v=S-d64q7Qt5Q&amp;t=2s" rel="noopener ugc nofollow" target="_blank">能把任何事情做得完美</a>，我们做的“它”越少，我们就过得越好。</p></div></div>    
</body>
</html>