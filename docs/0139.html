<html>
<head>
<title>What if we could verify npm packages?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果我们可以验证npm包会怎么样？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/what-if-we-could-verify-npm-packages-c2a319cff758?source=collection_archive---------2-----------------------#2019-01-07">https://medium.com/hackernoon/what-if-we-could-verify-npm-packages-c2a319cff758?source=collection_archive---------2-----------------------#2019-01-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="06a6" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">识别有害和恶意代码的可重复步骤</h2></div><h1 id="0668" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">NPM安全状况</h1><p id="a1a8" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">2018年给我们带来了一些关于NPM安全状况的相当高调的话题。</p><p id="3b38" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">一月份，<a class="lc ld gr" href="https://medium.com/u/f735d3b0f2f3?source=post_page-----c2a319cff758--------------------------------" rel="noopener" target="_blank">大卫·吉尔伯森</a>对每个人的PII ( <a class="ae le" href="https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5" rel="noopener ugc nofollow" target="_blank">我从你的网站上收集信用卡号码和密码)进行了一次貌似有理的攻击，从而破坏了互联网。以下是方法。</a>)假想的攻击集中在向不受源代码控制的包中添加恶意代码。</p><p id="4295" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">7月，<a class="ae le" href="https://status.npmjs.org/incidents/dn7c1fgrr7ng" rel="noopener ugc nofollow" target="_blank">攻击者向eslint-scope </a>添加了恶意代码，允许他们从其他包中窃取npm令牌。我们在NPM的朋友在攻击进一步扩散之前销毁了所有的代币。</p><p id="62c7" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">9月，<a class="ae le" href="https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident" rel="noopener ugc nofollow" target="_blank">恶意代码通过依赖关系</a>被添加到事件流中，并在数月内未被发现。</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff lf"><img src="../Images/8b1e567353af1f72c870664b2e2312ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvLEAWKXWP8EpGNiKTW_cA.jpeg"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Photo by <a class="ae le" href="https://unsplash.com/photos/UGQoo2nznz8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">João Silas</a> on <a class="ae le" href="https://unsplash.com/search/photos/detective?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="70f6" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">NPM有几个攻击媒介</h1><p id="c7ef" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我不愿意将下面的向量称为“安全缺陷”,因为其中一些只是包管理器的工作方式。然而，去年大部分引人注目的报道都是针对同样的事情。让我们看看它们是什么，然后看看是否可以做些什么来降低它们的风险。</p><h2 id="af51" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">合法的包包含不受源代码控制的内容</h2><p id="9026" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">npm包只是一堆文件。事实上，所有的包管理器(Npm、Nuget、Maven等)只是分发tarballs或zip文件或其他一些内容包。任何负责任的开发人员都会将他们的代码放在源代码控制中；然而，这个代码可能是也可能不是包中唯一的东西。</p><p id="088b" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">对于编译语言，如Java或。Net中，包包含构建工件，而不是源代码。特别是如果构建输出是模糊的，很难甚至不可能偶然发现包内容中的安全缺陷。Javascript有点不同，因为许多简单的包只是未经修改的源代码的tarballs。但是，在创建npm包之前，Typescript需要一个翻译步骤，许多其他非Typescrpt代码库包括某种形式的捆绑或缩小过程。</p><p id="e957" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">安全问题加剧了，但事实是缩小的代码难以阅读。不逐个字符地筛选代码就能发现缺陷的几率非常低。</p><p id="74e1" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">我不能过分强调这一切是多么正常；然而，Github和包中的内容之间的差异是隐藏恶意代码的好地方。</p><p id="510b" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这就是在对eslint-scope的攻击中发生的事情。攻击者获得了发布包所需的令牌，但没有获得该项目的Github帐户。在一个过于简单的解释中，他们在本地机器上添加了恶意代码，并重新发布了这个包。尘埃落定后，NPM公布了这个有问题的版本，但需要注意的是，最新版本的eslint-scope仍然与通过注册中心发布的git HEAD的存储库不匹配。(这个我后面会详细解释。)</p><h2 id="1d7a" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">合法的软件包可以用错误的依赖关系进行更新</h2><p id="b411" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">这是大卫·吉尔伯森假想攻击的基础，也是对事件流非常真实的攻击。通过瞄准依赖项，攻击者除了引起维护人员的注意之外，再也不必获取任何信息。Gilbertson(虚构地)创建了几个准有用的包，然后发出一串PRs让它们成为可信的包。平面图流实际上是由创建的<em class="mj">和<a class="ae le" href="https://github.com/dominictarr/event-stream/commit/e3163361fed01384c986b9b4c18feb1fc42b8285#diff-b9cfc7f2cdf78a7f4b91a753d10865a2" rel="noopener ugc nofollow" target="_blank">添加到事件流</a>中。</em></p><p id="a389" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">防范这种攻击的唯一方法是仔细检查影响整个<em class="mj">依赖树的所有提交。此外，使用package-lock.json文件有助于确保使用可预测的依赖关系，这降低了对子依赖关系进行攻击的风险。但是代码审查的安全性必须始终保持在点上<em class="mj"/>，而攻击者只需要运气<em class="mj">一次</em>。</em></p><h2 id="2987" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">没有规范的方法来证明一个包是合法的</h2><p id="5f1f" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">这在某种程度上是前两个向量的组合。如果NPM知道eslint-scope包含恶意代码，他们本可以阻止它被发布。</p><p id="ffa9" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">假设包中的代码必须总是与源代码控制中的相匹配。因为攻击者从未获得Github帐户的访问权限，所以他们无法更改回购协议。这将阻止发布新的包版本。但是这也会阻止基于类型脚本的项目的存在，比如RxJS。所以很明显，这不是一个好的启发。</p><p id="4ed3" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">在安装之前验证依赖项是否有效，或者是否可以用类似于<code class="eh mk ml mm mn b">npm audit</code>的东西来标记有问题的依赖项，这也是很好的。</p><h1 id="a100" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">有可行的解决方案吗？</h1><p id="d24b" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">理想情况下，发布npm包应该是这样的:</p><ol class=""><li id="5fc4" class="mo mp hu kd b ke kx kh ky kk mq ko mr ks ms kw mt mu mv mw dt translated">编辑码</li><li id="22bd" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">提交并推送到Github/Gitlab/Bitbucket/etc</li><li id="09b3" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt">???</li><li id="0a08" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">出版</li></ol><p id="3646" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">缺少一个自动过程来验证将要发布的包是否与源代码控制中的包匹配，或者至少是源代码控制中的包的确定性结果。</p><p id="9cb0" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">让我们来看看NPM为建立这样一个过程提供了什么。</p><h2 id="966c" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">NPM前置/后置脚本</h2><p id="b717" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我将在这里快速回顾一下npm脚本，这样我们就能达成共识。</p><p id="6816" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">您可以创建在任何其他脚本之前或之后运行的任何脚本的“前”或“后”版本。例如，如果您有一个运行Typescript编译器的“生成”脚本，您也可以创建一个“预生成”脚本来清除任何以前文件的生成输出文件夹。以这种方式分解复杂的脚本有助于产生小而易读的脚本。</p><p id="3b8f" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">但是您也可以为“内置”npm脚本编写“前”和“后”脚本。例如，“prepack”、“prepublish”和奇怪命名的“prepare”脚本让您在创建或发布包之前运行构建或测试。</p><p id="8103" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">下面是来自Redux package.json的实际的<a class="ae le" href="https://github.com/reduxjs/redux/blob/686d29b5d4e2dcb6709c16e31b79ecde90763156/package.json#L47" rel="noopener ugc nofollow" target="_blank">“准备”脚本</a>:</p><pre class="lg lh li lj fq nc mn nd ne aw nf dt"><span id="2b6a" class="lv jk hu mn b fv ng nh l ni nj">"prepare": "npm run clean &amp;&amp; npm run format:check &amp;&amp; npm run lint &amp;&amp; npm test"</span></pre><p id="8faa" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">正如你所看到的，打包Redux将首先清理，检查，皮棉，并测试所有的东西。如果开发人员不知何故偷偷通过了代码审查，甚至错误的格式，该脚本将阻止该更改被打包并随后发布。这真是太棒了！</p><h2 id="307e" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">NPM注册和源代码管理</h2><p id="ac89" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">虽然npm是一个命令行应用程序，但它的所有数据都来自registry.npmjs.com。这个API提供了任何关于包的公开数据。如果你想看到所有关于Redux的当前和历史数据，只需<a class="ae le" href="https://registry.npmjs.com/redux" rel="noopener ugc nofollow" target="_blank">获取https://registry.npmjs.com/redux</a>。</p><p id="c605" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">如您所见,“versions”对象包含由版本ID索引的每个版本的数据。在撰写本文时，<code class="eh mk ml mm mn b">redux@4.0.1</code>是最新的稳定版本。关于来自注册表的版本信息，有一些有趣的事情需要注意。下面是一个缩写的对象，这样我们就可以专注于相关的位:</p><pre class="lg lh li lj fq nc mn nd ne aw nf dt"><span id="96d5" class="lv jk hu mn b fv ng nh l ni nj">"4.0.1": {<br/>  ...<br/>  "repository": {<br/>    "type": "git",<br/>    "url": "git+https://github.com/reduxjs/redux.git"<br/>  },<br/>  ...<br/>  "gitHead": "c5d87d95f3b9b0ebdb57791f69b53d8507cebbed",<br/>  ...<br/>  "dist": {<br/>    ...<br/>    "shasum": "436cae6cc40fbe4727689d7c8fae44808f1bfef5",<br/>    ...<br/>  }<br/>}</span></pre><p id="add8" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">“gitHead”对应于发布包的机器上的当前提交。关于更多上下文，您可以访问Github上的commit来查看更多信息:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff nk"><img src="../Images/f951047cde1af68b6a115fe596a0af18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1esTz4LqPGFdVjQUdg3qw.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek"><a class="ae le" href="https://github.com/reduxjs/redux/commit/c5d87d95f3b9b0ebdb57791f69b53d8507cebbed" rel="noopener ugc nofollow" target="_blank">https://github.com/reduxjs/redux/commit/c5d87d95f3b9b0ebdb57791f69b53d8507cebbed</a></figcaption></figure><h2 id="d906" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">NPM包装试运行</h2><p id="2506" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">注册表输出中的“shasum”是生成的包的校验和。假设您已经克隆了Redux repo，那么您可以使用<code class="eh mk ml mm mn b">git checkout c5d87d95</code>(sha的前8个)检查包的“githead”并从锁文件:<code class="eh mk ml mm mn b">npm ci</code>安装依赖项。</p><p id="296e" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">现在我们可以试运行pack命令，该命令执行打包过程，而不实际生成文件:<code class="eh mk ml mm mn b">npm pack --dry-run</code>。以下是在此特定提交下运行时的输出:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff nl"><img src="../Images/ebe7db1c7b884c49beefac7a2c0243c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdniT8zKYGMvSIVCBelBag.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Result of packing Redux at c5d87d95</figcaption></figure><p id="5175" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">如果我们不进行“试运行”，这就是<em class="mj">将</em>放入包的tarball中的内容这里有两件非常酷的事情。首先，任何人在一个干净的回购上签出这个提交并运行“pack”脚本，都会得到完全相同的输出。其次，注意输出中的shasum与注册表中的shasum完全相同。这证明了当Tim Dorr打包并发布Redux时，他执行了与我们完全相同的步骤。没有无证的手动步骤，没有隐藏的恶意代码，没有偷偷摸摸的业务。</p><p id="ccb9" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">我们知道这一点，因为我们以相同的git头开始，以相同的shasum结束。我们可以查看回购中的一切，包括代码和“准备”脚本，并看到一切都是光明正大的。有了这些知识，我认为我们绝对可以信任这个版本的Redux！</p><p id="6006" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt">👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍</p><h1 id="cd2a" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">RealScience是可重复的</h1><p id="cb91" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">以下是我们刚刚采取的验证Redux的步骤:</p><ol class=""><li id="d3db" class="mo mp hu kd b ke kx kh ky kk mq ko mr ks ms kw mt mu mv mw dt translated">从NPM注册中心获取包数据</li><li id="9366" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">查找存储库URL</li><li id="6d1c" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">找到gitHead/commit</li><li id="f56b" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">签出提交(到临时文件夹中)</li><li id="b51a" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">安装依赖项</li><li id="9e84" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">包装试运行</li><li id="6ed1" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">比较发布的和重新创建的shasums</li></ol><p id="1c52" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">我创建了一个<a class="ae le" href="https://www.npmjs.com/package/tbv" rel="noopener ugc nofollow" target="_blank">概念验证包验证器，名为TBV(信任但验证)</a>，它自动化了验证包的这些步骤。软件包的repo被“浅克隆”到一个临时文件夹中，所有npm操作都在该文件夹中执行。以下是我们在Redux上运行TBV时的输出示例:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff nm"><img src="../Images/1a2a1adcde94a5b058f02aa1cf255398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n6aa7ZXt1lYRMhwFHVuKYw.png"/></div></div></figure><p id="4db5" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">Redux通行证。Express也是如此:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff nn"><img src="../Images/53b0eae59e0c29eb4192f14ad73aba9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjWD887nu9FGtR6VNuKdCQ.png"/></div></div></figure><p id="5703" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">注意，Express没有“准备”或“预打包”步骤，所以我们不需要安装依赖项。</p><p id="c0a2" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">但并不是所有流行的软件包都验证了这一点。在撰写本文时，lodash是NPM最依赖的软件包；但是，它没有“prepack”步骤，发布的shasum与Github中相应版本标签生成的shasum不匹配:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff nm"><img src="../Images/5371f2083ee1aa1da5fba84f094c56f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7tSoI9t3UeyQOvp4EsGCg.png"/></div></div></figure><p id="777a" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这并不是说Lodash使用起来有危险，只是说我们无法证明<em class="mj">不是用我们在其他软件包上执行的相同步骤</em>。在未来，我打算对最流行的软件包做进一步的研究，看看是否有办法减少假阴性。</p><h2 id="6689" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">发布前验证</h2><p id="0550" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">在发布之前，有一组类似的自我验证步骤。此处的目的是将易于验证的包引入市场:</p><ol class=""><li id="5437" class="mo mp hu kd b ke kx kh ky kk mq ko mr ks ms kw mt mu mv mw dt translated">确保package.json指定了一个存储库</li><li id="c39b" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">打包试运行(本地文件)</li><li id="96c5" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">签出最新的本地提交(到临时文件夹中)</li><li id="0348" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">安装依赖项</li><li id="67dc" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">打包试运行(临时文件夹)</li><li id="1a00" class="mo mp hu kd b ke mx kh my kk mz ko na ks nb kw mt mu mv mw dt translated">比较本地文件夹和临时文件夹的总和</li></ol><p id="c562" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这个过程类似于前面的验证过程；然而，shasum不是来自注册表(我们还没有发布)，而是来自本地代码的模拟运行。然后将其与源代码控制中的内容进行比较。结果是，如果您的本地上有任何未提交或未推送的更改，该过程将失败。</p><p id="78a2" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">“测试”过程表明如果你的包被发布，其他开发者是否能够验证它。因为它根本不是从NPM注册表中提取的，所以你可以根据需要进行任意多的修改，以在发布之前验证<em class="mj">。</em></p><p id="dcbd" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">下面是测试TBV项目本身的输出示例:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff no"><img src="../Images/7671ca34720987f9813f855b55085ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6XXIFc9C6RWQ8Wd952xrw.png"/></div></div></figure><h1 id="e059" class="jj jk hu bd jl jm jn jo jp jq jr js jt ja ju jb jv jd jw je jx jg jy jh jz ka dt translated">生产的概念验证</h1><p id="4cb5" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated"><a class="ae le" href="https://github.com/skonves/tbv" rel="noopener ugc nofollow" target="_blank"> TBV </a>工具只不过是一个快速而肮脏的实验，用来测试自动化包装验证是可能的这一假设。而且看起来确实如此！但就目前的形式而言，它只不过是一个概念验证。我们将何去何从？</p><h2 id="02b8" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">官方验证包</h2><p id="ab97" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">我认为NPM(可能还有所有的包经理)应该有这种包验证。Npmjs.com可以显示包装的验证状态，以指示哪些包装不太可能包含不可预测或不可再现的内容:</p><figure class="lg lh li lj fq lk fe ff paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="fe ff np"><img src="../Images/c6badbb74b0566366b099fddce1b8b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YSQHTmHWnVo9oiLNts8uBQ.png"/></div></div><figcaption class="lr ls fg fe ff lt lu bd b be z ek">Twitter, please don’t sue me. You’ll benefit from this, too. I promise! :D</figcaption></figure><h2 id="78fa" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">仅验证的帐户/包</h2><p id="a68e" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">NPM可以允许帐户被配置成禁止发布未经验证的软件包。这将防止类似eslint-scope上的攻击。黑客将无法更新Github中的代码，这意味着即使他们可以访问发布令牌，也不可能发布可以验证的包。</p><p id="4133" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">反过来说，package.json可以有一个“verifiedOnly”标志来防止安装未验证的依赖项或子依赖项。</p><h2 id="bd74" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">改进NPM审计</h2><p id="ee92" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">目前，<code class="eh mk ml mm mn b">npm audit</code>命令检查项目完全依赖树中已知的安全漏洞。对当前审计的一个有用的补充是报告依赖关系树中存在多少“未验证的”包。</p><p id="3e4e" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">目前存在许多合法的包，按照我在这篇文章中定义的简单规则，它们并不有效。如果这样一个特性进入npm(或yarn ),那么就需要将某些已知良好版本的未经验证的包列入白名单。</p><h2 id="77fa" class="lv jk hu bd jl lw lx ly jp lz ma mb jt kk mc md jv ko me mf jx ks mg mh jz mi dt translated">真的抓到一个坏人</h2><p id="1d79" class="pw-post-body-paragraph kb kc hu kd b ke kf iv kg kh ki iy kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">可能发生的最好的事情是新闻报道说某人<em class="mj">没有</em>将恶意代码引入流行的软件包。不，你是对的，这样一个没有故事的故事根本不会出现在博客上。👍</p></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><p id="3812" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">在研究这个项目的时候，我真的学到了很多关于NPM生态系统的知识！看着引人注目的安全漏洞攻击新闻机器是痛苦的，因为它总是引出NPM和NodeJS的仇恨。我乐观地认为解决方案唾手可得！让我们让2018年成为类似event-stream@3.3.6的事情发生的最后一次。让我们也确保大卫·吉尔伯森的脏手远离我们的信用卡号码和密码😃。</p><p id="662b" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">我真的对你对这种方法的反馈很感兴趣。发表评论或留下一些👏让我知道你的想法。另外，<a class="ae le" href="https://www.npmjs.com/package/tbv" rel="noopener ugc nofollow" target="_blank">看看TBV </a>(是的，它验证了😃)和<a class="ae le" href="https://github.com/skonves/tbv" rel="noopener ugc nofollow" target="_blank">给它一些🌟🌟🌟如果你认为这是他们应得的。</a></p><p id="a878" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">编码快乐！</p></div><div class="ab cl nq nr hc ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="hn ho hp hq hr"><p id="f50b" class="pw-post-body-paragraph kb kc hu kd b ke kx iv kg kh ky iy kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">编辑:我在构建“包验证即服务”的实验版本方面做了一些工作可以在这里了解:<a class="ae le" href="https://hackernoon.com/npm-package-verification-ep-2-2b2ec66eb610" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/NPM-package-verification-EP-2-2 B2 EC 66 EB 610</a></p></div></div>    
</body>
</html>