<html>
<head>
<title>How to fix the nasty ‘bash: ./wait-for-it.sh: Is a directory’ on Windows 💪</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复讨厌的“巴什:。/wait-for-it.sh:是Windows上的目录💪</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-fix-the-nasty-bash-wait-for-it-sh-is-a-directory-on-windows-7f34855dce87?source=collection_archive---------5-----------------------#2019-06-29">https://medium.com/hackernoon/how-to-fix-the-nasty-bash-wait-for-it-sh-is-a-directory-on-windows-7f34855dce87?source=collection_archive---------5-----------------------#2019-06-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="25fb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如今，当构建应用程序时，它们通常使用由许多服务组成的分布式微服务架构来构建。这些服务中有许多依赖于其他服务，通常是需要先启动的基础设施。以可控的简单方式管理多个服务<a class="ae jp" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae jp" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>可以帮助您。</p><p id="a21e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。然而，有限的是知道容器何时准备好开始接受流量。您可以通过使用<code class="eh jq jr js jt b">depends_on</code>来<a class="ae jp" href="https://docs.docker.com/compose/startup-order/" rel="noopener ugc nofollow" target="_blank">控制容器的启动顺序</a>。比如说:</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="51b7" class="kc kd hu jt b fv ke kf l kg kh">services:<br/>   service1:<br/>     ...omitted<br/>     depends_on:<br/>     - "rabbitmq"</span><span id="d488" class="kc kd hu jt b fv ki kf l kg kh">   rabbitmq:<br/>     ...omitted</span></pre><p id="f381" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将仅验证容器在<code class="eh jq jr js jt b">service1</code>引导之前正在运行。为了确保在依赖关系准备好接受流量之前不启动容器，wait-it是一个很好的脚本。</p><pre class="ju jv jw jx fq jy jt jz ka aw kb dt"><span id="d324" class="kc kd hu jt b fv ke kf l kg kh">services:<br/>  service1:<br/>    ...omitted<br/>    volumes:<br/>      - "./scripts/wait-for-it.sh:/app/wait-for-it.sh"<br/>    entrypoint: ["bash", "-c", "./wait-for-it.sh rabbitmq:15672 -t 0; ./start.sh"]</span><span id="e065" class="kc kd hu jt b fv ki kf l kg kh">  rabbitmq:<br/>     ...omitted</span></pre><p id="6ef3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将确保在执行下一个脚本(在本例中是一个简单的start.sh文件)之前，<code class="eh jq jr js jt b">rabbitmq</code>服务在端口15672上可用。这种方法通常非常有效，但是当您主要在Windows上开发时，可能会遇到麻烦:</p><p id="43b3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">bash: ./wait-for-it.sh: Is a directory</code></p><p id="5b32" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将分享我是如何解决这个问题的。我已经花了很多时间排除故障，所以希望我可以节省你一些时间。</p><h1 id="87b5" class="kj kd hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">错误的行尾</h1><p id="a458" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">您的<code class="eh jq jr js jt b">wait-for-it.sh</code>文件正在使用windows行尾(CRLF)。在Windows上创建的文件与在Unix上创建的文件具有不同的行尾。如果你运行Linux容器，你需要确保你的脚本文件使用LF而不是CRLF。您可以通过在一些现代的文本编辑器(如Notepad++或VSCode)中打开该文件来轻松找到答案。</p><h2 id="a1e8" class="kc kd hu bd kk ll lm ln ko lo lp lq ks jc lr ls kw jg lt lu la jk lv lw le lx dt translated">存储库中的行尾</h2><p id="eb40" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">你可能会对你的软件进行版本化，当你使用git时，你可以配置一个设置来处理行尾<a class="ae jp" href="https://help.github.com/en/articles/dealing-with-line-endings" rel="noopener ugc nofollow" target="_blank">。如果你是跨平台协作，你通常将设置配置为<code class="eh jq jr js jt b">auto</code>。这意味着，每当您向git repo添加一个git认为是文本文件的文件时，它都会将所有CRLF行尾都转换为LF，然后再将其存储在commit中。每当你做<code class="eh jq jr js jt b">git checkout</code>时，所有的文本文件都会自动将它们的LF行尾转换成CRLF尾。</a></p><p id="d33f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">确保您的回购中有一个当前的<code class="eh jq jr js jt b">.gitattributes</code>文件，该文件具有以下设置:</p><p id="a46e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">*.sh text eol=lf</code></p><p id="3de8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这将告诉git将LF行尾应用于所有。sh文件。</p><h1 id="ebb5" class="kj kd hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">共享驱动器</h1><p id="4149" class="pw-post-body-paragraph ir is hu it b iu lg iw ix iy lh ja jb jc li je jf jg lj ji jj jk lk jm jn jo hn dt translated">确保您共享您的驱动程序。在上面的例子中，我使用一个<a class="ae jp" href="https://docs.docker.com/storage/volumes/" rel="noopener ugc nofollow" target="_blank">主机卷挂载</a>将文件从我的主机共享到容器中。要做到这一点，你需要共享你的驱动器。你可以在Docker设置中通过右键点击托盘中的图标来实现。</p><figure class="ju jv jw jx fq lz fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff ly"><img src="../Images/afd43a539725101e74a6df22427ea0e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4p-0nXQRdporXyvzfJaNmg.png"/></div></div><figcaption class="mg mh fg fe ff mi mj bd b be z ek"><a class="ae jp" href="https://token2shell.com/img/howto/token2shell/docker/docker-settings-shared-drives.png" rel="noopener ugc nofollow" target="_blank">https://token2shell.com/img/howto/token2shell/docker/docker-settings-shared-drives.png</a></figcaption></figure><p id="3ed4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在我们的环境中(我假设您也是这种情况)，我们使用特定的本地管理员帐户来提升权限。若要共享您的驱动器，您需要使用此帐户进行身份验证。当这个本地帐户的密码到期时，Docker不会告诉你或再次提示你输入密码— <em class="mk">，除非</em>你取消勾选框，点击应用，勾选框，再次点击应用。令人沮丧！</p><p id="52cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">希望当您修复了行尾并共享了您的驱动程序后，您的问题将会消失，您将会看到如下内容:</p><p id="9be7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jq jr js jt b">service1 | wait-for-it.sh: waiting for rabbitmq:15672 without a timeout</code></p></div><div class="ab cl ml mm hc mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hn ho hp hq hr"><p id="6154" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这两样东西可能会咬你一口。希望我已经为您节省了一些故障排除时间！😆</p></div></div>    
</body>
</html>