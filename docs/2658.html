<html>
<head>
<title>How we Reduced the Time Complexity from 18 days to 4.5 minutes.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何将时间复杂性从18天减少到4.5分钟。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-we-reduced-the-time-complexity-from-18-days-to-4-5-minutes-a4bdfa72e523?source=collection_archive---------11-----------------------#2019-04-25">https://medium.com/hackernoon/how-we-reduced-the-time-complexity-from-18-days-to-4-5-minutes-a4bdfa72e523?source=collection_archive---------11-----------------------#2019-04-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/27c7fa2101232ded9b376175f9db9a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaL3SxOBXbrwXrAciJyM3Q.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo on <a class="ae jg" href="https://unsplash.com/search/photos/scaling?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jh ji jj"><p id="f563" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">垃圾几乎无处不在。和电脑没什么区别。如果我们想一想，即使我们没有付钱，我们的钱包里也会有很多垃圾。</p></blockquote><p id="d506" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">数据处理通常被认为是使用自动化脚本和请求从各种文本中提取模式。使用python进行数据挖掘的伟大命令可以从<a class="ae jg" href="https://www.pythonforbeginners.com/mechanize/browsing-in-python-with-mechanize" rel="noopener ugc nofollow" target="_blank">这里</a>学到</p><p id="8a19" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">数据处理通常被认为是许多人的痛苦。从较小大小的文件中提取标签需要努力，但与包含一百万个条目的语料库相比，相对容易。</p><blockquote class="jh ji jj"><p id="574b" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><strong class="jn hv"> <em class="hu">对了，我是</em></strong><a class="ae jg" href="https://medium.com/codesmyth" rel="noopener"><strong class="jn hv"><em class="hu">codes myth</em></strong></a><strong class="jn hv"><em class="hu">的策展人，一个简化代码，打破神话的线上平台。</em>T15】</strong></p></blockquote><p id="a62f" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这个职位不需要事先了解，因此是一个漫长的。所以，请原谅我。</p><h1 id="0be4" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">我们的情况</h1><p id="9558" class="pw-post-body-paragraph jk jl hu jn b jo lk jq jr js ll ju jv kj lm jy jz kk ln kc kd kl lo kg kh ki hn dt translated">我们的工作影响了电信领域，即电话和互联网相关的东西。因此，为了使它更容易，当一个人从世界上的任何地方打电话给世界上的任何其他人时，一个<strong class="jn hv">呼叫详细记录(CDR) </strong>在他们的谈话结束后被转储，以便根据可用的服务对他们适当地收费。在我们的例子中，CDR是一个单行，包含字段的数量，如谁给谁打电话、持续时间、到达时间、结束时间等。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lp"><img src="../Images/ac4e5040f92516dd76de50a083dbe37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwZ62eiMaUybV7Gsx0wYmg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/0C9VmZUqcT8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mario Caruso</a> on <a class="ae jg" href="https://unsplash.com/search/photos/telecommunication?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3aba" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">当来自一个服务提供商(比如A)的用户呼叫某个其他服务提供商(比如B)的另一个用户时，LRN值被转储到CDR中。</p><blockquote class="jh ji jj"><p id="c4eb" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">按照Google的说法，位置路由号码(LRN)是一个名为服务控制点(SCP)的数据库中的10位数字，用于标识本地电话交换机的交换端口。</p></blockquote><blockquote class="lu"><p id="35ed" class="lv lw hu bd lx ly lz ma mb mc md ki ek translated">基本上，LRN是一个映射到呼叫方的区号和服务提供商的唯一值。</p></blockquote><h1 id="f239" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx me kz la lb mf ld le lf mg lh li lj dt translated"><em class="mh">输入</em> —</h1><p id="b170" class="pw-post-body-paragraph jk jl hu jn b jo lk jq jr js ll ju jv kj lm jy jz kk ln kc kd kl lo kg kh ki hn dt translated">A)一个<strong class="jn hv">语料库，比如说C1 [XML格式] </strong>，它由分布在多个目录中的多个文件中的近<em class="jm">800万条记录组成</em>。每个记录由大约30个条目组成，其中一些条目是<em class="jm">主叫号码、被叫号码、始发区号、终接区号、LRN、设施</em>等。</p><p id="0f58" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">b)另一个<strong class="jn hv">语料库，比如C2 </strong>，其包括分布在多个文件夹中的多个文件中的8500万个CDR条目。这就是要改正的文集。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mi"><img src="../Images/2ffb9d913dbc1dbf24a9bfdd24bce4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvW1x-9fIaYCSsa2theRqA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/u2Ru4QBXA5Q?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Pankaj Patel</a> on <a class="ae jg" href="https://unsplash.com/search/photos/html?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="40b8" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">我们的任务—</h1><blockquote class="jh ji jj"><p id="f36e" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">我们将根据C2语料库的被叫号码，把C1语料库的字段[LRN]的值代入C2语料库。</p></blockquote><p id="8c8d" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">简而言之，我们所要做的就是从C2语料库的每一个CDR中提取一个“<strong class="jn hv">被叫号码</strong>”参数，然后基于C2语料库的“<strong class="jn hv">被叫号码</strong>”参数在整个C1语料库中搜索“<strong class="jn hv">【LRN】</strong>”参数，最后用C2的LRN参数替换那个特定的CDR。这一过程将对近8500万条记录执行。</p><h1 id="b8c0" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">之前的脚本—</h1><p id="81e8" class="pw-post-body-paragraph jk jl hu jn b jo lk jq jr js ll ju jv kj lm jy jz kk ln kc kd kl lo kg kh ki hn dt translated">在我们的组织中，有人为上述任务编写了一个脚本(用C编程语言),并最终使用暴力算法来实现它。想象一下以下程序需要的时间—</p><p id="68a7" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">1 —提取C2的被叫号码。</p><p id="eb67" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">2 —逐个打开C1子目录下的文件，然后搜索相应被叫号码所需的LRN。[800万条记录]</p><p id="bbb5" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">3 —一旦我们有了它，就用C1 CDR内的LRN代替相应的被叫号码。</p><p id="2ad8" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">4 —对8500万条记录重复此操作。</p><ul class=""><li id="3ddb" class="mj mk hu jn b jo jp js jt kj ml kk mm kl mn ki mo mp mq mr dt translated">更不用说许多不必要的打印、冗余的变量赋值、包含关于控制流的不必要的库以及被转储的不必要的日志。打印到控制台也会占用大量不必要的时间和资源。</li></ul><h1 id="2e36" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">我们如何优化它？</h1><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ms"><img src="../Images/062ed1666e2771b12aebaec319d16b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oT0-Tqda8sGMdKH0SHPbOw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/QQ9LainS6tI?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nate Grant</a> on <a class="ae jg" href="https://unsplash.com/search/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jh ji jj"><p id="88e9" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">在运行原始脚本一天之后，它已经处理了将近0.5 GB的CDR，CDR的总容量为9GB。一个简单的数学计算告诉我们，如果顺利和无干扰，将需要将近18-20天，如果大多数组织都有资源中心，这是不可能的。</p></blockquote><p id="1cd4" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我们都同意运行这个脚本没有意义，没有人有时间等这么长时间。整个过程将不得不从头开始。此外，语料库包含大量不必要的数据，并且存在错误替换的可能性。如果发生上述情况，所有的工作和资源利用都将是徒劳的。</p><p id="ba43" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">第一步:</p><blockquote class="jh ji jj"><p id="b7d4" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">有时候，你要找的东西已经在那里了。<br/>——阿撒·富兰克林</p></blockquote><p id="45e0" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">没有必要一遍又一遍地阅读C1文集。这就像重读圣书，但像一百万次。这个C1语料库以XML格式存在。我们已经有了XML解析器。</p><p id="60a2" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这是我们所做的——</p><ul class=""><li id="92b0" class="mj mk hu jn b jo jp js jt kj ml kk mm kl mn ki mo mp mq mr dt translated">每当我们在C1语料库中读取一个文件中的记录时，我们就搜索XML标记"<strong class="jn hv"> Called_Number </strong>和"<strong class="jn hv"> LRN </strong>"，然后提取它们，并将输出打印到一个文件中，文件格式如下，用分号("<strong class="jn hv">)隔开；</strong>”)。我们可以考虑("<strong class="jn hv">)；</strong>))作为字段之间的分隔符。</li></ul><p id="36ee" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">因此，我们不是读取整个记录，而是以如下所示的格式读取该记录的一行。</p><blockquote class="jh ji jj"><p id="d224" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><strong class="jn hv">被叫_号码；LRN </strong></p></blockquote><ul class=""><li id="4b36" class="mj mk hu jn b jo jp js jt kj ml kk mm kl mn ki mo mp mq mr dt translated">我们对所有其他记录做了同样的事情，最终创建了有近800万行的输出文件，因为有800万条记录。假设文件是(A)。</li><li id="ad7b" class="mj mk hu jn b jo mt js mu kj mv kk mw kl mx ki mo mp mq mr dt translated"><em class="jm">“A”由许多冗余的</em>组成，正如预期的那样——<br/><strong class="jn hv">1</strong>——在数字之间和数字末尾有冗余字符。<br/> <strong class="jn hv"> 2 </strong> -对于一些被叫号码，没有LRN值。<br/> <strong class="jn hv"> 3 </strong> -来电号码大小不统一，应为10个。它们就像打印在被叫号码字段的垃圾值。<br/> <strong class="jn hv"> 4 </strong> -文件中有重复值。</li><li id="6e80" class="mj mk hu jn b jo mt js mu kj mv kk mw kl mx ki mo mp mq mr dt translated">为了删除它们，我们在解析语料库C1和创建输出文件(“A”)时进行了以下检查。<br/> <strong class="jn hv"> * </strong>字符串“<strong class="jn hv"> Called_number </strong>”要用c中的“<strong class="jn hv"> atoi() </strong>”函数转换成整数，如果失败，我们不会把输出写到输出文件(<strong class="jn hv"> A </strong>)。(<strong class="jn hv">办案1 </strong> ) <br/> <strong class="jn hv"> * </strong>字符串“<strong class="jn hv"> Called_number </strong>”的长度应为10。(<strong class="jn hv">办案三</strong>)</li><li id="135e" class="mj mk hu jn b jo mt js mu kj mv kk mw kl mx ki mo mp mq mr dt translated">一旦我们创建了输出文件("<strong class="jn hv"> A </strong>")，我们就在vim中编辑它，并使用两个vim内部命令处理(<strong class="jn hv">案例2和案例4 </strong>)</li></ul><blockquote class="jh ji jj"><p id="e78c" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><strong class="jn hv">:g/；$/d</strong>[删除所有以“；”结尾的行]】<br/> <strong class="jn hv"> :sort u </strong>【用于升序排序，去除重复行】</p><p id="7787" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">在文本编辑器中，删除文件中的重复行通常很容易。例如，Atom。</p></blockquote><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e6f8d0a3d65b4a35045b03e42bb402be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YI8HiGMqFR_ylGd8ZqAWRg.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/89xuP-XmyrA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae jg" href="https://unsplash.com/search/photos/atom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jh ji jj"><p id="2274" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">有些人可能会说，我们可以为它写一个简单的程序。但是如果已经构建了解决问题的方法或工具，就应该使用它，而不是从头开始。从节省下来的时间和精力中，在你现有的应用/产品/平台上创造一些新的东西，从而为其他人提供一个垫脚石，帮助社区成长。这是开源的基本概念。</p></blockquote><p id="9542" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这个输出文件(“A”)是我们的最终文件，它将用于800万条目的C1语料库。经过适当处理后，保留在数据库中的条目总数只有220万条。</p><p id="e18d" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">从庞大的800万条记录(每条记录由30个条目组成)，我们缩小到220万条。</p><blockquote class="jh ji jj"><p id="5822" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><strong class="jn hv">缩放后的语料库规模= (8000000*30)/2200000 = 109倍</strong>。</p></blockquote><p id="cd14" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">这是很重要的，如果我们在分析了我们可以利用的资源之后再去思考它。</p><p id="63dc" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">下一步是优化C2语料库的CDR处理—</p><p id="e93e" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">与CDR的情况一样，我们在整个文件中("<strong class="jn hv"> A </strong>")线性地[ <strong class="jn hv">使用线性搜索</strong>)搜索特定的键。由于我们新生成的来自C1语料库的文件(“<strong class="jn hv"> A </strong>”)已经被排序，我们决定实现<strong class="jn hv">二分搜索法。</strong></p><blockquote class="jh ji jj"><p id="3fbe" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">因此，将复杂度从<strong class="jn hv"> O(N) </strong>转换为<strong class="jn hv"> O(logN) </strong>。</p></blockquote><p id="c420" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">来自科珀斯C2的cdr分布在多个目录中，每个目录对应不同的区号(大约252个目录)。早些时候，当我们处理CDR时，只有在前一个目录被处理时，我们才跳转到下一个目录。[一次处理一个目录]。</p><blockquote class="jh ji jj"><p id="a91d" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">这意味着整个进程在单个用户线程上运行。线程<br/>是操作系统的一个基本概念，在软件或应用中实现并行处理时使用。</p></blockquote><p id="a4f1" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">因此我们<strong class="jn hv">在多核处理器上实现了多线程。</strong>运行脚本的刀片由80个内核组成。<strong class="jn hv">因此，并行地，在通过shell实现线程化之后，我们能够同时执行来自80个目录的cdr。因此，我们的总时间减少了80倍。</strong></p><p id="e3c5" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我们刚刚创建了一个简单的shell脚本，它只是—</p><blockquote class="jh ji jj"><p id="5bd5" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><strong class="jn hv">。/script _ which _ process _ cdr[目录名][输出目录名] &amp; </strong></p></blockquote><p id="414f" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">下一个挑战是，虽然处理时间大大减少了，但是每个目录的每个脚本都是用一个新的进程ID创建的，并且与另一个线程同时运行的进程的进程ID没有任何关联。因此，来自语料库C1的文件(“A”)被加载到内存中近242次，这是相当浪费资源的。</p><blockquote class="jh ji jj"><p id="0857" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">因此，我们决定用C语言实现多线程，而不是通过shell应用多线程，我们的脚本最初就是在C语言中编写的。</p></blockquote><p id="cd70" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><em class="jm">我们决定，一旦语料库文件成功加载，我们就开始线程化。</em>使用<strong class="jn hv"> pthread </strong>，非常容易，而且线程对文件(<strong class="jn hv"> A </strong>)数据的修改也没有问题，因为执行的进程都不包括对文件(<strong class="jn hv"> A </strong>)的写入。</p><p id="4fd1" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">简而言之，我们所做的就是在删除某些冗余之后，在文本文件(<strong class="jn hv"> A </strong>)中获得语料库的输出(<strong class="jn hv"> C1 </strong>)，然后将该文件加载到我们刀片的内存中的一个二维数组中。如果加载到内存成功，二分搜索法用于识别和替换键-值对。为了使处理速度更快，我们实施了多线程，并创建了线程来并行处理大量目录。</p><p id="b7a6" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">从时间函数计算出的执行欢呼时间为</p><blockquote class="jh ji jj"><p id="af0d" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated">$ time process _ cdr . sh<directory of="" the="" path="" were="" cdr="" present=""><br/>$ 4分27秒执行完毕。</directory></p></blockquote><blockquote class="lu"><p id="b571" class="lv lw hu bd lx ly lz ma mb mc md ki ek translated">经过长达18天的处理，我们的数据处理仅用了4分27秒就完成了。</p></blockquote><p id="0361" class="pw-post-body-paragraph jk jl hu jn b jo my jq jr js mz ju jv kj na jy jz kk nb kc kd kl nc kg kh ki hn dt translated"><strong class="jn hv">从上述事件中，我感受到了时间复杂性的重要性。时间是唯一我们买不到也拿不回来的东西。从上面的例子中，我相信无论我们的脚本是如何编码的，总有某个地方或某些方面可以优化它，无论是空间或时间复杂度还是文档。我们只需要在没有任何外部障碍的情况下，给它更多的时间去分析和思考。</strong></p><blockquote class="lu"><p id="cffc" class="lv lw hu bd lx ly nd ne nf ng nh ki ek translated"><strong class="ak">祝你编码愉快，祝你更有力量。</strong></p></blockquote><figure class="nj nk nl nm nn iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ni"><img src="../Images/ee7488a99e1ea6ebdecb773d5d19fe6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aEiBn2Vkpc9X2J1lLNdbXQ.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/Jn1csk3lWDA?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Austin Distel</a> on <a class="ae jg" href="https://unsplash.com/search/photos/scaling?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="lq lr ls lt fq iv"><div class="bz el l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>