<html>
<head>
<title>Getting started with Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux入门</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/getting-started-with-redux-aa37180dbe93?source=collection_archive---------21-----------------------#2019-02-05">https://medium.com/hackernoon/getting-started-with-redux-aa37180dbe93?source=collection_archive---------21-----------------------#2019-02-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c74b754c9e031d45600231af58667f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCSXAi9OnqytvWiiuw5O0A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Redux</figcaption></figure><p id="b129" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我参与过几个有Redux的项目，我发现在刚入门的人中间有很多困惑。我的观点是，如果我们理解“redux试图解决什么问题”和“redux核心组件的职责”，生活会更容易。这篇文章是我试图解释这些事情的尝试。</p><h1 id="f64d" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">问题是…</h1><p id="4518" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">如今的SPAs(单页应用程序)非常复杂，它们在前端维护大量的状态，例如:api响应、缓存数据、UI小部件的状态，比如spinners和进度条等..</p><p id="b118" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通常我们有保存数据的模型和呈现数据的视图。一个视图可以更新一个或多个模型，一个模型可以更新另一个模型，基于这些模型的变化，视图得到更新。由于所有这些交互，很难弄清楚实际发生了什么以及数据是如何流动的。</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff lh"><img src="../Images/82b5120c831c0cd95616694bae7a8a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*6oGCXWJB4P9c0_Hf69Io1w.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">View Model Problem</figcaption></figure><h1 id="4dff" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">解决方案:单向数据流</h1><p id="4bb4" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">人们认为既然问题的出现是因为数据的交叉流动，那就让数据单向流动吧。由于数据流只是一种方式，它很容易跟踪，状态管理变得更加可预测。脸书通过流动普及了这一思想。让我们来看看Flux的架构</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lm"><img src="../Images/cd3512732403405db5ab9d46275e17c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jR6nJpOdao9I2hxwdWEa3w.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Flux Architecture</figcaption></figure><p id="971c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">好的，那边有很多新组件。让我们来详细了解一下其中的每一项</p><h1 id="9684" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">行动</h1><p id="dfd3" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">动作描述了系统中发生的事情。让我们举一个例子:我们有一个todo应用程序，用户点击了一个特定ToDo项的切换按钮。因此相应的动作可能看起来像这样</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="c2d2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">动作通常包含类型和有效负载。类型指定它是哪种操作，数据包含与该操作相关的有效负载。动作通常是由所谓的<strong class="ji hv">动作创建者创建的，</strong>它只是一个将你的输入格式化为动作格式(类型和数据)的函数。这提供了一些解耦，因为视图现在不需要知道动作需要什么格式。视图只是调用动作创建者。动作创建者的示例</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h1 id="41e8" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">商店</h1><p id="261b" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">Store是存储应用程序状态的地方，除此之外，store in Flux还存储存储更改逻辑。商店只能通过动作操作，不能直接改变。也可以有一个以上的通量储备。</p><h1 id="7d5a" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">分配器</h1><p id="6d6c" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">Dispatcher就像一个路由器，它将动作发送到适当的存储。</p><h1 id="62a3" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">视图控制器</h1><p id="391c" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">视图控制器订阅存储，并在存储发生变化时通知视图。</p><p id="7bc9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">是的，这就是流动的全部。</p><h1 id="0b27" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">Redux..但是为什么呢？</h1><p id="eac7" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">丹·阿布拉莫夫创造Redux有两个主要原因</p><ol class=""><li id="e611" class="lp lq hu ji b jj jk jn jo jr lr jv ls jz lt kd lu lv lw lx dt translated">热重装</li><li id="0f9c" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">时间旅行调试</li></ol><p id="03e1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">是的，Redux主要是为了更好的开发工具而创建的。</p><h1 id="4e86" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">变化</h1><ol class=""><li id="f1b6" class="lp lq hu ji b jj lc jn ld jr md jv me jz mf kd lu lv lw lx dt translated">在Flux中，Store具有状态和状态改变逻辑。在Redux中，状态改变逻辑作为Reducers被分离出来。这样做是因为如果你想支持“热代码重载”，并且如果“状态改变逻辑”和“状态”都存在于相同的空间，那么它们都将被更新，但是对于“热代码重载”，我们只想更新“状态改变逻辑”而不干扰“状态”。</li><li id="1ba6" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">在Flux中，Store是可变的，而在Redux中，Store是不可变的，每次更新都会创建一个新对象。这有助于“时间旅行调试”。</li><li id="0e70" class="lp lq hu ji b jj ly jn lz jr ma jv mb jz mc kd lu lv lw lx dt translated">没有单独的配送员，配送责任由商店承担。</li></ol><p id="e129" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Redux架构看起来像</p><figure class="li lj lk ll fq iv fe ff paragraph-image"><div class="fe ff mg"><img src="../Images/9221584bb7d71e794999fd016495f595.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*X3v-quqVAGL7UWxy3u3bkA.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Redux Architecture</figcaption></figure><h1 id="020f" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">还原剂</h1><p id="2be1" class="pw-post-body-paragraph jg jh hu ji b jj lc jl jm jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd hn dt translated">归约器决定每个动作的状态如何改变，即状态改变逻辑。可以有一个以上的减速器。每个归约器都注册了它感兴趣的状态的一部分，并在该范围内操作。</p><p id="adf7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们前面讨论过的一个动作的缩减器的例子</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="7589" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如您所见，上面定义的Reducer负责store对象的“todos”部分。初始状态是应用程序初始化时的状态，您可以在此设置默认值。在函数体中，我们所做的就是找到被切换的todo项，并更改completed标志，将修改后的状态作为新对象返回。请务必注意，我们不是在编辑现有的状态对象，而是在创建一个新的状态对象。</p><p id="eb66" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这就是所有要重复的，现在让我们看一个端到端的例子。</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="d6af" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们在第46-47行调度两个动作，然后将它们发送给reducer，reducer更新状态，结果视图(在我们的例子中是console.log)被通知存储更改，视图被更新。</p><p id="f0a3" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">通常你在React的设置中使用Redux，我们会使用类似<a class="ae mh" href="https://github.com/reduxjs/react-redux" rel="noopener ugc nofollow" target="_blank"> react-redux </a>的连接包。React-redux帮助React组件连接到redux存储。React和Redux是两个独立的东西，你可以把Redux和Vue、Ember或者其他任何视图框架一起使用。</p></div></div>    
</body>
</html>