<html>
<head>
<title>The Ideal Crypto Trading API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理想的加密交易API</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-ideal-crypto-trading-api-b1bbb2675875?source=collection_archive---------8-----------------------#2019-04-09">https://medium.com/hackernoon/the-ideal-crypto-trading-api-b1bbb2675875?source=collection_archive---------8-----------------------#2019-04-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5476" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在过去的几年里，我们已经整合了几十家交易所(最近统计有35家)。一路走来，我们看到、经历和遭受了许多与加密交换API相关的不同事情。本着与更广泛的加密社区合作的精神，并带着使我们未来的集成更容易的(有点自私的)希望，我们认为我们应该分享一些关于理想的交易API应该是什么样子的想法。</p><p id="a151" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">之所以提出这个建议，是因为存在各种各样的API实现，而大多数API都在重复同样的错误。使它们在机构环境中的使用复杂化的错误。我们建议对现有的API模型进行一些简单的修改，以构建我们认为的用于加密交易的健壮的机构级API。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/9f3643bd9305631c74492db58ef298f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MeKNiQ4uVbD99OtmU6UEOQ.jpeg"/></div></div></figure><p id="91d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">原料药的味道</strong></p><p id="091e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在整个加密交易领域，有多种类型的API可用于自动交易。从技术角度来看，API分为以下几类:</p><p id="76ba" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.REST:所有市场数据和交易都在REST端点之上</p><p id="f27d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.Websocket:所有的市场数据和交易都是通过Websockets进行的</p><p id="25c9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.FIX:纯粹的FIX实现很少见，但是这些类型的交易API在加密领域的势头越来越大。(Deribit有一个纯FIX实现，它也处理帐户更新)</p><p id="8854" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.组合</p><ul class=""><li id="ed05" class="kb kc hu it b iu iv iy iz jc kd jg ke jk kf jo kg kh ki kj dt translated">混合，REST用于私有端点，Websocket用于市场数据</li><li id="ee15" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">Hybrid-2.0，REST用于私有端点，Websocket用于市场数据和私有数据(订单更新、填充等)。)</li><li id="ed8e" class="kb kc hu it b iu kk iy kl jc km jg kn jk ko jo kg kh ki kj dt translated">修复+以上组合</li></ul><p id="c280" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">纯休息</em> </strong></p><p id="a941" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用这种风格的API，通常所有的交互都是基于投票的。不用说，这是非常有限的，主要是由任意的速率限制(这是缩放所必需的。)这种风格的API不适合全面的机构级交易系统。对更新(无论是市场数据还是我们自己的执行)进行投票的要求简直令人疲惫不堪。</p><p id="161d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">纯Websocket </em> </strong></p><p id="4b77" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有几个纯websocket apis的好例子coins.ph (pro)有一个定义非常好的纯websocket交易的API，HitBTC也是。Bitfinex也有一个很好的(理论上的)v2，但是当前的beta实现不稳定。对于希望实现一个好的基于websocket的API的交易所来说，一个好的模型是coins API。</p><p id="cf94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">杂交</em> </strong></p><p id="922d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有许多实施混合交易API的交易所的例子。通常只有市场数据或市场数据和一些私有数据可以通过websocket获得，而交易(创建订单或取消订单的过程)是通过REST端点进行的。Okex、Kucoin、币安等都是这种交易API的例子。</p><p id="26d4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">修复</em> </strong></p><p id="7aa2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这些类型的交易API正在密码领域获得发展势头。越来越多的新交易所提供这个(现有交易所也开始支持。)这种风格的API非常适合机构交易，但是也有一些限制。作为一个标准的主要修正不能解决我们在crypto中的所有需求(例如实例化交易以提取硬币)。)其他缺失的元素是账户余额等关键信息——在FIX中根本没有与之匹配的对等项。</p><p id="7a4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有人可能会说，这些可以通过最新FIX协议标准中的新位置维护消息来实现，但这感觉像是一种黑客攻击。在协议扩展到支持为此所需的额外消息之前，我们会发现这些API是交易和市场数据的FIX和其他账户相关活动的REST(或Websocket)的混合体。正是这种需求实现了许多不同的协议来完成完整的交易功能，这导致我们说FIX只在有限的情况下有效(在一些特定的交易所交易，如LMAX、LXDX或Blockfills。)</p><p id="b715" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">加密API缺少什么？</p><p id="da7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">到目前为止，如果你花些时间分析一下这种情况，那么我们所讨论的就不会感到惊讶。当我们建立自己的交易系统时，第一阶段(也是最消耗我们资源的阶段之一)是连接大量的交易所。由于我们的模型可以跨任意数量的交易所交易，并且我们可以让多个模型跨给定的交易所交易，所以我们需要的关键功能是健壮的订单和执行处理。</p><p id="12c8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">健壮的订单处理意味着我们需要随时了解订单的状态，健壮的执行处理意味着我们需要知道所有的执行(并能够将这些执行分配给生成订单的模型。)这最后一步对于我们在模型层面管理风险至关重要。</p><p id="4655" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">客户订单ID </em> </strong></p><p id="53e2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们在大多数API(甚至是声称是机构级的交易所)中看到的第一个差距是，很少有人支持客户订单id的概念。客户订单id是我们在订单管理系统中分配给订单的内部id。这个键允许我们识别生成特定订单的模型，然后这个键成为将该订单上的任何执行分配给该模型的键。</p><p id="d999" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">API失败的地方在于我们不能设置这个客户订单id。因此，我们调用REST来创建订单，响应为我们提供了交换订单id，但是由于某种原因，如果HTTP请求失败(例如有Cloudflare这样的服务提供商挡路，可能会有几个故障点),如果订单通过某种方式到达匹配引擎，我们就无法识别我们检测到的在交换中活动的订单。更糟糕的是，有时这些订单然后交易，我们收到执行——我们不能分配(如果我们有多个模型交易，很难区分哪个模型交易！)</p><p id="f0a3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于混合API，这个问题更加严重，因为通过websocket推出的订单更新没有客户端订单id，只有交换订单id，因此，我们必须缓冲所有内容，直到REST请求返回，以了解我们在websocket上收到的内容。我们认为简单地添加一个客户端订单id(用于创建、更改、取消操作，无论是Websocket还是REST)以及随后在输出中包含该字段(订单更新和执行)极大地提高了API的健壮性——因为我们可以处理来自交换的所有消息，并且只处理我们设置的客户端订单id。我们甚至可以区分特定于exchange的UI上的手动订单和自动订单，并适当地处理它们。</p><p id="5e81" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">每执行一个命令</em> </strong></p><p id="eae0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一些老一代API不提供填充端点，一个轮询订单状态以检测任何订单上的填充，并通过查看订单上的执行数量来计算部分填充(综合)。这实际上并不是很好，后来当我们需要将我们的交易与我们的交易的交换视图进行协调时，这个过程是复杂的，因为单个交易没有列出来，通常是订单级别的汇总。</p><p id="a65b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最新一代的API提供了填充端点，但是引入了相当有限的约束，例如必须提供订单id才能获得填充(例如Okex。)这是一个令人衰弱的要求，因为典型的机构级交易系统将跨许多模型生成许多订单，并且必须轮询每个单个订单以进行填充是浪费时间。返回我们的填充的端点可以通过一些标准进行过滤，例如符号和最后的交易id，使用这些标准，它应该返回我们所有订单的所有部分填充。</p><p id="0cb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">批量操作</em> </strong></p><p id="0263" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为一个做市商，我们经常被要求发布一个关于买价和卖价的深度订单。因此，能够发送一批订单(通过websocket，例如Bitfinex)或通过REST(例如Okex)减少了我们的订单处理负载，可以想象在交易所的网关上。通常，我们希望看到一个批处理创建和批处理取消端点，这样我们可以在一个单一的操作中移动我们的订单，而不必为每个订单操作提出单独的请求。例如，如果我们被要求发布三个出价和三个报价，每次价格移动，我们将发送六个取消和六个创建。如果API支持批处理，那么这将是两个请求，如果API支持订单替换，那么一个请求包含六个变更。交易所的负荷将会大大减少。</p><p id="400c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">【取消断开】和</em> </strong>一个取消所有点播的选项</p><p id="0a7e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于任何连接的API (websocket等。)，这是一个总的来说很有用的功能。启用后，如果我们从会话中断开，任何未结订单都将被取消。这为我们提供了一些保护，以防我们退出市场，并防止我们离开时任何订单被取消。理想情况下，如果有一个我们连接的专用频道，它应该支持此功能。</p><p id="7187" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="kp">那么理想的API是什么样子的呢？</em> </strong></p><p id="ac40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">从我们的经验来看(除非是与修复相关的非常特殊的情况),最理想的API是混合API。我们认为这对于交换来说具有最小的实现开销，并且是我们可以处理的最简单的模型。然而，要做到这一点，我们需要以下内容:</p><p id="15c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">1.创建/更新/取消休息</p><p id="44d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">2.用于更新和执行的Websocket</p><p id="2eec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">3.create order的REST端点必须接受一个客户订单id(最好是批处理的)</p><p id="35ae" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">4.如果<em class="kp">应该是用于订单修改的REST端点，这增加了匹配引擎的复杂性，并且<em class="kp">可以通过具有批处理端点来消除</em>。</em></p><p id="54df" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">5.要取消的其余端点应进行批处理</p><p id="5633" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">6.所有订单更新和个人填写都应该通过私有的websocket渠道发送，并且这些更新应该包含客户订单id。如果没有客户订单id，我们所做的任何分配都将完全依赖于交换订单id(它仅在对创建操作的响应中可用。)因此，这在我们这边引入了一种竞争，可以通过在更新中公开客户订单id来消除这种竞争。</p><p id="4c5a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">7.最后但同样重要的是，良好的文档和测试网络</p><p id="95ca" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整的websocket实现也很好，但是要实现一个完整的解决方案可能在技术上更具挑战性，因此，我们不会让这个模型成为最理想的API类型。</p><p id="1783" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如你所看到的，这些不是主要的要求或争议，只是一些简单的准则，如果满足了，应该会为像我们这样的机构交易者带来一个相当健壮的API。令人惊讶和有争议的是crypto中很少API有这个。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="kq kr l"/></div></figure></div></div>    
</body>
</html>