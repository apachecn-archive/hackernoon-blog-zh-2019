<html>
<head>
<title>Swift: Avoiding Memory Leaks by Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift:通过示例避免内存泄漏</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/swift-avoiding-memory-leaks-by-examples-f901883d96e5?source=collection_archive---------2-----------------------#2019-01-23">https://medium.com/hackernoon/swift-avoiding-memory-leaks-by-examples-f901883d96e5?source=collection_archive---------2-----------------------#2019-01-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/10b0742f3dac6acfac870f999844c739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vy54VZkKuf4zbd7WjdS75Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Art/memory_management_2x.png" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Art/memory_management_2x.png</a></figcaption></figure><p id="780e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在Swift中，自动引用计数(ARC)用于管理iOS应用程序中的内存使用。<br/>每次你创建一个类的新实例时，ARC都会分配一块内存来存储关于它的信息，并且当不再需要这个实例时会自动释放这些内存。<br/>作为开发人员，您不需要为这种管理做任何事情，除了3种情况，您需要告诉ARC更多关于实例之间关系的信息，以避免“保留循环”。</p><p id="5c34" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本文中，我们将一起了解管理这三种情况的过程，并了解保留周期的真实示例以及如何消除它们。<br/>但是首先，什么是保留周期，为什么我们需要避免它们？</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="0a80" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">保留周期:</h1><p id="7b20" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">Retain Cycle是这样的情况，当两个对象相互强烈引用并被保留时，使得ARC无法从内存中释放这些对象，并导致我们所说的“内存泄漏”。</p><blockquote class="lp lq lr"><p id="f920" class="jh ji ls jj b jk jl jm jn jo jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd ke hn dt translated">内存泄漏在你的应用程序中是很危险的，因为它们会影响你的应用程序的性能，并可能在应用程序耗尽内存时导致崩溃。</p></blockquote></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="dfd9" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">导致内存泄漏的三种情况:</h1><h2 id="77dc" class="lw kn hu bd ko lx ly lz ks ma mb mc kw js md me la jw mf mg le ka mh mi li mj dt translated"><strong class="ak"> 1-两个类之间的强引用:</strong></h2><p id="dd85" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">假设我们有两个直接相互引用的类(Author&amp;Book ):</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="1815" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">理论上，这应该打印出两个对象都被分配，然后因为它们被设置为nil而被取消分配，但是它打印出以下内容:</p><pre class="mk ml mm mn fq mq mr ms mt aw mu dt"><span id="feda" class="lw kn hu mr b fv mv mw l mx my"><strong class="mr hv">Author Object was allocated in memory<br/>Book object was allocated in memory</strong></span></pre><p id="cb59" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如你所看到的，这两个对象都没有从内存中释放出来，因为当两个类彼此有强引用时，会出现一个保留循环。</p><p id="f285" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了解决这个问题，我们可以将其中一个引用声明为弱引用或无主引用，如下所示:</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="fe87" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一次，两个对象都将被释放，控制台将打印以下内容:</p><pre class="mk ml mm mn fq mq mr ms mt aw mu dt"><span id="798f" class="lw kn hu mr b fv mv mw l mx my"><strong class="mr hv">Author Object was allocated in memory<br/>Book object was allocated in memory<br/>Author Object was deallocated<br/>Book Object was deallocated</strong></span></pre><p id="d2a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">问题得到了解决，当对象被释放时，ARC能够通过使其中一个引用变弱来清理内存块，但是弱和无主实际上意味着什么呢？根据苹果的文档:</p><h2 id="3aa3" class="lw kn hu bd ko lx ly lz ks ma mb mc kw js md me la jw mf mg le ka mh mi li mj dt translated">弱引用</h2><blockquote class="lp lq lr"><p id="09c0" class="jh ji ls jj b jk jl jm jn jo jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd ke hn dt translated">弱引用是一种对它所引用的实例没有很强控制的引用，因此不会阻止ARC释放被引用的实例。这种行为可以防止引用成为强引用周期的一部分。通过将<code class="eh mz na nb mr b">weak</code>关键字放在属性或变量声明之前来指示弱引用。</p></blockquote><h2 id="5080" class="lw kn hu bd ko lx ly lz ks ma mb mc kw js md me la jw mf mg le ka mh mi li mj dt translated">无主参考文献</h2><blockquote class="lp lq lr"><p id="9c97" class="jh ji ls jj b jk jl jm jn jo jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd ke hn dt translated">像弱引用一样，<em class="hu">无主引用</em>不会牢牢控制它所引用的实例。但是，与弱引用不同，当另一个实例具有相同或更长的生存期时，将使用无主引用。通过将<code class="eh mz na nb mr b">unowned</code>关键字放在属性或变量声明之前，可以指示一个无主引用。</p></blockquote></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h2 id="4397" class="lw kn hu bd ko lx ly lz ks ma mb mc kw js md me la jw mf mg le ka mh mi li mj dt translated"><strong class="ak">二级协议关系:</strong></h2><p id="9552" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">内存泄漏的另一个原因可能是协议和类之间的紧密联系。在下面的示例中，我们将采用一个真实的场景，其中我们有一个tabviewcontroller类和一个TableViewCell类，当用户按下TableViewCell中的按钮时，它应该将此操作委托给tabviewcontroller，如下所示:</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="c5bb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，当我们关闭TableViewController时，应该调用deinit，并且print语句应该出现在控制台中，但是在这种情况下，由于TableViewCellDelegate和TableViewController相互之间有很强的引用，因此它们永远不会从内存中释放。<br/>要解决这个问题，我们可以简单地将TableViewCell类调整如下:</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="27d9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一次关闭TableViewController并查看控制台:</p><pre class="mk ml mm mn fq mq mr ms mt aw mu dt"><span id="6b81" class="lw kn hu mr b fv mv mw l mx my"><strong class="mr hv">TableViewController is deallocated</strong></span></pre></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h2 id="5fe0" class="lw kn hu bd ko lx ly lz ks ma mb mc kw js md me la jw mf mg le ka mh mi li mj dt translated">3-闭包的强参考周期:</h2><p id="87ca" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">假设我们有以下视图控制器:</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="a3b3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">尝试关闭ViewController，将永远不会执行deinit方法。<br/>原因是因为闭包捕获了ViewController的强引用。为了解决这个问题，我们需要把自我当作弱者或无主者，如下所示:</p><figure class="mk ml mm mn fq iv"><div class="bz el l di"><div class="mo mp l"/></div></figure><p id="adb4" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这一次当关闭ViewController时，控制台将打印:</p><pre class="mk ml mm mn fq mq mr ms mt aw mu dt"><span id="29e4" class="lw kn hu mr b fv mv mw l mx my"><strong class="mr hv">ClosureViewController was deallocated</strong></span></pre></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="ae25" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">结论</h1><p id="f741" class="pw-post-body-paragraph jh ji hu jj b jk lk jm jn jo ll jq jr js lm ju jv jw ln jy jz ka lo kc kd ke hn dt translated">毫无疑问，ARC在管理应用程序的内存方面做得非常出色，作为开发人员，我们所要做的就是意识到类之间、类和协议之间以及闭包内部的强引用，在这些情况下声明弱变量或无主变量。</p></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="e6b0" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">关于ARC的一些重要参考资料:</h1><ul class=""><li id="78e8" class="nc nd hu jj b jk lk jo ll js ne jw nf ka ng ke nh ni nj nk dt translated"><a class="ae jg" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank">苹果的文档。</a></li><li id="fde1" class="nc nd hu jj b jk nl jo nm js nn jw no ka np ke nh ni nj nk dt translated"><a class="ae jg" href="https://www.raywenderlich.com/959-arc-and-memory-management-in-swift" rel="noopener ugc nofollow" target="_blank"> Raywenderlich </a>关于电弧的文章。</li></ul></div><div class="ab cl kf kg hc kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="hn ho hp hq hr"><h1 id="a596" class="km kn hu bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj dt translated">阅读我之前在Swift发表的关于GCD的文章:</h1><div class="nq nr fm fo ns nt"><a rel="noopener follow" target="_blank" href="/@BarekJaafar/swift-multi-threading-using-gcd-for-beginners-2581b7aa21cb"><div class="nu ab ej"><div class="nv ab nw cl cj nx"><h2 class="bd hv fv z el ny eo ep nz er et ht dt translated">初学者使用GCD的快速多线程。</h2><div class="oa l"><h3 class="bd b fv z el ny eo ep nz er et ek translated">使用GCD优化您的应用程序性能和用户体验。</h3></div><div class="ob l"><p class="bd b gc z el ny eo ep nz er et ek translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ja nt"/></div></div></a></div></div></div>    
</body>
</html>