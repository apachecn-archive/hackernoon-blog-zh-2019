<html>
<head>
<title>Writing a GraphQL Domain Specific Language (DSL) in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Kotlin 编写 GraphQL 领域特定语言(DSL)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/writing-a-graphql-dsl-in-kotlin-4a74e55e2c49#2019-03-18">https://medium.com/hackernoon/writing-a-graphql-dsl-in-kotlin-4a74e55e2c49#2019-03-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/60c7b67efaaa287625c6d9003456ff47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YL-fQhGhBPAti9tX5kMd4A.png"/></div></div></figure><div class=""/><p id="d7af" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我最近花了一些时间针对几个查询测试了一个 GraphQL 端点。目前，我将我的查询保存为多行字符串，但是我想知道:</p><blockquote class="ka kb kc"><p id="4058" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><em class="if">用 Kotlin 构建一个 GraphQL 查询 DSL 会有多难？</em></p></blockquote><p id="ec5f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我认为这是一个更熟悉 Kotlin DSL 功能的好机会。</p><p id="27ae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是我目前掌握的情况。</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/e054975264f519d39b04e37bfab40abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHIcCzlH3fchV-BFeXhJTw.png"/></div></div><figcaption class="km kn fg fe ff ko kp bd b be z ek">A GraphQL DSL in Kotlin</figcaption></figure><p id="7347" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">上面的代码片段会产生以下结果:</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/0eed83f17f4e83a8c3910be7bfdc3536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOcTWgMb1rBIy1o123bdeQ.png"/></div></div><figcaption class="km kn fg fe ff ko kp bd b be z ek">The GraphQL resulting from the DSL</figcaption></figure><p id="fca1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到目前为止，我面临的主要挑战是支持:</p><ul class=""><li id="c6a5" class="kq kr if je b jf jg jj jk jn ks jr kt jv ku jz kv kw kx ky dt translated">用作查询根字段的任何字符串(例如<code class="eh kz la lb lc b">"allUsers"</code>)</li><li id="f5dc" class="kq kr if je b jf ld jj le jn lf jr lg jv lh jz kv kw kx ky dt translated">字段的嵌套选择</li><li id="5ad5" class="kq kr if je b jf ld jj le jn lf jr lg jv lh jz kv kw kx ky dt translated">字段参数的类似 map 的语法(目前我已经满足于使用<code class="eh kz la lb lc b"><a class="ae li" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/to.html#to" rel="noopener ugc nofollow" target="_blank">to</a></code>方法)</li></ul><h1 id="084e" class="lj lk if bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">任何字符串都是一个字段</h1><p id="473d" class="pw-post-body-paragraph jc jd if je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">从上面的例子可以看出，可以使用一个字符串开始根字段声明，后跟字段选择:</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/7fc61d9a577d3109ecfb8bee8fb20112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yfg5mYQLV82MDgZtvm8MA.png"/></div></div></figure><p id="c3bc" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">多亏了对<a class="ae li" href="https://kotlinlang.org/docs/reference/operator-overloading.html#invoke" rel="noopener ugc nofollow" target="_blank">调用操作符重载</a>的支持，我才做到了这一点。请继续阅读，了解我是如何实现它的。</p><h1 id="a6f9" class="lj lk if bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">拯救世界</h1><p id="e80d" class="pw-post-body-paragraph jc jd if je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">极其强大的<a class="ae li" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">扩展支持</a>帮助我在<code class="eh kz la lb lc b">String</code>上定义自己的<code class="eh kz la lb lc b">invoke</code>实现。</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/ed2b2214456c63a5b7d1c3bb0e684c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9y8t90_hNclcaFydfWUaA.png"/></div></div><figcaption class="km kn fg fe ff ko kp bd b be z ek">String.invoke overload</figcaption></figure><p id="a5b9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，通过将一个块传递给<code class="eh kz la lb lc b">invoke</code>操作符<code class="eh kz la lb lc b">()</code>，任何字符串实例都可以变成一个<code class="eh kz la lb lc b">Field.Builder</code>。此外，Kotlin 的紧凑语法使我们不必显式地使用左括号和右括号，从而使结果更具可读性。</p><h1 id="e6c6" class="lj lk if bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">选择子字段</h1><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/7fc61d9a577d3109ecfb8bee8fb20112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yfg5mYQLV82MDgZtvm8MA.png"/></div></div></figure><p id="8626" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在声明的根字段中，一系列的<code class="eh kz la lb lc b">select</code>指令通知当前的字段构建器我们对哪些子字段感兴趣。实现这一点的方法是让编译器知道我们在一个<code class="eh kz la lb lc b">Field.Builder</code>的上下文中，并且块中指定的任何方法都必须根据它进行解析。多亏了带有接收者的<em class="kd">函数文字，这才成为可能。</em></p><h1 id="e027" class="lj lk if bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">带接收器的函数文字</h1><p id="2254" class="pw-post-body-paragraph jc jd if je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">这可能是 Kotlin 在构建 DSL 时提供的最有用的特性。</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/36286af19ffccaf606bbe92cff2fdd4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rFxkAqx6EN2EB2q5XMigpg.png"/></div></div></figure><p id="4171" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">块参数已被声明为<code class="eh kz la lb lc b">Field.Builder.() -&gt; Unit</code>。<br/>从文件中我们可以看到:</p><blockquote class="ka kb kc"><p id="af85" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><em class="if"> […] Kotlin 提供了</em> <a class="ae li" href="https://kotlinlang.org/docs/reference/lambdas.html#invoking-a-function-type-instance" rel="noopener ugc nofollow" target="_blank"> <em class="if">调用函数类型的实例</em> </a> <em class="if">的能力，receiver 提供了</em> receiver 对象<em class="if">。</em></p><p id="76ba" class="jc jd kd je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><a class="ae li" href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver" rel="noopener ugc nofollow" target="_blank"> <em class="if">带接收方的函数文字—科特林引用</em> </a></p></blockquote><p id="2807" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这意味着我可以调用当前的<code class="eh kz la lb lc b">Field.Builder</code>实例作为接收者的<code class="eh kz la lb lc b">block</code>,导致<code class="eh kz la lb lc b">select</code>调用被解析。</p><h1 id="2548" class="lj lk if bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">字段参数</h1><p id="fa12" class="pw-post-body-paragraph jc jd if je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">当谈到指定字段参数时，我不得不满足于这种不太好的语法。</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/d17a5e7d2f1010dfbc687cfb622669ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6jzEbEChQEZ1_CuuHo9Lg.png"/></div></div></figure><p id="eba5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我仍然认为这是一个很好的妥协，因为 Kotlin 在地图构建语法方面并没有提供太多。</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/2eaa6e28768580229c47b4c2bc1de78a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GE5Rm-x1L4j4RNKza4BGcQ.png"/></div></div></figure><p id="6e9d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">允许这样做的 to 方法来自标准库。</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff kh"><img src="../Images/a05436a7c770f0a3b861a486550c30e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guTQNAMY-DWvLnyuggVSJw.png"/></div></div></figure><p id="21cf" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，<code class="eh kz la lb lc b"><a class="ae li" href="https://kotlinlang.org/docs/reference/functions.html#infix-notation" rel="noopener ugc nofollow" target="_blank">infix</a></code>关键字允许简化符号<code class="eh kz la lb lc b">receiver method argument</code>。</p><p id="ada1" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，<code class="eh kz la lb lc b">String.invoke</code>稍微复杂一点的定义接受<code class="eh kz la lb lc b">Pair&lt;String, T&gt;</code>的实例，允许在指定字段参数时使用<code class="eh kz la lb lc b"><em class="kd">to</em></code>语法。作为左类型的显式字符串类型有助于使它更加健壮。</p><figure class="ki kj kk kl fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mm"><img src="../Images/a349b7b41ff1717eacf2d70ff13059ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3nDWyB5XacJpO4QkijF2Zw.png"/></div></div></figure><h1 id="ff63" class="lj lk if bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg dt translated">包扎</h1><p id="bb08" class="pw-post-body-paragraph jc jd if je b jf mh jh ji jj mi jl jm jn mj jp jq jr mk jt ju jv ml jx jy jz hn dt translated">如你所见，我不是 DSL 专家(根本不是！)但这是一个有趣的实验。你可以在<a class="ae li" href="https://github.com/alediaferia/graphql-forger" rel="noopener ugc nofollow" target="_blank">graph QL-forger</a>repo 跟踪我的工作。请随意提出问题或请求。</p><p id="3190" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我希望你喜欢这篇文章，并对科特林有所了解。</p></div><div class="ab cl mn mo hc mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hn ho hp hq hr"><p id="79d4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kd">原载于 2019 年 3 月 18 日</em><a class="ae li" href="https://alediaferia.com/2019/03/18/writing-graphql-dsl-kotlin/" rel="noopener ugc nofollow" target="_blank"><em class="kd">alediaferia.com</em></a><em class="kd">。</em></p></div></div>    
</body>
</html>