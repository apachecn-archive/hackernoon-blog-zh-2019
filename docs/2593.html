<html>
<head>
<title>Algorithms and Data Structures Interview Preparation &amp; Walkthrough — Part 3, Linked List, Queue and Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法和数据结构面试准备和演练—第 3 部分，链表、队列和堆栈</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/algorithms-and-data-structures-interview-preparation-walkthrough-part-3-linked-list-queue-63e5e71f76a6#2019-04-23">https://medium.com/hackernoon/algorithms-and-data-structures-interview-preparation-walkthrough-part-3-linked-list-queue-63e5e71f76a6#2019-04-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/002f245e98d21912fd417089e2bee6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OGmLzYOr0XV9RFuG.jpg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">(Source: <a class="ae jg" href="https://www.fotolia.com/tag/queue" rel="noopener ugc nofollow" target="_blank">fotolia.com</a>)</figcaption></figure><p id="3a09" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在我之前的帖子:<a class="ae jg" rel="noopener" href="/@victorlin_38374/algorithms-and-data-structures-interview-preparation-walkthrough-part-2-array-and-string-80f28e095ca8"> <strong class="jj hv">算法和数据结构面试准备&amp;演练—第二部分</strong> </a>中，我们谈到了如何从头实现一个静态数组，将其扩展为动态数组，并讨论了摊销的含义。</p><p id="9d56" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这篇文章中，我想谈谈链表、队列和堆栈，因为它们都是线性数据结构，这些元素是按顺序组织的。</p><h2 id="a82a" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">链表</h2><p id="f7fa" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">与 Array 类似，它也以线性方式存储元素。但是，它不会将它们存储在内存中连续的位置；它使用相互连接但分散在各处的节点。一个<strong class="jj hv">节点</strong>包含指向其他节点的值和指针，这取决于它是一个单向还是双向链表。在下面的代码片段中，我将实现节点和单链表。</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="e026" class="kf kg hu lk b fv lo lp l lq lr">function Node(value = null){<br/>  this.value = value;<br/>  this.next = null;<br/>}</span><span id="ccff" class="kf kg hu lk b fv ls lp l lq lr">function LinkedList(){<br/>  this.head = null;<br/>  this.tail = null;<br/>  this.length = 0;<br/>}</span><span id="9d5b" class="kf kg hu lk b fv ls lp l lq lr">// Time Complexity: O(1)<br/>// Auxiliary Space Complexity: O(1)<br/>LinkedList.prototype.<strong class="lk hv">append</strong> = function(value) {<br/>  let newNode = new Node(value);<br/>  if (this.head === null) {<br/>    this.head = this.tail = newNode;<br/>  } else if (this.head === this.tail) {<br/>    this.tail = newNode;<br/>    this.head.next = this.tail;<br/>  } else {<br/>    this.tail.next = newNode;<br/>    this.tail = newNode;<br/>  }<br/>  this.length += 1;<br/>};</span><span id="d253" class="kf kg hu lk b fv ls lp l lq lr">// Time Complexity: O(n)<br/>// Auxiliary Space Complexity: O(1)<br/>LinkedList.prototype.<strong class="lk hv">insert</strong> = function(value, index) {<br/>  if (index &gt; this.length || index &lt; 0) return;</span><span id="374e" class="kf kg hu lk b fv ls lp l lq lr">let prev = new Node(value);<br/>  let node = this.head;<br/>  if (this.head === null &amp;&amp; index === 0) {<br/>    this.head = this.tail = prev;<br/>    this.length += 1;<br/>    return;<br/>  } else if (this.head === this.tail) {<br/>    if (index === 0) {<br/>      prev.next = this.head;<br/>      this.head = prev;<br/>    } else {<br/>      this.head.next = prev;<br/>      this.tail = prev;<br/>    }<br/>    this.length += 1;<br/>    return;<br/>  }</span><span id="7c4f" class="kf kg hu lk b fv ls lp l lq lr">while (index &gt; 1) {<br/>    node = node.next;<br/>    index--;<br/>  }</span><span id="4c35" class="kf kg hu lk b fv ls lp l lq lr">let nextNode = node.next;<br/>  node.next = prev;<br/>  prev.next = nextNode;<br/>  this.length += 1;</span><span id="c006" class="kf kg hu lk b fv ls lp l lq lr">return;<br/>};</span><span id="7649" class="kf kg hu lk b fv ls lp l lq lr">// Time Complexity: O(n)<br/>// Auxiliary Space Complexity: O(1)<br/>LinkedList.prototype.<strong class="lk hv">delete</strong> = function(index) {<br/>  if (index &gt; this.length || index &lt; 0 || this.length === 0) return;<br/>  if (index === 0 &amp;&amp; this.length === 1) {<br/>    this.head = this.tail = null;<br/>    this.length = 0;<br/>    return;<br/>  } else if (this.length === 2) {<br/>    if (index === 0) {<br/>      this.head.next = null<br/>      this.head = this.tail;<br/>    } else {<br/>      this.tail = this.head;<br/>      this.head.next = null;<br/>    }<br/>    this.length = 1;<br/>    return;<br/>  }<br/>  let node = this.head;<br/>  while (index !== 0) {<br/>    if (node === this.tail) return;<br/>    node = node.next;<br/>    index--;<br/>  }<br/>  node.next.next = null;<br/>  node.next = node.next.next;<br/>  this.length -= 1;<br/>};</span><span id="a3ee" class="kf kg hu lk b fv ls lp l lq lr">// Time Complexity: O(n)<br/>// Auxiliary Space Complexity: O(1)<br/>LinkedList.prototype.<strong class="lk hv">contains</strong> = function(value) {<br/>  let node = this.head;<br/>  while (node !== null) {<br/>    if (node.value === value) return true;<br/>    node = node.next;<br/>  }<br/>  return false;<br/>};</span></pre><p id="8d38" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我为单链表实现 append(value)，insert(value，index)，delete(index)，contains(value)。对于 append()，因为我们知道它总是在尾部附加一个新节点，我们只需要将 tail.next 指向新节点，并将 tail 指向新节点。时间复杂度为 O(1)。在单链表中，从头部删除()也是 O(1)。然而当涉及到带有某个索引的 insert()、delete()或 contains()时，最坏的情况是我们需要遍历整个列表来找到正确的位置，时间复杂度是 O(n)。</p><p id="8e48" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在一个双向链表中，除了节点中的 next 属性，我们还有 prev 属性可以从尾部开始以相反的顺序跟踪。从其中移除最后一个元素的时间复杂度是 O(1)，因为现在可以在两个方向上遍历列表，所以可以从 tail 和 point tail.prev 中移除最后一个元素，并指向最后一个-1 元素。使用双向链表更容易也更有效，但是你需要小心维护节点中的 next 和 prev 指针。如何重新分配 next 和 prev 指针是链表相关<a class="ae jg" href="https://hackernoon.com/tagged/interview" rel="noopener ugc nofollow" target="_blank">面试</a>题中的关键。</p><p id="ca66" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">链表的优点是我们可以动态地扩展和收缩它，因为我们不连续地在内存中存储节点。但是，我们需要额外的内存来存储指针，访问节点必须按顺序读取。</p><p id="4560" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">链表可以创建许多其他的数据结构:队列、栈、图、哈希表。</p><p id="c5bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">什么时候</strong>应该使用链表？</p><p id="b2a0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●主要需要的是在你的集合中间插入和删除——不需要重新分配内存中的节点，只需要修改指针。</p><p id="9a98" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●分割和连接是常见操作——原因同上。</p><p id="5f6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●不需要搜索和访问值—我们不想要 O(n)搜索和访问时间。</p><p id="b781" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●不需要随机访问。</p><p id="81db" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以从链表创建其他数据结构:</p><p id="833e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●排队</p><p id="28f2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●堆栈</p><p id="7d08" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●图表</p><p id="5239" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">●哈希表</p><p id="8176" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将在另一篇文章中讨论图和散列表。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h2 id="db1a" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">长队</h2><p id="c809" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">Queue 是一个线性的<a class="ae jg" href="https://hackernoon.com/tagged/data-structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>，它使用先进先出(FIFO)规则添加和删除元素。我们可以从数组或链表中实现队列。在下面的实现中，为了简单起见，我们使用数组。然而，<em class="ma">最好使用双向链表来获得固定的时间复杂度。</em></p><p id="8dd9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">常用方法:</p><p id="36a7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">○入队—将元素添加到队列中</p><p id="f4df" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">○dequee—从队列中移除并返回第一个元素</p><p id="6ffb" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">○ peek —返回第一个元素，但不从队列中删除</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="9a13" class="kf kg hu lk b fv lo lp l lq lr">function Queue(){<br/>  this.store = [];<br/>}</span><span id="7c1d" class="kf kg hu lk b fv ls lp l lq lr">Queue.prototype.enqueue = function(num) {<br/>  this.store.push(num);<br/>}</span><span id="f412" class="kf kg hu lk b fv ls lp l lq lr">Queue.prototype.deque = function() {<br/>  this.store.shift();<br/>}</span><span id="dfe1" class="kf kg hu lk b fv ls lp l lq lr">Queue.prototype.peek = function() {<br/>  this.store[0];<br/>}</span></pre><p id="f0e2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用队列的好处是当我们想要强制执行 FIFO 限制时，也能够动态扩展和收缩。在多个用户之间共享资源(即 CPU)和处理异步操作(I/O 缓冲区)是我们现在使用队列的两个常见例子。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h2 id="b831" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">堆</h2><p id="d2c4" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">一种线性数据结构，使用后进先出(LIFO)规则添加和删除元素。与队列类似，我们可以从数组或链表中实现队列。</p><p id="2e75" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">常用方法:</p><p id="d5f7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">推送—将元素添加到堆栈中</p><p id="3982" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">○ pop —从堆栈中移除并返回最后一个元素</p><p id="60bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">○ peek —返回最后一个元素，但不从堆栈中删除</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f824" class="kf kg hu lk b fv lo lp l lq lr">function Stack(){<br/>  this.store = [];<br/>}</span><span id="a246" class="kf kg hu lk b fv ls lp l lq lr">Stack.prototype.push = function(num) {<br/>  this.store.push(num);<br/>}</span><span id="70aa" class="kf kg hu lk b fv ls lp l lq lr">Stack.prototype.pop = function() {<br/>  this.store.pop();<br/>}</span><span id="2562" class="kf kg hu lk b fv ls lp l lq lr">Stack.prototype.peek = function() {<br/>  this.store[this.store.length - 1];<br/>}</span></pre><p id="17e6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用队列的好处是，当我们想要强制执行 LIFO 限制时，还可以像队列一样使用链表来动态扩展和收缩。然而，它限制了对值的访问，并且在一些现代语言(Ruby、Python、JavaScript)中已经过时了。对于某些语言，动态数组已经包含了与堆栈相同的方法。</p><p id="5145" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">实现堆栈的一些例子:撤销/重做特性，浏览器上的后退按钮，以及计算表达式。</p><p id="5eb3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有各种各样与数组、链表、堆栈和队列相关的面试问题，因为它们是非常基本的，并且被大多数面试问题所涵盖。我将列举一些例子供您研究:</p><ol class=""><li id="78e0" class="mb mc hu jj b jk jl jo jp js md jw me ka mf ke mg mh mi mj dt translated"><a class="ae jg" href="https://www.geeksforgeeks.org/tag/palindrome/" rel="noopener ugc nofollow" target="_blank">回文</a></li><li id="89b7" class="mb mc hu jj b jk mk jo ml js mm jw mn ka mo ke mg mh mi mj dt translated"><a class="ae jg" href="https://www.geeksforgeeks.org/array-data-structure/#rotation" rel="noopener ugc nofollow" target="_blank">数组旋转</a></li><li id="8537" class="mb mc hu jj b jk mk jo ml js mm jw mn ka mo ke mg mh mi mj dt translated"><a class="ae jg" href="https://www.geeksforgeeks.org/array-data-structure/#searchSort" rel="noopener ugc nofollow" target="_blank">分类和搜索</a></li><li id="5996" class="mb mc hu jj b jk mk jo ml js mm jw mn ka mo ke mg mh mi mj dt translated">对<a class="ae jg" href="https://www.geeksforgeeks.org/stack-data-structure/#operations" rel="noopener ugc nofollow" target="_blank">堆栈</a> / <a class="ae jg" href="https://www.geeksforgeeks.org/queue-data-structure/#operations" rel="noopener ugc nofollow" target="_blank">队列</a>的操作</li></ol><p id="649c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我发现没有人真正阅读我为我的思考过程创建的编码问题帖子，所以我会发布其他网站的链接来准备面试问题。</p><h2 id="115d" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">在你走之前—</h2><p id="38d7" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">没有比在 Medium 上给我一个 follow(<a class="ae jg" rel="noopener" href="/@victorlin_38374"><strong class="jj hv">Victor Lin</strong></a>)更好的支持我的方式了。让我知道我应该多写！</p><p id="4b85" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你知道你可以放弃 50 吗👏通过按下👏按钮？如果你<em class="ma">真的</em>喜欢这篇文章，那就试试吧！</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="mp mq l"/></div></figure></div></div>    
</body>
</html>