<html>
<head>
<title>Create an Ethereum Dapp with React and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 React 和 Docker 创建一个以太坊 Dapp</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/create-an-ethereum-dapp-with-react-and-docker-211223005f17#2019-04-14">https://medium.com/hackernoon/create-an-ethereum-dapp-with-react-and-docker-211223005f17#2019-04-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/52640426078eed752573efdc9eeb346b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUSD_BBMH-x2C6i61V10OQ.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Images Google Sources</figcaption></figure><p id="1a0a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在本教程中，我们将创建一个以太坊 Dapp，并在一个单独的 docker 容器中运行它的不同组件。</p><p id="e571" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可以使用这个<a class="ae ke" href="https://github.com/schadokar/docker-ethereum.git" rel="noopener ugc nofollow" target="_blank"> GitHub 链接</a>来克隆这个项目。</p><p id="55c9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">感谢那些文章和课程帮了大忙的人:</p><p id="a868" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><a class="kf kg gr" href="https://medium.com/u/e9031892baf5?source=post_page-----211223005f17--------------------------------" rel="noopener" target="_blank">布兰登·莫雷利</a>负责 HTML 和 CSS ( <a class="ae ke" href="https://codeburst.io/build-a-weather-website-in-30-minutes-with-node-js-express-openweather-a317f904897b" rel="noopener" target="_blank">建立一个天气网站</a></p><p id="1845" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">Stephen Grider<a class="kf kg gr" href="https://medium.com/u/d058882d8cd2?source=post_page-----211223005f17--------------------------------" rel="noopener" target="_blank">参加 Udemy 的</a><a class="ae ke" href="https://www.udemy.com/share/1000CIAkUTc1xbQng=/" rel="noopener ugc nofollow" target="_blank">以太坊</a>和<a class="ae ke" href="https://www.udemy.com/share/100r4uAkUTc1xbQng=/" rel="noopener ugc nofollow" target="_blank">码头工人</a>课程。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><p id="a4e8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在开始之前，让我们了解我们将要构建什么，以及我们的 Dapp 的结构将会是什么样子。</p><p id="5645" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在 Dapp 中将有三个模块:</p><ol class=""><li id="7b0f" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd kt ku kv kw dt translated">加纳切-cli</li><li id="894c" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd kt ku kv kw dt translated">以太坊-Dapp 和服务器</li><li id="afbc" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd kt ku kv kw dt translated">客户端(反应应用程序)</li></ol><p id="8aa0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">上述 3 个模块将在单独的 docker 容器中运行。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div class="fe ff lc"><img src="../Images/502152b015c69f49c891ca3471688b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*X0gVeyEzww4sOw1FNh6fBQ.png"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">D app</figcaption></figure><blockquote class="lh li lj"><p id="4f43" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">当所有服务都可以在一个容器中构建时，为什么我们要为每个服务构建单独的容器？</p></blockquote><p id="8ea2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">是的，所有这些都可以在一个容器中构建，一切都很简单。只是为了好玩，我们使用不同的容器。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="237a" class="lo lp hu bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated"><strong class="ak">项目设置</strong></h1><p id="842f" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个项目文件夹，命名为<strong class="ji hv">“docker-ether eum”</strong>。</p><p id="8ccd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">目录结构</strong></p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="eb14" class="mw lp hu ms b fv mx my l mz na">docker-ethereum<br/>- client<br/>- ethereum<br/>- server<br/>- .dockerignore<br/>- docker-compose.yml<br/>- Dockerfile<br/>- Dockerfile.ganache<br/>- package.json</span></pre><h2 id="9a88" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">package.json</h2><p id="9bf9" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个<code class="eh no np nq ms b">package.json</code>并粘贴下面的代码:</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">package.json</figcaption></figure><p id="8470" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们已经完成了项目依赖项的安装。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><p id="2b7a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要构建任何应用程序，我们的网络都应该做好准备。所以，我们先从我们的 ganache-cli 作为网络开始。</p><h1 id="a35c" class="lo lp hu bd lq lr nt lt lu lv nu lx ly lz nv mb mc md nw mf mg mh nx mj mk ml dt translated">1.加纳切-cli</h1><p id="f9c6" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">这是一个测试网络，有 10 个帐户，每个帐户有 100 个以太网。这是最好的发展，在那里你不必等待交易挖掘。</p><blockquote class="lh li lj"><p id="82d9" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">Ganache 是一个用于以太坊开发的个人区块链，你可以用它来部署合同、开发应用程序和运行测试。</p></blockquote><p id="09b8" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在我们的应用程序中，ganache-cli 将在 docker 容器中运行。</p><p id="fdc5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在项目目录中，创建一个<code class="eh no np nq ms b">Dockerfile.ganache</code>。</p><p id="0cf9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这个 docker 文件中，我们将编写在容器中设置和运行 ganache-cli 的所有指令。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Dockerfile.ganache</figcaption></figure><p id="5b67" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在第 2 行，为了构建这个 ganache-cli 映像，我们将 node:alpine 作为基础映像。</p><p id="51e2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在第 5 行，我们将/app 文件夹设置为图像的工作目录，所有的指令都将在这里运行。</p><p id="9e4d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在第 8 行，我们正在全球安装<strong class="ji hv"> ganache-cli </strong>。</p><p id="6934" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在第 12 行，我们将<code class="eh no np nq ms b">ganache-cli -h 0.0.0.0</code>设置为图像的默认命令。</p><blockquote class="lh li lj"><p id="78fa" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">Ganache-cli 的默认主机是 127.0.0.1，但对于 docker 实例，它是 0.0.0.0</p></blockquote><p id="6ac5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我在<a class="ae ke" rel="noopener" href="/@shubhamchadokar04/run-the-ganache-cli-inside-the-docker-container-5e70bc962bfe">上一篇</a>中已经详细解释了以上所有说明。如果你在这里发现任何困难，请检查它。</p><p id="76dc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的网络已配置好。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="de8a" class="lo lp hu bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">2.以太坊 Dapp 和服务器</h1><h2 id="4d4d" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">以太坊 Dapp</h2><p id="af28" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在项目目录中创建一个<code class="eh no np nq ms b">Ethereum</code>文件夹。</p><p id="072e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">目录结构</strong></p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="f39e" class="mw lp hu ms b fv mx my l mz na">Ethereum<br/>- build<br/>- contracts<br/>  - Message.sol<br/>- compile.js<br/>- deploy.js<br/>- logic.js<br/>- receipt-ganache.json<br/>- web3.js</span></pre><p id="d386" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">以太坊目录中:</p><h2 id="64e8" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated"><strong class="ak">合同</strong></h2><p id="a064" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在合同文件夹中创建一个新文件夹<code class="eh no np nq ms b">contracts</code>和一个新文件<code class="eh no np nq ms b">Message.sol</code>，并粘贴下面的代码。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Message.sol</figcaption></figure><p id="08fb" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们正在创建一个简单的消息契约。在这个智能契约中将有 3 个函数(1)构造器(2) setMessage (3) getMessage</p><p id="1c7e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在消息智能合约第一次运行时，那一次<code class="eh no np nq ms b">constructor</code>会将该消息设置为初始消息。</p><p id="79de" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">setMessage</code>功能将设置一条新消息。</p><p id="aaf5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">getMessage</code>是一个视图函数，它将返回由<code class="eh no np nq ms b">constructor</code>或<code class="eh no np nq ms b">setMessage</code>设置的消息变量的值。</p><h2 id="e3be" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">编译. js</h2><p id="ac00" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个新文件<code class="eh no np nq ms b">compile.js</code>并将下面的代码粘贴到其中。这将编译<code class="eh no np nq ms b">Message.sol</code>智能合同，并将编译后的合同作为<code class="eh no np nq ms b">Message.json</code>保存在<code class="eh no np nq ms b">build</code>文件夹中。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">compile.js</figcaption></figure><h2 id="2ee9" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">web3.js</h2><p id="b0a6" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个<code class="eh no np nq ms b">web3.js</code>文件，作为应用程序和以太网之间的桥梁。</p><blockquote class="lh li lj"><p id="171a" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">web3.js 是一个库的集合，它允许你使用 HTTP、WebSocket 或 IPC 连接与本地或远程以太坊节点进行交互。</p></blockquote><p id="3a36" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">web3.js 可以 2 种方式使用，(1)服务器端 web3js:在服务器端签名的事务(2)客户端 web3js:在浏览器端签名的事务。在这个 web3js 中，由 Mist 或 Metamask 等第三方调用。在客户端的 web3js 中调用 html 页面。</p><p id="9eaf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">对于这个项目，我们使用服务器端的 web3js。</p><p id="376c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">将以下代码复制并粘贴到<code class="eh no np nq ms b">web3.js</code></p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">web3.js</figcaption></figure><blockquote class="lh li lj"><p id="00ec" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">记下 web3 提供商<code class="eh no np nq ms b">http://ganache:8545</code>。这里，<strong class="ji hv"> ganache </strong>是运行 ganache-cli 的容器的名称。</p></blockquote><h2 id="d3d0" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">部署. js</h2><p id="89d5" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个<code class="eh no np nq ms b">deploy.js</code>文件，并将下面的代码粘贴到其中。它将采用编译后的合同<code class="eh no np nq ms b">Message.json</code>并将合同部署到网络。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">deploy.js</figcaption></figure><p id="6c3b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">deploy.js</code>从<code class="eh no np nq ms b">web3.js</code>文件中导入<code class="eh no np nq ms b">ganache-cli</code>和<code class="eh no np nq ms b">web3network</code>的<code class="eh no np nq ms b">web3</code>实例为<code class="eh no np nq ms b">ganache</code>。</p><h2 id="a012" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">logic.js</h2><p id="386a" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个新文件<code class="eh no np nq ms b">logic.js</code>并将下面的代码粘贴到其中。它包含了与网络上部署的<code class="eh no np nq ms b">Message</code>契约进行交互的所有逻辑。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">logic.js</figcaption></figure><p id="9b46" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">logic.js</code>内部有 3 个功能</p><ol class=""><li id="e896" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd kt ku kv kw dt translated"><code class="eh no np nq ms b">getContractObject</code>它将返回使用<code class="eh no np nq ms b">deploy.js</code>部署在网络上的合同对象/实例。然后，该对象将调用智能协定。</li><li id="4f83" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd kt ku kv kw dt translated"><code class="eh no np nq ms b">setMessage</code>它需要 1 个字符串参数，并将其作为消息设置给智能合约中的<code class="eh no np nq ms b">message</code>变量。</li><li id="45fc" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd kt ku kv kw dt translated"><code class="eh no np nq ms b">getMessage</code>将返回由<code class="eh no np nq ms b">constructor</code>或<code class="eh no np nq ms b">setMessage</code>设置的信息</li></ol><p id="67b0" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">ethereum</code>模块完成。</p><p id="6b8e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，需要设置<code class="eh no np nq ms b">server</code>，它将调用<code class="eh no np nq ms b">ethereum</code>模块。</p><h1 id="9c06" class="lo lp hu bd lq lr nt lt lu lv nu lx ly lz nv mb mc md nw mf mg mh nx mj mk ml dt translated">计算机网络服务器</h1><p id="2a56" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在项目目录下创建一个<code class="eh no np nq ms b">server</code>文件夹。</p><p id="6e8f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">目录结构</strong></p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="b420" class="mw lp hu ms b fv mx my l mz na">server<br/>- routes<br/>  - contract-API.js<br/>  - smart-contract-API.js<br/>- index.js</span></pre><h2 id="d5a0" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">路线</h2><p id="afb6" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在<code class="eh no np nq ms b">server</code>文件夹内创建一个<code class="eh no np nq ms b">routes</code>文件夹。</p><p id="3a82" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">合同-API.js </strong></p><p id="ae18" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">创建一个<code class="eh no np nq ms b">contract-API.js</code>文件并粘贴到代码下面。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">contract-API.js</figcaption></figure><p id="43aa" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">为了编译和部署契约，我们创建了 API，而不是手动编译并在网络上部署它。</p><p id="efaf" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您还记得，我们的<code class="eh no np nq ms b">Message</code>智能契约的构造函数需要一个初始消息。为了简单起见，默认情况下我们将初始消息设置为<code class="eh no np nq ms b">Hello World!</code>。您可以在部署路由器中更改它。</p><h2 id="8978" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">智能合同 API.js</h2><p id="c5b2" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个<code class="eh no np nq ms b">smart-contract-API.js</code>并粘贴下面的代码。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">smart-contract-API.js</figcaption></figure><p id="1404" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">smart-contract-API.js</code>路由器会从<code class="eh no np nq ms b">logic.js</code>调用<code class="eh no np nq ms b">setMessage</code>和<code class="eh no np nq ms b">getMessage</code></p><h2 id="7976" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">索引. js</h2><p id="5430" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在<code class="eh no np nq ms b">server</code>文件夹中创建一个<code class="eh no np nq ms b">index.js</code>文件，并粘贴以下代码。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div></figure><p id="cd92" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这是以太坊 dapp 的服务器。</p><p id="d301" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在顶部，我们正在导入路线<code class="eh no np nq ms b">contract-API.js</code>和<code class="eh no np nq ms b">smart-contract-API.js</code>。服务器在端口<code class="eh no np nq ms b">4000</code>监听。</p><p id="1aa4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">服务器模块在这里已经完成。</p><p id="bf41" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">让我们把它归档。</p><h2 id="64e5" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">Dockerfile 文件</h2><p id="f064" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在根项目目录中创建一个<code class="eh no np nq ms b">Dockerfile</code>，并粘贴下面的代码。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">server Dockerfile</figcaption></figure><p id="7872" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">docker 映像将根据 Dockerfile 创建。</p><ul class=""><li id="a856" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><code class="eh no np nq ms b">node:alpine</code>要创建一个图像，我们需要一个基础图像，附带一些先决条件的软件。我们的服务器和以太坊依赖于<code class="eh no np nq ms b">node</code>，这就是为什么我们使用<code class="eh no np nq ms b">node:alpine</code>作为基础映像。<code class="eh no np nq ms b">alpine</code>简而言之，是运行一个节点应用程序所需的最小库。</li><li id="53ce" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">WORKDIR /app</code>将基础映像的<code class="eh no np nq ms b">/app</code>目录设置为工作目录。</li><li id="15e5" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated">第 8 &amp; 9 行安装以太坊 dapp 的必备软件，如<code class="eh no np nq ms b">python</code>需要安装<code class="eh no np nq ms b">web3</code>库。</li><li id="af4d" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">COPY ./package.json .</code>将<code class="eh no np nq ms b">package.json</code>复制到<code class="eh no np nq ms b">/app</code>目录中</li><li id="42e3" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">RUN npm install</code>安装<code class="eh no np nq ms b">package.json</code>中提到的依赖项</li><li id="919b" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">COPY . .</code>复制完整的根目录并粘贴到<code class="eh no np nq ms b">/app</code>目录中</li><li id="f168" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">CMD ["npm","start"]</code>设置默认命令</li></ul><p id="c013" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果你注意到我们正在复制包含<code class="eh no np nq ms b">node_modules</code>的完整根目录。这将使图像变大，而且毫无意义，因为我们是从图像中复制的<code class="eh no np nq ms b">package.json</code>安装的。</p><p id="a3a2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在构建 docker 镜像时忽略文件或文件夹，就像 docker 中的<code class="eh no np nq ms b">.gitignore</code>一样，这里有<code class="eh no np nq ms b">.dockerignore</code>文件。</p><h2 id="f246" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">。dockerignore</h2><p id="b503" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">创建一个<code class="eh no np nq ms b">.dockerignore</code>文件并粘贴下面的代码。</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="ab14" class="mw lp hu ms b fv mx my l mz na">node_modules/</span><span id="a9da" class="mw lp hu ms b fv nz my l mz na">client/</span></pre><p id="cefe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它将忽略我们将在下一节创建的<code class="eh no np nq ms b">node_modules</code>和<code class="eh no np nq ms b">client</code>目录。如果我们不忽略<code class="eh no np nq ms b">client</code>目录，那么它也会复制客户端应用程序。</p><p id="f1fe" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，我们可以转到最后一个模块 React 应用程序<code class="eh no np nq ms b">client</code>。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="6d78" class="lo lp hu bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">3.客户端(反应应用程序)</h1><p id="335b" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">对于 react 应用程序，我们使用 Dapp 的<code class="eh no np nq ms b">create-react-app</code>工具。</p><blockquote class="lh li lj"><p id="d597" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">Create React App 是一款工具(由脸书的开发人员开发)，在开发 React 应用时，它会给你一个很好的开端。它为您节省了耗时的设置和配置。——<a class="ae ke" href="https://blog.teamtreehouse.com/getting-started-create-react-app-tool" rel="noopener ugc nofollow" target="_blank">树屋</a></p></blockquote><p id="5489" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">安装 Create React 应用</strong></p><p id="52d9" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们需要在全球安装<code class="eh no np nq ms b">create-react-app</code>。打开您的终端或控制台并运行:</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="f378" class="mw lp hu ms b fv mx my l mz na">npm install -g create-react-app</span></pre><p id="da8a" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从项目目录中，打开终端或控制台，创建名为<code class="eh no np nq ms b">client</code>的 react 应用程序，并运行下面的命令。</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="250f" class="mw lp hu ms b fv mx my l mz na">create-react-app client</span></pre><p id="6ab7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">目录结构</strong></p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="7464" class="mw lp hu ms b fv mx my l mz na">client <br/>- public<br/>  - favicon.ico<br/>  - index.html<br/>  - manifest.json<br/>- src<br/>  - App.css<br/>  - App.js<br/>  - App.test.js<br/>  - index.css<br/>  - index.js<br/>  - logo.svg<br/>  - <strong class="ms hv">message.js</strong><br/>  - serviceWorker.js<br/>- <strong class="ms hv">.dockerignore</strong><br/>- <strong class="ms hv">Dockerfile</strong><br/>- package-lock.json<br/>- package.json<br/>- README.md</span></pre><p id="884e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦<code class="eh no np nq ms b">client</code>被创建，你会看到一个类似上面的文件夹结构，除了<code class="eh no np nq ms b">src</code>、<code class="eh no np nq ms b">Dockerfile</code>和<code class="eh no np nq ms b">.dockerignore</code>里面的<code class="eh no np nq ms b">message.js</code>。</p><p id="2d33" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有关 react 的更多信息，请点击以下链接:</p><ul class=""><li id="5d5d" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><a class="ae ke" href="https://facebook.github.io/create-react-app/docs/getting-started" rel="noopener ugc nofollow" target="_blank">https://Facebook . github . io/create-react-app/docs/getting-started</a></li><li id="217a" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><a class="ae ke" href="https://blog.teamtreehouse.com/getting-started-create-react-app-tool" rel="noopener ugc nofollow" target="_blank">https://blog . teamtreehouse . com/getting-started-create-react-app-tool</a></li></ul><h2 id="5fbb" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">index.html</h2><p id="c2b8" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">从<code class="eh no np nq ms b">public</code>文件夹中打开<code class="eh no np nq ms b">index.html</code>，将标题改为<code class="eh no np nq ms b">Message App</code>。在<code class="eh no np nq ms b">&lt;head&gt;</code>标签中添加下面的链接。这是应用程序中使用的字体。</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="1224" class="mw lp hu ms b fv mx my l mz na">&lt;link href='https://fonts.googleapis.com/css?family=Open+Sans:300' rel='stylesheet' type='text/css'&gt;</span></pre><h2 id="c8d3" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">App.css</h2><p id="faca" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">从<code class="eh no np nq ms b">src</code>文件夹中打开<code class="eh no np nq ms b">App.css</code>并粘贴此<a class="ae ke" href="https://gist.github.com/schadokar/7635212e2a284bf6055f806f8fc1f664" rel="noopener ugc nofollow" target="_blank">连杆</a>中的<code class="eh no np nq ms b">css</code>。</p><h2 id="098a" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">message.js</h2><p id="1444" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在<code class="eh no np nq ms b">src</code>文件夹中创建一个<code class="eh no np nq ms b">message.js</code>并粘贴下面的代码。这是将作为应用程序前端的文件。</p><blockquote class="lh li lj"><p id="a6bf" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">注意:我不擅长 React，所以我只能给出其中使用的方法的细节。</p></blockquote><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">message.js</figcaption></figure><p id="58a7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">组件是任何 react 应用程序的构建块。要创建一个组件，它需要来自<code class="eh no np nq ms b">react</code>库中的<code class="eh no np nq ms b">Component</code>模块。当服务器在<code class="eh no np nq ms b">4000</code>端口运行时，端点被设置为<code class="eh no np nq ms b">http://localhost:4000</code>。</p><p id="d9f4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">向服务器发出任何请求都要使用<code class="eh no np nq ms b">axios</code>库。要了解更多信息，请点击此<a class="ae ke" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><p id="9174" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从<code class="eh no np nq ms b">client</code>目录打开终端并运行以下命令:</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="0ca1" class="mw lp hu ms b fv mx my l mz na">npm install axios --save</span></pre><p id="c8d6" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们通过扩展<code class="eh no np nq ms b">Component</code>创建了一个<code class="eh no np nq ms b">Message</code>组件，并在底部导出了<code class="eh no np nq ms b">Message</code>。</p><p id="f961" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<code class="eh no np nq ms b">Message</code>组件<code class="eh no np nq ms b">message</code>和<code class="eh no np nq ms b">output</code>中有两种状态。</p><p id="6f5e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">状态是定义和控制组件行为的数据。在此<a class="ae ke" href="https://facebook.github.io/react-native/docs/state" rel="noopener ugc nofollow" target="_blank">链接</a>中了解更多关于状态的信息。</p><p id="c4ab" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">message</code>状态将存储在表单中输入的消息，该状态将用作一个参数，将 POST 请求从<code class="eh no np nq ms b">localhost:4000/</code>发送到<code class="eh no np nq ms b">setMessage</code>。</p><p id="730d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">output</code>状态将存储并显示来自服务器的响应。</p><p id="b5ae" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">message.js</code>中使用了以下方法:</p><ul class=""><li id="dd50" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><code class="eh no np nq ms b">onChange</code>根据输入的输入设置<code class="eh no np nq ms b">message</code>状态</li><li id="3659" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">onsubmitcompile</code>向<code class="eh no np nq ms b">localhost:4000/compile</code>发送请求以编译智能合同</li><li id="86dc" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">onsubmitdeploy</code>向<code class="eh no np nq ms b">localhost:4000/deploy</code>发送部署智能合同的请求</li><li id="b06a" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">onsubmitsetmsg</code>向<code class="eh no np nq ms b">localhost:4000/</code>发送请求，将<code class="eh no np nq ms b">message</code>州作为参数，将消息设置到智能合约</li><li id="5eab" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">onsubmitgetmsg</code>向<code class="eh no np nq ms b">localhost:4000/</code>发送请求，以从智能合同中获取消息</li></ul><h2 id="518b" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">App.js</h2><p id="8166" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">从<code class="eh no np nq ms b">src</code>文件夹中打开<code class="eh no np nq ms b">App.js</code>并粘贴以下代码。应用程序的<code class="eh no np nq ms b">Route</code>设置为<code class="eh no np nq ms b">/</code>。在这条航线上，它将服务于<code class="eh no np nq ms b">message.js</code>组件。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div></figure><p id="092c" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">创建路线时使用了<code class="eh no np nq ms b">react-router-dom</code>库。</p><p id="6e7f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从<code class="eh no np nq ms b">client</code>目录打开终端，运行以下命令:</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="e772" class="mw lp hu ms b fv mx my l mz na">npm install react-router-dom --save</span></pre><h2 id="24fe" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">Dockerfile 文件</h2><p id="3c3a" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">有了这个 docker 文件，我们的客户端模块就完成了。</p><p id="7e23" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在这个 Dockerfile 文件中，我们将编写创建 react 应用程序映像的指令。</p><p id="f458" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<code class="eh no np nq ms b">client</code>目录下创建一个<code class="eh no np nq ms b">Dockerfile</code>并粘贴下面的代码。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Dockerfile</figcaption></figure><p id="38f2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所有命令都是不言自明的。根据这个 docker 文件，将构建一个 docker 映像。客户端(react-app)将使用这个映像在容器内部运行。</p><p id="cba7" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><code class="eh no np nq ms b">COPY</code>命令也在复制<code class="eh no np nq ms b">node_modules</code>。创造一个<code class="eh no np nq ms b">.dockerignore</code>。</p><p id="1207" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">。dockerignore </strong></p><p id="5f75" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在客户端目录下创建一个<code class="eh no np nq ms b">.dockerignore</code>文件，并粘贴下面的代码。</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="960f" class="mw lp hu ms b fv mx my l mz na">node_modules/</span></pre><p id="de70" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们的客户端模块也完成了。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><p id="fdc1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一切都准备好了。现在，我们要做的最后一件事是，构建这些 docker 映像，并将它们作为单独的容器运行。</p><h2 id="59b7" class="mw lp hu bd lq nb nc nd lu ne nf ng ly jr nh ni mc jv nj nk mg jz nl nm mk nn dt translated">docker-compose.yml</h2><p id="9fcb" class="pw-post-body-paragraph jg jh hu ji b jj mm jl jm jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd hn dt translated">在根项目目录中创建一个<code class="eh no np nq ms b">docker-compose.yml</code>,并粘贴下面的代码。</p><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="nr ns l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">docker-compose.yml</figcaption></figure><p id="df61" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可能会想为什么我们甚至需要<code class="eh no np nq ms b">docker-compose.yml</code>。</p><p id="552b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它只是让应用程序有点流畅。怎么会？</p><blockquote class="lh li lj"><p id="8e82" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">Compose 是一个定义和运行多容器 Docker 应用程序的工具。</p></blockquote><p id="7acd" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们为应用程序的 3 个模块创建了 3 个 Dockerfile。如果我们不使用<code class="eh no np nq ms b">docker-compose.yml</code>，那么我们必须分别构建 3 个图像，然后在 3 个不同的终端中分别运行它们。所以，这是一个拖累。</p><p id="ba8f" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">在<code class="eh no np nq ms b">docker-compose.yml</code>中，我们可以定义所有容器的配置，并且都可以用一个命令运行。</p><ul class=""><li id="34ec" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><code class="eh no np nq ms b">version</code>docker 编写文件的版本</li><li id="3a4b" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">services</code>所有容器的定义。</li></ul><p id="659d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">有 3 个服务/容器:</p><p id="f22d" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 1。加纳切</strong></p><ul class=""><li id="75cf" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><code class="eh no np nq ms b">ganache</code>是容器的名称</li><li id="3a34" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">build</code>在哪里找到要构建的 Dockerfile 文件。如果我们不给出 Dockerfile 的名称，那么默认情况下它会构建<code class="eh no np nq ms b">Dockerfile</code>。对于<code class="eh no np nq ms b">ganache</code>，我们已经创建了<code class="eh no np nq ms b">Dockerfile.ganache</code>。它的语法会有一点不同。<code class="eh no np nq ms b">build</code>下有<code class="eh no np nq ms b">context</code>是<code class="eh no np nq ms b">Dockerfile</code>的<code class="eh no np nq ms b">Dockerfile</code>和<code class="eh no np nq ms b">dockerfile</code>名称的路径。</li><li id="db66" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated">容器是与外界隔离的，这意味着无论我们试图从容器外部发出什么请求，它都不会响应。这就是为什么我们设置了<code class="eh no np nq ms b">ports</code>，它将外部的端口映射到容器的端口。在这里，我们将端口<code class="eh no np nq ms b">8545</code>映射到<code class="eh no np nq ms b">8545</code>，如果我们从外部向<code class="eh no np nq ms b">8545</code>发出任何请求，它会在<code class="eh no np nq ms b">8545</code>将请求发送到容器。</li></ul><p id="d59e" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 2。dapp </strong></p><ul class=""><li id="f58f" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><code class="eh no np nq ms b">dapp</code>是容器的名称。</li><li id="8da1" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">build</code>在当前目录<code class="eh no np nq ms b">.</code>中找到<code class="eh no np nq ms b">Dockerfile</code></li><li id="97ef" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">ports</code>映射<code class="eh no np nq ms b">4000:4000</code>处的端口</li><li id="ff7e" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">depends_on</code>开始后<code class="eh no np nq ms b">ganache</code></li></ul><p id="e1f1" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> 3。做出反应</strong></p><ul class=""><li id="a187" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><code class="eh no np nq ms b">react</code>是容器的名称</li><li id="d04b" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">build</code>在<code class="eh no np nq ms b">client</code>目录中找到<code class="eh no np nq ms b">Dockerfile</code></li><li id="66fd" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">ports</code>在<code class="eh no np nq ms b">3000:3000</code>映射端口</li><li id="195d" class="ko kp hu ji b jj kx jn ky jr kz jv la jz lb kd ny ku kv kw dt translated"><code class="eh no np nq ms b">depends_on</code>开始后<code class="eh no np nq ms b">dapp</code></li></ul><p id="14dc" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">要了解更多关于<code class="eh no np nq ms b">docker-compose.yml</code>的信息，请点击此<a class="ae ke" href="https://docs.docker.com/compose/overview/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><p id="2a5b" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">所以，最难的部分已经过去了。现在，有趣的部分让我们运行应用程序。</p><p id="f1b2" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">从根项目目录打开终端，并运行以下命令:</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="3be1" class="mw lp hu ms b fv mx my l mz na">docker-compose up --build</span></pre><p id="0de4" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它将在当前目录中检查并运行<code class="eh no np nq ms b">docker-compose.yml</code>文件。第一次，需要一些时间，所以要有耐心。</p><p id="e317" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦一切运行完毕，打开浏览器并进入<code class="eh no np nq ms b">localhost:3000</code>，你会看到 react 应用程序正在运行。</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oa"><img src="../Images/de3565c78692786cc3e4e63ee41ff3e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEHsQxYq43Mj0rgOh40i-Q.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">localhost:3000</figcaption></figure><ul class=""><li id="4334" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><strong class="ji hv">编译合同:</strong>您将看到编译成功的消息。</li></ul><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ob"><img src="../Images/cbff7155009c8ba52c180dafb40aacb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6F6jsNZMzP9Jg6CE03B8mA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">compile contract</figcaption></figure><ul class=""><li id="ad83" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><strong class="ji hv">部署契约:</strong>它会发回它被部署的契约的地址。</li></ul><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oc"><img src="../Images/9f36ff58763c181b15240c28c2f7ffc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsroPl4BSeFoGF6Q7FZNjg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">deploy contract</figcaption></figure><p id="f397" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="lk">注意:</em> </strong> <em class="lk"> </em> <strong class="ji hv"> <em class="lk">编译或部署命令后，在运行任何其他命令前等待几秒钟，因为这两个命令都将重新启动服务器。为什么？</em>T44】</strong></p><p id="0e80" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="lk">在编译时，它会将编译好的契约保存在 build 中，如果服务器没有重启，那么它将使用最后编译好的契约来部署契约。</em>T48】</strong></p><p id="4a32" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv"> <em class="lk">部署时，保存保存有部署合同地址的回执，如果服务器没有重启，将会与上次部署的合同进行交互，因为服务器仍然使用上次部署的合同地址。</em> </strong></p><ul class=""><li id="9504" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><strong class="ji hv">获取消息:</strong>如果你记得我们将初始消息设置为<code class="eh no np nq ms b">Hello World!</code></li></ul><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff od"><img src="../Images/a598d23d8911ef0310e9e6beded7492b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqtF-Z_kafiJLkwdSAnY0A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Hello World!</figcaption></figure><ul class=""><li id="f523" class="ko kp hu ji b jj jk jn jo jr kq jv kr jz ks kd ny ku kv kw dt translated"><strong class="ji hv">设置消息:</strong>设置消息，返回该交易的交易哈希。我将消息设置为<strong class="ji hv">“Docker ether eum Dapp”</strong><strong class="ji hv"><em class="lk">“0x 464385 a 1914 b 0d 8 FFB 48d 660 aa 55d 419 f 0 AFE 040 e 0 def 20 ff 581338 bbce 545 e 2”</em></strong>为事务哈希。</li></ul><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff oe"><img src="../Images/9eebf475425ee078a1d4df467ba5b9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5WFDCqRrRmWAzk3gUFqCg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Set Message</figcaption></figure><p id="b635" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">使用“获取消息”检查消息</p><figure class="ld le lf lg fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff of"><img src="../Images/a821378b890cd97c35b488acb50e7577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n3uBnySxPJ80pRiDLCydLA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Get Message</figcaption></figure><p id="ed74" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我们用 React 和 Docker 成功创建了以太坊 Dapp。</p><p id="d0c5" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你不必每次都构建<code class="eh no np nq ms b">docker-compose.yml</code>。下次你只需运行下面的命令来运行应用程序。</p><pre class="ld le lf lg fq mr ms mt mu aw mv dt"><span id="9eea" class="mw lp hu ms b fv mx my l mz na">docker-compose up</span></pre><p id="2e44" class="pw-post-body-paragraph jg jh hu ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">你可以从<a class="ae ke" href="https://github.com/schadokar/docker-ethereum.git" rel="noopener ugc nofollow" target="_blank"> GitHub 链接</a>中克隆完整的项目。</p><blockquote class="lh li lj"><p id="aed1" class="jg jh lk ji b jj jk jl jm jn jo jp jq ll js jt ju lm jw jx jy ln ka kb kc kd hn dt translated">希望你喜欢这个教程。请评论文章中的任何改进。如果你学到了有趣的东西，请鼓掌分享。</p></blockquote><figure class="ld le lf lg fq iv"><div class="bz el l di"><div class="og ns l"/></div></figure></div></div>    
</body>
</html>