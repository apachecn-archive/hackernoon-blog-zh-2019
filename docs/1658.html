<html>
<head>
<title>Why React Hooks? A developer’s perspective.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么要反应钩子？一个开发者的视角。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/why-react-hooks-a-developers-perspective-2aedb8511f38?source=collection_archive---------6-----------------------#2019-03-11">https://medium.com/hackernoon/why-react-hooks-a-developers-perspective-2aedb8511f38?source=collection_archive---------6-----------------------#2019-03-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/bdb0d16fa3d5c917992666b702914f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kVELhLDKiT0DDPHQ"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@ckirby?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cameron Kirby</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="jh ji jj"><p id="0f5f" class="jk jl jm jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki hn dt translated"><em class="hu">钩子</em>是React 16.8中新增的。它们允许您使用状态和其他React特性，而无需编写类。—反应文档</p></blockquote><p id="fbdb" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">从React版本≤ 16.7开始，如果某个组件需要状态和/或对生命周期方法的访问，它必须作为类组件构建，因为功能组件没有<code class="eh km kn ko kp b">instances</code>的概念。</p><p id="089c" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">但是有了React 16.8，我们就有了钩子。这并不意味着类不能工作，也不意味着类会被弃用。<a class="ae jg" href="https://reactjs.org/docs/hooks-faq.html#do-hooks-cover-all-use-cases-for-classes" rel="noopener ugc nofollow" target="_blank">钩子也没有解决类的所有特性</a>，有一些拼图缺失了，但是React核心团队说这些将很快被解决。</p></div><div class="ab cl kq kr hc ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hn ho hp hq hr"><h1 id="a1d0" class="kx ky hu bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">钩子背后的动机</h1><p id="1d83" class="pw-post-body-paragraph jk jl hu jn b jo lv jq jr js lw ju jv kj lx jy jz kk ly kc kd kl lz kg kh ki hn dt translated">在当前的it世界中，学习和理解一个新的范例而不从中获得显著的好处是非常困难的。</p><p id="e894" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">阅读React文档的<a class="ae jg" href="https://reactjs.org/docs/hooks-intro.html#motivation" rel="noopener ugc nofollow" target="_blank">动机部分</a>并没有给我提供转型所需的动力。所以我给自己做了一个PoC(概念验证)。我将通过我的概念证明中的伪代码来检查动机文档中提到的3点。</p><p id="2931" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我们的PoC将是一个Facebooks feed组件。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ma"><img src="../Images/206257ec6d4452d57762a455060763e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xAL0S5zpPeYVTnBT.jpg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Sample Facebook feed mockup — <a class="ae jg" href="https://www.behance.net/gallery/64942921/FREE-Facebook-PSD-Post-Mockup-2018" rel="noopener ugc nofollow" target="_blank">https://www.behance.net/gallery/64942921/FREE-Facebook-PSD-Post-Mockup-2018</a></figcaption></figure><p id="53ca" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">为了节省时间，让我们降低对组件的要求。它应该能够喜欢饲料，如果有人点击它，并能够评论时，有人在评论框中输入和点击回车。让我们现在不要担心类似的类型和共享功能。</p><p id="1fa5" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我们需要这个组件的内部状态。对模型的初步观察表明，我们将需要一个状态变量:</p><ol class=""><li id="2ae5" class="mf mg hu jn b jo jp js jt kj mh kk mi kl mj ki mk ml mm mn dt translated">要知道提要是否已经被自己喜欢了。(<code class="eh km kn ko kp b">likedByMySelf</code>)</li><li id="3c2d" class="mf mg hu jn b jo mo js mp kj mq kk mr kl ms ki mk ml mm mn dt translated">来维持点赞数。(<code class="eh km kn ko kp b">likes</code>)</li><li id="74fc" class="mf mg hu jn b jo mo js mp kj mq kk mr kl ms ki mk ml mm mn dt translated">维护评论。(<code class="eh km kn ko kp b">comments</code>)</li></ol><h1 id="e59b" class="kx ky hu bd kz la mt lc ld le mu lg lh li mv lk ll lm mw lo lp lq mx ls lt lu dt translated">很难在组件之间重用有状态逻辑。</h1><p id="bb4b" class="pw-post-body-paragraph jk jl hu jn b jo lv jq jr js lw ju jv kj lx jy jz kk ly kc kd kl lz kg kh ki hn dt translated">假设这些是我们的需求:</p><p id="8449" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">当用户点击like按钮时，如果<code class="eh km kn ko kp b">likedByMySelf</code>为<code class="eh km kn ko kp b">false</code>则<code class="eh km kn ko kp b">likes</code>应增加1，如果<code class="eh km kn ko kp b">likedByMySelf</code>为<code class="eh km kn ko kp b">true</code>则减少1，然后切换<code class="eh km kn ko kp b">likedByMySelf</code>的值。</p><p id="4b75" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">当用户点击评论按钮时，评论输入框应该高亮显示。</p><p id="f1eb" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">在输入一些东西后，如果用户点击enter，一个注释将被添加到<code class="eh km kn ko kp b">comments</code>状态，输入框将被清空。</p><p id="2eb2" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">通常对于类，我们将在类中编写动作处理程序作为实例方法，因为它们需要访问内部状态。</p><p id="47b8" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">例如:</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff my"><img src="../Images/8ccdf51b6a1388c15a6a9f581c12d854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoIHHrM6UPehpoubUrgs6Q.png"/></div></div></figure><p id="a99a" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">两天后，如果有一个新的需求，要在注释中添加像一样的<em class="jm">功能，我们将无法重用onLike处理程序，因为它与Feed组件及其状态相关联。为了在类中解决这样的问题，我们可以使用hoc(高阶组件),分别实现like和comment，并用这些hoc包装Feed组件。使用hoc，我们将无关的状态逻辑分离成不同的功能，并将它们作为道具注入到主组件中。</em></p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mz"><img src="../Images/64e6fff7a48a9f866b1d629ffca772f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9FIl2D0gmponpBRxw9s_w.png"/></div></div></figure><p id="1268" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">但是hoc制造了包装地狱。我们将呈现3个组件，其中2个是包装器组件，而不是只呈现提要组件。在React dev工具中进行检查时可以看到这一点。</p><p id="d68b" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">有了钩子，我们可以像HOCs一样解决这个问题，但没有包装地狱。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff na"><img src="../Images/bbd82c3d1d1d526dc240e7d46ac73dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4NuFEZWHcfPHV_f487GRA.png"/></div></div></figure><p id="0cf7" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><code class="eh km kn ko kp b">useLikes</code>和<code class="eh km kn ko kp b">useComments</code>拥有HOCs同样的优势，而且它们没有引入包装器地狱。</p><h2 id="ba6d" class="nb ky hu bd kz nc nd ne ld nf ng nh lh kj ni nj ll kk nk nl lp kl nm nn lt no dt translated"><a class="ae jg" href="https://reactjs.org/docs/hooks-intro.html#complex-components-become-hard-to-understand" rel="noopener ugc nofollow" target="_blank"> 2。复杂组件变得难以理解</a>。</h2><p id="9856" class="pw-post-body-paragraph jk jl hu jn b jo lv jq jr js lw ju jv kj lx jy jz kk ly kc kd kl lz kg kh ki hn dt translated">对于类，没有办法组成生命周期挂钩。例如，如果我们必须在Feed组件mount上进行网络调用，以获得要呈现的赞和评论。</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff np"><img src="../Images/8b83dc874b410ae034f392d380e78d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uwUbYcjba11BTrlVohkEKQ.png"/></div></div></figure><p id="e13e" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">很快,<code class="eh km kn ko kp b">componentDidMount</code>的逻辑会变得复杂，对于将来读到这篇文章的人来说，这会让他们一阵子不寒而栗。</p><p id="eeac" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">Hooks用一种漂亮的方式解决了这个问题。钩子支持同一类型的多个生命周期钩子。例如:</p><figure class="mb mc md me fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nq"><img src="../Images/d448519146be682b52313276888640ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GBpFFdgaaVihx7R1ZQidLg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><a class="ae jg" href="https://gist.github.com/revanth0212/1a4c949a70a98aae3cb7f0ed5775692c" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/revanth0212/1a4c949a70a98aae3cb7f0ed5775692c</a></figcaption></figure><p id="8956" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jn hv">第4行和第19行</strong>是钩子中的<code class="eh km kn ko kp b">componentDidMount</code>生命周期方法。如果我们以<code class="eh km kn ko kp b">useLikes</code>为例，它有状态和<code class="eh km kn ko kp b">componentDidMount</code>生命周期挂钩。在装载时，它将进行网络调用并立即返回当前状态。以后一旦网络调用解决，状态更新，<code class="eh km kn ko kp b">likes</code>也会改变。这将触发任何使用<code class="eh km kn ko kp b">useLikes</code>钩子的组件的重新渲染。</p><p id="54e4" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated"><strong class="jn hv">第29行和第30行</strong>展示了生命周期钩子与钩子的可组合性特征。所以现在，我们可以将生命周期挂钩写入自定义挂钩，让它们在本地维护状态，而不用担心挂载、更新和卸载逻辑。这使得代码可维护性成为一种愿望，而不是地狱。</p><h2 id="1170" class="nb ky hu bd kz nc nd ne ld nf ng nh lh kj ni nj ll kk nk nl lp kl nm nn lt no dt translated"><a class="ae jg" href="https://reactjs.org/docs/hooks-intro.html#classes-confuse-both-people-and-machines" rel="noopener ugc nofollow" target="_blank"> 3。类混淆了人和机器。</a></h2><p id="27df" class="pw-post-body-paragraph jk jl hu jn b jo lv jq jr js lw ju jv kj lx jy jz kk ly kc kd kl lz kg kh ki hn dt translated">嗯，我不接受上课会把人搞糊涂的前提。他们不应该。我们是开发者，理解语言提供的原语是我们的职责。</p><p id="58f4" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">另一方面，机器确实会混淆函数和类。例如，缩小器/取消器很难处理类。</p><p id="4851" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">此外，根据文档，React团队一直在试验提前编译和拥有组件折叠等特性，但已经意识到类组件可能会鼓励无意的模式，使这些优化退回到更慢的路径。</p><p id="4887" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我个人对课程没有怨恨，也不能过多评论第三个动机。但是如果你们有什么想法，请随意评论，让我们知道。</p></div><div class="ab cl kq kr hc ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="hn ho hp hq hr"><p id="7c29" class="pw-post-body-paragraph jk jl hu jn b jo jp jq jr js jt ju jv kj jx jy jz kk kb kc kd kl kf kg kh ki hn dt translated">我希望这篇文章能够令人信服地说明钩子在React中的优势。让我们知道你是否在使用钩子，你最喜欢的特性是什么。</p></div></div>    
</body>
</html>