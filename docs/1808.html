<html>
<head>
<title>Container Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器驱动开发</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/container-driven-development-1bd08c2f126d?source=collection_archive---------5-----------------------#2019-03-17">https://medium.com/hackernoon/container-driven-development-1bd08c2f126d?source=collection_archive---------5-----------------------#2019-03-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/2a44418cb1f4ed494714769de6b6fdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*To_NXcpHcDR7lIlJ"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/@nitram509?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin W. Kirst</a> on <a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d21e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章的目的是介绍一个开发和测试软件的工作流程，它与容器化的环境紧密相关。我喜欢称这个工作流为<strong class="jj hv">容器驱动开发</strong>。容器驱动开发背后的核心思想是从应用程序开发周期的一开始就在容器化的环境中编写、执行和测试每一行代码。</p><p id="12ee" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通常，我们首先编写和测试我们的应用程序，然后在发货或部署之前对它们进行容器化。对于我们大多数人来说，我们的应用程序第一次真正在容器中运行是在生产中。这并不理想，因为它会导致容器化的问题在开发周期中被发现得太晚。</p><p id="b7ea" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">另一种方法是从应用程序开发过程的一开始就引入容器。这样做的最大好处是，它使我们能够在一个看起来和行为完全像我们的生产环境的环境中开发和测试我们的应用程序。</p><p id="b7b9" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这篇文章的剩余部分使用一个玩具应用程序来演示我通常是如何进行容器驱动开发的。因为我大部分时间都在用python开发，所以这篇文章是专门针对基于python的工作流的。如何对其他编程语言采用类似的方法。</p><h2 id="6b9b" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated"><strong class="ak">项目设置</strong></h2><p id="d682" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">下面是我在名为<code class="eh lf lg lh li b">myapp</code>的python应用上进行容器驱动开发的典型目录结构。这个目录中最重要的文件是<em class="lj"> docker-compose.yml </em>和<em class="lj">docker文件。</em>我们将详细了解每一项的内容。</p><pre class="lk ll lm ln fq lo li lp lq aw lr dt"><span id="01dc" class="kf kg hu li b fv ls lt l lu lv">myapp<br/>├── Dockerfile<br/>├── docker-compose.yml<br/>├── myapp<br/>│   ├── __init__.py<br/>│   └── main.py<br/>├── requirements.txt<br/>└── tests<br/>    ├── __init__.py<br/>    └── test_main.py</span></pre><h2 id="c510" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">Docker撰写</h2><p id="bc04" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我很少需要编写独立的应用程序。我编写的大多数应用程序都依赖于其他系统——其中最普遍的是SQL数据库。随着docker的出现，我很少发现自己在安装软件。相反，我尽可能地使用各自的docker容器。Docker Compose是一个管理多容器应用程序的好工具，我经常使用它。我为应用程序编写的典型docker-compose文件(在本例中为<code class="eh lf lg lh li b">myapp</code>)如下所示:</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="e867" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">docker-compose文件中的<code class="eh lf lg lh li b">services</code>节点是最重要的。在这里，我描述了我的应用程序(<code class="eh lf lg lh li b">myapp</code>)及其依赖项的构建配置。</p><p id="2b67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">docker-compose文件中的第一个服务节点是<code class="eh lf lg lh li b">myapp</code>。您可能已经猜到，这是与正在构建的应用程序相对应的服务定义</p><p id="5046" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lf lg lh li b">myapp</code>节点有四个感兴趣的子节点:<code class="eh lf lg lh li b">build</code>、<code class="eh lf lg lh li b">image</code>、<code class="eh lf lg lh li b">depends_on</code>和<code class="eh lf lg lh li b">volumes</code>。</p><p id="7a06" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lf lg lh li b">build</code>节点定义了构建配置。作为这个配置的一部分，我提供了一个名为<code class="eh lf lg lh li b">app_name</code>的构建时参数。我们马上会看到这个参数是如何在<code class="eh lf lg lh li b">Dockerfile</code>中使用的。最后，我已经将build <code class="eh lf lg lh li b">context</code>指定为当前目录。<code class="eh lf lg lh li b">context</code>只是表示相对于docker-compose文件要构建的服务的<code class="eh lf lg lh li b">Dockerfile</code>的位置。</p><p id="c5dd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lf lg lh li b">image</code>节点配置正在构建的服务的命名。在这种情况下，我将名称定义为形式<code class="eh lf lg lh li b">myapp:${TAG}</code>。<code class="eh lf lg lh li b">TAG</code>是一个将在构建时定义的环境变量。</p><p id="2e91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><code class="eh lf lg lh li b">depends_on</code>节点定义上游服务依赖关系。作为该节点一部分列出的服务必须在<code class="eh lf lg lh li b">docker-compose</code>文件中定义。<code class="eh lf lg lh li b">depends_on</code>配置确保依赖服务在应用服务启动之前被拉入并启动。</p><p id="1155" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后，<code class="eh lf lg lh li b">volumes</code>节点确保源代码目录被挂载到应用程序容器中的适当位置。在这种情况下，<code class="eh lf lg lh li b">myapp</code>的源代码目录被挂载到应用程序容器内的<code class="eh lf lg lh li b">/myapp</code>目录。将源代码目录安装到应用程序容器中是非常重要的，因为它使我能够在容器中编辑、运行和测试我的代码，而不是每次编辑时都将源文件复制到容器中。</p><p id="0120" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">除了<code class="eh lf lg lh li b">myapp </code>服务，docker-compose文件还包括<code class="eh lf lg lh li b">redis</code>和<code class="eh lf lg lh li b">postgres</code>的服务节点。因为我们自己并不是从头开始构建这些服务，所以所需要的只是我们需要的每个服务的图像名称和标签。在运行期间，将从<a class="ae jg" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Dockerhub </a>下拉相应的图像和标签。</p><h2 id="70e1" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">Dockerfile文件</h2><p id="ed32" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">我的Dockerfiles通常相当简单，除非我在处理一些更深奥的东西:</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure><p id="0ea3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在上面的docker文件中，我只是拉下一个基本的python映像，将源代码目录添加到容器中，并安装相关的python包。注意<code class="eh lf lg lh li b">Dockerfile</code>中的<code class="eh lf lg lh li b">ARG app_name</code>语句。这基本上声明了一个构建时参数，我们在上面的docker-compose文件中设置了它的值，即<code class="eh lf lg lh li b">app_name: myapp</code>。入口点<code class="eh lf lg lh li b">CMD</code>将根据应用程序的类型而变化，但通常它类似于上面Dockerfile中显示的内容。</p><h2 id="cf14" class="kf kg hu bd kh ki kj kk kl km kn ko kp js kq kr ks jw kt ku kv ka kw kx ky kz dt translated">工作流程</h2><p id="3985" class="pw-post-body-paragraph jh ji hu jj b jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka le kc kd ke hn dt translated">一旦<code class="eh lf lg lh li b">docker-compose</code>和<code class="eh lf lg lh li b">Dockerfile</code>被设置好，从这里开始的工作流程非常简单，只需要几个命令就可以了。</p><p id="bb4b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对我来说，起点是在我的应用程序docker容器中获得一个终端外壳。这可以通过简单的docker-compose命令来完成:</p><pre class="lk ll lm ln fq lo li lp lq aw lr dt"><span id="c26f" class="kf kg hu li b fv ls lt l lu lv">TAG=development docker-compose run myapp bash</span></pre><p id="d421" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的命令做了几件事。它下拉(如果还没有)并启动应用程序的上游依赖项(在本例中是<code class="eh lf lg lh li b">redis</code>和<code class="eh lf lg lh li b">postgres</code>容器)。它构建应用程序容器<code class="eh lf lg lh li b">myapp</code>并用关键字<code class="eh lf lg lh li b">development</code>标记它。它在<code class="eh lf lg lh li b">redis</code>、<code class="eh lf lg lh li b">postgres</code>和应用程序容器<code class="eh lf lg lh li b">myapp</code>之间创建一个桥接网络，并在<code class="eh lf lg lh li b">myapp</code>容器中打开一个shell提示符。从现在开始，我可以像在任何其他终端shell中一样在这个shell中编写和执行代码。唯一的区别是，这个shell是在一个隔离的docker容器中执行的，其中安装了我的所有源代码及其各自的依赖项。多酷啊！</p><p id="d5d7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我在VI / TMUX环境中开发代码。下面是我的开发环境在这个工作流程中的简单截图。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="ly lx l"/></div></figure><p id="c3a5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在截屏中，顶部窗格显示了我的VI文本编辑器，其中加载了源代码。底部窗格有一个在<code class="eh lf lg lh li b">myapp</code>容器内运行的终端外壳。我可以简单地在文本编辑器中编辑代码，并在容器中执行它。生活真好:)</p><p id="684b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有时，我会通过<code class="eh lf lg lh li b">docker-compose</code>为所有测试或测试子集直接执行测试运行程序，而不是在应用程序容器中获取终端外壳，然后执行测试运行程序:</p><pre class="lk ll lm ln fq lo li lp lq aw lr dt"><span id="555c" class="kf kg hu li b fv ls lt l lu lv">TAG=development docker-compose run myapp pytest tests/test_main.py</span></pre><p id="0940" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">上面的命令简单地启动应用docker容器(以及相关的容器依赖项，如果还没有运行的话)，在容器内执行测试运行器命令<code class="eh lf lg lh li b">pytest tests/test_main.py</code>并退出。下面是一个简短的截屏，展示了它的实际效果:</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="ly lx l"/></div></figure></div><div class="ab cl lz ma hc mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hn ho hp hq hr"><p id="9a1a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">总之，我认为从应用程序开发环境的最开始就在容器内部开发有几个优点。最显著的是在类似运行时环境的生产环境中编写和测试代码的能力。这可以防止容器化的错误和问题在游戏后期被发现。</p><p id="f960" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">希望这篇文章中展示的工作流能让容器成为开发生命周期的重要组成部分变得更容易。</p><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="mg lx l"/></div></figure></div></div>    
</body>
</html>