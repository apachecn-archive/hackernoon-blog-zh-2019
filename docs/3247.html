<html>
<head>
<title>Swift Weak vs Unowned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift弱vs无主</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/swift-weak-vs-unowned-by-examples-ffcc7c25ecc8?source=collection_archive---------0-----------------------#2019-05-23">https://medium.com/hackernoon/swift-weak-vs-unowned-by-examples-ffcc7c25ecc8?source=collection_archive---------0-----------------------#2019-05-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="9ab6" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">什么时候用弱，什么时候用无主，举例说明。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/1c82fed63349431532144f5f0c1f3f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6VUYaIQqOjUicOtyAyd8Q.jpeg"/></div></div></figure><h2 id="eb2a" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">问题</h2><p id="072f" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">在<a class="ae lm" href="https://hackernoon.com/swift-avoiding-memory-leaks-by-examples-f901883d96e5" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中，我们讨论了如何使用自动引用计数(ARC)来管理iOS应用程序中的内存使用。然而，在某些情况下，由于保留周期，ARC不能从内存中释放对象。</p><p id="ce4d" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">Retain Cycle是这样的情况，当两个对象相互强烈引用并被保留时，使得ARC无法从内存中释放这些对象，并导致我们所说的“内存泄漏”。</p><h2 id="08a1" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">解决办法</h2><p id="7500" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">默认情况下，每当我们声明一个变量时，它都被认为是“强”，为了避免保留循环，我们应该将这些变量声明为“弱”或“无主的”。本文主要关注的不是处理内存管理，如果您不熟悉该主题，请阅读<a class="ae lm" href="https://hackernoon.com/swift-avoiding-memory-leaks-by-examples-f901883d96e5" rel="noopener ugc nofollow" target="_blank">上一篇文章。</a></p><p id="ef91" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">我们的重点将放在何时使用weak以及何时使用unowned by real-world示例更好。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h1 id="5d0c" class="lz jw hu bd jx ma mb mc kb md me mf kf ja mg jb kj jd mh je kn jg mi jh kr mj dt translated">弱小与无主</h1><p id="b387" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated"><a class="ae lm" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank">根据苹果的文档:</a></p><blockquote class="mk ml mm"><p id="b86d" class="kt ku mn kv b kw ln iv ky kz lo iy lb mo lp ld le mp lq lg lh mq lr lj lk ll hn dt translated">当闭包和它捕获的实例总是相互引用，并且总是同时被释放时，将闭包中的捕获定义为无主引用。</p><p id="44e5" class="kt ku mn kv b kw ln iv ky kz lo iy lb mo lp ld le mp lq lg lh mq lr lj lk ll hn dt translated">相反，当捕获的引用可能在将来的某个时刻变成<code class="eh mr ms mt mu b">nil</code>时，将捕获定义为弱引用。弱引用总是可选类型，当它们引用的实例被释放时，会自动变成<code class="eh mr ms mt mu b">nil</code>。这使您能够检查它们在闭包体内的存在。</p></blockquote><p id="2b1f" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">虚弱和无主的主要区别在于<code class="eh mr ms mt mu b">weak</code>是可选的，而<code class="eh mr ms mt mu b">unowned</code>是非可选的。<br/>通过声明它<code class="eh mr ms mt mu b">weak</code>，你可以处理这样的情况:在闭包里，它可能在某个时刻为零。如果你试图访问一个碰巧为零的<code class="eh mr ms mt mu b">unowned</code>变量，将会使整个程序崩溃。所以只有当你确信当闭包在附近的时候变量总是在附近的时候，才使用<code class="eh mr ms mt mu b">unowned</code>。</p><h2 id="bc86" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated"><strong class="ak">无主</strong></h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mv"><img src="../Images/0efe9d1a32c99fe2e88e7a48c134ebef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOKexWxKDY5dXmjE_Tna9w.png"/></div></div></figure><p id="32e2" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">你可能之前已经听过很多了，但是当你真的应该确信当闭包在附近时变量总是在附近，所以你可以毫无顾虑地使用<code class="eh mr ms mt mu b">unowned</code>？<br/>让我们看看下面的例子:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="dcd2" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">在上面的例子中，闭包不可能比ViewController活得更长，在这种情况下，您可以放心地使用<code class="eh mr ms mt mu b">unowned</code>。</p><h2 id="d622" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated"><strong class="ak">弱</strong></h2><p id="2b62" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">现在在下面的例子中，让我们看看什么时候应该使用<code class="eh mr ms mt mu b">weak</code>来避免崩溃:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mw mx l"/></div></figure><p id="d9f4" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">在上面的例子中，你永远不能确定ViewController会比closure活得更久，因为网络调用响应可能在关闭控制器后发生，所以你应该明确地使用<code class="eh mr ms mt mu b">weak</code>作为一个选项来避免崩溃。</p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><p id="5296" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">如果我们可以在所有情况下使用<code class="eh mr ms mt mu b">weak</code>，那么为什么要使用<code class="eh mr ms mt mu b">unowned</code>并冒着应用崩溃的风险呢？根据苹果公司的说法，答案很简单:</p><blockquote class="mk ml mm"><p id="1fc6" class="kt ku mn kv b kw ln iv ky kz lo iy lb mo lp ld le mp lq lg lh mq lr lj lk ll hn dt translated">如果捕获的引用永远不会变成<code class="eh mr ms mt mu b">nil</code>，那么它应该总是被捕获为一个无主引用，而不是一个弱引用。</p></blockquote><p id="2723" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">Unowned速度更快，并且允许不变性和非可选性。</p><p id="1962" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated"><strong class="kv hv">不需要弱的就不要用。</strong></p></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><h2 id="325f" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">结论</h2><p id="d812" class="pw-post-body-paragraph kt ku hu kv b kw kx iv ky kz la iy lb kg lc ld le kk lf lg lh ko li lj lk ll hn dt translated">为了避免内存泄漏，我们应该将变量声明为弱变量或无主变量，而不是默认的强变量实现。<br/>然而，它们之间的关键区别在于，weak是一个可选类型，而unowned不是，所以我们应该只在100%确定闭包与变量具有相同的生存期时才使用unowned，所以闭包只有在变量可达之前才可达<em class="mn">。</em></p><h2 id="6867" class="jv jw hu bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dt translated">参考</h2><ul class=""><li id="78e8" class="my mz hu kv b kw kx kz la kg na kk nb ko nc ll nd ne nf ng dt translated"><a class="ae lm" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank">苹果的文档</a></li><li id="fde1" class="my mz hu kv b kw nh kz ni kg nj kk nk ko nl ll nd ne nf ng dt translated"><a class="ae lm" href="https://stackoverflow.com/questions/24320347/shall-we-always-use-unowned-self-inside-closure-in-swift" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></li></ul></div><div class="ab cl ls lt hc lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="hn ho hp hq hr"><p id="a596" class="pw-post-body-paragraph kt ku hu kv b kw ln iv ky kz lo iy lb kg lp ld le kk lq lg lh ko lr lj lk ll hn dt translated">阅读我以前的文章，通过例子来避免内存泄漏</p><div class="nm nn fm fo no np"><a href="https://hackernoon.com/swift-avoiding-memory-leaks-by-examples-f901883d96e5" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab ej"><div class="nr ab ns cl cj nt"><h2 class="bd hv fv z el nu eo ep nv er et ht dt translated">Swift:通过示例避免内存泄漏</h2><div class="nw l"><h3 class="bd b fv z el nu eo ep nv er et ek translated">在Swift中，自动引用计数(ARC)用于管理iOS应用程序中的内存使用。每次你创造…</h3></div><div class="nx l"><p class="bd b gc z el nu eo ep nv er et ek translated">hackernoon.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jt np"/></div></div></a></div></div></div>    
</body>
</html>