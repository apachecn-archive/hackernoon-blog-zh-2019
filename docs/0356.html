<html>
<head>
<title>Git Reset 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git重置101</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/reset-101-ba05d9e3f2c7?source=collection_archive---------8-----------------------#2019-01-15">https://medium.com/hackernoon/reset-101-ba05d9e3f2c7?source=collection_archive---------8-----------------------#2019-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ea03fb1a52827152c719d8715feba774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NrGKscjOEwZhaDYwBjdJ8Q.png"/></div></div></figure><p id="1c5f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ka"> Reset可能是最难理解的</em><a class="ae kb" href="https://hackernoon.com/tagged/git" rel="noopener ugc nofollow" target="_blank"><em class="ka">git</em></a><em class="ka">命令之一，此外还有一个危险的坏名声。这两种说法都有一个有效的理由:是的，重置</em> <a class="ae kb" href="https://hackernoon.com/tagged/command" rel="noopener ugc nofollow" target="_blank"> <em class="ka">命令</em> </a> <em class="ka">有点难以理解，在某些情况下，这可能是危险的。但是，这并没有那么难。所以在这篇文章中，我会尽我所能给你一个清晰的，精炼的重置命令教程。为了使它简短而不至于让人不知所措，我抽象出了一些不重要的细节并简化了一些东西，但是如果你想了解更多关于git的内部工作方式，你也可以查看我的</em> <a class="ae kb" href="https://hackernoon.com/https-medium-com-zspajich-understanding-git-data-model-95eb16cc99f5" rel="noopener ugc nofollow" target="_blank"> <em class="ka">理解Git </em> </a> <em class="ka">系列来了解这里介绍的一些东西的更多细节。</em></p><h1 id="56ba" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">Git三</h1><p id="f815" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">在我们深入研究<code class="eh lf lg lh li b">reset</code>命令之前，我们需要看一下git的树:工作目录、暂存区和存储库。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/887c740883a8fd5c421d652704fdf6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8RWblihxXuh6KdUZNZLUw.png"/></div></div></figure><p id="0688" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从git的角度来看，您可以将它们视为可以进行更改的三个领域:</p><ul class=""><li id="b6fc" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">工作目录——文件系统上的项目文件</li><li id="a760" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">临时区域—下一次提交的预览</li><li id="4980" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">repository—git保存所有(过去的)提交的数据存储。</li></ul><p id="44ba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh lf lg lh li b">reset</code>命令对这些三/区域进行操作，但是首先，让我们看看<code class="eh lf lg lh li b">add</code>和<code class="eh lf lg lh li b">commit</code>命令(我们日常使用的)如何影响这些区域。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><p id="25ec" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们有一个web应用程序，我们对我们的<code class="eh lf lg lh li b">index.php</code>文件做了一些重构。我们所做的更改会反映在工作目录中:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/6462603e87db406be20c3dd8f4d88fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fblz1fP3EyO0jI6j3DUnOg.png"/></div></div></figure><p id="f7de" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们可以通过运行<code class="eh lf lg lh li b">git status</code>来确认这一点:</p><pre class="lk ll lm ln fq mj li mk ml aw mm dt"><span id="b699" class="mn kd hu li b fv mo mp l mq mr">Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><span id="df70" class="mn kd hu li b fv ms mp l mq mr">modified:   index.php</span></pre><p id="94c9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们通过使用<code class="eh lf lg lh li b">add</code>命令将这些更改移动到暂存区域:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/43a79fde6a1876090a72f7fd48b1ce28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWxqdbVGazNiR29RpwR6gw.png"/></div></div></figure><p id="8dd8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行<code class="eh lf lg lh li b">status</code>命令会告诉我们:</p><pre class="lk ll lm ln fq mj li mk ml aw mm dt"><span id="a6f9" class="mn kd hu li b fv mo mp l mq mr">Changes to be committed:<br/>  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><span id="dd90" class="mn kd hu li b fv ms mp l mq mr">modified:   index.php</span></pre><p id="9b18" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为<code class="eh lf lg lh li b">status</code>命令看到我们在工作目录和暂存区中有相同版本的<code class="eh lf lg lh li b">index.php</code>文件，但是在存储库中没有。</p><p id="864a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了在那里添加它，我们使用<code class="eh lf lg lh li b">commit</code>命令:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/67c3fcceb7da474f9e4cff34b5ff8715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GJqZGvdTK9tU_-DeaTth4w.png"/></div></div></figure><p id="0a3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在工作目录、暂存区和存储库都包含相同版本的<code class="eh lf lg lh li b">index.php</code>，运行<code class="eh lf lg lh li b">git status</code>会告诉我们有:</p><pre class="lk ll lm ln fq mj li mk ml aw mm dt"><span id="4ff6" class="mn kd hu li b fv mo mp l mq mr">nothing to commit, working tree clean</span></pre><p id="260b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，<code class="eh lf lg lh li b">status</code>命令的工作方式是，它比较工作目录、暂存区和存储库中的文件版本，如果有不同的版本，就要暂存/提交文件。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><p id="84dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">假设我们对<code class="eh lf lg lh li b">index.php</code>文件做了更多的重构，并再次执行整个添加/提交周期。</p><p id="d688" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们的工作目录、暂存区和存储库都将包含我们的<code class="eh lf lg lh li b">index.php</code>文件的新的第二个版本。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/da032cbbd86b8b343f46797047d1cfc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5QSLmd62Gq1UdKNn0yBwg.png"/></div></div></figure><p id="e719" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是第一个版本呢？如果您还记得，我们说过存储库保存所有以前的提交，所以第一个版本的<code class="eh lf lg lh li b">index.php</code>仍然在那里:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/21a9ffb1e272f3e55d63f42e541133c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqXE7BaoE4nKVFRIH4FEiQ.png"/></div></div></figure><p id="89e1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了跟踪<code class="eh lf lg lh li b">index.php</code>文件的哪个版本是当前版本，存储库有一个名为<code class="eh lf lg lh li b">HEAD</code>的特殊指针，它指向当前版本(当与暂存区的版本进行比较时，<code class="eh lf lg lh li b">status</code>命令只查看<code class="eh lf lg lh li b">HEAD</code>指向的当前版本)。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><p id="2051" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们已经了解了这一点，我们终于可以进入我们的<code class="eh lf lg lh li b">reset</code>命令，看看它是如何操作这些git区域(树)的内容的。</p><h1 id="7ce7" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">复位—软</h1><p id="ed4a" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">第一种模式的<code class="eh lf lg lh li b">reset</code>命令只会做一件事:</p><ul class=""><li id="8412" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">移动<code class="eh lf lg lh li b">HEAD</code>指针</li></ul><p id="50d5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我们的例子中，我们将通过运行以下命令将其移动到之前的提交(第一个版本的<code class="eh lf lg lh li b">index.php</code>):</p><pre class="lk ll lm ln fq mj li mk ml aw mm dt"><span id="5351" class="mn kd hu li b fv mo mp l mq mr">git reset --soft HEAD~1</span></pre><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/bc3994ece13abb714bcaef1d5c87263f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RhMdDD1SJ2DaQgNUUdJjA.png"/></div></div></figure><p id="839c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">git的树现在看起来像这样:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/c0fa62971d02dfaea24d28948c783d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VjNBM3xG-_CzI9LY5MXu_Q.png"/></div></div></figure><p id="146a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我们运行<code class="eh lf lg lh li b">git status</code>时，我们会看到一条熟悉的消息:</p><pre class="lk ll lm ln fq mj li mk ml aw mm dt"><span id="310f" class="mn kd hu li b fv mo mp l mq mr">Changes to be committed:<br/>  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><span id="c243" class="mn kd hu li b fv ms mp l mq mr">modified:   index.php</span></pre><p id="8694" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，运行<code class="eh lf lg lh li b">git reset — soft HEAD~1</code>基本上撤销了我们的最后一次提交，但是包含在该提交中的更改并没有丢失——它们在我们的暂存区和工作目录中。</p><h1 id="dcaf" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">重置—混合</h1><p id="6b8f" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">第二种模式的<code class="eh lf lg lh li b">reset</code>命令将做两件事:</p><ul class=""><li id="5a1b" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">移动<code class="eh lf lg lh li b">HEAD</code>指针</li><li id="43cf" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">更新暂存区(使用<code class="eh lf lg lh li b">HEAD</code>指向的内容)</li></ul><p id="d11f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，第一步与<code class="eh lf lg lh li b">--soft</code>模式相同。第二步获取<code class="eh lf lg lh li b">HEAD</code>指向的任何内容(在本例中，它是<code class="eh lf lg lh li b">index.php </code>文件的版本1)并将其放入暂存区。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/50c40804ecc592eff5fe3c7a451db3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsTb6U6aWEZdsUwzke9tmg.png"/></div></div></figure><p id="4a00" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在运行<code class="eh lf lg lh li b">git reset --mixed HEAD~1</code>之后，我们的区域看起来像这样:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/5cfd5b37651d40c42e8459fa7ce42e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSpFhanrYXAfsB5UO9oTnA.png"/></div></div></figure><p id="717a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行<code class="eh lf lg lh li b">git status</code>现在又给了我们一个熟悉的信息:</p><pre class="lk ll lm ln fq mj li mk ml aw mm dt"><span id="98f5" class="mn kd hu li b fv mo mp l mq mr">Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><span id="ba33" class="mn kd hu li b fv ms mp l mq mr">modified:   index.php</span></pre><p id="3e3e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，运行<code class="eh lf lg lh li b">git reset — mixed HEAD~1</code>撤销了我们上一次的提交，但是这次提交后的更改(只)在我们的工作目录中。</p><h1 id="0d55" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">重置—硬</h1><p id="67fc" class="pw-post-body-paragraph jc jd hu je b jf la jh ji jj lb jl jm jn lc jp jq jr ld jt ju jv le jx jy jz hn dt translated">现在是臭名昭著的硬模式。运行<code class="eh lf lg lh li b">reset — hard</code>将做三件事:</p><ul class=""><li id="0a48" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">移动<code class="eh lf lg lh li b">HEAD</code>指针</li><li id="00be" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">更新临时区域(使用<code class="eh lf lg lh li b">HEAD</code>指向的内容)</li><li id="1853" class="lo lp hu je b jf lx jj ly jn lz jr ma jv mb jz lt lu lv lw dt translated">更新工作目录以匹配临时区域</li></ul><p id="ee23" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，前两步与<code class="eh lf lg lh li b">--mixed.</code>相同，第三步使工作目录看起来像暂存区(已经填充了<code class="eh lf lg lh li b">HEAD</code>指向的内容)。</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/a3c738523853e2f20659e961a76cc440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLooB8JOKT2TSgBlFC_obQ.png"/></div></div></figure><p id="942f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，在运行<code class="eh lf lg lh li b">git reset --hard HEAD~1</code>之后，我们的区域看起来像这样:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/35c37f5f8266d9efc7180079471bcbdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFAobqRN_eLBzNsjduJEAg.png"/></div></div></figure><p id="e8f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行git状态给我们提供了:</p><pre class="lk ll lm ln fq mj li mk ml aw mm dt"><span id="2581" class="mn kd hu li b fv mo mp l mq mr">nothing to commit, working tree clean</span></pre><p id="75cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，运行<code class="eh lf lg lh li b">git reset — hard HEAD~1</code>已经撤销了我们的最后一次提交，并且该提交中包含的更改既不在我们的工作目录中，也不在暂存区中。但它们并没有完全消失。Git不会从存储库中删除提交(实际上，有时会，但很少)，所以这意味着我们的第二个版本的提交仍然在存储库中，只是有点难以找到(你可以通过查看名为<em class="ka"> reflog </em>的东西来跟踪它)。</p><p id="7965" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，重置是危险的这个名声又是怎么回事呢？嗯，有一种情况下，一些更改可能会永久丢失。考虑这样一个场景，在第二次提交之后，您对您的<code class="eh lf lg lh li b">index.php </code>文件做了更多的更改，但是您没有暂存和提交它们:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/2e9a24731e907635602bdfa94da62943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lWD5aMyx3FVX69i6UH13CA.png"/></div></div></figure><p id="89ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你跑<code class="eh lf lg lh li b">git reset --hard HEAD~1</code>:</p><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/f7fbdc73079a2015c9cbd0ff2434b2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9hzDKHy84w55jyEJNoEMA.png"/></div></div></figure><p id="8c16" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">由于<code class="eh lf lg lh li b">reset --hard</code>覆盖了您的工作目录的内容以匹配暂存区(它已经与<code class="eh lf lg lh li b">HEAD</code>相匹配),并且您从未暂存和提交您的更改，因此没有提交存储库中的那些更改，所有这些更改现在都将及时丢失……就像雨中的眼泪。</p><p id="259b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">硬重置的危险在于它不是工作目录安全的——这意味着如果您的工作目录中有文件更改，并且在您运行它时会被覆盖(和丢失)，它不会给你任何警告。所以在硬重置时要格外小心。</p></div><div class="ab cl mc md hc me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hn ho hp hq hr"><p id="e9a5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这就是你要的——重置命令。我希望我解释得很好，并且你会同意这并不困难。是的，它可能是危险的，但只有在与<code class="eh lf lg lh li b">--hard</code>选项一起使用时。</p><p id="6f65" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如开始所说，如果你想知道更多关于git的内部工作原理，你可以查看我的<a class="ae kb" href="https://hackernoon.com/https-medium-com-zspajich-understanding-git-data-model-95eb16cc99f5" rel="noopener ugc nofollow" target="_blank"> <em class="ka">理解Git </em> </a>系列，如果你想更深入地了解复位命令，你可以查看Scot Cachon的git pro书中的<a class="ae kb" href="https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified" rel="noopener ugc nofollow" target="_blank"> git复位揭秘</a>章节。</p><h1 id="6588" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated"><strong class="ak">附录:</strong></h1><ul class=""><li id="d01d" class="lo lp hu je b jf la jj lb jn mt jr mu jv mv jz lt lu lv lw dt translated">在示例中，我们使用了<code class="eh lf lg lh li b">HEAD~1</code>作为<code class="eh lf lg lh li b">reset</code>命令的参数。正如您可能已经知道的，git中的每个提交都有一个唯一的标识符，称为<em class="ka">校验和</em>，我们可以使用它作为reset命令的参数来重置特定的提交</li></ul><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/ed8685e7b9dd7e5197bc7155a7291f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mT4Cexk-o9MAhLavZOiPGQ.png"/></div></div></figure><ul class=""><li id="3f2f" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">为了简化示例，我们只编辑和提交了一个文件，实际上，我们经常提交多个文件，所以一个特定的提交包含多个文件的不同版本。</li></ul><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/019d4f1222e30d8ca2f2bc404b8a20a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*72WGl-DR_B-UKMvF0PI6bw.png"/></div></div></figure><ul class=""><li id="27bb" class="lo lp hu je b jf jg jj jk jn lq jr lr jv ls jz lt lu lv lw dt translated">特殊的<code class="eh lf lg lh li b">HEAD</code>指针通常不直接指向提交(为简单起见，如示例所示)，而是指向一个分支指针，然后该分支指针指向一个特定的提交</li></ul><figure class="lk ll lm ln fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/cfa097493810f4a074e6cd803e0e1a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGsrQnzDBlKKq2c305Yp1A.png"/></div></div></figure><figure class="lk ll lm ln fq iv"><div class="bz el l di"><div class="mw mx l"/></div></figure></div></div>    
</body>
</html>