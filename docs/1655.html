<html>
<head>
<title>4 Ways to Go Monorepo in 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Monorepo在2019年的4种发展方式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/4-ways-to-go-monorepo-in-2019-ea5d19fc1f08?source=collection_archive---------3-----------------------#2019-03-11">https://medium.com/hackernoon/4-ways-to-go-monorepo-in-2019-ea5d19fc1f08?source=collection_archive---------3-----------------------#2019-03-11</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="d388" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">观察野外Monorepos的有用工具和想法…</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/97fc033240cbe5d8d8bc25a111853e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*k-6VaSftIDLt-IgJCN03Vw.png"/></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">So yeah… just put everything in there. It should be ok I think.</figcaption></figure><p id="9efd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最近，我听到和谈论了很多关于扩展代码共享的方法。一个流行的话题是“<a class="ae kr" href="https://hackernoon.com/tagged/monorepo" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv"/></a>”或多包共享存储库。</p><p id="2877" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将单独的包保存在单个存储库中对于代码共享是有用的，因为它使团队能够共享他们项目的一部分，以供其他团队和项目使用，而没有设置和维护许多存储库的开销。</p><p id="adce" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如，想象一个组织，其中不同的前端团队希望使用共享的React组件进行协作和工作。为了支持这一点，他们构建了一个共享的React库(就像Pinterest的格式塔或惠普的索环)。</p><p id="adb8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了实现这一点，他们考虑采用“monorepo ”;将所有组件保存在一个库中，而每个组件都是自己的包。这种“有用的邪恶”也使得贡献、运行CI/CD和管理变更变得更加容易。</p><p id="8162" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这篇文章中，我将回顾并分享生态系统中实现这一目标的最佳工具和解决方案。请根据您的经验随意评论和建议您自己的见解和工具！</p></div><div class="ab cl ks kt hc ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="hn ho hp hq hr"><h1 id="8aec" class="kz la hu bd lb lc ld le lf lg lh li lj ja lk jb ll jd lm je ln jg lo jh lp lq dt translated">1.比特分量单报告</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><a href="https://bitsrc.io/components"><div class="fe ff lr"><img src="../Images/461f34a59ad3dd4eebcdc55f883345e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*kg9Avc-5WQb2G2PQxHRPIg.gif"/></div></a></figure><p id="dc53" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">关于<a class="ae kr" href="https://github.com/teambit/bit" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">位</strong> </a>的事情是，每个存储库已经是一个monorepo。</p><p id="68b0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">你不需要重构任何东西。你不需要重组项目，设置不同的包，定义<code class="eh ls lt lu lv b">package.json</code>文件或其他任何东西。</p><p id="02b7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">取而代之的是，你只需要把Bit添加到存储库中，共享组件。这之所以成为可能，是因为Bit能够自动将组件从项目中分离出来，包括它们所有的依赖关系等等。</p><p id="a282" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">几十个组件可以在几分钟内共享，从将Bit添加到存储库中，到在<a class="ae kr" href="https://bitsrc.io" rel="noopener ugc nofollow" target="_blank"> Bit的hub </a>中变得可用，在那里它们可以被组织、共享和在线播放，然后与NPM和Yarn一起安装。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><a href="https://bitsrc.io/components"><div class="fe ff lr"><img src="../Images/bb8c03e0a561b0a943c42bc003fd567f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*F_ozsf8lx04FUu87xzqO8w.gif"/></div></a></figure><p id="2726" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当您对存储库中的一个组件进行更改时，Bit会自动跟踪这些更改，并识别将它作为依赖项的其他组件。然后，如果您运行<code class="eh ls lt lu lv b">bit status</code>，您可以看到所有的组件，当它们的依赖关系被修改时，它们被自动修改。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff lw"><img src="../Images/bc117f88c66cd47e706824a91aaf8254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flvUgpjm0izD834WajNKlQ.png"/></div></div><figcaption class="jr js fg fe ff jt ju bd b be z ek">Made changes to 1 component in the repo; Dependents were automatically updated</figcaption></figure><p id="4a0e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">也就是说，不需要手动通过<code class="eh ls lt lu lv b">package.json</code>文件来管理对依赖项的更改，因为Bit为您做了这项工作，使您的monorepo维护更加简单。</p><p id="ec40" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">您还可以将Bit添加到您的库的release management (CI/CD)中，以便用所有的更改更新每个版本中的组件。由于Bit运行、构建和测试您的组件，您可以快速了解一切的新状态。</p><p id="4912" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">PRs可以直接提交给monorepo，或者通过<code class="eh ls lt lu lv b">bit import</code>让其他人直接从他们的最终项目中导入和开发组件。</p><p id="d71d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">总而言之，如果你有一个组件库，你想做一个多包monorepo，Bit可能是最快和最省力的方法。它还提供了附加价值，如可发现性、在线社区等。</p><p id="d967" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae kr" href="https://bitsrc.io" rel="noopener ugc nofollow" target="_blank">试试看</a>。</p><h1 id="2504" class="kz la hu bd lb lc mb le lf lg mc li lj ja md jb ll jd me je ln jg mf jh lp lq dt translated">例子</h1><p id="ce32" class="pw-post-body-paragraph jv jw hu jx b jy mg iv ka kb mh iy kd ke mi kg kh ki mj kk kl km mk ko kp kq hn dt translated">Bit之前的语义UI组件库。</p><div class="ml mm fm fo mn mo"><a href="https://github.com/Semantic-Org/Semantic-UI-React" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">语义-组织/语义-用户界面-反应</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">官方的语义-用户界面-反应集成。为语义组织/语义用户界面反应开发做出贡献</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jp mo"/></div></div></a></div><p id="9f0c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">带Bit (0重构)的语义-UI组件库。</p><div class="ml mm fm fo mn mo"><a href="https://github.com/teambit/Semantic-UI-React/tree/addBit" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">teambit/Semantic-UI-React</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">官方的语义-用户界面-反应集成。通过创建帐户，为teambit/Semantic-UI-React开发做出贡献…</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">github.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc jp mo"/></div></div></a></div><p id="4027" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><a class="ae kr" href="https://bitsrc.io/semantic-org/semantic-ui-react" rel="noopener ugc nofollow" target="_blank">与Bit </a>共用的部件。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><a href="https://bitsrc.io/semantic-org/semantic-ui-react"><div class="fe ff ne"><img src="../Images/73dd405b2911267a8408baf2c5118ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ph-sfE9INlkSQP98Qy3Tjg.png"/></div></a></figure><h2 id="e61f" class="nf la hu bd lb ng nh ni lf nj nk nl lj ke nm nn ll ki no np ln km nq nr lp ns dt translated">赞成的意见</h2><ul class=""><li id="52be" class="nt nu hu jx b jy mg kb mh ke nv ki nw km nx kq ny nz oa ob dt translated">0重构到存储库。从0到从现有库中发布100个包只需几分钟。试试看。</li><li id="7a5e" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">无开销的可扩展代码共享。</li><li id="1fad" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">组件的出色视觉<a class="ae kr" href="https://bitsrc.io/components" rel="noopener ugc nofollow" target="_blank">可发现性</a>。</li><li id="38cd" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">Bit自动管理repo中的所有依赖项，包括对组件依赖项的更改，并根据需要更新所有组件。没有不同的<code class="eh ls lt lu lv b">package.json</code>文件需要维护或更新。</li><li id="ff31" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">变更管理可以通过PRs到repo来完成，也可以通过从任何其他存储库中发布组件更新来完成，方法是导入一个组件，对原始存储库进行更改并发布更新。</li><li id="4886" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">版本的自动更新(CI/CD中的Bit)。</li></ul><h2 id="0b38" class="nf la hu bd lb ng nh ni lf nj nk nl lj ke nm nn ll ki no np ln km nq nr lp ns dt translated">骗局</h2><ul class=""><li id="9906" class="nt nu hu jx b jy mg kb mh ke nv ki nw km nx kq ny nz oa ob dt translated">扩展系统即将启动。在此之前，您可能需要为您使用的不同工具稍微修改一下构建/测试环境。</li><li id="4fcb" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">通过Bit的注册表与NPN/Yarn客户端(您的选择)一起作为包安装。不支持NPM的注册表。</li><li id="d34c" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">hub的所有功能(搜索、游戏、npm安装)都要求你在hub中托管代码(比如GitHub和NPM)。没有供应商锁定(Bit像Git一样分布，可以在任何服务器上设置)。</li></ul><h1 id="bcd5" class="kz la hu bd lb lc mb le lf lg mc li lj ja md jb ll jd me je ln jg mf jh lp lq dt translated">2.莱娜·莫诺repo</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oh"><img src="../Images/36b6602aef9712c796df99abb320b523.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*ThKdRpHZcYp_Yau6DWUUFw.png"/></div></figure><p id="f5c6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Lerna是一个工具，用于管理单个存储库中的多个包。</p><p id="579c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">使用Lerna，您可以重构您的库，在其中保存多个包，而Lerna允许您链接依赖项(<code class="eh ls lt lu lv b">lerna bootstrap) </code>,并根据您的选择单独或一起对它们进行版本化(独立模式意味着每个子包都有自己的semver，并在其依赖项更新时相应地更新)。</p><pre class="jk jl jm jn fq oi lv oj ok aw ol dt"><span id="ca2e" class="nf la hu lv b fv om on l oo op">my-lerna-repo/<br/>  package.json<br/>  packages/<br/>    package-1/<br/>      package.json<br/>    package-2/<br/>      package.json</span></pre><p id="a1d9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Lerna自动执行monorepo中的软件包任务。<code class="eh ls lt lu lv b">lerna run build</code>将在每个子包中运行<code class="eh ls lt lu lv b">npm run build</code>，而<code class="eh ls lt lu lv b">lerna publish</code>将所有包发布到npm，并将更新git标签，等等。然后，可以从NPM的注册表安装软件包。</p><p id="6f33" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Lerna一开始就需要做一些工作，而且在整个过程中还需要做更多的工作，但是它是一种可靠的方法，可以将少量的核心包保存在一个存储库中，并将每个包独立地发布给NPM。</p><p id="6f56" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">一些开源项目使用Lerna来处理核心包，包括Babel、Jest和Gatsby。它在网上有许多教程和帖子。它对于在一个存储库中管理一个项目的几个部分特别有用，而每个部分都是独立的“迷你项目”。</p><h2 id="b784" class="nf la hu bd lb ng nh ni lf nj nk nl lj ke nm nn ll ki no np ln km nq nr lp ns dt translated">例子</h2><p id="eec0" class="pw-post-body-paragraph jv jw hu jx b jy mg iv ka kb mh iy kd ke mi kg kh ki mj kk kl km mk ko kp kq hn dt translated"><a class="ae kr" href="https://github.com/babel/babel/tree/master/packages" rel="noopener ugc nofollow" target="_blank">带Lerna的巴别塔包</a>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><a href="https://github.com/babel/babel/tree/master/packages"><div class="fe ff oq"><img src="../Images/c51fc541bb77bb8fdfc59c61e1e55686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x_c0HonRuhagUqCP3nKh-w.png"/></div></a></figure><div class="ml mm fm fo mn mo"><a href="https://github.com/babel/babel/tree/master/packages" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab ej"><div class="mq ab mr cl cj ms"><h2 class="bd hv fv z el mt eo ep mu er et ht dt translated">巴别/巴别</h2><div class="mv l"><h3 class="bd b fv z el mt eo ep mu er et ek translated">🐠Babel是一个用于编写下一代JavaScript的编译器。巴别塔/巴别塔</h3></div><div class="mw l"><p class="bd b gc z el mt eo ep mu er et ek translated">github.com</p></div></div><div class="mx l"><div class="or l mz na nb mx nc jp mo"/></div></div></a></div><h2 id="65f6" class="nf la hu bd lb ng nh ni lf nj nk nl lj ke nm nn ll ki no np ln km nq nr lp ns dt translated">赞成的意见</h2><ul class=""><li id="6d5b" class="nt nu hu jx b jy mg kb mh ke nv ki nw km nx kq ny nz oa ob dt translated">成熟和丰富的网络教程。</li><li id="00a8" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">单独或在一行中对所有包进行版本控制。</li><li id="c5c2" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">用<code class="eh ls lt lu lv b">lerna bootstrap</code>链接项目中的依赖项。</li><li id="f192" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">repo中所有包的任务执行自动化。</li><li id="2ca7" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated"><code class="eh ls lt lu lv b">Lerna publish</code>发布NPM的所有更新。</li></ul><h2 id="a7c9" class="nf la hu bd lb ng nh ni lf nj nk nl lj ke nm nn ll ki no np ln km nq nr lp ns dt translated">骗局</h2><ul class=""><li id="a3e1" class="nt nu hu jx b jy mg kb mh ke nv ki nw km nx kq ny nz oa ob dt translated">对存储库进行大量重构。大量的初始开销。</li><li id="0cb1" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">维护开销随着每个包的不同<code class="eh ls lt lu lv b">package.json</code>和环境而增长。</li><li id="3e7c" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">包的可发现性依赖于NPM/图书馆的文档。</li><li id="85a4" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">PRs只能在回购中制定，并且很难让新的开发人员加入回购，这反过来又会损害包的采用。</li></ul><h1 id="951a" class="kz la hu bd lb lc mb le lf lg mc li lj ja md jb ll jd me je ln jg mf jh lp lq dt translated">3.Bit + Lerna + Yarn工作空间组合</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff os"><img src="../Images/0405e7ea008bc199abe2d64a4392c9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jvy-TiBnROlZtNN1L4Pfnw.png"/></div></div></figure><p id="c4d3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Lerna和Bit可以在一个库中一起玩。</p><p id="bb7c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">例如，Lerna可用于管理核心包，而Bit可用于共享所有较小的组件。Bit还为组件提供了可发现性，并减少了所需的重构和维护量。</p><p id="7a8a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这两个也可以玩纱线工作空间。Bit将自动管理存储库中组件之间的依赖关系，而Lerna将帮助您处理更大的核心包，Workspaces将帮助整合和优化存储库中外部包的安装。</p><h2 id="f793" class="nf la hu bd lb ng nh ni lf nj nk nl lj ke nm nn ll ki no np ln km nq nr lp ns dt translated">赞成的意见</h2><ul class=""><li id="4274" class="nt nu hu jx b jy mg kb mh ke nv ki nw km nx kq ny nz oa ob dt translated">使用Lerna处理库中3-4个较大的包，而Bit将处理几十个组件。</li><li id="0297" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">共享任意数量的回购组件不会产生开销。</li><li id="17f2" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">组件的可发现性和更简单的协作。</li><li id="f4e1" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">与Yarn工作空间相结合，优化工作流程和性能。</li></ul><h2 id="2854" class="nf la hu bd lb ng nh ni lf nj nk nl lj ke nm nn ll ki no np ln km nq nr lp ns dt translated">骗局</h2><ul class=""><li id="8de5" class="nt nu hu jx b jy mg kb mh ke nv ki nw km nx kq ny nz oa ob dt translated">使用两个工具而不是一个。</li><li id="4e87" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">您必须手动维护较大的软件包。</li><li id="7277" class="nt nu hu jx b jy oc kb od ke oe ki of km og kq ny nz oa ob dt translated">使用2个包注册中心(两者都与NPM客户端一起工作，所以在运行1个命令后，它应该不会影响内部使用)。</li></ul><h1 id="d56c" class="kz la hu bd lb lc mb le lf lg mc li lj ja md jb ll jd me je ln jg mf jh lp lq dt translated">4.Git子模块</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff ot"><img src="../Images/3f0d37fb28eaa2a99d3fbf0e676afb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*6T2ij2_Uxh-UnPngtenRmw.png"/></div></figure><p id="6e01" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Git是大多数开发团队的选择。它允许你将一个库<a class="ae kr" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" rel="noopener ugc nofollow" target="_blank">作为另一个库的子目录</a>，为整个项目创建一个<a class="ae kr" rel="noopener" href="/@porteneuve/mastering-git-submodules-34c65e940407">单一工作树</a>，并且一个项目可以使用另一个项目的代码。</p><p id="292f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">但是……Git子模块对于大多数开发者来说是一个痛苦的话题。</p><p id="3ec2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，他们只在<code class="eh ls lt lu lv b">master</code>分支工作。第二，子模块在项目之间创建了高度耦合的代码，使得在跨repo任务上的合并和协作变得困难。子模块repo也不知道它是嵌套的，可能有一个从属repo。</p><p id="64aa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">有各种工具围绕子模块特性提供额外的自动化，例如<a class="ae kr" href="https://github.com/apenwarr/git-subtree/" rel="noopener ugc nofollow" target="_blank"> git-subtree </a>、<a class="ae kr" href="http://gitslave.sourceforge.net" rel="noopener ugc nofollow" target="_blank"> gitslave </a>、<a class="ae kr" href="https://github.com/cristibalan/braid" rel="noopener ugc nofollow" target="_blank"> braid </a>和<a class="ae kr" href="https://github.com/patmaddox/giternal" rel="noopener ugc nofollow" target="_blank"> giternal </a>。这些工具试图改善子模块的一些可用性问题，但是不被特定的供应商支持，并且具有不同的缺点。</p><h1 id="472d" class="kz la hu bd lb lc mb le lf lg mc li lj ja md jb ll jd me je ln jg mf jh lp lq dt translated">结论</h1><p id="6abb" class="pw-post-body-paragraph jv jw hu jx b jy mg iv ka kb mh iy kd ke mi kg kh ki mj kk kl km mk ko kp kq hn dt translated">围绕Monorepos的讨论在社区中蓬勃发展。虽然大多数人都同意多回购架构的优点，但一些用例使得维护和发布来自多个存储库的多个包变得非常困难。尤其是在共享库上工作时。</p><p id="4c88" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了使这更容易，生态系统中出现了新的工具。从在单个存储库中自动保存和发布较大软件包的Lerna，到将组件库体验提升到一个新水平的Bit，一切都不费吹灰之力，而且好处多多。</p><p id="3fd6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">别忘了，代码共享不仅关乎技术，也关乎人。你和你的团队必须面向编写可重用的代码，模块化地思考，鼓励交流和效率。感谢您的阅读，有任何问题，请不要犹豫在下面评论。<strong class="jx hv">欢呼</strong></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ou ov l"/></div></figure></div></div>    
</body>
</html>