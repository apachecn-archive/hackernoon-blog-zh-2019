<html>
<head>
<title>Render props for Elm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为榆树渲染道具</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/render-props-for-elm-d5547efd66f5?source=collection_archive---------9-----------------------#2019-02-21">https://medium.com/hackernoon/render-props-for-elm-d5547efd66f5?source=collection_archive---------9-----------------------#2019-02-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="3939" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">嗯，差不多吧。</h2></div><p id="3697" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是一种常见的UI模式，在Elm中实现起来有点困难。类似React世界的渲染道具或者<em class="kf">的特效</em>，如果你已经逃离了棱角分明的世界。</p><p id="cf89" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个想法是，你想创建一个通用组件来提供一些包装器用户界面和一点点状态管理，然后重用这个组件，但是在其中注入你自己的视图(渲染属性)。这种技术的一个很好的例子就是模态或者标签条。在这些情况下，您不希望每次都重写通用的标记和逻辑。一个模态有一个页眉和一个页脚，你需要跟踪它是打开的还是关闭的等等，但是当你<em class="kf">使用</em>时，你最关心的是你特定用例的内容。</p><h1 id="67b4" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">那么问题出在哪里？</h1><p id="a82c" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">它在铅字里。让我们试着去做，我们会看到为什么它不能立即工作。为了简单起见，假设我的通用组件基本上只是一个div，我希望能够呈现我的自定义容器组件，但将自定义UI注入其中。我的div将有一个标题，当你点击它时，它会改变颜色(这是它内部跟踪的状态，我想抽象掉)。</p><h1 id="af41" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">让我们试试吧</h1><p id="fe7f" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">我们的ColourClicker组件将具有通常的Elm生命周期，因为它需要跟踪这一点点内部状态，它最初可能看起来像这样:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="2d53" class="lm kh hu li b fv ln lo l lp lq">type alias Model =<br/>    { colour : String }</span><span id="3746" class="lm kh hu li b fv lr lo l lp lq">type Msg<br/>    = ToggleColour</span><span id="65cd" class="lm kh hu li b fv lr lo l lp lq">init : Model<br/>init =<br/>    { colour = "blue" }</span><span id="fb4b" class="lm kh hu li b fv lr lo l lp lq">update : Msg -&gt; Model -&gt; Model<br/>update msg model =<br/>    case msg of<br/>        ToggleColour -&gt;<br/>            toggleColour model</span><span id="7dbd" class="lm kh hu li b fv lr lo l lp lq">toggleColour : Model -&gt; Model<br/>toggleColour model =<br/>    case model.colour of<br/>        "blue" -&gt;<br/>            { model | colour = "red" }<br/>        _ -&gt;<br/>            { model | colour = "blue" }</span><span id="09de" class="lm kh hu li b fv lr lo l lp lq">view : Model -&gt; List (Html Msg) -&gt; Html Msg<br/>view model content =<br/>    div<br/>        [ class "colour-clicker" ]<br/>        [ h1<br/>            [ onClick ToggleColour<br/>            , style "background" model.colour<br/>            ]<br/>            [ text "This is the magical header" ]<br/>        , div []<br/>            content<br/>        ]</span></pre><p id="30e7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">希望这不需要太多解释。view函数只允许我们从消费代码中注入内容。</p><p id="565a" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">使用该组件的代码可能看起来有点像这样:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="2f11" class="lm kh hu li b fv ln lo l lp lq">import ColourClicker as C</span><span id="46e3" class="lm kh hu li b fv lr lo l lp lq">type alias Model =<br/>    { colourClicker : C.Model }</span><span id="92d8" class="lm kh hu li b fv lr lo l lp lq">init : ( Model, Cmd Msg )<br/>init =<br/>    ( { colourClicker = C.init }, Cmd.none )</span><span id="6e40" class="lm kh hu li b fv lr lo l lp lq">type Msg<br/>    = ColourClickerMsg C.Msg</span><span id="a896" class="lm kh hu li b fv lr lo l lp lq">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        ColourClickerMsg subMsg -&gt;<br/>            let<br/>                subModel =<br/>                    C.update subMsg model.colourClicker<br/>            in<br/>            ( { model | colourClicker = subModel }, Cmd.none )</span><span id="2f4d" class="lm kh hu li b fv lr lo l lp lq">view : Model -&gt; Html Msg<br/>view model =<br/>    div [ class "demo" ]<br/>        [ h1 [] [ text "Demo of render props technique for Elm" ]<br/>        , Html.map ColourClickerMsg &lt;|<br/>            C.view model.colourClicker<br/>                [ div []<br/>                    [ text "This is the content of the colour clicker provided by the parent" ]<br/>                ]<br/>        ]</span></pre><p id="ab7f" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最终结果看起来是这样的，并且工作正常:</p><figure class="ld le lf lg fq lt fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/ff589a6397ddf758b2d230cddaabdea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*-y8ifPQ-4pxsimjYTbbf0A.png"/></div></figure><h1 id="2304" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">新功能请求</h1><p id="5caf" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">现在假设我希望我注入的内容包含一个按钮，并且我希望在我的父组件中处理这个按钮的点击。像这样:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="15db" class="lm kh hu li b fv ln lo l lp lq">type Msg<br/>    = ColourClickerMsg C.Msg<br/>    | ButtonClicked</span><span id="d462" class="lm kh hu li b fv lr lo l lp lq">update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )<br/>update msg model =<br/>    case msg of<br/>        ...</span><span id="fd59" class="lm kh hu li b fv lr lo l lp lq">        ButtonClicked -&gt;<br/>            let<br/>                _ =<br/>                    Debug.log "Button Clicked!" ()<br/>            in<br/>            ( model, Cmd.none )</span><span id="4bdd" class="lm kh hu li b fv lr lo l lp lq">view : Model -&gt; Html Msg<br/>view model =<br/>    div [ class "demo" ]<br/>        [ h1 [] [ text "Demo of render props technique for Elm" ]<br/>        , Html.map ColourClickerMsg &lt;|<br/>            C.view model.colourClicker<br/>                [ div []<br/>                    [ text "Now we need to add a button"<br/>                    , button [ onClick ButtonClicked ] [ text "Click me!" ]<br/>                    ]<br/>                ]<br/>        ]</span></pre><p id="088c" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这是想做的一件合理的事情。我们不希望ColourClicker组件本身处理这个按钮单击，因为逻辑属于调用组件。ColourClicker应该只对它自己的状态负责(即它的标题的颜色)。但是我们有一个问题。我们的ColourClicker的视图函数期望它的内容是类型<code class="eh lw lx ly li b">Html ColourClicker.Msg</code>，但是我们现在试图传入<code class="eh lw lx ly li b">Html Parent.Msg</code>，所以类型没有对齐，编译器(正确地)报错。</p><figure class="ld le lf lg fq lt fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff lz"><img src="../Images/0a52ff81f11cb5fc6626cc0555c0d744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59le0Ff0mpsfr5JLxS8-4g.png"/></div></div></figure><h1 id="fadb" class="kg kh hu bd ki kj kk kl km kn ko kp kq ja kr jb ks jd kt je ku jg kv jh kw kx dt translated">那么我们能做什么呢？</h1><p id="1836" class="pw-post-body-paragraph jj jk hu jl b jm ky iv jo jp kz iy jr js la ju jv jw lb jy jz ka lc kc kd ke hn dt translated">我们按照类型来。首先，我们必须让ColourClicker的视图函数接受多态类型的内容，如下所示:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="0ee9" class="lm kh hu li b fv ln lo l lp lq">view : Model -&gt; List (Html parent) -&gt; Html Msg</span></pre><p id="4466" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这个签名中,“parent”是一个类型参数，表示我们不知道这个Html将具有什么类型。这消除了以前的编译器错误，但用一个新的错误代替了它。</p><figure class="ld le lf lg fq lt fe ff paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="fe ff me"><img src="../Images/28953e861eab00689692f1c3f263bf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJl01dvvQvdQTBWZutD3zA.png"/></div></div></figure><p id="f0f3" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在的问题是我们的ColourPicker视图试图将<code class="eh lw lx ly li b">Html parent</code>嵌入到<code class="eh lw lx ly li b">Html ColourPicker.Msg</code>的块中，这是不允许的。因此，很明显，我们需要以某种方式映射传入的Html，以将它强制转换为正确的类型。</p><p id="30a9" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为此，我们需要在ColourClicker中创建一个新的Msg类型，将父Msg类型映射到该类型，创建一个函数来执行映射，并在我们写出内容时调用该函数:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="3712" class="lm kh hu li b fv ln lo l lp lq">type Msg parent<br/>    = ToggleColour<br/>    | Parent parent</span><span id="17ec" class="lm kh hu li b fv lr lo l lp lq">wrap : Html parent -&gt; Html (Msg parent)<br/>wrap =<br/>    Html.map Parent</span><span id="d739" class="lm kh hu li b fv lr lo l lp lq">view : Model -&gt; List (Html parent) -&gt; Html (Msg parent)<br/>view model content =<br/>    div<br/>        [ class "colour-clicker" ]<br/>        [ h1<br/>            [ onClick ToggleColour<br/>            , style "background" model.colour<br/>            ]<br/>            [ text "This is the magical header" ]<br/>        , div []<br/>            (List.map wrap content)<br/>        ]</span></pre><p id="fc87" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们所做的是<em class="kf">用多态父类型参数化</em>我们自己的消息类型，这样我们可以创建一个包含<em class="kf">父消息的消息类型的实例。请注意，所有这些对调用代码都是透明的，不会引入更多的复杂性。这使得类型排成一行，但这不只是一个技巧吗？我们的更新功能会发生什么变化？它需要进行如下更改:</em></p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="855b" class="lm kh hu li b fv ln lo l lp lq">update : Msg parent -&gt; Model -&gt; ( Model, Cmd parent )<br/>update msg model =<br/>    case msg of<br/>        ToggleColour -&gt;<br/>            ( toggleColour model, Cmd.none )</span><span id="b620" class="lm kh hu li b fv lr lo l lp lq">        Parent p -&gt;<br/>            ( model, Task.perform identity (Task.succeed p) )</span></pre><p id="aaf7" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">首先我们需要改变返回类型，允许我们返回一个<code class="eh lw lx ly li b">Cmd parent</code>。这很不寻常——通常应该是<code class="eh lw lx ly li b">Cmd Msg</code>。如果需要的话，我们也可以这样做<em class="kf"/>，但是在这种情况下，我们没有这样做。记住更新功能没有什么神奇的，它只是一个功能——我们可以做我们喜欢的事情。在处理新的<code class="eh lw lx ly li b">Parent parent</code>消息类型的case语句的分支中，我们简单地使用任务api将该消息转换成一个<code class="eh lw lx ly li b">Cmd</code>，并将其返回给调用者。</p><p id="0caf" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">最后需要对父类的更新函数进行修改，以正确处理这个新的返回类型。现在看起来像这样:</p><pre class="ld le lf lg fq lh li lj lk aw ll dt"><span id="5f20" class="lm kh hu li b fv ln lo l lp lq">case msg of<br/>   ColourClickerMsg subMsg -&gt;<br/>       let<br/>           ( subModel, subCmd ) =<br/>               C.update subMsg model.colourClicker<br/>       in<br/>       ( { model | colourClicker = subModel }, subCmd )</span></pre><p id="9a76" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">从update函数出来的subCmd已经是直接从父update函数返回的正确类型。它最终将作为ButtonClicked msg反馈到更新函数中。</p><p id="e3da" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在一切都编译了！我们有非常好的惯用语法，我们能够自然地处理父级的按钮单击，而ColourClicker组件对此一无所知。我们现在可以更有效地重用ColourClicker组件。</p><p id="3b92" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我很乐意听到解决这个问题的其他方法，因为我花了一段时间才弄明白这个问题，而且这似乎是一个很普遍的要求。</p><p id="602d" class="pw-post-body-paragraph jj jk hu jl b jm jn iv jo jp jq iy jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个例子的代码可以在<a class="ae mf" href="https://github.com/julianjelfs/elm-render-props" rel="noopener ugc nofollow" target="_blank">这里</a>找到。希望这对某人有用。</p></div></div>    
</body>
</html>