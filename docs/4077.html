<html>
<head>
<title>Asynchronous Programming 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步编程 101</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/asynchronous-programming-101-5ac0fa4e84e8#2019-07-10">https://medium.com/hackernoon/asynchronous-programming-101-5ac0fa4e84e8#2019-07-10</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="5aec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C#中异步编程的自顶向下介绍</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/4dac4e56e99201c39cbb92aa60b38c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKGPQ3GxOvEtdnr8UL9U7g.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Ships at sea as seen from a ferry from Redwood City to San Francisco, July 2018</figcaption></figure><p id="d796" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇博文中，我将自上而下地介绍 C#中的异步编程。这篇文章可能对 C#新手和学习过线程和并发的学生有用。我相信自顶向下的方法将是理想的，因为它将首先向您展示什么是异步编程，这样您就可以对它的<em class="kf">如何</em>和<em class="kf">为什么</em>感兴趣。</p><p id="d5da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇博客中使用的代码可以在我的 GitHub <a class="ae kg" href="https://github.com/DeeptanshuM/AsyncProgramming101/blob/master/AsyncProgrammingDemo/Program.cs" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="f941" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">基本面快速回顾</h1><h2 id="5c9a" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">延迟和吞吐量</h2><p id="efaa" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">延迟是对工作所用时间单位的度量。吞吐量是衡量单位时间内完成的工作的单位。</p><h2 id="4143" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">并发</h2><p id="1c5c" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">并发意味着多个计算同时发生[1]。它不同于<a class="ae kg" href="https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism" rel="noopener ugc nofollow" target="_blank">本</a> stackoverflow 答案中解释的并行性:</p><blockquote class="mf mg mh"><p id="7b60" class="ir is kf it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">并发性:至少有两个线程正在进行的情况。一种更通用的并行形式，可以将时间片作为虚拟并行的一种形式[2]。</p><p id="d748" class="ir is kf it b iu iv iw ix iy iz ja jb mi jd je jf mj jh ji jj mk jl jm jn jo hn dt translated">并行性:当至少两个线程同时执行时出现的情况[2]。</p></blockquote><h2 id="ec86" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">任务</h2><p id="1e4c" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">任务是代表操作的抽象[3]。此操作可能会也可能不会得到多个线程的支持，并且可能会也可能不会同时执行。我们可以使用任务，而不是直接使用线程，这样我们就不需要手动、显式地实现线程的锁定、连接和同步操作，也不需要手动直接创建或销毁线程。默认情况下，C#任务使用线程池中的线程。线程池是一种维护多个线程的设计模式，这样它们就可以被重用/回收。我们可以使用这种设计模式来减少重复创建、启动和删除线程的延迟。</p><h2 id="3951" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">同步与异步操作</h2><p id="1c6a" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">同步操作会在返回到调用者之前完成它的工作，而异步操作会在返回到调用者之后完成它的部分(包括全部)工作[3]。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff ml"><img src="../Images/d0fe50f11756a22e507d4203fc6d7214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vRpXl1K95fntjytdK-yQQ.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Purdue University, West Lafayette, IN, I think sometime during winter 2018–2019</figcaption></figure><h2 id="0024" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">用类比来概括这些基本概念</h2><p id="f027" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">让我们考虑一个自助洗衣店。如果你几乎同时将衣物放入两台洗衣机，例如一只手拿着一台洗衣机，另一只手同时拿着另一台洗衣机<em class="kf"/>，那么你是在平行<em class="kf">放置衣物</em>。但是，如果您同时将衣物放入两台洗衣机，在给定的时间内，您一次只能将衣物放入一台洗衣机，那么您将同时放入衣物<em class="kf">和</em>。</p><p id="458c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">洗衣机洗一负荷衣服所用的时间将是一台洗衣机的<em class="kf">潜伏期</em>。为了减少等待洗涤 n 件衣物所花费的时间，可以同时运行 n 台机器，而不是运行一台机器 n 次:在两种情况下，一台机器所做的工作花费相同的时间，但不同之处在于，在后一种情况下，在相同时间内所做的工作量(同时洗涤 n 件衣物)更多，即<em class="kf">吞吐量</em>更多。</p><p id="0f03" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要做所有这些事情，你可能会问前台的人要 25 美分的硬币:当时你什么也做不了，你排在队伍的前面，给了那个人两张 1 美元的钞票，然后等着他们退回 25 美分的硬币。这是一个<em class="kf">同步</em>操作。当洗衣机运行时，你仍然保持控制——你可以在第一台洗衣机仍在运行时继续加载并开始运行另一台洗衣机——这使得洗衣机的运行成为<em class="kf">异步</em>操作。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><h1 id="1af1" class="ko kp hu bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">异步编程演示</h1><p id="3e8e" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">让我们看一个演示来理解如何定义和调用异步函数，以及异步编程如何通过提高吞吐量来影响程序延迟。</p><p id="f3e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">C#中的异步函数是通过在函数定义中添加关键字<code class="eh mm mn mo mp b">async</code>来定义的。它们可以像其他函数一样被调用。C#中的异步函数必须返回一个任务或某种类型的任务。在下面的演示程序中，我们将看到如何启动这些任务，如何同步和异步运行它们，以及如何使用<code class="eh mm mn mo mp b">await</code>关键字停止代码流以等待任务的结果。</p><h2 id="b19c" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">虚拟同步和异步功能</h2><p id="abcc" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">让我们实现一个虚拟异步函数:</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="142c" class="lm kp hu mp b fv mu mv l mw mx">private async Task&lt;int&gt; longRunningMultiplyBy10(int number)<br/>{<br/>    Console.WriteLine("# Initiated long running op on for the input number=" + number + " from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId + " #");</span><span id="430e" class="lm kp hu mp b fv my mv l mw mx">    //100 delays of 100 ms = 10 seconds<br/>    for (int i = 0; i &lt; 100 ; i++)<br/>    {<br/>        await Task.Delay(100);<br/>    }</span><span id="ab49" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("# Completed long running op on for the input number=" + number + " from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId + " #");<br/>    return number * 10;<br/>}</span></pre><p id="5fda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个函数中，我们使用本机异步<code class="eh mm mn mo mp b">Delay</code>函数，通过使用<code class="eh mm mn mo mp b">await</code>关键字异步调用它，总共等待 10 秒，然后将输入数字乘以 10 并返回它。我们现在将看到同步和异步调用时的性能差异。为此，我们将实现一些函数来输入数字，对每个数字执行虚拟的长时间运行操作，并返回它们的总和。</p><p id="411b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">同步调用<code class="eh mm mn mo mp b">longRunningMultiplyBy10</code>的函数是:</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="60bb" class="lm kp hu mp b fv mu mv l mw mx">private int syncMultiplyBy10AndAdd(int num1, int num2)<br/>{<br/>    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int a = longRunningMultiplyBy10(num1).Result;</span><span id="4fe3" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int b = longRunningMultiplyBy10(num2).Result;</span><span id="4166" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Executing return from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    return a + b;<br/>}</span></pre><p id="faa1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们编写一个使用异步编程的函数:</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="a384" class="lm kp hu mp b fv mu mv l mw mx">private async Task&lt;int&gt; asyncMultiplyBy10AndAddAwaitImmediately(int num1, int num2)<br/>{<br/>    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int a = await longRunningMultiplyBy10(num1);</span><span id="9b94" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int b = await longRunningMultiplyBy10(num2);</span><span id="59aa" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Executing return from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    return a + b;<br/>}</span></pre><p id="be99" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以在这里观察到，我们不需要<code class="eh mm mn mo mp b">await</code>长时间运行的操作，直到我们需要访问任务的结果——让我们写一个函数来反映这一点，并观察它的性能。</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="ff18" class="lm kp hu mp b fv mu mv l mw mx">private async Task&lt;int&gt; asyncMultiplyBy10AndAddAwaitAtEnd(int num1, int num2)<br/>{<br/>    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    Task&lt;int&gt; a = longRunningMultiplyBy10(num1);</span><span id="8881" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    Task&lt;int&gt; b = longRunningMultiplyBy10(num2);</span><span id="4a46" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Executing return from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    return await a + await b;<br/>}</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/e0749bafc34dfceb16f97fe9ef6733ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nknBUAQXYlA8c6PSTxwx8w.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">A tree at Purdue University, West Lafayette, IN, 1st or 2nd week of October, 2018</figcaption></figure><h2 id="0527" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">帮助器函数调用虚拟函数并记录它们的性能</h2><p id="b057" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated"><em class="kf">本节没有必要，可能会分散注意力，请跳到下一节</em></p><p id="597b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们将调用<code class="eh mm mn mo mp b">demo</code>来调用我们的演示函数，并测量它们的性能，如下所示:</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="5cc8" class="lm kp hu mp b fv mu mv l mw mx">private void demo()<br/>{<br/>    Console.WriteLine("##### Testing synchronous code #####");<br/>    demoSyncFunction(syncMultiplyBy10AndAdd);<br/>    Console.WriteLine("####################################" + Environment.NewLine);</span><span id="cd55" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("##### Testing await immediately #####");<br/>    demoAsyncFunction(asyncMultiplyBy10AndAddAwaitImmediately);<br/>    Console.WriteLine("####################################" + Environment.NewLine);<br/>    Console.WriteLine();</span><span id="1d3c" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("##### Testing await at end #####");<br/>    demoAsyncFunction(asyncMultiplyBy10AndAddAwaitAtEnd);<br/>    Console.WriteLine("####################################" + Environment.NewLine);<br/>    Console.WriteLine();<br/>}</span><span id="9c1c" class="lm kp hu mp b fv my mv l mw mx">private void demoSyncFunction(Func&lt;int, int, int&gt; asyncDemoFunction)<br/>{<br/>    int num1 = 15;<br/>    int num2 = 33;<br/>    int result;<br/>    Stopwatch stopWatch = new Stopwatch();</span><span id="cb93" class="lm kp hu mp b fv my mv l mw mx">    stopWatch.Start();<br/>    result = asyncDemoFunction(num1, num2);<br/>    stopWatch.Stop();<br/>    displayRuntime(stopWatch.Elapsed);</span><span id="ddf6" class="lm kp hu mp b fv my mv l mw mx">}</span><span id="62ad" class="lm kp hu mp b fv my mv l mw mx">private void demoAsyncFunction(Func&lt;int, int, Task&lt;int&gt;&gt; asyncDemoFunction)<br/>{<br/>    int num1 = 15;<br/>    int num2 = 33;<br/>    Stopwatch stopWatch = new Stopwatch();</span><span id="3196" class="lm kp hu mp b fv my mv l mw mx">    stopWatch.Start();</span><span id="f228" class="lm kp hu mp b fv my mv l mw mx">    int result = asyncDemoFunction(num1, num2).Result;</span><span id="68fb" class="lm kp hu mp b fv my mv l mw mx">    stopWatch.Stop();</span><span id="6277" class="lm kp hu mp b fv my mv l mw mx">    displayRuntime(stopWatch.Elapsed);<br/>}</span><span id="d630" class="lm kp hu mp b fv my mv l mw mx">private void displayRuntime(TimeSpan ts)<br/>{<br/>    string elapsedTime = String.Format("{0:00}min:{1:00}s.{2:00}ms",<br/>        ts.Minutes, ts.Seconds,<br/>        ts.Milliseconds / 10);</span><span id="0d50" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Runtime: " + elapsedTime);<br/>}</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mz"><img src="../Images/4894d2158e56afe23e50ee48d7c5e7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQs8Xs10MDQ5KcdOAC2gRA.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">A bridge I saw from the window of Amtrak en route to Portland from Seattle or maybe the other around</figcaption></figure><h2 id="90e3" class="lm kp hu bd kq ln lo lp ku lq lr ls ky jc lt lu lc jg lv lw lg jk lx ly lk lz dt translated">结果呢</h2><p id="ae6c" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">输出如下所示:</p><p id="eed5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于功能<code class="eh mm mn mo mp b">syncMultiplyBy10AndAdd</code></p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="7fdc" class="lm kp hu mp b fv mu mv l mw mx">private int syncMultiplyBy10AndAdd(int num1, int num2)<br/>{<br/>    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int a = longRunningMultiplyBy10(num1).Result;</span><span id="175e" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int b = longRunningMultiplyBy10(num2).Result;</span><span id="d945" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Executing return from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    return a + b;<br/>}</span></pre><p id="c645" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出是:</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="270b" class="lm kp hu mp b fv mu mv l mw mx">##### Testing synchronous code #####<br/>Calling long running Op from Thread 1<br/># Initiated long running op on for the input number=15 from Thread 1 #<br/># Completed long running op on for the input number=15 from Thread 8 #<br/>Calling long running Op from Thread 1<br/># Initiated long running op on for the input number=33 from Thread 1 #<br/># Completed long running op on for the input number=33 from Thread 8 #<br/>Executing return from Thread 1<br/>Runtime: 00min:20s.08ms<br/>####################################</span></pre><p id="ef4e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们观察到线程 1 开始执行<code class="eh mm mn mo mp b">syncMultiplyBy10AndAdd</code>。当它调用<code class="eh mm mn mo mp b">longRunningMultiplyBy10</code>时，<code class="eh mm mn mo mp b">syncMultiplyBy10AndAdd</code>的执行被阻止。然后，线程 1 开始执行异步运行的长时间运行的操作。当函数异步运行时，线程 1 从执行<code class="eh mm mn mo mp b">longRunningMultiplyBy10</code>的任务中释放出来。然而，因为<code class="eh mm mn mo mp b">syncMultiplyBy10AndAdd</code>是同步的，当<code class="eh mm mn mo mp b">longRunningMultiplyBy10</code>完成时，线程 1 始终负责执行<code class="eh mm mn mo mp b">syncMultiplyBy10AndAdd</code>。我们注意到该函数执行用了<strong class="it hv">20.08 毫秒</strong>。</p><p id="6ed0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，当执行功能<code class="eh mm mn mo mp b">asyncMultiplyBy10AndAddAwaitImmediately</code>时:</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="9cba" class="lm kp hu mp b fv mu mv l mw mx">private async Task&lt;int&gt; asyncMultiplyBy10AndAddAwaitImmediately(int num1, int num2)<br/>{<br/>    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int a = await longRunningMultiplyBy10(num1);</span><span id="5fc5" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    int b = await longRunningMultiplyBy10(num2);</span><span id="715a" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Executing return from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    return a + b;<br/>}</span></pre><p id="fa80" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">输出是</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="8338" class="lm kp hu mp b fv mu mv l mw mx">##### Testing await immediately #####<br/>Calling long running Op from Thread 1<br/># Initiated long running op on for the input number=15 from Thread 1 #<br/># Completed long running op on for the input number=15 from Thread 7 #<br/>Calling long running Op from Thread 7<br/># Initiated long running op on for the input number=33 from Thread 7 #<br/># Completed long running op on for the input number=33 from Thread 8 #<br/>Executing return from Thread 8<br/>Runtime: 00min:20s.04ms<br/>####################################</span></pre><p id="e4f8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们观察到线程 1 开始执行<code class="eh mm mn mo mp b">asyncMultiplyBy10AndAddAwaitImmediately</code>。这一次的不同之处在于，因为对<code class="eh mm mn mo mp b">longRunningMultiplyBy10</code>的调用是异步的，所以线程 1 从执行<code class="eh mm mn mo mp b">asyncMultiplyBy10AndAddAwaitImmediately</code>的任务中释放出来，线程池中的另一个线程，即线程 7，继续执行。我们注意到这个函数用了<strong class="it hv">20.04 毫秒</strong>。这肯定比同步调用实现更快，我们可以直观地看到在现实世界中延迟的改善是多么显著。</p><p id="5643" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们还可以观察到低效率:我们在需要使用长时间运行操作的结果时提前完成了该操作。因此，尽管我们使用线程池通过使用异步编程将执行<code class="eh mm mn mo mp b">asyncMultiplyBy10AndAddAwaitImmediately</code>的任务更有效地分配给一个线程，但我们没有利用异步编程的全部能力来允许长时间运行的操作(在本例中为<code class="eh mm mn mo mp b">longRunningMultiplyBy10 </code>)与调用程序函数的执行(在本例中为<code class="eh mm mn mo mp b">asyncMultiplyBy10AndAddAwaitImmediately</code>)同时运行。</p><p id="6e22" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们解决这种低效率的时候，直到我们需要使用任务的结果，然后测试我们的功能</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="0deb" class="lm kp hu mp b fv mu mv l mw mx">private async Task&lt;int&gt; asyncMultiplyBy10AndAddAwaitAtEnd(int num1, int num2)<br/>{<br/>    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    Task&lt;int&gt; a = longRunningMultiplyBy10(num1);</span><span id="0f63" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Calling long running Op from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    Task&lt;int&gt; b = longRunningMultiplyBy10(num2);</span><span id="b8df" class="lm kp hu mp b fv my mv l mw mx">    Console.WriteLine("Executing return from Thread " + System.Threading.Thread.CurrentThread.ManagedThreadId);<br/>    return await a + await b;<br/>}</span></pre><p id="7a66" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们得到以下结果:</p><pre class="jq jr js jt fq mq mp mr ms aw mt dt"><span id="f620" class="lm kp hu mp b fv mu mv l mw mx">##### Testing await at end #####<br/>Calling long running Op from Thread 1<br/># Initiated long running op on for the input number=15 from Thread 1 #<br/>Calling long running Op from Thread 1<br/># Initiated long running op on for the input number=33 from Thread 1 #<br/>Executing return from Thread 1<br/># Completed long running op on for the input number=33 from Thread 8 #<br/># Completed long running op on for the input number=15 from Thread 6 #<br/>Runtime: 00min:10s.04ms<br/>####################################</span></pre><p id="ccd9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">长时间运行的操作一被调用就开始执行。调用函数和长时间运行的操作同时继续执行。有效异步编码的函数的运行时间只有<strong class="it hv">10 秒 04 毫秒</strong>:这比调用 2 个长时间运行的操作的同步实现有 50%的延迟改进<strong class="it hv"/>。由于异步编码的函数操作调用两个长时间运行的操作，从而允许它们并发运行，因此 50%的性能提升是意料之中的。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff na"><img src="../Images/cf219d5ed2598e91a756acb7188c4028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLskb_YvmGvH8P9i8E8XwQ.jpeg"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Santa Monica on a hottest August day in 2018 (my most favorite picture of the past 12 months)</figcaption></figure><h1 id="44f8" class="ko kp hu bd kq kr nb kt ku kv nc kx ky kz nd lb lc ld ne lf lg lh nf lj lk ll dt translated">什么是异步编程，它是如何工作的</h1><p id="cedc" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">正如我们现在所观察到的，异步编程允许我们有效地利用线程并发运行任务。当一个异步函数被调用时，控制立即返回给调用函数(一旦异步函数的同步部分完成)，调用函数和被调用函数在不同的线程上同时执行，直到调用函数必须完成被调用函数。这有助于通过有效地利用线程池将任务实例分配给并发运行的不同线程来增加吞吐量(单位时间内完成的工作),从而改善整体程序延迟(程序运行所需的总时间)。</p><h1 id="b7e4" class="ko kp hu bd kq kr nb kt ku kv nc kx ky kz nd lb lc ld ne lf lg lh nf lj lk ll dt translated">参考</h1><p id="0999" class="pw-post-body-paragraph ir is hu it b iu ma iw ix iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo hn dt translated">[1]<a class="ae kg" href="https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/" rel="noopener ugc nofollow" target="_blank">https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/</a><br/>【2】定义多线程术语<a class="ae kg" href="https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html" rel="noopener ugc nofollow" target="_blank"> Oracle 多线程编程指南</a><br/>【3】第十四章并发&amp;C # 5.0 的异步<a class="ae kg" href="https://www.amazon.com/C-5-0-Nutshell-Definitive-Reference-dp-1449320104/dp/1449320104/ref=mt_paperback?_encoding=UTF8&amp;me=&amp;qid=" rel="noopener ugc nofollow" target="_blank">简而言之:权威参考第五版作者:Joseph Albahari，Ben Albahari(作者)</a></p><p id="2f40" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Hilton Lange 的一个大喊:他对异步编程和演示异步程序的解释启发了我写这篇博客。</p></div><div class="ab cl kh ki hc kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hn ho hp hq hr"><p id="9e0f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="kf">原载于 2019 年 7 月 3 日</em><a class="ae kg" href="https://deeptanshumalik.com/2019/07/03/async-programming-demo/" rel="noopener ugc nofollow" target="_blank"><em class="kf">deeptanshumalik.com</em></a><em class="kf">。</em></p></div></div>    
</body>
</html>