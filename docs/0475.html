<html>
<head>
<title>Swift Multi-Threading using GCD For Beginners.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者使用 GCD 的快速多线程。</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/swift-multi-threading-using-gcd-for-beginners-2581b7aa21cb#2019-01-19">https://medium.com/hackernoon/swift-multi-threading-using-gcd-for-beginners-2581b7aa21cb#2019-01-19</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/efa6cde6edb9a866fbfbb5acea2a44d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJjow20BfCPn5bh8211khw.png"/></div></div></figure><h1 id="cb52" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated"><strong class="ak">简介:什么是大中央调度(GCD) </strong></h1><blockquote class="ka kb kc"><p id="b4d3" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb hn dt translated">据苹果:<br/>“GCD 提供并管理 FIFO 队列，你的应用可以以块对象的形式向其提交任务。提交到调度队列的工作在完全由系统管理的线程池中执行。不保证任务在哪个线程上执行。</p></blockquote><p id="663e" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">换句话说，GCD 是 apple 提供的一个 API，允许您以一种平滑的方式管理并发操作，以避免您的应用程序冻结，并保持它始终响应用户。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="a472" class="jc jd hu bd je jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz dt translated">队列类型:</h1><p id="ae2e" class="pw-post-body-paragraph kd ke hu kg b kh lr kj kk kl ls kn ko lc lt kr ks ld lu kv kw le lv kz la lb hn dt translated">在处理 GCD 时，有 3 种类型的队列:</p><h2 id="53fa" class="lw jd hu bd je lx ly lz ji ma mb mc jm lc md me jq ld mf mg ju le mh mi jy mj dt translated"><strong class="ak"> 1-主队列:</strong></h2><p id="1ee3" class="pw-post-body-paragraph kd ke hu kg b kh lr kj kk kl ls kn ko lc lt kr ks ld lu kv kw le lv kz la lb hn dt translated">这个队列具有最高的优先级，它运行在主线程上。所有的用户界面更新都应该在这个线程上完成，否则你的应用程序会出现滞后和奇怪的崩溃。你可以像这样简单地使用它:</p><figure class="ml mm mn mo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mk"><img src="../Images/9e3b34d3ffa1c92544c0db2d35170bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*jC62XxHntUd7Gb7IEKU5gg.png"/></div></div></figure><h2 id="8579" class="lw jd hu bd je lx ly lz ji ma mb mc jm lc md me jq ld mf mg ju le mh mi jy mj dt translated">2-全局队列:</h2><p id="a7ab" class="pw-post-body-paragraph kd ke hu kg b kh lr kj kk kl ls kn ko lc lt kr ks ld lu kv kw le lv kz la lb hn dt translated">根据 QOS(服务质量)，从最高优先级到最低优先级，该队列分为 4 种主要类型和一种默认类型:</p><p id="4528" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">1-用户互动:<em class="kf">工作几乎是即时的。类似于主线程。<br/> </em> 2-用户发起:工作<strong class="kg hv">几乎是瞬间的</strong>，比如<strong class="kg hv">几秒钟或者更少。<br/> <strong class="kg hv"> 3-默认</strong>:平时不用，类型会由系统推断<br/> 4-效用:工作需要几秒到几分钟。<br/> 5-背景:工作需要大量时间，例如<strong class="kg hv">分钟或</strong>小时。</strong></p><p id="6ebf" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">实用程序和后台线程都应该用于需要时间的繁重操作，以免阻塞主线程。<br/>你可以简单地调用一个如下:</p><figure class="ml mm mn mo fq iv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/30dc80a208131d51bf644ce2203f69a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*_y6xTVvJQ0cdIqs9P0I8Vg.png"/></div></figure><h2 id="a645" class="lw jd hu bd je lx ly lz ji ma mb mc jm lc md me jq ld mf mg ju le mh mi jy mj dt translated">3-自定义队列:</h2><p id="c975" class="pw-post-body-paragraph kd ke hu kg b kh lr kj kk kl ls kn ko lc lt kr ks ld lu kv kw le lv kz la lb hn dt translated">自定义队列是您可以自己创建的队列，并提供您想要的任何 QOS 和属性:</p><figure class="ml mm mn mo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mq"><img src="../Images/1b2440e743724422d03b9998ff0b50d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HHyZRAiUfRF2Kw51t0TngQ.png"/></div></div></figure><h1 id="7015" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">一起使用队列:</h1><p id="bd0f" class="pw-post-body-paragraph kd ke hu kg b kh lr kj kk kl ls kn ko lc lt kr ks ld lu kv kw le lv kz la lb hn dt translated">通常在现实世界中，您经常需要一起使用这些队列。<br/>比方说，你需要做一个繁重的操作，比如下载和图像，然后在 imageView 中显示这个图像。你按如下方式做:</p><figure class="ml mm mn mo fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/a539e2d57308356bc8c23d1dd7bd72b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPWzUUUEzhKMCyyB4rnl_A.png"/></div></div></figure><p id="872f" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">正如你所注意到的，我们在后台线程中做了大量耗时的操作，然后使用主线程在 imageView 中显示图像。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="536f" class="jc jd hu bd je jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz dt translated">异步与同步:</h1><p id="cb91" class="pw-post-body-paragraph kd ke hu kg b kh lr kj kk kl ls kn ko lc lt kr ks ld lu kv kw le lv kz la lb hn dt translated">正如你在上面的例子中看到的，我们在每个队列后使用了单词 async。使用 GCD，您可以同步或异步地分派任务。<br/> Sync 表示在同步操作完成之前不会启动其他任务，而 Async 则允许其他任务启动，即使它尚未完成。</p><p id="38b3" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">让我们看看现实世界中的例子:</p><div class="ml mm mn mo fq ab cb"><figure class="ms iv mt mu mv mw mx paragraph-image"><img src="../Images/9328966e7711896c5f63b7008489675d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1414/format:webp/1*Coy9pJvN-gg6VsPy-OHBew.png"/></figure><figure class="ms iv my mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/abad3f89d40419d9ec8445809626481c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*P7FaXqAI-RZelJeChvPHAg.png"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek nd di ne nf">The Emojis are used to help distinguish between each thread.</figcaption></figure></div><p id="0c37" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">注意，在上面的例子中，两个任务都是异步的，它们是同时执行的。然而，用户交互线程比后台线程有更高的执行优先级，这在前面讨论过。<br/>现在让我们看看，如果第一个任务是同步，会发生什么:</p><div class="ml mm mn mo fq ab cb"><figure class="ms iv ng mu mv mw mx paragraph-image"><img src="../Images/5a52e2d07ac3b9aa0ba4760d01fef9e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*EIzRlmpLJBeDsmtfIN1DPA.png"/></figure><figure class="ms iv nh mu mv mw mx paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><img src="../Images/caacbb4866b8f986da701ac81e28dafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*L52NppUKB6b9VWYI4YNBbA.png"/></div></figure></div><p id="e551" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">正如您所看到的，尽管 userInteractive 线程具有更高的优先级，但它直到第一个同步任务完成后才被执行。</p><p id="8501" class="pw-post-body-paragraph kd ke hu kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb hn dt translated">尽管上面的例子很简单，但它清楚地显示了一个程序如何处理同步和异步运行的队列，所以除非需要，否则您应该知道使用 sync，并且在大多数情况下使用 async 以避免在用户面前阻塞您的应用程序。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="cf12" class="jc jd hu bd je jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz dt translated">结论:</h1><p id="a6b0" class="pw-post-body-paragraph kd ke hu kg b kh lr kj kk kl ls kn ko lc lt kr ks ld lu kv kw le lv kz la lb hn dt translated">关于如何管理应用程序中的线程，还有很多需要了解的内容可以放在一篇文章中。但是作为初学者，重要的是要知道，你不应该异步地执行缓慢或昂贵的进程，你应该总是在低优先级线程上执行它们(例如:后台线程)，并且总是记住在主线程上进行任何 UI 更新。</p></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h1 id="92e2" class="jc jd hu bd je jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz dt translated">关于 GCD 的一些重要参考资料:</h1><ul class=""><li id="78e8" class="ni nj hu kg b kh lr kl ls lc nk ld nl le nm lb nn no np nq dt translated"><a class="ae nr" href="https://www.raywenderlich.com/5370-grand-central-dispatch-tutorial-for-swift-4-part-1-2" rel="noopener ugc nofollow" target="_blank"> Ray Wenderlich </a>线程教程。</li><li id="fde1" class="ni nj hu kg b kh ns kl nt lc nu ld nv le nw lb nn no np nq dt translated"><a class="ae nr" href="https://www.appcoda.com/grand-central-dispatch/" rel="noopener ugc nofollow" target="_blank"> Appcoda </a>关于并发的文章。</li><li id="4816" class="ni nj hu kg b kh ns kl nt lc nu ld nv le nw lb nn no np nq dt translated">当然了..<a class="ae nr" href="https://developer.apple.com/documentation/dispatch" rel="noopener ugc nofollow" target="_blank">苹果文档</a>。</li></ul></div><div class="ab cl lf lg hc lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hn ho hp hq hr"><h2 id="9552" class="lw jd hu bd je lx ly lz ji ma mb mc jm lc md me jq ld mf mg ju le mh mi jy mj dt translated"><strong class="ak">如果你有兴趣，请阅读我关于 swift 内存管理的文章:</strong></h2><div class="nx ny fm fo nz oa"><a rel="noopener follow" target="_blank" href="/@BarekJaafar/swift-avoiding-memory-leaks-by-examples-f901883d96e5"><div class="ob ab ej"><div class="oc ab od cl cj oe"><h2 class="bd hv fv z el of eo ep og er et ht dt translated">Swift:通过示例避免内存泄漏</h2><div class="oh l"><h3 class="bd b fv z el of eo ep og er et ek translated">在 Swift 中，自动引用计数(ARC)用于管理 iOS 应用程序中的内存使用。每次你创造…</h3></div><div class="oi l"><p class="bd b gc z el of eo ep og er et ek translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ja oa"/></div></div></a></div></div></div>    
</body>
</html>