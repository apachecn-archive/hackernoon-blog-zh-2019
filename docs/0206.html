<html>
<head>
<title>WebSockets &amp; API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebSockets &amp; API网关</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/websockets-api-gateway-9d4aca493d39?source=collection_archive---------1-----------------------#2019-01-09">https://medium.com/hackernoon/websockets-api-gateway-9d4aca493d39?source=collection_archive---------1-----------------------#2019-01-09</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="dc70" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">快速的实际操作演示</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/cab1ce97d7725d2c8d6a56d2e82bc5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cK1Fb7RsEuzlnnPC3zgrog.png"/></div></div></figure><p id="c7be" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">2018年，我赢得了许多关于为什么无服务器WebSocket API网关永远不会工作的虚构论点。我错了。</p><p id="b44f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在我道歉之前，让我解释一下:当状态与执行逻辑分离时，无服务器模式工作得最好，但是我认为这两者在实时应用程序中是不可分的，与连接状态有关。所以当<a class="ae kr" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> API Gateway </a>团队在re:Invent上宣布支持WebSocket时，我渴望了解更多。</p><p id="dad0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">让我们将一个简单的实时应用程序重构为一个无服务器的实时应用程序，并将其部署到WebSocket API网关。</p><h2 id="daab" class="ks kt hu bd ku kv kw kx ky kz la lb lc ke ld le lf ki lg lh li km lj lk ll lm dt translated">你好你好</h2><p id="1b35" class="pw-post-body-paragraph jv jw hu jx b jy ln iv ka kb lo iy kd ke lp kg kh ki lq kk kl km lr ko kp kq hn dt translated">我们从一个简单的NodeJS客户机开始，它与wss://echo.websocket.org对话:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="33ad" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我还准备了一个演示<a class="ae kr" href="https://github.com/robzhu/ws-demos" rel="noopener ugc nofollow" target="_blank">回购</a>:</p><pre class="jk jl jm jn fq lu lv lw lx aw ly dt"><span id="aa8c" class="ks kt hu lv b fv lz ma l mb mc">git clone <a class="ae kr" href="https://github.com/robzhu/ws-demos" rel="noopener ugc nofollow" target="_blank">https://github.com/robzhu/ws-demos</a><br/>cd ws-demos/echo<br/>npm install<br/>node client wss://echo.websocket.org</span><span id="0491" class="ks kt hu lv b fv md ma l mb mc"># Once the process starts, type something and press enter<br/>connected<br/>&gt; happy 2019<br/>From server: happy 2019</span></pre><p id="49e8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果我们想在本地实现echo服务器功能:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ls lt l"/></div></figure><pre class="jk jl jm jn fq lu lv lw lx aw ly dt"><span id="fff7" class="ks kt hu lv b fv lz ma l mb mc"># Terminal Tab A<br/>node serverLocal<br/># Terminal Tab B, note 'ws' protocol, not 'wss'<br/>node client ws://localhost:8080</span></pre><p id="5def" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们如何准备这些代码来使用API Gateway呢？这十行代码实际上做了几件事:</p><ul class=""><li id="8737" class="me mf hu jx b jy jz kb kc ke mg ki mh km mi kq mj mk ml mm dt translated">接受传入的websocket连接</li><li id="acdb" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">监听传入的消息</li><li id="ce23" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">给予消息处理程序对源套接字的访问权，通过源套接字将数据发送回客户端</li><li id="7cdf" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">(隐式)处理客户端断开连接</li></ul><p id="f90c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">如果我们将这段代码粘贴到一个无服务器函数中，它将需要不断地运行来处理传入的连接请求，这违反了无服务器函数的按需特性。</p><p id="d6bb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">然而，如果我们将内部echo逻辑隔离为一个无服务器的函数，我们将需要为它提供某种方式来与API网关持有的WebSockets进行通信。因为无服务器函数是无状态的，所以我们在上面的函数闭包中的对象引用是不够的。相反，我们需要一个表示连接的可序列化令牌，我们称之为“connectionId”:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="a056" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在隔离<em class="ms"> echo </em>功能逻辑的过程中，我们还分离了API网关的职责，尽管这是一个过于简单的例子(这里有一个关于API网关实际工作方式的<a class="ae kr" href="https://www.youtube.com/watch?v=3SCdzzD0PdQ" rel="noopener ugc nofollow" target="_blank">视频</a>)。</p><p id="454d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在第10–28行，我们定义了三个特殊的默认动作处理程序:<em class="ms">连接</em>、<em class="ms">断开</em>和<em class="ms">默认</em>(处理任何没有在<em class="ms">自定义动作</em>中明确定义的消息)。</p><p id="96c4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="ms"> echo </em>自定义动作处理程序现在将<em class="ms"> connectionId </em>和<em class="ms"> data </em>作为显式函数参数，两者都是字符串。唯一的外部依赖是<em class="ms">发送</em>，我们很快就会回来</p><p id="4633" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们还修改了协议，要求客户端发送类似于{ " action ":…" data ":…}的请求。这只是一行(18)的变化:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="696f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">要测试新重构的服务器和客户机:</p><pre class="jk jl jm jn fq lu lv lw lx aw ly dt"><span id="1012" class="ks kt hu lv b fv lz ma l mb mc"># Terminal Tab A<br/>node serverWithActions<br/># Terminal Tab B, note 'ws' protocol, not 'wss'<br/>node clientWithActions ws://localhost:8080</span></pre><p id="ad93" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们准备在API Gateway中创建WebSocket API。登录AWS，(我在北弗吉尼亚地区测试了这个演示，但是在其他地区应该也可以)。打开<a class="ae kr" href="https://console.aws.amazon.com/apigateway" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>，点击“创建API”，选择WebSocket，填写以下设置:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/bdafb059b360d6673630ef6d0bfae1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*gIm78iVzP42834Am2Y5DEg.png"/></div></figure><p id="fdb5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">仔细检查路由选择表达式是否为“$request.body.action”，因为该表达式告诉API Gateway如何确定调用哪个操作。</p><p id="e5f2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">接下来，单击“创建API”，您应该会看到Routes页面。添加“echo”作为“新路由关键字”,然后单击“检查”按钮:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/bb8ae6aed0a519f18c4cfe719600438e.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*vhDo86afT12xAxmq7ZJg6g.png"/></div></figure><p id="7cd6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在新的浏览器标签中，打开<a class="ae kr" href="https://console.aws.amazon.com/lambda" rel="noopener ugc nofollow" target="_blank"> Lambda AWS控制台</a>，点击“创建功能”，然后选择“从头开始创作”</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/e473754fed7e2ecbea4497c5e869be74.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*hgErVA0FsSZE4KkijuI9Ng.png"/></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mw"><img src="../Images/aa575498493dc210a1dd134180339868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lBn-a0068L8TIB3Efco0vQ.png"/></div></div></figure><p id="7e0f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">给你的函数起一个名字，比如“WSDemoEchoHandler”，选择一个IAM角色，这个角色有权限<a class="ae kr" href="https://gist.github.com/robzhu/aec8f92c404ff29465fc3e874812c708" rel="noopener ugc nofollow" target="_blank">管理web socket连接</a>。如果您的Lambda函数没有IAM角色，请选择“创建自定义角色”,然后编辑策略，在上面的链接中包含Allow语句。例如，一个完整的策略可能看起来像<a class="ae kr" href="https://gist.github.com/robzhu/2a496e62840b0fcca3caaa5472043c51" rel="noopener ugc nofollow" target="_blank"> this </a>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mx"><img src="../Images/1fb0063b8d8e85c715468325403ec3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjJ__doOZyQMmMSvR-L5Ww.png"/></div></div></figure><p id="d921" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">WebSocket API仍然非常新，所以我们需要为现有的<em class="ms"> aws-sdk </em>模块添加一些功能。在嵌入式代码编辑器中，右键单击您的函数文件夹并选择“新建文件”:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff my"><img src="../Images/7ea3005c4221f13da4f89fcec602f477.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*nzipyJLWzKgeFfD52qLYhg.png"/></div></figure><p id="050b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">将其命名为“patch.js”并粘贴到这个文件的<a class="ae kr" href="https://gist.githubusercontent.com/robzhu/2714d1c5183be9e620beba8b0d567544/raw/ed8b172569a0af95831f1221e0d80fce8dca791d/patch.js" rel="noopener ugc nofollow" target="_blank">内容中。接下来，打开“index.js”并粘贴以下内容:</a></p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ls lt l"/></div></figure><p id="5a9c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">还记得早先echo函数的本地实现依赖于“send”函数的时候吗？现在我们可以看到它是如何通过aws-sdk实现的。</p><p id="4b23" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">保存Lambda并返回到API网关控制台选项卡。在“Lambda Function”字段中，输入我们刚刚创建的Lambda函数的名称:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mz"><img src="../Images/f7f1d05c627a9a92b1492fbae83052df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1Wt1zRh5Kbp1z4yFOscKg.png"/></div></div></figure><p id="6f9d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过这种方式，API网关知道调用WSDemoEchoHandler函数来响应对echo <em class="ms"> " </em> route "的请求。请注意,“路由”不是指HTTP路由。一旦连接了路由，我们就可以部署我们的API了:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff na"><img src="../Images/3579e67d2da6048abbe44ff2607ae868.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*BZKhKIBRPHefyYTKtgDe-Q.png"/></div></figure><p id="1567" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们需要定义一个新的部署阶段:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/4c9dd07f59c3c4aaa8bc9e15b3d95aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*YMrQ2Jy0Q-99h6NP7R8cCw.png"/></div></figure><p id="cf07" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">部署完成后，您将看到Stage编辑器，它显示了新WebSocket API的URL:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff nc"><img src="../Images/97b5c1e43652cab459929dc5d12c61ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bO7vB9pd9VvGsDAHsySfpA.png"/></div></div></figure><p id="15c2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">复制顶部“WebSocket URL”字段的文本。看起来会是:<em class="ms">WSS://something . execute-API . us-east-1 . Amazon AWS . com/prod</em><em class="ms">。</em></p><p id="646f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">回到我们的终端窗口，我们可以测试新的WebSocket API:</p><pre class="jk jl jm jn fq lu lv lw lx aw ly dt"><span id="29df" class="ks kt hu lv b fv lz ma l mb mc">node clientWithActions.js wss://something.execute-api.us-east-1.amazonaws.com/prod<br/>meow<br/>From server: Echo: meow</span></pre><p id="c2f5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">目前就是这样，但还有一些后续主题需要探索:</p><ul class=""><li id="e0eb" class="me mf hu jx b jy jz kb kc ke mg ki mh km mi kq mj mk ml mm dt translated">当连接仍然处于活动状态时，在API重新部署和Lambda函数更新期间会发生什么？</li><li id="0f04" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">使用fanout构建真正的应用程序</li><li id="9859" class="me mf hu jx b jy mn kb mo ke mp ki mq km mr kq mj mk ml mm dt translated">与API网关团队的访谈和架构讨论。</li></ul><p id="4524" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">那些话题听起来有趣吗？你被卡住了吗？请留言或发邮件给我(robzhu at amazon dot com)。</p></div></div>    
</body>
</html>