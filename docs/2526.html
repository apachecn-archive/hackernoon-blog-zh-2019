<html>
<head>
<title>ES6 and Beyond &gt; Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6及以后&gt;第1部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/es6-and-beyond-28aed8574e00?source=collection_archive---------1-----------------------#2019-04-20">https://medium.com/hackernoon/es6-and-beyond-28aed8574e00?source=collection_archive---------1-----------------------#2019-04-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/406d8b96abf2637c7ef448c3b3af7964.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnFCu3IeIhmvPg3GCk769A.jpeg"/></div></div></figure><p id="de9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">大家好，</p><p id="2676" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ES6，这几天在前端世界里非常热门的话题。</p><p id="902d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，学习一下<strong class="je hv"> ES6和超越</strong> <em class="ka"> (like，ES7，ES8) </em>的一些很酷的功能怎么样。</p><p id="bd6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先要做的事。</p><blockquote class="kb kc kd"><p id="f94f" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated"><em class="hu">ES是什么意思？</em></p></blockquote><p id="e936" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kh ki kj kk b">ES</code>代表<code class="eh kh ki kj kk b">ECMAScript</code>。</p><blockquote class="kb kc kd"><p id="3b64" class="jc jd ka je b jf jg jh ji jj jk jl jm ke jo jp jq kf js jt ju kg jw jx jy jz hn dt translated">那么,“ECMAScript”和“JavaScript”有什么不同呢？</p></blockquote><ul class=""><li id="5abe" class="kl km hu je b jf jg jj jk jn kn jr ko jv kp jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">ECMAScript</code>是标准，而<code class="eh kh ki kj kk b">JavaScript</code>也是标准。<strong class="je hv"> <em class="ka">而是</em> </strong>，</li><li id="8fe4" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">ECMAScript</code>是规范，<code class="eh kh ki kj kk b">JavaScript</code>是<code class="eh kh ki kj kk b">ECMAScript</code>规范的实现。</li></ul><p id="5caa" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么，我们开始吧。</p><h2 id="91b5" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">我们要学什么？</h2><ul class=""><li id="9765" class="kl km hu je b jf lu jj lv jn lw jr lx jv ly jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">let</code></li><li id="62a2" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">const</code></li><li id="8d8e" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated">对象静止/扩散属性</li><li id="991f" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated">箭头功能</li><li id="19a0" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated">字符串插值</li><li id="5bd8" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated">指数<code class="eh kh ki kj kk b">**</code></li><li id="476d" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">Array.prototype.includes</code></li><li id="2b9e" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">String.prototype.padStart</code></li><li id="874d" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">String.prototype.padEnd</code></li><li id="3c42" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">Object.values</code></li><li id="b35a" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated"><code class="eh kh ki kj kk b">Object.entries</code></li></ul><h2 id="0739" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">让</h2><p id="25ba" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated"><code class="eh kh ki kj kk b">let</code>是新的<code class="eh kh ki kj kk b">var</code>，但优点是它是可访问的&amp;仅在范围内可用。让我们看一个例子。</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="032f" class="kz la hu kk b fv mk ml l mm mn">function let_n_var() {<br/>    console.log(foo);<br/>    if(true) {<br/>        let foo = 'foo';<br/>    }<br/>}<br/>let_n_var();</span><span id="deb2" class="kz la hu kk b fv mo ml l mm mn">// Output: Uncaught ReferenceError: foo is not defined</span></pre><p id="1234" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的例子中，如果你用<code class="eh kh ki kj kk b">var</code>替换<code class="eh kh ki kj kk b">let</code>，输出将是<code class="eh kh ki kj kk b">undefined</code>并且没有错误。因此，如你所见，<code class="eh kh ki kj kk b">let</code>帮助我们捕捉早期错误，避免范围混乱。</p><h2 id="c09e" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">常数</h2><p id="23db" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">这又是一种声明<code class="eh kh ki kj kk b">var</code>的新方法，但是不同之处在于一旦定义了<code class="eh kh ki kj kk b">const</code>，我们就不能给它重新赋值。</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="6105" class="kz la hu kk b fv mk ml l mm mn">const baz = 'baz';<br/>console.log('baz: ', baz);<br/>// Output: baz<br/>baz = 'baaz'<br/>// Output: Uncaught TypeError: Assignment to constant variable.</span></pre><p id="30f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们所知，JavaScript是一种动态语言，我们在用不同的数据类型或数据更新变量时容易出错，<code class="eh kh ki kj kk b">const</code>有助于我们不覆盖已设置的值。</p><h2 id="6320" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">对象静止/扩散属性</h2><p id="17c0" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">让我们来看一个例子。</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="a0df" class="kz la hu kk b fv mk ml l mm mn">// Rest<br/>const vowels = ['A', 'E', 'I', 'O', 'U'];<br/>const [firstVowel, secondVowel, ...restVowels] = vowels;<br/>console.log(firstVowel); // Output: 'A'<br/>console.log(secondVowel);// Output: 'E'<br/>console.log(restVowels); // Output: ['I', 'O', 'U']</span></pre><p id="4fc1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在上面的代码片段中，我试图将变量<code class="eh kh ki kj kk b">vowels</code>的值放入前两个元音的独立变量中，并保留在rest变量中。下面是实现同样目标的步骤。</p><ul class=""><li id="2fd2" class="kl km hu je b jf jg jj jk jn kn jr ko jv kp jz kq kr ks kt dt translated">用数组符号创建一个变量:<code class="eh kh ki kj kk b">[firstVowel, secondVowel]</code>。将变量<code class="eh kh ki kj kk b">vowels</code>赋给它。这将给出相应变量中的前两个元音(基于索引)</li><li id="f19e" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated">现在，数组符号中第三个值的一部分，使用带有变量名的<code class="eh kh ki kj kk b">...</code>。<code class="eh kh ki kj kk b">restVowels</code>如。所以，变量看起来会像<code class="eh kh ki kj kk b">const [firstVowel, secondVowel, ...restVowels]=vowels;</code></li><li id="050a" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz kq kr ks kt dt translated">当代码执行时，它将创建具有上述值的变量。实现相同结果的替代方法可以是:</li></ul><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="a47f" class="kz la hu kk b fv mk ml l mm mn">const firstVowel = vowels[0];<br/>const secondVowel = vowels[1];<br/>const restVowels = vowels.slice(2); // all remaining values</span></pre><p id="c1be" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">但是，rest方法使代码更具可读性和可管理性。</p><p id="9aaf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下是考虑到上述代码块的<strong class="je hv">扩展</strong>的代码示例(用于rest)</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="2eed" class="kz la hu kk b fv mk ml l mm mn">// Rest<br/>const vowels = ['A', 'E', 'I', 'O', 'U'];<br/>const [firstVowel, secondVowel, ...restVowels] = vowels;</span><span id="b97b" class="kz la hu kk b fv mo ml l mm mn">// Spread<br/>const vowelsWithOneConsonant = ['B', ...vowels];<br/>console.log(vowelsWithOneConsonant); // Output: ['B', 'A', 'E', 'I', 'O', 'U']</span></pre><p id="e02e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如你在上面看到的，很容易扩展变量<code class="eh kh ki kj kk b">vowels</code>来创建一个具有相同和一个附加值的新变量。</p><p id="d363" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些相同的概念也可以应用在物体上。继续做一些练习。一旦你学会并习惯了，使用起来会很有趣。</p><h2 id="518f" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">箭头功能</h2><p id="1912" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">这是<code class="eh kh ki kj kk b">function</code>的简写符号，但是<code class="eh kh ki kj kk b">this</code>的绑定方式不同。</p><p id="a567" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们先来了解一下语法。</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="5930" class="kz la hu kk b fv mk ml l mm mn">// standard way of defining function<br/>function getName() {<br/>   console.log('getName function');<br/>}<br/>// converted to arrow function<br/>const getName = () =&gt; {<br/>   console.log('getName function');<br/>}</span></pre><p id="cb6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当从函数返回值时，这变得更加有趣和简单。</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="4746" class="kz la hu kk b fv mk ml l mm mn">const getName = (name) =&gt; 'Hello' + name;<br/>console.log(getName('Anand')); // Output: Hello Anand</span></pre><p id="1057" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">乍一看，它可能看起来令人困惑，但是让我们稍微分解一下代码。</p><ol class=""><li id="c1d3" class="kl km hu je b jf jg jj jk jn kn jr ko jv kp jz mp kr ks kt dt translated">我们创建了一个名为<code class="eh kh ki kj kk b">getName</code>的<code class="eh kh ki kj kk b">const</code>变量</li><li id="1e23" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz mp kr ks kt dt translated">为箭头功能<code class="eh kh ki kj kk b">() =&gt; {//function body}</code>指定了一个功能简写</li><li id="4fef" class="kl km hu je b jf ku jj kv jn kw jr kx jv ky jz mp kr ks kt dt translated">默认情况下，如果我们的代码不需要多于一行，那么arrow函数不需要任何括号。如果需要，使用花括号。如果没有花括号，arrow函数返回执行的代码行。在上面的例子中，它返回<code class="eh kh ki kj kk b">Hello Anand</code></li></ol><p id="13e0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，上面的代码也可以写成如下所示，输出也是一样的。</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="942f" class="kz la hu kk b fv mk ml l mm mn">const getName = (name) =&gt; {<br/>     return 'Hello' + name;<br/>}<br/>console.log(getName('Anand')); // Output: Hello Anand</span></pre><p id="5510" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">经过一些练习，你就会明白了。继续，启动浏览器控制台并做一些练习。你要做的一个练习是，与普通函数相比，检查箭头函数的“this”行为。</p><h2 id="401c" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">字符串插值</h2><p id="8590" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">在javascript的早期，如果我们需要创建带有一些动态值的字符串，我们通常使用<code class="eh kh ki kj kk b">+</code>。如果真的变大了，迟早会变得更混乱。</p><p id="084b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以，字符串插值来拯救。语法是用反勾(`)代替单引号/双引号。而且，<code class="eh kh ki kj kk b">${}</code>有助于我们输入动态数据，而不用担心打开/关闭引用或因缺少<code class="eh kh ki kj kk b">+</code>或单引号/双引号而出错。</p><p id="d6ad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看下面的例子:</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="c6d3" class="kz la hu kk b fv mk ml l mm mn">// Old approach<br/>var guest = 'all';<br/>var name = 'Anand';<br/>var age = 32;<br/>var hobby1= "listening to music";<br/>var hobby2 = "mobiles games";<br/>const sayHello = "Hello " + guest + "! My name is " + name + ". My age is " + age + " years. My hobbies are " + hobby1 + ", "+ hobby2 + '.';<br/>console.log(sayHello); // Output: Hello all! My name is Anand. My age is 32 years. My hobbies are listening to music, mobiles games.</span></pre><p id="2b19" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我敢肯定，这对你们来说已经很困惑了。现在看看下面的例子</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="1426" class="kz la hu kk b fv mk ml l mm mn">// New approach<br/>const guest = 'all';<br/>const name = 'Anand';<br/>const age = 32;<br/>const hobby1= "listening to music";<br/>const hobby2 = "mobiles games";<br/>const sayHello = `Hello ${guest}! My name is ${name}. My age is ${age} years. My hobbies are ${hobby1}, ${hobby2}.`;<br/>console.log(sayHello); // Output: Hello all! My name is Anand. My age is 32 years. My hobbies are listening to music, mobiles games.</span></pre><p id="6405" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">很酷吧。😎</p><h2 id="c4fa" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">指数的</h2><p id="62b1" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">我相信你们都知道数学。在Javascript中，我们曾经使用<code class="eh kh ki kj kk b">Math.pow(5, 6); // Output: 15625</code>来获取指数。</p><p id="a314" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们有一个捷径，通过做<code class="eh kh ki kj kk b">3 ** 4; // Output: 15625</code>得到同样的结果。<br/>所以，我们可以这样说:</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="2ddd" class="kz la hu kk b fv mk ml l mm mn">Math.pow(5, 6) == 5 ** 6;</span></pre><h2 id="e961" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">数组.原型.包含</h2><p id="246a" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">顾名思义，我们可以使用<code class="eh kh ki kj kk b">includes</code>通过检查值是否包含来获得<code class="eh kh ki kj kk b">true</code>或<code class="eh kh ki kj kk b">false</code>结果值。<br/>举例:</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="ca72" class="kz la hu kk b fv mk ml l mm mn">[1, 2].includes(1); // true<br/>[1, 3].includes(2); // false<br/>var foo = 'foo';<br/>foo.includes('f'); // true<br/>foo.includes('F'); // false<br/>// So, it is case sensitive too. Please take care.</span></pre><h2 id="fa0e" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">String.prototype.padStart/String.prototype.padEnd</h2><p id="d185" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">这个挺有意思的。让我们先定义它。</p><p id="7ffb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kh ki kj kk b">padStart</code>和<code class="eh kh ki kj kk b">padEnd</code>用于用另一个字符串填充当前字符串，直到达到给定的字符串长度。<br/> <code class="eh kh ki kj kk b">padStart</code>从字符串的开始(左侧)应用填充。另一方面，<code class="eh kh ki kj kk b">padEnd</code>从字符串的末端(右侧)应用填充。</p><blockquote class="mq"><p id="5420" class="mr ms hu bd mt mu mv mw mx my mz jz ek translated">如果需要的话，这些函数也可以用另一个字符串多次填充当前字符串。</p></blockquote><p id="b09f" class="pw-post-body-paragraph jc jd hu je b jf na jh ji jj nb jl jm jn nc jp jq jr nd jt ju jv ne jx jy jz hn dt translated">让我们来看一个例子</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="5dcb" class="kz la hu kk b fv mk ml l mm mn">// padStart<br/>const cardNumber = '1234567812345678';<br/>const last3Digit = cardNumber.slice(-3);<br/>const maskedCardNumber = last3Digit.padStart(16, 'X');<br/>console.log(maskedCardNumber); // Output: "XXXXXXXXXXXXX678"</span><span id="49de" class="kz la hu kk b fv mo ml l mm mn">// padEnd<br/>const loremIpsum = "Lorem Ipsum is simply dummy text of the printing and";<br/>const loremIpsumWithDots = loremIpsum.padEnd(loremIpsum.length+3, '.');<br/>console.log(loremIpsumWithDots);<br/>// Output: Lorem Ipsum is simply dummy text of the printing and...</span></pre><p id="420e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">多酷啊。它非常有趣和有用。但是一定要练习。</p><h2 id="3f29" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">对象.值</h2><p id="7f72" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">之前，如果我们需要迭代一个对象，我们会使用<code class="eh kh ki kj kk b">Object.keys</code>。但是现在，我们可以根据需要使用<code class="eh kh ki kj kk b">values</code>或<code class="eh kh ki kj kk b">entries</code>来代替<code class="eh kh ki kj kk b">keys</code>。</p><p id="dc10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因此，对于<code class="eh kh ki kj kk b">Object.values</code>，它将所有的<em class="ka">可枚举的</em>属性值作为一个数组返回。然后，就很容易直接消费掉这些价值。<br/>举例:</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="3367" class="kz la hu kk b fv mk ml l mm mn">const objectFoo = {<br/>   name: 'foo',<br/>   isAvailable: false<br/>};<br/>Object.values(objectFoo);<br/>// Output: ['foo', false]</span></pre><h2 id="69fb" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">对象.条目</h2><p id="d9fa" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">另一方面，<code class="eh kh ki kj kk b">Object.entries</code>也给出了一个数组，但是它包含对象的<em class="ka">自己的可枚举的</em>字符串键属性<code class="eh kh ki kj kk b">[key, value]</code>对。顺序与<code class="eh kh ki kj kk b">for...in</code>提供的顺序相同。<br/>举例:</p><pre class="mc md me mf fq mg kk mh mi aw mj dt"><span id="f68a" class="kz la hu kk b fv mk ml l mm mn">const objectFoo = {<br/>   name: 'foo',<br/>   isAvailable: false<br/>};<br/>Object.entries(objectFoo);<br/>// Output: [['name', 'foo'], ['isAvailable', false]]</span></pre><h2 id="c0c4" class="kz la hu bd lb lc ld le lf lg lh li lj jn lk ll lm jr ln lo lp jv lq lr ls lt dt translated">摘要</h2><p id="d458" class="pw-post-body-paragraph jc jd hu je b jf lu jh ji jj lv jl jm jn lz jp jq jr ma jt ju jv mb jx jy jz hn dt translated">这个帖子到此为止。</p><p id="cd1b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们学习了ES6+的一些关键和有用的特性。一定要自己练习。写下评论作为反馈。也请给予一些掌声，不要忘记分享。</p><figure class="mc md me mf fq iv"><div class="bz el l di"><div class="nf ng l"/></div></figure></div></div>    
</body>
</html>