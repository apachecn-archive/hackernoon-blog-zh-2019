<html>
<head>
<title>Move over Next.js and Webpack!!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移过去Next.js和Webpack！！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/move-over-next-js-and-webpack-ba367f07545?source=collection_archive---------1-----------------------#2019-01-15">https://medium.com/hackernoon/move-over-next-js-and-webpack-ba367f07545?source=collection_archive---------1-----------------------#2019-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="5697" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">简单的流式SSR与样式组件和包进行反应</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/0cd72eea58c5ceeb66f7ac3717a835a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xA00gg1teaPto3A_Cz26oA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo via my Adobe Stock Photo license.</figcaption></figure><p id="db89" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt kv translated"><span class="l kw kx ky bm kz la lb lc ld di"> O </span>当我第一次使用Next.js时，我喜欢它的一点是它让Webpack所需的大量样板文件几乎消失了。它还规定了简单的、符合逻辑的惯例，如果你遵循这些惯例，你会很容易成功。</p><p id="db46" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我发现与以前创建服务器端呈现(SSR) React应用程序的复杂性相比，这在简单性上是一个巨大的进步。</p><p id="7e69" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，去年早些时候，我意识到一个新工具可以解决我的相同问题，同时更接近核心的React API。</p><p id="d066" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我对Next.js最大的不满之一是它的自定义路由——尽管使用起来很简单——替代的React路由器真的很棒，并且有很棒的动画库，我喜欢创建看起来很漂亮的易用的东西！</p><p id="4e2c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因此，在2018年初，我放弃了Next.js和Webpack，转而使用一些“更接近金属”的东西，并开始用Parcel构建React应用。</p><p id="0dbe" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这篇文章中，我想向你展示我是如何用Parcel构建应用程序来创建流服务器端渲染的带有样式化组件的react应用程序的。</p><p id="2eb5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你想知道我为什么如此兴奋，或者还没有尝试过Parcel——Parcel是Javascript领域中较新的模块捆绑器。</p><p id="a7aa" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">“我必须学习的另一个伟大的工具”你想。</p><p id="c1e7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那鸿包裹不会像那样滚动。它是零配置的。</p><p id="fa0e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">它只是工作。</p><p id="b2bf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">可以导入。css文件，图像，以及任何你想要的东西，它完全像你所期望的那样工作。</p><p id="665d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这使得使用React生态系统中所有最新和最棒的应用程序变得非常容易，这些应用程序包括代码分割、流渲染，甚至是差异捆绑，从而可以轻松地获得最新的性能优化。</p><p id="eb3b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我想使用新的React <code class="eh le lf lg lh b">lazy</code>和<code class="eh le lf lg lh b">Suspense</code>API来实现代码分割，但是，它在服务器端仍然不受支持，所以我们将使用类似的替代方法。</p><p id="81f3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在某些情况下，它可能仍然比Next.js稍微冗长一些，但是对于我的用例来说，我更喜欢额外的可定制性。我想，如果您已经有一段时间没有评估您的工具了，您会惊讶地发现事情变得如此简单。</p><p id="8597" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是为了让你能够跟进，并以一个漂亮的新样板结束。</p><p id="cbc4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我总是有一个个人目标，让东西尽可能轻。如果这不是SSR，我会建议检查一下<a class="ae lj" href="https://github.com/jorgebucaran/hyperapp/" rel="noopener ugc nofollow" target="_blank"> Hyperapp </a>而不是React。我为一个Shopify插件开发了一个非常酷的JS SDK，这个插件在整个夏天都在推荐机器学习。</p><p id="cfa3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">那么我们还在等什么呢？我们开始吧！</p><h1 id="64a8" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">1.设置</h1><p id="1c64" class="pw-post-body-paragraph jz ka hu kb b kc mc iv ke kf md iy kh ki me kk kl km mf ko kp kq mg ks kt ku hn dt translated">首先，使用以下目录结构创建一个新项目——一个文件，两个文件夹。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="2632" class="ml ll hu lh b fv mm mn l mo mp">- app/<br/>- server/<br/>.gitignore</span></pre><p id="19c4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们用<code class="eh le lf lg lh b">mkdir</code>做一个名为<code class="eh le lf lg lh b">stream-all-the-things</code>的目录。然后我们将cd放入那个目录，创建一个名为<code class="eh le lf lg lh b">app</code>的文件夹和一个名为<code class="eh le lf lg lh b">server</code>的文件夹。最后，我们将使用<code class="eh le lf lg lh b">touch</code>来创建我们的<code class="eh le lf lg lh b">.gitignore</code>文件。</p><p id="2884" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里有一个快速的小片段。请随意输入每一行，或者将整行内容复制并粘贴到您的终端中。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="a369" class="ml ll hu lh b fv mm mn l mo mp">mkdir stream-all-the-things &amp;&amp; cd stream-all-the-things<br/>mkdir app<br/>mkdir server<br/>touch .gitignore</span></pre><p id="02c6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是我们<code class="eh le lf lg lh b">.gitignore</code>的内容</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="ed70" class="ml ll hu lh b fv mm mn l mo mp">node_modules<br/>*.log<br/>.cache<br/>dist</span></pre><p id="5761" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，让我们安装我们需要的依赖项。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="7d3b" class="ml ll hu lh b fv mm mn l mo mp">npm init</span><span id="a573" class="ml ll hu lh b fv mq mn l mo mp">npm i --save react react-dom react-router styled-components react-helmet-async react-imported-component</span><span id="a7fa" class="ml ll hu lh b fv mq mn l mo mp">npm i --save-dev parcel-bundler react-hot-loader</span></pre><p id="2dab" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好吧，我来解释一下。虽然没什么你没见过的。</p><p id="3cb1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有你以前可能用过的基础依赖… <code class="eh le lf lg lh b">react</code>，<code class="eh le lf lg lh b">react-dom</code>，加上<code class="eh le lf lg lh b">react-router</code>。然后我们还有<code class="eh le lf lg lh b">styled-components</code>来利用<a class="ae lj" rel="noopener" href="/styled-components/v3-1-0-such-perf-wow-many-streams-c45c434dbd03">的流渲染支持</a>。除了styled-components是一个支持流式渲染的CSS-in-JS库这一事实之外，我更喜欢styled-components！它固执己见的方法有助于实施最佳实践，并且对CSS开发人员友好。</p><p id="4c95" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><code class="eh le lf lg lh b">react-helmet-async</code>是流行库<code class="eh le lf lg lh b">react-helmet</code>的异步版本，支持流SSR。它允许您在导航时更改HTML文档头中的信息。例如，更新页面的<code class="eh le lf lg lh b">title</code>。</p><p id="3770" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">此外，我们有<code class="eh le lf lg lh b">parcel-bundler</code>负责捆绑，<code class="eh le lf lg lh b">cross-env </code>负责将Windows的一些问题扼杀在萌芽状态，<code class="eh le lf lg lh b">nodemon</code>负责开发我们的服务器，<code class="eh le lf lg lh b">react-hot-loader</code>负责开发我们的客户端，<code class="eh le lf lg lh b">rimraf</code>负责清理。</p><h1 id="c08a" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">2.宗地开发模式</h1><p id="8677" class="pw-post-body-paragraph jz ka hu kb b kc mc iv ke kf md iy kh ki me kk kl km mf ko kp kq mg ks kt ku hn dt translated">看来我们的目标是如何发展的，先从发展模式说起吧。</p><p id="d90b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<code class="eh le lf lg lh b">package.json</code>的<code class="eh le lf lg lh b">scripts</code>部分添加一个<code class="eh le lf lg lh b">dev</code>脚本。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="3d7f" class="ml ll hu lh b fv mm mn l mo mp">"scripts": {<br/>  <strong class="lh hv">"dev": "parcel app/index.html"</strong><br/>}</span></pre><p id="fdc4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">对于Parcel，您只需将应用程序的入口点作为开始开发的唯一参数。</p><p id="6f81" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在让我们创建我们引用的那个<code class="eh le lf lg lh b">app/index.html</code>文件。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="1a75" class="ml ll hu lh b fv mm mn l mo mp">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"&gt;<br/>    &lt;meta content="utf-8" http-equiv="encoding"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt;      <br/>  &lt;/head&gt;<br/>  <br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;&lt;/div&gt;<br/>    &lt;script id="js-entrypoint" src="./client.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="9e4a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在其中，另一个对我们还没有创建的文件的引用:<code class="eh le lf lg lh b">client.js</code>。</p><p id="cfc7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这是我们的客户端应用程序的入口点。换句话说，起点。这是我们最初的树将被渲染的地方。</p><p id="8557" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们创建<code class="eh le lf lg lh b">app/client.js</code>，然后我将分解它。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="bc42" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import ReactDOM from 'react-dom'<br/>import App from './App'<br/>import { HelmetProvider } from 'react-helmet-async';</span><span id="8b2c" class="ml ll hu lh b fv mq mn l mo mp">const element = document.getElementById('app')<br/>const app = (<br/>  &lt;HelmetProvider&gt;<br/>    &lt;App /&gt;<br/>  &lt;/HelmetProvider&gt;<br/>)</span><span id="b2e1" class="ml ll hu lh b fv mq mn l mo mp">ReactDOM.render(app, element)</span><span id="0feb" class="ml ll hu lh b fv mq mn l mo mp">// Enable Hot Module Reloading<br/>if (module.hot) {<br/>  module.hot.accept();<br/>}</span></pre><p id="148c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，在我们测试任何东西之前，我们还需要<code class="eh le lf lg lh b">app/App.jsx</code>。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="a98d" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import Helmet from 'react-helmet-async'</span><span id="a537" class="ml ll hu lh b fv mq mn l mo mp">const App = () =&gt; (<br/>  &lt;React.Fragment&gt;</span><span id="7bd7" class="ml ll hu lh b fv mq mn l mo mp">    &lt;Helmet&gt;<br/>      &lt;title&gt;Home Page&lt;/title&gt;<br/>    &lt;/Helmet&gt;</span><span id="8cfe" class="ml ll hu lh b fv mq mn l mo mp">    &lt;div&gt;<br/>      Follow me at &lt;a href="<a class="ae lj" rel="noopener" href="/@patrickleet">https://medium.com/@patrickleet</a>"&gt;<a class="ae lj" href="http://twitter.com/patrickleet" rel="noopener ugc nofollow" target="_blank">@patrickleet</a>&lt;/a&gt;<br/>    &lt;/div&gt;<br/>    <br/>  &lt;/React.Fragment&gt;<br/>)</span><span id="3046" class="ml ll hu lh b fv mq mn l mo mp">export default App</span></pre><p id="d385" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，您应该能够运行<code class="eh le lf lg lh b">npm run dev</code>来启动您的开发服务器，进行热代码重载！</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="6945" class="ml ll hu lh b fv mm mn l mo mp">➜  npm run dev</span><span id="0efb" class="ml ll hu lh b fv mq mn l mo mp">&gt; stream-all-the-things@1.0.0 dev Users/me/dev/patrickleet/stream-all-the-things<br/>&gt; parcel app/index.html</span><span id="2391" class="ml ll hu lh b fv mq mn l mo mp">Server running at <a class="ae lj" href="http://localhost:1234" rel="noopener ugc nofollow" target="_blank">http://localhost:1234</a><br/>✨  Built in 192ms.</span></pre><p id="b291" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们去看看吧！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mr"><img src="../Images/b53c8a5052538c4506d672f96823c89d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChMo_gIazp4BEp5V84WRdA.png"/></div></div></figure><p id="0b68" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">因为你不是我，试着更新页面到你自己的链接，注意你不必重新加载就能看到你的改变！</p><h1 id="b84f" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">3.添加一些风格</h1><p id="4caf" class="pw-post-body-paragraph jz ka hu kb b kc mc iv ke kf md iy kh ki me kk kl km mf ko kp kq mg ks kt ku hn dt translated">我混合使用了全局样式和样式组件。</p><p id="425c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们添加一些基础重置和样式，并定义一些有用的CSS变量，这些变量将在数学上帮助我们即将到来的设计冒险。</p><p id="5eb1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创建文件<code class="eh le lf lg lh b">styles.js</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="3f27" class="ml ll hu lh b fv mm mn l mo mp">import { createGlobalStyle } from 'styled-components'</span><span id="7252" class="ml ll hu lh b fv mq mn l mo mp">export const GlobalStyles = createGlobalStyle`<br/>/* Base 10 typography scale courtesty of <a class="ae lj" href="http://twitter.com/wesbos" rel="noopener ugc nofollow" target="_blank">@wesbos</a> 1.6rem === 16px */<br/>html {<br/>  font-size: 10px;<br/>}</span><span id="1ae3" class="ml ll hu lh b fv mq mn l mo mp">body {<br/>  font-size: 1.6rem;<br/>}</span><span id="a116" class="ml ll hu lh b fv mq mn l mo mp">/* Relative Type Scale */<br/>/* <a class="ae lj" href="https://blog.envylabs.com/responsive-typographic-scales-in-css-b9f60431d1c4" rel="noopener ugc nofollow" target="_blank">https://blog.envylabs.com/responsive-typographic-scales-in-css-b9f60431d1c4</a> */<br/>:root {<br/>  --step-up-5: 2em;<br/>  --step-up-4: 1.7511em;<br/>  --step-up-3: 1.5157em;<br/>  --step-up-2: 1.3195em;<br/>  --step-up-1: 1.1487em;<br/>  /* baseline: 1em */<br/>  --step-down-1: 0.8706em;<br/>  --step-down-2: 0.7579em;<br/>  --step-down-3: 0.6599em;<br/>  --step-down-4: 0.5745em;<br/>  --step-down-5: 0.5em;<br/>  /* Colors */<br/>  --header: rgb(0,0,0);<br/>}</span><span id="a6c6" class="ml ll hu lh b fv mq mn l mo mp">/* <a class="ae lj" href="https://css-tricks.com/snippets/css/system-font-stack/" rel="noopener ugc nofollow" target="_blank">https://css-tricks.com/snippets/css/system-font-stack/</a> */<br/>/* Define the "system" font family */<br/>/* Fastest loading font - the one native to their device */<br/><a class="ae lj" href="http://twitter.com/font" rel="noopener ugc nofollow" target="_blank">@font</a>-face {<br/>  font-family: system;<br/>  font-style: normal;<br/>  font-weight: 300;<br/>  src: local(".SFNSText-Light"), local(".HelveticaNeueDeskInterface-Light"), local(".LucidaGrandeUI"), local("Ubuntu Light"), local("Segoe UI Light"), local("Roboto-Light"), local("DroidSans"), local("Tahoma");<br/>}</span><span id="9a7e" class="ml ll hu lh b fv mq mn l mo mp">/* Modern CSS Reset */<br/>/* <a class="ae lj" href="https://alligator.io/css/minimal-css-reset/" rel="noopener ugc nofollow" target="_blank">https://alligator.io/css/minimal-css-reset/</a> */<br/>body, h1, h2, h3, h4, h5, h6, p, ol, ul, input[type=text], input[type=email], button {<br/>  margin: 0;<br/>  padding: 0;<br/>  font-weight: normal;<br/>}</span><span id="4aed" class="ml ll hu lh b fv mq mn l mo mp">body, h1, h2, h3, h4, h5, h6, p, ol, ul, input[type=text], input[type=email], button {<br/>  font-family: "system"<br/>}</span><span id="6a91" class="ml ll hu lh b fv mq mn l mo mp">*, *:before, *:after {<br/>  box-sizing: inherit;<br/>}</span><span id="b469" class="ml ll hu lh b fv mq mn l mo mp">ol, ul {<br/>  list-style: none;<br/>}</span><span id="fab1" class="ml ll hu lh b fv mq mn l mo mp">img {<br/>  max-width: 100%;<br/>  height: auto;<br/>}</span><span id="19bd" class="ml ll hu lh b fv mq mn l mo mp">/* Links */<br/>a {<br/>  text-decoration: underline;<br/>  color: inherit;</span><span id="7e46" class="ml ll hu lh b fv mq mn l mo mp">&amp;.active {<br/>    text-decoration: none;<br/>  }<br/>}</span><span id="90c9" class="ml ll hu lh b fv mq mn l mo mp">`</span></pre><p id="40c5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<code class="eh le lf lg lh b">app/App.jsx</code>进口<code class="eh le lf lg lh b">GlobalStyles</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="e682" class="ml ll hu lh b fv mm mn l mo mp">import { GlobalStyles } from './styles'</span></pre><p id="4af8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后更改<code class="eh le lf lg lh b">App</code>来呈现<code class="eh le lf lg lh b">GlobalStyles</code>组件。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ms"><img src="../Images/e08b95db57af71bf5a24237cc8b61603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPDhMVEJ4YGmwC9HRVZUQA.png"/></div></div></figure><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="08c9" class="ml ll hu lh b fv mm mn l mo mp">const App = () =&gt; (<br/>  &lt;div&gt;<br/>    &lt;GlobalStyles /&gt;<br/>    Follow me at &lt;a href="<a class="ae lj" rel="noopener" href="/@patrickleet">https://medium.com/@patrickleet</a>"&gt;<a class="ae lj" href="http://twitter.com/patrickleet" rel="noopener ugc nofollow" target="_blank">@patrickleet</a>&lt;/a&gt;<br/>  &lt;/div&gt;<br/>)</span></pre><p id="a14f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">你的应用应该看起来不那么难看。</p><h1 id="4b76" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">4.按指定路线发送</h1><p id="a21d" class="pw-post-body-paragraph jz ka hu kb b kc mc iv ke kf md iy kh ki me kk kl km mf ko kp kq mg ks kt ku hn dt translated">我们需要的下一件事是页面要简单。</p><p id="5158" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们加入React路由器。</p><p id="c1db" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在您的客户端中，我们需要从React路由器导入<code class="eh le lf lg lh b">BrowserRouter</code>，然后简单地用它包装我们的应用程序。</p><p id="9dc8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<code class="eh le lf lg lh b">app/client.js</code></p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="abe9" class="ml ll hu lh b fv mm mn l mo mp"><strong class="lh hv">import { BrowserRouter } from 'react-router-dom'</strong></span><span id="de04" class="ml ll hu lh b fv mq mn l mo mp">// ...</span><span id="5644" class="ml ll hu lh b fv mq mn l mo mp">const app = (<br/><strong class="lh hv">  </strong>&lt;HelmetProvider&gt;<br/><strong class="lh hv">    &lt;BrowserRouter&gt;</strong><br/>      &lt;GlobalStyles /&gt;<br/>      &lt;App /&gt;<br/><strong class="lh hv">    &lt;/BrowserRouter&gt;</strong><br/>  &lt;/HelmetProvider&gt;<strong class="lh hv"><br/></strong>)</span></pre><p id="788d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在在<code class="eh le lf lg lh b">app/App.jsx</code>中，我们需要将当前内容提取到一个新的组件中，并通过路由器加载。让我们从创建一个新页面开始，使用与我们目前在<code class="eh le lf lg lh b">App.jsx</code>中几乎相同的内容。</p><p id="82bc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创建<code class="eh le lf lg lh b">app/pages/Home.jsx</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="f9df" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import Helmet from 'react-helmet-async'</span><span id="f21b" class="ml ll hu lh b fv mq mn l mo mp">const Home = () =&gt; (<br/>  &lt;React.Fragment&gt;</span><span id="c862" class="ml ll hu lh b fv mq mn l mo mp">    &lt;Helmet&gt;<br/>      &lt;title&gt;Home Page&lt;/title&gt;<br/>    &lt;/Helmet&gt;</span><span id="1299" class="ml ll hu lh b fv mq mn l mo mp">    &lt;div&gt;<br/>      Follow me at &lt;a href="<a class="ae lj" rel="noopener" href="/@patrickleet">https://medium.com/@patrickleet</a>"&gt;<a class="ae lj" href="http://twitter.com/patrickleet" rel="noopener ugc nofollow" target="_blank">@patrickleet</a>&lt;/a&gt;<br/>    &lt;/div&gt;<br/>    <br/>  &lt;/React.Fragment&gt;<br/>)</span><span id="6f09" class="ml ll hu lh b fv mq mn l mo mp">export default Home</span></pre><p id="3cd1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后，将<code class="eh le lf lg lh b">App.jsx</code>修改为以下内容:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="8c38" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import { Switch, Route, Redirect } from 'react-router-dom'<br/>import Home from './pages/Home'</span><span id="caf5" class="ml ll hu lh b fv mq mn l mo mp">const App = () =&gt; (<br/>  &lt;React.Fragment&gt;<br/>    &lt;GlobalStyles /&gt;<br/>    &lt;Switch&gt;<br/>      &lt;Route exact path="/" component={Home} /&gt;<br/>      &lt;Redirect to="/" /&gt;<br/>    &lt;/Switch&gt;<br/>  &lt;/React.Fragment&gt;<br/>)</span><span id="9d36" class="ml ll hu lh b fv mq mn l mo mp">export default App</span></pre><p id="9225" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，当我们运行我们的应用程序时，它看起来应该和以前一样，只是这次它是基于路线的匹配通过我们的路由器呈现的<code class="eh le lf lg lh b">/</code>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ms"><img src="../Images/a2058e419f7f60e265bdb4f7eded3849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRYHF1ww_b-ifKKq0uBDUw.png"/></div></div></figure><p id="ec34" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我们继续之前，让我们添加第二条路线，但是这次使用“代码分割”。</p><p id="62c4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们创建第二个页面，<code class="eh le lf lg lh b">app/pages/About.jsx</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="d116" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import Helmet from 'react-helmet-async'</span><span id="9191" class="ml ll hu lh b fv mq mn l mo mp">const About = () =&gt; (<br/>  &lt;React.Fragment&gt;</span><span id="a16a" class="ml ll hu lh b fv mq mn l mo mp">    &lt;Helmet&gt;<br/>      &lt;title&gt;About Page&lt;/title&gt;<br/>    &lt;/Helmet&gt;</span><span id="e619" class="ml ll hu lh b fv mq mn l mo mp">    &lt;div&gt;<br/>      This is the about page<br/>    &lt;/div&gt;<br/>    <br/>  &lt;/React.Fragment&gt;<br/>)</span><span id="ccc7" class="ml ll hu lh b fv mq mn l mo mp">export default About</span></pre><p id="68b8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">以及在<code class="eh le lf lg lh b">app/pages/Loading.jsx</code>处的加载部件:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="ac01" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'</span><span id="a5ec" class="ml ll hu lh b fv mq mn l mo mp">const Loading = () =&gt; (<br/>  &lt;div&gt;<br/>    Loading...<br/>  &lt;/div&gt;<br/>)<br/>export default Loading</span></pre><p id="3b5d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后是<code class="eh le lf lg lh b">app/pages/Error.jsx</code>处的误差分量:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="15d2" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'</span><span id="cace" class="ml ll hu lh b fv mq mn l mo mp">const Error = () =&gt; (<br/>  &lt;div&gt;<br/>    Error!<br/>  &lt;/div&gt;<br/>)<br/>export default Error</span></pre><p id="2931" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了导入它，我想使用新的<code class="eh le lf lg lh b">React.lazy</code>和<code class="eh le lf lg lh b">Suspense</code>API，不幸的是，虽然它们可以在客户端工作，但一旦我们到达服务器端渲染，我们会发现ReactDomServer还不支持悬念。</p><p id="a764" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">相反，我们将依赖另一个名为<code class="eh le lf lg lh b">react-imported-component</code>的库，它将与客户端和服务器端呈现的应用程序一起工作。</p><p id="3d97" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下面是我们更新的<code class="eh le lf lg lh b">app/App.jsx</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="2edd" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import { Switch, Route, Redirect } from 'react-router-dom';<br/><strong class="lh hv">import importComponent from 'react-imported-component';</strong><br/>import Home from './pages/Home.jsx'<br/><strong class="lh hv">import LoadingComponent from './pages/Loading'<br/>import ErrorComponent from './pages/Error'</strong></span><span id="3c5f" class="ml ll hu lh b fv mq mn l mo mp"><strong class="lh hv">const About = importComponent(() =&gt; import("./pages/About"), {<br/>  LoadingComponent,<br/>  ErrorComponent<br/>});</strong></span><span id="b794" class="ml ll hu lh b fv mq mn l mo mp">const App = () =&gt; (<br/>  &lt;React.Fragment&gt;<br/>    &lt;GlobalStyles /&gt;</span><span id="c0b7" class="ml ll hu lh b fv mq mn l mo mp">    &lt;Switch&gt;<br/>      &lt;Route exact path="/" component={Home} /&gt;<br/>      <strong class="lh hv">&lt;Route exact path="/about" render={() =&gt; &lt;About /&gt;} /&gt;</strong><br/>      &lt;Redirect to="/" /&gt;<br/>    &lt;/Switch&gt;</span><span id="0b64" class="ml ll hu lh b fv mq mn l mo mp">  &lt;/React.Fragment&gt;<br/>)</span><span id="dc52" class="ml ll hu lh b fv mq mn l mo mp">export default App</span></pre><p id="93bf" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在我们应该能够导航到<code class="eh le lf lg lh b">/about</code>来查看我们的新页面。如果你快速看，你会看到<code class="eh le lf lg lh b">Loading...</code>出现在页面内容之前。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mt"><img src="../Images/8ef6c32a678bc5b67eb1b5c07a96a4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tiljYLt3uSrbJHZv50PNdw.png"/></div></div></figure><h1 id="c60b" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">5.布局和导航</h1><p id="55a6" class="pw-post-body-paragraph jz ka hu kb b kc mc iv ke kf md iy kh ki me kk kl km mf ko kp kq mg ks kt ku hn dt translated">现在我们需要通过在地址栏中输入路线来导航，这并不理想。在我们进入服务器端渲染之前，让我们为页面添加一个通用布局和一个带有导航的标题。</p><p id="5f8c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们从一个标题开始，这样我们可以得到点击。</p><p id="e6fe" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创造<code class="eh le lf lg lh b">app/components/Header.jsx</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="dbcc" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react';<br/>import styled from 'styled-components'<br/>import { NavLink } from 'react-router-dom';</span><span id="2ed0" class="ml ll hu lh b fv mq mn l mo mp">const Header = styled.header`<br/>  z-index: 100;<br/>  position: fixed;<br/>  top: 0;<br/>  left: 0;<br/>  right: 0;</span><span id="52bb" class="ml ll hu lh b fv mq mn l mo mp">  max-width: 90vw;<br/>  margin: 0 auto;<br/>  padding: 1em 0;</span><span id="3e3b" class="ml ll hu lh b fv mq mn l mo mp">  display: flex;<br/>  justify-content: space-between;<br/>  align-items: center;<br/>`</span><span id="2147" class="ml ll hu lh b fv mq mn l mo mp">const Brand = styled.h1`<br/>  font-size: var(--step-up-1);<br/>`</span><span id="567b" class="ml ll hu lh b fv mq mn l mo mp">const Menu = styled.ul`<br/>  display: flex;<br/>  justify-content: flex-end;<br/>  align-items: center;<br/>  width: 50vw;<br/>`</span><span id="39ee" class="ml ll hu lh b fv mq mn l mo mp">const MenuLink = styled.li`<br/>  margin-left: 2em;<br/>  text-decoration: none;<br/>`</span><span id="20de" class="ml ll hu lh b fv mq mn l mo mp">export default () =&gt; (<br/>  &lt;Header&gt;<br/>    &lt;Brand&gt;Stream all the things!&lt;/Brand&gt;<br/>    &lt;Menu&gt;<br/>      &lt;MenuLink&gt;<br/>        &lt;NavLink <br/>          to="/"<br/>          exact activeClassName="active"<br/>        &gt;Home&lt;/NavLink&gt;<br/>      &lt;/MenuLink&gt;<br/>      &lt;MenuLink&gt;<br/>        &lt;NavLink <br/>          to="/about" <br/>          exact activeClassName="active"<br/>        &gt;About&lt;/NavLink&gt;<br/>      &lt;/MenuLink&gt;<br/>    &lt;/Menu&gt;<br/>  &lt;/Header&gt;<br/>)</span></pre><p id="8f9c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们需要导入它并将其放入我们的<code class="eh le lf lg lh b">App</code>。</p><p id="e266" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下面是更新后的<code class="eh le lf lg lh b">App.jsx</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="d37f" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import { Switch, Route, Redirect } from 'react-router-dom';<br/>import importComponent from 'react-imported-component';<br/>import { GlobalStyles } from './styles'<br/><strong class="lh hv">import Header from './components/Header'<br/></strong>import Home from './pages/Home'<br/>import LoadingComponent from './pages/Loading'<br/>import ErrorComponent from './pages/Error'</span><span id="e950" class="ml ll hu lh b fv mq mn l mo mp">const About = importComponent(() =&gt; import("./pages/About"), {<br/>  LoadingComponent,<br/>  ErrorComponent<br/>});</span><span id="938a" class="ml ll hu lh b fv mq mn l mo mp">const App = () =&gt; (<br/>  &lt;React.Fragment&gt;<br/>    &lt;GlobalStyles /&gt;<br/><strong class="lh hv">    &lt;Header /&gt;</strong></span><span id="6588" class="ml ll hu lh b fv mq mn l mo mp">    &lt;Switch&gt;<br/>      &lt;Route exact path="/" component={Home} /&gt;<br/>      &lt;Route exact path="/about" render={() =&gt; &lt;About /&gt;} /&gt;<br/>      &lt;Redirect to="/" /&gt;<br/>    &lt;/Switch&gt;</span><span id="74ec" class="ml ll hu lh b fv mq mn l mo mp">  &lt;/React.Fragment&gt;<br/>)</span><span id="84a2" class="ml ll hu lh b fv mq mn l mo mp">export default App</span></pre><p id="f6d4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们也创建一个<code class="eh le lf lg lh b">Page</code>组件，我们的每个页面都可以使用它来实现一致的页面风格。</p><p id="16af" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创建<code class="eh le lf lg lh b">app/components/Page.jsx</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="f76e" class="ml ll hu lh b fv mm mn l mo mp">import styled from 'styled-components';</span><span id="f5f2" class="ml ll hu lh b fv mq mn l mo mp">const Page = styled.div`<br/>  width: 100vw;<br/>  height: 100vh;<br/>  display: flex;<br/>  justify-content: center;<br/>  align-items: center;<br/>  text-align: center;<br/>`</span><span id="f908" class="ml ll hu lh b fv mq mn l mo mp">export default Page</span></pre><p id="cffc" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然后，在我们的四个页面中，导入新的<code class="eh le lf lg lh b">Page</code>组件，并用它替换每个页面中的包装<code class="eh le lf lg lh b">React.Fragment</code>。</p><p id="5db9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这里是<code class="eh le lf lg lh b">Home</code>页面:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="f998" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import Helmet from 'react-helmet-async'<br/>import Page from '../components/Page.jsx'</span><span id="e983" class="ml ll hu lh b fv mq mn l mo mp">const Home = () =&gt; (<br/>  <strong class="lh hv">&lt;Page&gt;</strong></span><span id="46a8" class="ml ll hu lh b fv mq mn l mo mp">    &lt;Helmet&gt;<br/>      &lt;title&gt;Home Page&lt;/title&gt;<br/>    &lt;/Helmet&gt;</span><span id="0a45" class="ml ll hu lh b fv mq mn l mo mp">    &lt;div&gt;<br/>      Follow me at &lt;a href="<a class="ae lj" rel="noopener" href="/@patrickleet">https://medium.com/@patrickleet</a>"&gt;<a class="ae lj" href="http://twitter.com/patrickleet" rel="noopener ugc nofollow" target="_blank">@patrickleet</a>&lt;/a&gt;<br/>    &lt;/div&gt;<br/>    <br/>  <strong class="lh hv">&lt;/Page&gt;</strong><br/>)</span><span id="0ffd" class="ml ll hu lh b fv mq mn l mo mp">export default Home</span></pre><p id="3539" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">对<code class="eh le lf lg lh b">About</code>页以及<code class="eh le lf lg lh b">Error</code>和<code class="eh le lf lg lh b">Loading</code>页进行同样的操作。</p><p id="733c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们的应用程序开始变得更好看了！</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mu"><img src="../Images/0bc7d9f7e8617ba357b25c7036c9b596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIKWF62D3aR6yHJFoPk08A.png"/></div></div></figure><p id="2771" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">很明显，有无数种可能的方式来设计这个应用程序，所以我将把让它变得更漂亮作为一个练习。</p><h1 id="29bf" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">6.流式服务器端渲染</h1><p id="3e47" class="pw-post-body-paragraph jz ka hu kb b kc mc iv ke kf md iy kh ki me kk kl km mf ko kp kq mg ks kt ku hn dt translated">我们实现目标的下一步是添加流媒体服务器端渲染。如果你一直在关注，你会发现到目前为止，我们已经创建了一个静态的客户端应用程序。</p><p id="6aa6" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">从客户端到同构需要在服务器上创建一个新的入口点，它将加载与我们的客户端入口点相同的<code class="eh le lf lg lh b">App</code>组件。</p><p id="bd75" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们还需要其他几个新的npm包:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="16e6" class="ml ll hu lh b fv mm mn l mo mp">npm i --save llog pino express <!-- -->through cheerio<!-- --> <br/>npm i --save-dev concurrently rimraf nodemon @babel/polyfill cross-env</span></pre><p id="9856" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们创建<code class="eh le lf lg lh b">server/index.js</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="dd2e" class="ml ll hu lh b fv mm mn l mo mp">import path from 'path'<br/>import express from 'express'<br/>import log from 'llog'<br/>import ssr from './lib/ssr'</span><span id="5c05" class="ml ll hu lh b fv mq mn l mo mp">const app = express()</span><span id="c871" class="ml ll hu lh b fv mq mn l mo mp">// Expose the public directory as /dist and point to the browser version<br/>app.use('/dist/client', express.static(path.resolve(process.cwd(), 'dist', 'client')));</span><span id="7a1a" class="ml ll hu lh b fv mq mn l mo mp">// Anything unresolved is serving the application and let<br/>// react-router do the routing!<br/>app.get('/*', ssr)</span><span id="d972" class="ml ll hu lh b fv mq mn l mo mp">// Check for PORT environment variable, otherwise fallback on Parcel default port<br/>const port = process.env.PORT || 1234;<br/>app.listen(port, () =&gt; {<br/>  log.info(`Listening on port ${port}...`);<br/>});</span></pre><p id="9c8a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好了，这里有几样东西需要打开:</p><ol class=""><li id="742f" class="mv mw hu kb b kc kd kf kg ki mx km my kq mz ku na nb nc nd dt translated">我们使用的是express——它可以是任何其他服务器。我们真的没有做太多，所以应该不会太难转换到您选择的服务器。</li><li id="1784" class="mv mw hu kb b kc ne kf nf ki ng km nh kq ni ku na nb nc nd dt translated">我们正在为<code class="eh le lf lg lh b">/dist/clients</code>目录设置一个静态文件服务器。我们目前没有建立生产资产，但当我们这样做时，我们可以把它们放在那里。</li><li id="2c3b" class="mv mw hu kb b kc ne kf nf ki ng km nh kq ni ku na nb nc nd dt translated">每一条其他的路线都在走<code class="eh le lf lg lh b">ssr</code>。我们只做React路由器所做的事情，而不是在服务器上进行路由。</li></ol><p id="a5ac" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们创建<code class="eh le lf lg lh b">ssr</code>函数。这可能会比本教程的其余部分更复杂，但这只是需要做一次的事情，然后基本上就不用管了。</p><p id="7f01" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我们继续之前，让我们看一下我们需要创建的脚本。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="1700" class="ml ll hu lh b fv mm mn l mo mp">"scripts": {<br/>  "<strong class="lh hv">dev</strong>": "npm run generate-imported-components &amp;&amp; parcel app/index.html",<br/>  "<strong class="lh hv">dev:server</strong>": "nodemon -e js,jsx,html --ignore dist --ignore app/imported.js --exec 'npm run build &amp;&amp; npm run start'",<br/>  "start": "node dist/server"<br/>  "<strong class="lh hv">build</strong>": "rimraf dist &amp;&amp; npm run generate-imported-components &amp;&amp; npm run create-bundles",<br/>  "<strong class="lh hv">create-bundles</strong>": "concurrently \"npm run create-bundle:client\" \"npm run create-bundle:server\"",<br/>  "<strong class="lh hv">create-bundle:client</strong>": "cross-env BABEL_ENV=client parcel build app/index.html -d dist/client --public-url /dist/client",<br/>  "<strong class="lh hv">create-bundle:server</strong>": "cross-env BABEL_ENV=server parcel build server/index.js -d dist/server --public-url /dist --target=node",<br/>  "<strong class="lh hv">generate-imported-components</strong>": "imported-components app app/imported.js",<br/>  "<strong class="lh hv">start</strong>": "node dist/server"<br/>}</span></pre><p id="1da2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在多了不少。我已经突出显示了这些名字，以便于阅读。在高层次上，我们添加了构建脚本来生成一个包含导入组件信息的文件，以及一个使用parcel并发构建客户机和服务器包的构建脚本。</p><p id="31fd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们现在还需要一个用于导入组件的<code class="eh le lf lg lh b">.babelrc</code>文件。也许在接下来的几个月里，这种情况会有所改变。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="3d1b" class="ml ll hu lh b fv mm mn l mo mp">{<br/>  "env": {<br/>    "server": {<br/>      "plugins": ["react-imported-component/babel", "babel-plugin-dynamic-import-node"]<br/>    },<br/>    "client": {<br/>      "plugins": [<br/>        ["react-imported-component/babel"]<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="26b8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">解决了这个问题后，我们有两个主要部分要解决。</p><ol class=""><li id="561b" class="mv mw hu kb b kc kd kf kg ki mx km my kq mz ku na nb nc nd dt translated">创建SSR中间件</li><li id="b869" class="mv mw hu kb b kc ne kf nf ki ng km nh kq ni ku na nb nc nd dt translated">为SSR重用客户机HTML数据，并从中解析生成的src名称</li></ol><p id="7525" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创建<code class="eh le lf lg lh b">server/lib/ssr.js</code>:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="a388" class="ml ll hu lh b fv mm mn l mo mp">import React from 'react'<br/>import { renderToNodeStream } from 'react-dom/server'<br/>import { HelmetProvider } from 'react-helmet-async'<br/>import { StaticRouter } from 'react-router-dom'<br/>import { ServerStyleSheet } from 'styled-components'<br/>import { printDrainHydrateMarks } from 'react-imported-component';<br/>import log from 'llog'<br/>import through from 'through'<br/>import App from '../../app/App'<br/>import { getHTMLFragments } from './client'<br/>// import { getDataFromTree } from 'react-apollo';</span><span id="6053" class="ml ll hu lh b fv mq mn l mo mp">export default (req, res) =&gt; {<br/>  const context = {};<br/>  const helmetContext = {};</span><span id="7a9d" class="ml ll hu lh b fv mq mn l mo mp">const app = (<br/>    &lt;HelmetProvider context={helmetContext}&gt;<br/>      &lt;StaticRouter<br/>        location={req.originalUrl}<br/>        context={context}<br/>      &gt;<br/>        &lt;App /&gt;<br/>      &lt;/StaticRouter&gt;<br/>    &lt;/HelmetProvider&gt;<br/>  );</span><span id="c2fe" class="ml ll hu lh b fv mq mn l mo mp">  try {<br/>    // If you were using Apollo, you could fetch data with this<br/>    // await getDataFromTree(app);</span><span id="5544" class="ml ll hu lh b fv mq mn l mo mp">    const sheet = new ServerStyleSheet()<br/>    const stream = sheet.interleaveWithNodeStream(<br/>      renderToNodeStream(sheet.collectStyles(app))<br/>    )</span><span id="0e7a" class="ml ll hu lh b fv mq mn l mo mp">    if (context.url) {<br/>      res.redirect(301, context.url);<br/>    } else {<br/>      const [<br/>        startingHTMLFragment,<br/>        endingHTMLFragment<br/>      ] = getHTMLFragments({ drainHydrateMarks: printDrainHydrateMarks() })<br/>      res.status(200)<br/>      res.write(startingHTMLFragment)<br/>      stream<br/>        .pipe(<br/>          through(<br/>            function write(data) {<br/>              this.queue(data)<br/>            },<br/>            function end() {<br/>              this.queue(endingHTMLFragment)<br/>              this.queue(null)<br/>            }<br/>          )<br/>        )<br/>        .pipe(res)<br/>    }<br/>  } catch (e) {<br/>    log.error(e)<br/>    res.status(500)<br/>    res.end()<br/>  }<br/>};</span></pre><p id="b39f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">使用<code class="eh le lf lg lh b">server/lib/client.js</code>,我们需要读入我们的<code class="eh le lf lg lh b">app/index.html</code>文件，并把它分成两个块，使上面的流更容易。</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="cbb9" class="ml ll hu lh b fv mm mn l mo mp">import fs from 'fs';<br/>import path from 'path';<br/>import cheerio from 'cheerio';</span><span id="9be3" class="ml ll hu lh b fv mq mn l mo mp">export const htmlPath = path.join(process.cwd(), 'dist', 'client', 'index.html');<br/>export const rawHTML = fs.readFileSync(htmlPath).toString();</span><span id="33b0" class="ml ll hu lh b fv mq mn l mo mp">export const parseRawHTMLForData = (template, selector = "#js-entrypoint") =&gt; {<br/>  const $template = cheerio.load(template);<br/>  let src = $template(selector).attr('src')</span><span id="7e8a" class="ml ll hu lh b fv mq mn l mo mp">  return {<br/>    src<br/>  }<br/>}</span><span id="70b1" class="ml ll hu lh b fv mq mn l mo mp">const clientData = parseRawHTMLForData(rawHTML)</span><span id="f592" class="ml ll hu lh b fv mq mn l mo mp">const appString = '&lt;div id="app"\&gt;'<br/>const splitter = '###SPLIT###'<br/>const [ <br/>  startingRawHTMLFragment, <br/>  endingRawHTMLFragment <br/>] = rawHTML<br/>      .replace(appString, `${appString}${splitter}`)<br/>      .split(splitter)</span><span id="e2d4" class="ml ll hu lh b fv mq mn l mo mp">export const getHTMLFragments = ({ drainHydrateMarks }) =&gt; {<br/>  const startingHTMLFragment = `${startingRawHTMLFragment}${drainHydrateMarks}`<br/>  return [startingHTMLFragment, endingRawHTMLFragment]<br/>}</span></pre><p id="bbf9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这将通过服务器呈现我们的应用程序，但是如果不对客户端进行一些小的更改，它不会成功地重新连接到客户端应用程序。</p><p id="4d22" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们正在通过SSR功能提供“再水合标记”,但还没有使用它们。</p><p id="2b62" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<code class="eh le lf lg lh b">app/client.js</code>做如下修改:</p><ol class=""><li id="137b" class="mv mw hu kb b kc kd kf kg ki mx km my kq mz ku na nb nc nd dt translated">导入<code class="eh le lf lg lh b">rehydrateMarks</code> <strong class="kb hv">和</strong> <code class="eh le lf lg lh b">importedComponents</code></li></ol><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="1894" class="ml ll hu lh b fv mm mn l mo mp"><strong class="lh hv">import { rehydrateMarks } from 'react-imported-component';<br/>import importedComponents from './imported'; // eslint-disable-line</strong></span></pre><p id="dda4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">2.将<code class="eh le lf lg lh b">ReactDOM.render(app, element)</code>替换为:</p><pre class="jk jl jm jn fq mh lh mi mj aw mk dt"><span id="44c8" class="ml ll hu lh b fv mm mn l mo mp">// In production, we want to hydrate instead of render<br/>// because of the server-rendering<br/>if (process.env.NODE_ENV === 'production') {<br/>  // rehydrate the bundle marks<br/>  rehydrateMarks().then(() =&gt; {<br/>    ReactDOM.hydrate(app, element);<br/>  });<br/>} else {<br/>  ReactDOM.render(app, element);<br/>}</span></pre><p id="443b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">搞定了。</p><p id="f13e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，当您运行<code class="eh le lf lg lh b">npm run dev:server</code>或<code class="eh le lf lg lh b">npm run build &amp;&amp; npm run start</code>时，您将使用服务器端渲染！</p><h1 id="4062" class="lk ll hu bd lm ln lo lp lq lr ls lt lu ja lv jb lw jd lx je ly jg lz jh ma mb dt translated">结论</h1><p id="3532" class="pw-post-body-paragraph jz ka hu kb b kc mc iv ke kf md iy kh ki me kk kl km mf ko kp kq mg ks kt ku hn dt translated">我承认，仍有比Next.js更多的样板文件，但希望不是压倒性的，那里的内容是透明的和可以理解的。而且平心而论，Next.js还在为我们多做几件事，比如预取组件。</p><p id="e907" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">然而，我仍然更喜欢这种方法，因为这没有什么神秘之处，webpack配置完全消失了，并且很容易利用react路由器的动画库，我将把它作为一个练习。</p><p id="5ac4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">希望您发现这很有用！</p><p id="217e" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你做了，帮助我的最好方法是给我一些掌声和/或分享！</p><p id="683a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><br/>最佳，<a class="ae lj" href="https://twitter.com/pat_scott" rel="noopener ugc nofollow" target="_blank">李雅达·斯科特</a></p><p id="eaf2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">附:这里是GitHub 上的<a class="ae lj" href="https://github.com/patrickleet/streaming-ssr-react-styled-components" rel="noopener ugc nofollow" target="_blank">完整代码。</a></p><p id="f5eb" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">页（page的缩写）附:本文是系列文章的一部分。看看下面的其他部分！</p><div class="nj nk fm fo nl nm"><a href="https://hackernoon.com/a-better-way-to-develop-node-js-with-docker-cd29d3a0093" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab ej"><div class="no ab np cl cj nq"><h2 class="bd hv fv z el nr eo ep ns er et ht dt translated">第2部分:用Docker开发Node.js的更好方法</h2><div class="nt l"><h3 class="bd b fv z el nr eo ep ns er et ek translated">并保持您的热代码重载</h3></div><div class="nu l"><p class="bd b gc z el nr eo ep ns er et ek translated">hackernoon.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa jt nm"/></div></div></a></div><div class="nj nk fm fo nl nm"><a href="https://hackernoon.com/enforcing-code-quality-for-node-js-c3b837d7ae17" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab ej"><div class="no ab np cl cj nq"><h2 class="bd hv fv z el nr eo ep ns er et ht dt translated">第3部分:加强Node.js的代码质量</h2><div class="nt l"><h3 class="bd b fv z el nr eo ep ns er et ek translated">使用林挺、格式化和带有代码覆盖的单元测试来实施质量标准</h3></div><div class="nu l"><p class="bd b gc z el nr eo ep ns er et ek translated">hackernoon.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa jt nm"/></div></div></a></div><div class="nj nk fm fo nl nm"><a href="https://hackernoon.com/the-100-code-coverage-myth-900b83d20d3d" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab ej"><div class="no ab np cl cj nq"><h2 class="bd hv fv z el nr eo ep ns er et ht dt translated">第4部分:100%代码覆盖率的神话</h2><div class="nt l"><h3 class="bd b fv z el nr eo ep ns er et ek translated">现在互联网上有很多建议说100%的覆盖率不是一个有价值的目标。是吗？</h3></div><div class="nu l"><p class="bd b gc z el nr eo ep ns er et ek translated">hackernoon.com</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa jt nm"/></div></div></a></div><div class="nj nk fm fo nl nm"><a href="https://hackernoon.com/a-tale-of-two-docker-multi-stage-build-layers-85348a409c84" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab ej"><div class="no ab np cl cj nq"><h2 class="bd hv fv z el nr eo ep ns er et ht dt translated">第5部分:两层(Docker多阶段构建)的故事</h2><div class="nt l"><h3 class="bd b fv z el nr eo ep ns er et ek translated">Node.js的生产就绪docker文件</h3></div><div class="nu l"><p class="bd b gc z el nr eo ep ns er et ek translated">hackernoon.com</p></div></div><div class="nv l"><div class="od l nx ny nz nv oa jt nm"/></div></div></a></div></div></div>    
</body>
</html>