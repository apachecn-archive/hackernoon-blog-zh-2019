<html>
<head>
<title>The JavaScript Keyboard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript键盘</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/the-javascript-keyboard-31b88379eeb3?source=collection_archive---------6-----------------------#2019-05-07">https://medium.com/hackernoon/the-javascript-keyboard-31b88379eeb3?source=collection_archive---------6-----------------------#2019-05-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c45b34db36cf0a4222cd3dec35f2d4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KMyDGlJmcQ-JAGwgOmxYbw.jpeg"/></div></div></figure><h2 id="3dbf" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">TL；DR I试验了React codebase中的字符，设计了基于字符频率的键盘布局。结果就是上图。</h2><h1 id="2af2" class="ka jd hu bd je kb kc kd ji ke kf kg jm kh ki kj jq kk kl km ju kn ko kp jy kq dt translated">动机</h1><p id="4968" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">我们开发人员倾向于在笔记本电脑前花大部分时间按键盘按钮。我们中的一些人，如果不是大多数，打字非常快，并认为这提高了我们的生产力。</p><p id="3c3c" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">最流行的键盘布局是QWERTY布局，它在打字速度方面有一些缺点。它是专门为防止老式机械打字机的按键卡住而设计的，而且在速度方面也有限制。此外，它没有考虑到程序员(可能)使用一些符号比字母更频繁。</p><p id="d03c" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我决定基于非常简单的<strong class="kt hv">三个</strong> <strong class="kt hv">原则</strong>为通用编程语言(JavaScript)准备一个布局。</p><ul class=""><li id="8194" class="lr ls hu kt b ku lm ky ln jn lt jr lu jv lv ll lw lx ly lz dt translated">将最常用的键放在主行(QWERTY中以ASD开头的行),将最不常用的键放在下一行</li><li id="2b8f" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">平衡左右手之间的负荷</li><li id="878e" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">按从高到低的顺序将负荷加到手指上，依次为食指、中指、无名指和小指。</li></ul><h1 id="3c1c" class="ka jd hu bd je kb kc kd ji ke kf kg jm kh ki kj jq kk kl km ju kn ko kp jy kq dt translated">分析</h1><p id="ceed" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">我首先在我的笔记本电脑上克隆了一个流行的JavaScript库React。React是一个用于构建用户界面的JavaScript库，截至目前，它在GitHub上拥有超过128，000颗星。我只锁定了扩展名为<code class="eh mf mg mh mi b">.js</code>的文件。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="1180" class="jc jd hu mi b fv mr ms l mt mu">import os</span><span id="4c2b" class="jc jd hu mi b fv mv ms l mt mu">path = "/Users/halilcoban/Documents/projects/react"</span><span id="0b9d" class="jc jd hu mi b fv mv ms l mt mu">js_files = []</span><span id="838a" class="jc jd hu mi b fv mv ms l mt mu">for root, dirs, files in os.walk(path):<br/>    for file in files:<br/>        if file.endswith(".js"):<br/>            js_files.append(os.path.join(root, file))</span><span id="5261" class="jc jd hu mi b fv mv ms l mt mu">print("Found " + str(len(js_files)) + " files")</span></pre><p id="dbd9" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">上面的python脚本只是在react文件夹中进行遍历，并将文件附加到一个数组中供以后使用。执行后，它输出“找到869个文件”。然后我可以开始在这些文件中进行分析。</p><p id="a6b2" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">为了实现我上面提到的原则，我们只需要计算字符的频率。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="9687" class="jc jd hu mi b fv mr ms l mt mu">frequencies = {}</span><span id="d6d4" class="jc jd hu mi b fv mv ms l mt mu">for test_file in js_files:<br/>   with open(test_file, 'r') as file:<br/>        for line in file:<br/>            for char in line:<br/>                lower_char = char.lower()<br/>                if lower_char in frequencies:<br/>                    frequencies[lower_char] += 1<br/>                else:<br/>                    frequencies[lower_char] = 1</span></pre><p id="a8b0" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated"><code class="eh mf mg mh mi b">frequencies</code>是一个将字符映射到React代码库中出现次数的字典。似乎</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="f04d" class="jc jd hu mi b fv mr ms l mt mu">{<br/>  '\n': 197854,<br/>  ' ': 1376531,<br/>  '!': 2950,<br/>  '"': 8298,<br/>  '#': 361,<br/>  '$': 1709,<br/>  ...<br/>}</span></pre><p id="4d34" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我决定只关注最常用的33个字符，因为如果您忽略F行、数字行、空格键行以及caps lock、return等键所在的最右边和最左边的键，我的键盘上有33个键。你可以在下面看到我聚焦的键，从1到33。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e614749ec913bc5c1532c5e61b3b3985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRayznVYkqBbhJaNZkX78w.jpeg"/></div></div></figure><p id="c3ab" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">从最常见的字符中，我过滤掉了分别对应于回车键和空格键的<code class="eh mf mg mh mi b">\n</code>和<code class="eh mf mg mh mi b"> </code>，因为它们通常不在常规键盘的33个键中。</p><p id="0d3d" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">根据我们的第三个原则，我们希望按照食指、中指、无名指和小指的顺序(从最高负荷到最低负荷)给手指施加负荷。由于手的位置，通常左手控制每排5个键，右手控制5个键，此外还有几个额外的键由小手指控制。忽略这些额外的键，我决定把注意力集中在每行的10个键上。对于一组10个键，每只手将负责5个键，其中2个将由食指按压，其余的将由其他手指(中指、无名指或小指)按压。</p><p id="a562" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我解决这个问题的算法如下</p><ul class=""><li id="4eec" class="lr ls hu kt b ku lm ky ln jn lt jr lu jv lv ll lw lx ly lz dt translated">在每一行中，根据频率按顺序分配密钥</li></ul><ol class=""><li id="2435" class="lr ls hu kt b ku lm ky ln jn lt jr lu jv lv ll mw lx ly lz dt translated">食指</li><li id="6dbf" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll mw lx ly lz dt translated">中指</li><li id="6f51" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll mw lx ly lz dt translated">无名指</li><li id="077c" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll mw lx ly lz dt translated">小手指</li><li id="5628" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll mw lx ly lz dt translated">再次食指(因为食指应该带两个键)</li></ol><ul class=""><li id="844e" class="lr ls hu kt b ku lm ky ln jn lt jr lu jv lv ll lw lx ly lz dt translated">为了在两只手之间均匀分配负荷(原则2)，连续地给左手一把钥匙，给右手一把钥匙。</li></ul></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="0e97" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">考虑从0到9的一行中键的位置(索引)。下表说明了哪个索引对应于哪个手指，例如左手中指将按下索引2处的键(例如QWERTY中的E)。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ne"><img src="../Images/3c0d3525e4444060487b75fe2a07ffc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cI-UqE6XRjg1YRjUyuhH-A.png"/></div></div></figure><p id="7071" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">应用我们上面的算法应该会产生如下结果</p><ul class=""><li id="db6d" class="lr ls hu kt b ku lm ky ln jn lt jr lu jv lv ll lw lx ly lz dt translated">最常用的键应该用食指按，让我们从左手开始，所以应该是左手食指(3)。之后，我们应该交换手，使用右手食指(6)</li><li id="687b" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">然后是左手中指(2)和右手中指(7)</li><li id="8b74" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">然后是左手无名指(1)和右手无名指(8)</li><li id="97a8" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">然后是左手小指(0)和右手小指(9)</li><li id="0d2b" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">随后再次是左手食指(4)和右手食指(5)</li></ul><p id="98e0" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">使我们的频率顺序为3，6，2，7，1，8，0，9，4，5。我们以后会用到它。</p><p id="3475" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">这种排序应该照顾到我们的第二和第三原则。为了实现第一个原则，我们可以简单地将最常用的键分配给home行，而将其余的键分配给上面和下面的行。</p><p id="0caa" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我们之前定义了一个字典<code class="eh mf mg mh mi b">frequencies</code>,将每个字符映射到它出现的次数。Python字典是哈希映射数据结构的一个实现，非常适合快速查找，但是它们是不可排序的。我们可以使用<code class="eh mf mg mh mi b">frequencies</code>字典定义一个字符列表，并根据出现的次数进行排序。这个列表中的每个元素都可以是一个(字符，频率)元组，所以我们可以访问这两个值。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="fc5f" class="jc jd hu mi b fv mr ms l mt mu">num_keyboard_keys = 33<br/>ignored_chars = [" ", "\n"]</span><span id="c26e" class="jc jd hu mi b fv mv ms l mt mu"># a custom sorter to sort by the second element of tuples<br/># gives a 0 value to ignored chars<br/>def sort_by_occurrence(item):<br/>    if item[0] in ignored_chars:<br/>        return 0<br/>    else:<br/>        return item[1]</span><span id="2638" class="jc jd hu mi b fv mv ms l mt mu"># create a list of frequent chars ordered by frequencies<br/># will be a tuple of (character, frequency)<br/>frequent_chars = sorted(frequencies.items(),<br/>                        reverse=True,<br/>                        key=sort_by_occurrence<br/>                       )[:num_keyboard_keys]</span></pre><p id="3f84" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">现在我们有了<code class="eh mf mg mh mi b">frequent_chars</code>，我们可以循环遍历它来准备一个<code class="eh mf mg mh mi b">keyboard</code>字典。</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="3dfc" class="jc jd hu mi b fv mr ms l mt mu">frequency_order = [3, 6, 2, 7, 1, 8, 0, 9, 4, 5]</span><span id="7283" class="jc jd hu mi b fv mv ms l mt mu"># initialise a dictionary with 3 keys each corresponding <br/># to a keyboard row<br/>keyboard = { “upper”: {}, “middle”: {}, “lower”: {} }</span><span id="6ab7" class="jc jd hu mi b fv mv ms l mt mu"># loop through frequent characters<br/>for i, frequent_char in enumerate(frequent_chars): <br/>    # apply the first principle <br/>    row = “middle”</span><span id="0c56" class="jc jd hu mi b fv mv ms l mt mu">    if i &gt; 29:<br/>        break<br/>    elif i &gt; 19:<br/>        row = “lower"<br/>    elif i &gt; 9:<br/>        row = “upper”</span><span id="ab2f" class="jc jd hu mi b fv mv ms l mt mu">    # apply the second and third principles<br/>    keyboard[row][frequency_order[i % 10]] = frequent_char</span></pre><h1 id="f8a2" class="ka jd hu bd je kb kc kd ji ke kf kg jm kh ki kj jq kk kl km ju kn ko kp jy kq dt translated">结果呢</h1><p id="5fbe" class="pw-post-body-paragraph kr ks hu kt b ku kv kw kx ky kz la lb jn lc ld le jr lf lg lh jv li lj lk ll hn dt translated">如果我们打印我们的<code class="eh mf mg mh mi b">keyboard</code>字典，它看起来像这样</p><pre class="mj mk ml mm fq mn mi mo mp aw mq dt"><span id="e889" class="jc jd hu mi b fv mr ms l mt mu">{<br/>    'lower': {<br/>        0: ('}', 42020),<br/>        1: ('g', 45226),<br/>        2: ('=', 51082),<br/>        ...<br/>}</span></pre><p id="bedc" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">这意味着下一行，索引0处的键(用左手按下的键，见上表)将是<code class="eh mf mg mh mi b">}</code>字符，在React代码库中的JavaScript文件中出现了42020次。紧挨着它的键应该是出现45226次的<code class="eh mf mg mh mi b">g</code>键，依此类推。</p><p id="c967" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">由于上面的脚本处理了30个键(每行10个键)，但我们实际上有33个常用字符，我决定手动处理最不常用的3个键:<code class="eh mf mg mh mi b">x</code>、<code class="eh mf mg mh mi b">w</code>和<code class="eh mf mg mh mi b">:</code>。他们只是被分配到由右手小指控制的额外按键。</p><p id="99a3" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">现在让我们来看一下布局，并在字符下方包括使用百分比(该键的出现次数/所有33个最常用键的总出现次数)。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5148edff4671ce70f9d62abf991dae58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bu1WhdNbr5ca5v2Gh0-VIw.jpeg"/></div></div></figure><p id="7ea2" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">第一眼看到上面的布局，你会发现<code class="eh mf mg mh mi b">j</code>、<code class="eh mf mg mh mi b">k</code>、<code class="eh mf mg mh mi b">q</code>、<code class="eh mf mg mh mi b">z</code>、<code class="eh mf mg mh mi b">[</code>和<code class="eh mf mg mh mi b">]</code>不像普通键盘那样出现在最常见的33个字符中。它们被替换为<code class="eh mf mg mh mi b">(</code>、<code class="eh mf mg mh mi b">)</code>、<code class="eh mf mg mh mi b">=</code>、<code class="eh mf mg mh mi b">{</code>、<code class="eh mf mg mh mi b">}</code>和<code class="eh mf mg mh mi b">:</code>。</p><p id="fffb" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">视觉上的每种颜色代表一个单独的手指，从左到右依次为:左小指、左戒指、左中指、左食指、右食指、右中指、右戒指、右小指。正如你所看到的，大部分的负荷都给了后排的食指。但是让我们更深入地看看。</p><p id="48da" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">分别有64.22%、24.35%和11.42%的字符出现是由主行、上行和下行中的键处理的。这很好，满足了我们的首要原则。</p><p id="908a" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">让我们也检查对应于每个键和手的频率百分比，以更好地理解我们是否实现了剩下的两个原则。</p><figure class="mj mk ml mm fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/0f6f4b9e12f1b3ebaa43fcabe11dfaf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PudpRIWp4d0v8iMHKIxWgw.png"/></div></div><figcaption class="ng nh fg fe ff ni nj bd b be z ek">Character frequency percentages of keys assigned to different fingers</figcaption></figure><p id="1c43" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我们的第二个原则，平衡左手和右手的负载似乎已经实现，但肯定还可以做得更好。左手负荷(52.29%)略高于右手负荷(47.70)。这可能是因为我们开始先给左手分配按键，并且每次分配都交替进行。实际上，如果我们从右手开始会更好，因为70-95%的人都是右撇子，所以右手的负重更大适合更多的人。此外，我们非常简单的算法只是将一个键连续地放入每只手，这应该通过例如考虑百分比而不仅仅是它们的顺序来改进。</p><p id="7ae0" class="pw-post-body-paragraph kr ks hu kt b ku lm kw kx ky ln la lb jn lo ld le jr lp lg lh jv lq lj lk ll hn dt translated">我们的最后一个原则是食指承受最大的负荷，中指和无名指承受最小的负荷。我们可以看到，除了右手小指，这大部分都实现了。这是由于将额外的手指分配给右手小指造成的。在用30个键填充<code class="eh mf mg mh mi b">keyboard</code>字典时，我们本可以考虑到这一点。</p><h1 id="d653" class="ka jd hu bd je kb kc kd ji ke kf kg jm kh ki kj jq kk kl km ju kn ko kp jy kq dt translated">结论与展望</h1><ul class=""><li id="354a" class="lr ls hu kt b ku kv ky kz jn nk jr nl jv nm ll lw lx ly lz dt translated">JavaScript开发人员更多地使用一些字符，如圆括号和花括号，而不是一些字母，如<code class="eh mf mg mh mi b">k</code>和<code class="eh mf mg mh mi b">q</code></li><li id="dda6" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">一个简单的算法可以用来平衡双手的按键，并增加home行和食指的使用，但改进是必要的</li><li id="c21c" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">分析哪个键在哪个键之后被频繁地按下(例如在<code class="eh mf mg mh mi b">i</code>之后，也许<code class="eh mf mg mh mi b">f</code>经常来做<code class="eh mf mg mh mi b">if</code>)并且在设计键盘布局时考虑到这一点也是很棒的</li><li id="3d10" class="lr ls hu kt b ku ma ky mb jn mc jr md jv me ll lw lx ly lz dt translated">每种编程语言都有不同的布局是不合理的，但是通过分析最常见的编程语言，可以使用类似的方法来设计通用编程键盘</li></ul></div></div>    
</body>
</html>