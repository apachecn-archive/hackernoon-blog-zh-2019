<html>
<head>
<title>Helm from the trenches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">战壕里的头盔</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/helm-from-the-trenches-17f87859ee47?source=collection_archive---------5-----------------------#2019-02-16">https://medium.com/hackernoon/helm-from-the-trenches-17f87859ee47?source=collection_archive---------5-----------------------#2019-02-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="9bdf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果您正在使用Kubernetes，那么您应该使用<a class="ae jp" href="https://www.helm.sh" rel="noopener ugc nofollow" target="_blank"> Helm </a>来轻松地为您的应用程序更改YAML资源。Helm就像一个用于在集群上部署应用程序的包管理器，它给你一个已经创建的准备安装的应用程序(图表)的列表，你也可以开始创建自己的应用程序，并在你自己的图表博物馆中发布它们。就像在操作系统上一样，没有包管理器的生活会困难得多。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff jq"><img src="../Images/e77fa26e862cc64eea5d2a6461dd154c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*9mJCHusRXGq9PViqeajcZw.png"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">Helm charts for an easier Kubernetes installation (image source: <a class="ae jp" href="https://helm.sh" rel="noopener ugc nofollow" target="_blank">https://helm.sh</a>)</figcaption></figure><p id="5eb9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我每天都在使用Helm，这些是我在创建新图表或修改现有图表时发现的事情。如果我在开始使用helm之前就知道这些，事情会变得更加顺利，我也不会浪费太多时间去搜索错误消息和各种问题的解决方案，或者可能只是花更少的时间去重构。</p><p id="dfef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">作为先决条件，我假设您已经安装了kubectl，并且可以访问一个集群，不管它是在云平台上创建的还是仅仅是<a class="ae jp" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank"> minikube </a>。我也希望你有一些关于如何使用头盔的知识，你已经安装了一些图表，你对更多地参与头盔充满信心。</p><p id="5a7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在开始任何工作之前，看一下在<a class="ae jp" href="https://github.com/helm/charts/tree/master/stable" rel="noopener ugc nofollow" target="_blank">头盔库</a>中找到的包列表是个好主意。从这些图表中可以学到很多东西，我们将用它们作为例子来说明一些你可以用来创建自己的图表的想法。helm stable repo是在安装helm时自动添加的，所以你已经可以开始下载和使用这些图表了。</p><h2 id="d03e" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">总是使用helm创建新图表</h2><p id="67e7" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">创建一个图表并不复杂，您只需要在一个文件夹中创建一些文件，比如Chart.yaml、values.yaml和templates文件夹中的实际资源(比如部署)。你可能会想用手一个接一个地创建它们，这看起来确实是一个不错的练习。或者你可以在学习go、node.js或其他语言的时候为它搭建自己的脚手架。但这不是个好主意。相反，您应该始终尝试使用helm create命令。因为它总是与推荐的实践保持同步。比如你现在运行<code class="eh lc ld le lf b">helm create test-chart</code>，它设置的标签是<a class="ae jp" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/" rel="noopener ugc nofollow" target="_blank">最新推荐的</a>，比如<code class="eh lc ld le lf b">app.kubernetes.io/name,</code>、<code class="eh lc ld le lf b">app.kubernetes.io/instance</code>或者<code class="eh lc ld le lf b">app.kubernetes.io/managed-by</code>。如果你只是浏览一些来自<a class="ae jp" href="https://github.com/helm/charts/tree/master/stable" rel="noopener ugc nofollow" target="_blank"> helm stable repo </a>的图表，你可以看到他们没有使用这样的标签，仅仅是因为当他们被创建时还有其他的推荐。</p><p id="6bd3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此外，如果您查看它创建的部署(在templates/deployment.yaml文件中)，您可以看到其他有趣的事情，例如，为您的容器参数化图像存储库和标记(尤其是标记，因为它会经常更改)是一个好主意，但是参数化活动或就绪探测路径之类的事情并不常见。如果将来参数化其他值会很有用，请确保模板会被更新。因此，通过使用helm create启动图表，您可以确保遵循最新的最佳实践，当然有一个条件:安装最新的helm客户端版本。</p><h2 id="82c6" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">包含自定义值的图表</h2><p id="45a5" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">在尝试安装图表之前，最好先清理一下。林挺将应用模板(发生在客户机上),并验证输出是格式良好的yaml。</p><p id="cc15" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有时默认情况下，应用模板时会排除一些资源。例如，web api可以添加一个入口规则，以便仅当某个变量设置为<em class="lg">真(</em>并且默认为<em class="lg">假)</em>时，才启用外部通信。因为不会创建入口资源，所以不会被丢弃。在这种情况下，<a class="ae jp" href="https://docs.helm.sh/helm/#helm-lint" rel="noopener ugc nofollow" target="_blank"> lint命令</a>可以接受其他值文件而不是缺省值文件(并将该文件中的变量设置为true)。</p><p id="4d9b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个好的做法是在与您的<em class="lg">模板</em>文件夹相同的层次上创建一个<em class="lg"> ci </em>文件夹，并将您想要验证的附加值文件放在那里。因此，如果您的ci文件夹中有一个名为<em class="lg">ingress-enabled-values . YAML</em>的文件，只需在稳定图表中运行<code class="eh lc ld le lf b">helm lint --values ci/ingress-enables-values.yaml</code>，您就可以看到<a class="ae jp" href="https://github.com/helm/charts/tree/master/stable/karma" rel="noopener ugc nofollow" target="_blank">有几个有ci文件夹</a>，我注意到最近越来越多的人添加了这个文件夹(这个文件夹可能不仅仅用于林挺，而是主要用于测试版本，对此我打算写一篇单独的文章)。</p><h2 id="2b5e" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">使用试运行和<em class="lh">调试</em>来查看图表将安装什么</h2><p id="697f" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">我们将查看一下<a class="ae jp" href="https://github.com/helm/charts/tree/master/stable/postgresql" rel="noopener ugc nofollow" target="_blank"> Postgresql图表</a>，看看它将为我们安装什么，而不需要实际安装，只需使用两个标志:模拟运行和调试</p><p id="945c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">helm install stable/postgresql --name standalone --dry-run --debug</code></p><p id="c879" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">屏幕上将显示的是所有那些将被发送到tiller (helm服务器组件)以便在集群上应用的YAML文件。您还可以添加您的本地文件(使用<code class="eh lc ld le lf b">-f values.yaml</code>标志),该文件可以覆盖一些默认设置，这在您想检查如何修改要部署的资源而不安装应用程序时非常有用。</p><p id="0eb0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">更重要的是，这种在本地呈现图表并验证其输出的方式可以在一个用于单元测试的<a class="ae jp" href="https://github.com/lrills/helm-unittest" rel="noopener ugc nofollow" target="_blank">库中找到</a>。看一看它，如果你发现它有用，把它添加到你的图表管道中。不幸的是，现在图书馆看起来不再维护了。</p><figure class="jr js jt ju fq jv fe ff paragraph-image"><div class="fe ff li"><img src="../Images/07e6c0be2ecabbcee12fe3a712e02a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*WAliQmzjOx5qPuk4lxW1TA.png"/></div><figcaption class="jy jz fg fe ff ka kb bd b be z ek">context is important for subcharts (image source: <a class="ae jp" href="https://podfanatic.com" rel="noopener ugc nofollow" target="_blank">https://podfanatic.com</a>)</figcaption></figure><h2 id="ee5c" class="kc kd hu bd ke kf kg kh ki kj kk kl km jc kn ko kp jg kq kr ks jk kt ku kv kw dt translated">理解上下文，尤其是在使用子图表时</h2><p id="6511" class="pw-post-body-paragraph ir is hu it b iu kx iw ix iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo hn dt translated">这是使用子图表时需要把握的一件非常重要的事情。为了解释上下文的意思，我们来看一下<a class="ae jp" href="https://github.com/helm/charts/tree/master/stable/kong" rel="noopener ugc nofollow" target="_blank">孔图</a>。Kong是一个基于nginx的很好的api网关，可以通过一系列<a class="ae jp" href="https://docs.konghq.com/hub/" rel="noopener ugc nofollow" target="_blank">插件</a>进行扩展。孔使用Postgres或Cassandra来保持其状态，所以它们是图表中的要求。</p><p id="cec1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你查看<a class="ae jp" href="https://github.com/helm/charts/blob/master/stable/postgresql/templates/_helpers.tpl" rel="noopener ugc nofollow" target="_blank"> Postgres图表模板函数文件</a>，你会看到有几个函数使用了<em class="lg"> .Chart.Name </em>值，你还可以看到图表名称是<a class="ae jp" href="https://github.com/helm/charts/blob/master/stable/postgresql/Chart.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> postgresql </em> </a> <em class="lg">。</em>所以每当我们使用<code class="eh lc ld le lf b">{{ template "postgresql.fullname" . }}</code>时，我们应该得到一个包含<em class="lg"> postgresql </em>的值，因为<em class="lg"> .Chart.Name </em>是方法的一部分。</p><p id="3c1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，当在kong chart中使用模板并且postgresql是子图表时，Chart.Name将实际指向kong图表名称。因为这是现在的上下文，所以我们不再使用postgresql，在我们的示例中，我们将使用<a class="ae jp" href="https://github.com/helm/charts/blob/master/stable/kong/Chart.yaml" rel="noopener ugc nofollow" target="_blank"> kong图表名称</a>。所以使用<code class="eh lc ld le lf b">{{ template "postgresql.fullname" . }} </code>实际上会产生一个包含<em class="lg"> kong </em>的名称(同样，当在kong chart下使用时—不是postgresql subchart)。</p><p id="5cf1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">helm install stable/kong --name apigateway</code></p><p id="3845" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，这个问题可以通过添加另一个名为<em class="lg"> postgresql </em>的硬编码方法来解决。所以这意味着代码重复，我们必须记住不要使用postgresql chart中定义的方法，而是需要使用下面的方法。但是在我们有Helm提供的更好的解决方案之前，社区使用这个。</p><figure class="jr js jt ju fq jv"><div class="bz el l di"><div class="lj lk l"/></div></figure><p id="3582" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">检查独立测试命名空间上的安装</strong></p><p id="ebd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在将图表保存到您自己的图表博物馆之前，请在测试名称空间上进行实际安装。这个helm版本不应该影响集群中运行的任何其他应用程序，这就是为什么最好首先创建一个带有随机名称的测试名称空间。安装完成后，检查所有的pod是否处于运行状态，是否附加了所有的配置图和密码，所有的入口规则是否连接到服务，是否定义了资源和限制等等。</p><p id="0e82" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">也尝试用一些不同的值升级当前版本。并检查升级是否正常，遵循与上面相同的规则。</p><p id="5fe9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最后，清理发布版本并删除测试名称空间。这是一个很好的功能测试，表明您的图表可以被其他开发人员使用。很有可能这样的测试需要成为你的<em class="lg">发布到图表博物馆</em>管道的一部分，以及helm lint完成的静态分析。</p><p id="e596" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">其他有用的舵命令</strong></p><p id="d971" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是一些有用的舵命令，但您可能不太熟悉:</p><p id="8245" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对于大图表很有用，当调试和模拟运行标志产生一个很大的输出，很难跟踪。将-x与要输出的资源的路径一起使用，将简化检查和调试。</p><p id="adab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">helm history [RELEASE]</code> —你可以用它来查看一个版本的修订，我们需要它以便在我们的安装/升级出现问题时能够呼叫<code class="eh lc ld le lf b">helm rollback [RELEASE] [REVISION]</code>。</p><p id="3767" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">helm upgrade --reuse-values </code> —当您想要对某个版本进行小的更改，而不使用所有参数再次运行helm安装/升级时，重用值标志非常有用。例如，当您的安装中有一个输入错误，您修复了代码，但是不想再等5分钟让管道运行</p><p id="f0f2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">helm upgrade --install</code> —这非常有用，尤其是在管道中运行该命令时，您不需要编写代码来检查该版本是否已经存在，它会为您完成这项工作:如果找到该版本，它将使用提供的新值进行升级，如果没有版本，它将安装它</p><p id="a133" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">helm install/upgrade --debug</code> —我知道我已经在上面提到了进行模拟安装时的调试标志，但是它非常有用，所以我会再做一次。将它添加到您的命令中是很重要的，尤其是在管道中运行时，因为它允许您在安装或升级的情况下看到实际发生了什么。如果没有它，输出的信息就不多，而且当您试图理解管道上出了什么问题以及向命令提供了什么值时，它也帮不了您太多。</p><p id="c932" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh lc ld le lf b">helm install/upgrade --set name=sandbox</code> —您可以使用set标志覆盖安装/升级的值。这对于设置在管道中计算的值很有用，比如git提交散列。但是有了这个标志，我不建议在你的管道上使用这个标志，因为这个值被隐藏了。相反，在计算之后，将它提交到values.yaml文件中的存储库中，并使用该文件。这样你就有了回购的变化历史，并遵循gitops方法。</p><p id="018e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">就这样，现在你应该为使用舵图做更多的准备。如果你对Helm有用的东西有其他想法，请告诉我，我会把它们添加到文章中(连同致谢)。</p><p id="e156" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="lg">如果你喜欢这个并且想要更多的精神食粮</em> <a class="ae jp" href="https://mailchi.mp/8eac933e024a/cloud-native-newsletter" rel="noopener ugc nofollow" target="_blank"> <em class="lg">你也可以注册我的对云原生技术感兴趣的人的时事通讯</em> </a> <em class="lg">。我一个月至少发一次。</em></p></div></div>    
</body>
</html>