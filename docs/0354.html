<html>
<head>
<title>Finding Area by Integrating Google Maps SDK in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在Android中集成谷歌地图SDK来查找区域</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/finding-area-by-integrating-google-maps-sdk-in-android-db5ead49458c?source=collection_archive---------6-----------------------#2019-01-15">https://medium.com/hackernoon/finding-area-by-integrating-google-maps-sdk-in-android-db5ead49458c?source=collection_archive---------6-----------------------#2019-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><blockquote class="ir is it"><p id="8f37" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">本文原帖<a class="ae jt" href="https://ayusch.com/integrating-google-maps-in-android/" rel="noopener ugc nofollow" target="_blank">此处</a></p></blockquote><p id="eeae" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在本教程中，我们将看到如何通过在Android应用程序中集成谷歌地图来计算一个地区的面积。</p><p id="c415" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">在谷歌地图上计算一个地区的面积</strong>对于像测量员、建筑师、99 acres等网站这样的人和组织来说可能是一个非常现实的需求。用任何测量仪器来计算诸如地理位置、纪念碑、平房等非常大的区域的面积实际上是不可能的。</p><p id="deda" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">虽然有很多方法可以做到这一点，但它们可能很麻烦，如果有人只需要对该区域进行粗略的估计，这种麻烦是不值得的。</p><p id="7c78" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在这种情况下，<strong class="ix hv">这个应用可以证明是非常有用的</strong>。它使用谷歌地图来加载位置，然后通过一些定制，用户能够标记他们想要估计面积的区域的边界，应用程序将根据地球上的坐标标准化这些点，并计算出该区域的近似面积。</p><p id="c1d1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们将在这个android应用中使用<a class="ae jt" href="https://ayusch.com/mvp-architecture-android/" rel="noopener ugc nofollow" target="_blank"> MVP架构</a>。如果你不熟悉Android的MVP架构，我强烈推荐<a class="ae jt" href="https://ayusch.com/mvp-architecture-android/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hv">查看这个资源</strong> </a> <strong class="ix hv">。</strong></p><p id="a026" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这个<strong class="ix hv"> Android应用</strong>的整个开发过程将分为4个主要步骤:</p><ul class=""><li id="9314" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">在Google云平台上创建一个项目&amp;启用地图API。</li><li id="75cf" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">获取API密钥</li><li id="40ac" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">将地图SDK集成到新的Android应用程序中</li><li id="d665" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">添加用于计算区域面积的自定义设置</li></ul><p id="209c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">那么，我们开始吧！！</strong></p><h1 id="0ec2" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">在谷歌云平台上创建项目</h1><p id="dc0b" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">为了使用谷歌的任何API，你需要在谷歌云平台上创建一个项目。它有图像识别的视觉API、Youtube数据API、<strong class="ix hv">谷歌地图API </strong>等等API。</p><p id="32ee" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">在本教程中，我们将使用谷歌地图API。所以，为了创建一个新项目，去https://cloud.google.com/<a class="ae jt" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">T21T23】</a></p><ul class=""><li id="e30f" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">登录您的google帐户。</li><li id="984b" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">转到“控制台”</li><li id="a982" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">在左上角的汉堡包图标附近，点击下拉箭头。</li></ul><figure class="lp lq lr ls fq lt fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lo"><img src="../Images/8840116ecede38043d8c002bd8870606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0Y_ewe1nBOH2U9Fl.png"/></div></div></figure><ul class=""><li id="de22" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">然后点击“新建项目”。给它起个名字，然后点击“创建”。</li><li id="37d1" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">然后从同一个下拉箭头中，单击新创建的项目来选择它。</li><li id="bfb7" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">现在我们需要启用maps API。为此，点击左上角的汉堡图标，然后<strong class="ix hv">进入API&amp;服务</strong>。</li><li id="45f4" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">点击<strong class="ix hv">启用API和服务</strong>。</li></ul><figure class="lp lq lr ls fq lt fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lo"><img src="../Images/73b92ed18d2636c250984e4416818a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pBl7luXzg4L0Gg9x.png"/></div></div></figure><ul class=""><li id="3c22" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">选择Android版地图软件开发套件，然后点击启用。</li><li id="8d31" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">您的地图API已经可以在您的android应用程序中使用了！！</li></ul><h1 id="9a9a" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">获取API密钥</h1><p id="4d8d" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">Google需要验证请求来自一个经过验证的来源，为此，它向授权用户提供一个API密钥来验证请求。我们需要将这个API密钥添加到我们的<strong class="ix hv"> Android应用程序</strong>中。</p><p id="e638" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">因此，让我们继续为我们的应用程序创建一个API密钥。</p><ul class=""><li id="3208" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">在谷歌云平台，进入控制台，然后选择你的项目，点击APIs &amp; Services。</li><li id="ed8a" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">在左侧，点击“<strong class="ix hv">凭证</strong></li><li id="7eb2" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">然后点击屏幕中间的“创建凭证”按钮。您将有4个选项:</li><li id="215d" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">API密钥</li><li id="da5c" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">OAuth客户端ID</li><li id="147f" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">服务帐户密钥</li><li id="c90e" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">帮我选择</li></ul><figure class="lp lq lr ls fq lt fe ff paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="fe ff lo"><img src="../Images/9722b276e8f30931e5fc377b57e64a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*swjs_YDM9qungQpY.png"/></div></div></figure><ul class=""><li id="c231" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">点击API键。</li><li id="06e4" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">现在，谷歌将为您创建一个API密钥，您将在弹出窗口中看到。复制API密钥。当我们开始将地图SDK添加到我们的应用程序时，我们会将它添加到我们的android应用程序中。</li></ul><blockquote class="ir is it"><p id="8fac" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated">**注意:为了本教程的简单性，我没有对API密钥添加任何限制，但是当将应用程序发布到生产环境中时，强烈建议将API密钥限制到您的特定用途，如Android应用程序、iOS应用程序或web应用程序。**</p></blockquote><h1 id="56fe" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">将SDK集成到新的Android应用中</h1><p id="00e3" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">现在我们将开始在Android Studio中编写我们的应用程序。</p><h1 id="87f3" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">创建新的Android应用程序项目</h1><ul class=""><li id="11f7" class="jx jy hu ix b iy lj jc lk ju ma jv mb jw mc js kc kd ke kf dt translated">像往常一样，首先在Android Studio中创建一个新的Android应用程序。</li><li id="c4c9" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">打开应用程序级别的build.gradle文件，并添加以下依赖项</li></ul><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="7d6d" class="mi km hu me b fv mj mk l ml mm">implementation 'com.google.android.gms:play-services-maps:16.0.0'</span></pre><ul class=""><li id="73ab" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">现在点击同步项目，等待Android Studio下载依赖项并完成构建。</li><li id="86f4" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">一旦Android Studio完成构建，我们就可以将API密钥添加到我们的应用程序中了。</li><li id="6100" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">打开AndroidManifest.xml并在<application>标签中添加以下标签。<strong class="ix hv">记住，这些元标签应该放在任何&lt;活动&gt;标签之外。</strong></application></li></ul><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="0ef4" class="mi km hu me b fv mj mk l ml mm">&lt;meta-data<br/>    android:name="com.google.android.gms.version"<br/>    android:value="@integer/google_play_services_version" /&gt;<br/>&lt;meta-data<br/>    android:name="com.google.android.geo.API_KEY"<br/>    android:value="YOUR API KEY GOES HERE" /&gt;</span></pre><ul class=""><li id="e719" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">我们已经在应用程序中添加了API密钥。</li></ul><p id="990a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">设置工作已经基本完成，现在我们可以专注于创建实际的应用程序了。首先，我们需要将<strong class="ix hv"> Google Maps SDK </strong>提供的地图片段添加到我们的主活动布局文件中。因此，转到您的布局文件，在我的例子中是activity_main.xml，并将以下内容添加到您的代码中:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="5f67" class="mi km hu me b fv mj mk l ml mm">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".activities.MainActivity"&gt;<br/></span><span id="75dc" class="mi km hu me b fv mn mk l ml mm">    &lt;LinearLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        android:orientation="vertical"&gt;</span><span id="d4f6" class="mi km hu me b fv mn mk l ml mm">        &lt;TextView<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:background="@android:color/white"<br/>            android:padding="4dp"<br/>            android:text="Area:"<br/>            android:textSize="16sp" /&gt;</span><span id="96e9" class="mi km hu me b fv mn mk l ml mm">        &lt;TextView<br/>            android:id="@+id/tv_area"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="wrap_content"<br/>            android:background="@android:color/white"<br/>            android:padding="4dp"<br/>            android:text="18 m^2"<br/>            android:textSize="16sp" /&gt;</span><span id="b85b" class="mi km hu me b fv mn mk l ml mm">        &lt;fragment xmlns:android="http://schemas.android.com/apk/res/android"<br/>            xmlns:tools="http://schemas.android.com/tools"<br/>            android:id="@+id/map"<br/>            android:name="com.google.android.gms.maps.SupportMapFragment"<br/>            android:layout_width="match_parent"<br/>            android:layout_height="match_parent"<br/>            tools:context=".MapsActivity" /&gt;<br/>    &lt;/LinearLayout&gt;</span><span id="1e10" class="mi km hu me b fv mn mk l ml mm">    &lt;android.support.design.widget.FloatingActionButton<br/>        android:layout_width="wrap_content"<br/>        android:id="@+id/fab_undo"<br/>        android:layout_height="wrap_content"<br/>        android:layout_gravity="bottom|end"<br/>        android:layout_margin="16dp"<br/>        app:backgroundTint="@android:color/white"<br/>        app:elevation="2dp"<br/>        app:fabSize="normal"<br/>        app:rippleColor="@android:color/darker_gray"<br/>        app:srcCompat="@drawable/ic_undo_black_24dp" /&gt;</span><span id="3941" class="mi km hu me b fv mn mk l ml mm">&lt;/FrameLayout&gt;</span></pre><p id="4ac6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这将把一个<strong class="ix hv">地图片段</strong>添加到您的布局中。在地图片段的顶部，我们还添加了一个浮动的动作按钮来撤销我们最后标记的点。随着我们继续学习教程，这个按钮的用法将会很清楚。</p><h1 id="7b79" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">设置MVP架构</h1><p id="1741" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">虽然你可以在一个单独的活动中编写所有的代码，但是随着你的应用程序变得越来越大，管理它是不可能的，你最终会放弃这个应用程序(就像我几年前做的那样:P)。</p><p id="9db3" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">所以，我建议你<a class="ae jt" href="https://ayusch.com/mvp-architecture-android/" rel="noopener ugc nofollow" target="_blank">通读本教程，理解MVP架构</a>，一旦你理解了演示者、视图和模型是如何工作的，你就可以继续了。</p><p id="5473" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">下面是<strong class="ix hv">视图和演示者</strong>界面的代码:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="5b64" class="mi km hu me b fv mj mk l ml mm">public interface MapsContract {<br/>    interface View extends BaseView&lt;Presenter&gt; {</span><span id="79d6" class="mi km hu me b fv mn mk l ml mm">        void loadMap();</span><span id="ef4f" class="mi km hu me b fv mn mk l ml mm">        void showLocationPermissionNeeded();</span><span id="989e" class="mi km hu me b fv mn mk l ml mm">        void addMarkerToMap(MarkerOptions options, LatLng latLng);<br/>    }</span><span id="ae0f" class="mi km hu me b fv mn mk l ml mm">    interface Presenter extends BasePresenter{</span><span id="146d" class="mi km hu me b fv mn mk l ml mm">        void locationPermissionGranted();<br/>        void locationPermissionRefused();</span><span id="e758" class="mi km hu me b fv mn mk l ml mm">        void requestGps();</span><span id="98bc" class="mi km hu me b fv mn mk l ml mm">        void addMarker(LatLng latLng);<br/>    }</span><span id="a88c" class="mi km hu me b fv mn mk l ml mm">}</span></pre><p id="4a02" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">下面是<strong class="ix hv"> BasePresenter和Base View </strong>:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="e255" class="mi km hu me b fv mj mk l ml mm">public interface BasePresenter {<br/>    void start();<br/>}</span><span id="df55" class="mi km hu me b fv mn mk l ml mm">public interface BaseView &lt;T&gt;{<br/>    void setPresenter(T presenter);<br/>    Activity getViewActivity();<br/>}</span></pre><p id="c03a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv"><em class="iw">* *注意:这些放在单独的文件中** </em> </strong></p><p id="8b44" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在实现MapsContract。查看您的MainActivity.java并覆盖它的方法。</p><p id="de4e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">另外，创建一个MapsPresenter.java并实现MapsContract。演示者并重写其方法。</p><p id="ae95" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这是我们的<strong class="ix hv"> MainActivity和maps present</strong>目前的样子:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="9ef9" class="mi km hu me b fv mj mk l ml mm">public class MainActivity extends AppCompatActivity implements MapsContract.View, OnMapReadyCallback {</span><span id="6296" class="mi km hu me b fv mn mk l ml mm">    MapsContract.Presenter mPresenter;<br/>    private TextView areaTextView;</span><span id="8379" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        setContentView(R.layout.activity_main);<br/>        mPresenter = new MapsPresenter(this);<br/>        areaTextView = findViewById(R.id.tv_area);<br/>    }</span><span id="0d39" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void setPresenter(MapsContract.Presenter presenter) {<br/>        mPresenter = presenter;<br/>        mPresenter.start();<br/>    }</span><span id="7c44" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public Activity getViewActivity() {<br/>        return this;<br/>    }</span><span id="32c9" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void loadMap() {</span><span id="a5c8" class="mi km hu me b fv mn mk l ml mm">    }</span><span id="f8dd" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void showLocationPermissionNeeded() {<br/>    }</span><span id="2d43" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void addMarkerToMap(MarkerOptions options, LatLng latLng) {</span><span id="46fc" class="mi km hu me b fv mn mk l ml mm">    }</span><span id="bc8c" class="mi km hu me b fv mn mk l ml mm">}</span><span id="089f" class="mi km hu me b fv mn mk l ml mm">public class MapsPresenter implements MapsContract.Presenter, GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener {<br/>    MapsContract.View mView;</span><span id="be3f" class="mi km hu me b fv mn mk l ml mm">    MapsPresenter(MapsContract.View view) {<br/>        mView = view;<br/>        view.setPresenter(this);<br/>    }</span><span id="fe5a" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void start() {<br/>       <br/>    }</span><span id="f6a1" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void locationPermissionGranted() {<br/>        <br/>    }</span><span id="16c3" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void locationPermissionRefused() {<br/>    }</span><span id="d56a" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void requestGps() {<br/>        <br/>    }</span><span id="a9c9" class="mi km hu me b fv mn mk l ml mm">    @Override<br/>    public void addMarker(LatLng latLng) {</span><span id="7a26" class="mi km hu me b fv mn mk l ml mm">    }</span><span id="5b8f" class="mi km hu me b fv mn mk l ml mm">}</span></pre><h1 id="b427" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">设置地图</h1><p id="bae1" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">现在我们需要在MainActivity.java找到碎片并加载地图。要做到这一点，前往MainActivity.java，找到地图碎片的id如下:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="88ef" class="mi km hu me b fv mj mk l ml mm">@Override<br/>public void loadMap() {<br/>    SupportMapFragment fragment = (SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map);<br/>    fragment.getMapAsync(this);<br/>}</span></pre><p id="7b87" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们也异步加载地图。</p><p id="27d1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">要实现回调，请在“this”下的红色曲线行上按alt+enter，然后选择“实现方法”。</p><p id="dfdf" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，尝试在您的设备/模拟器上运行该应用程序。你会发现我们的地图还没起作用！！</p><h1 id="5434" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">许可</h1><p id="1bcb" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">您会注意到片段已经成功添加，您会看到google徽标，但您还看不到地图。这是因为我们没有要求用户允许他们的位置。</p><p id="90d1" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">从Android M开始，在运行时向用户询问许可是强制性的，而不是在下载应用程序时只询问一次。</p><p id="82d2" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">因此，我们现在将添加一些运行时权限。</p><p id="4535" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">首先，我们将在AndroidManifest.xml中为Android M以下的用户添加权限。</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="dfa2" class="mi km hu me b fv mj mk l ml mm">&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;</span></pre><p id="b0d6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在，在我们的演示者中，我们将检查权限是否已经被授予:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="f22e" class="mi km hu me b fv mj mk l ml mm">@Override<br/>public void start() {<br/>    checkPermission();<br/>}</span><span id="2e66" class="mi km hu me b fv mn mk l ml mm">private void checkPermission() {<br/>    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {</span><span id="7548" class="mi km hu me b fv mn mk l ml mm">        if (mView.getViewActivity().checkSelfPermission(android.Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {<br/>            if (mView.getViewActivity().shouldShowRequestPermissionRationale(android.Manifest.permission.ACCESS_FINE_LOCATION)) {<br/>                Toast.makeText(mView.getViewActivity(), "Please grant location permission", Toast.LENGTH_SHORT).show();<br/>                mView.getViewActivity().requestPermissions(new String[]{android.Manifest.permission.ACCESS_FINE_LOCATION}, Config.PERMISSION_LOCATION);<br/>            } else {<br/>                mView.getViewActivity().requestPermissions(new String[]{android.Manifest.permission.ACCESS_FINE_LOCATION}, Config.PERMISSION_LOCATION);<br/>            }<br/>        } else {<br/>            mView.loadMap();<br/>        }</span><span id="8d7e" class="mi km hu me b fv mn mk l ml mm">    } else {<br/>        mView.loadMap();<br/>    }<br/>}</span></pre><p id="0c9f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果没有，那么我们将检查我们之前是否已经请求了该权限，为此我们使用<strong class="ix hv">shouldshowrequestpermissionrational()</strong>方法。</p><p id="606f" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果我们之前没有请求这个权限，那么我们可以直接转到<strong class="ix hv"> requestPermissions() </strong>方法。</p><blockquote class="ir is it"><p id="c6a6" class="iu iv iw ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hn dt translated"><em class="hu">* *注意:由于只有Android M以上才需要这个，我们放置了一个包装器来检查版本是否在M以上，如果不是，那么我们直接加载地图** </em></p></blockquote><p id="331c" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果用户先前选择了“不再询问”选项，我们将不能再请求许可，这个方法将返回false，否则，我们将显示一个解释并再次请求许可。</p><p id="afa0" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">我们请求权限的结果在<strong class="ix hv">onRequestPermissionResult</strong>方法中获得，我们将在活动中覆盖该方法。</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="6b94" class="mi km hu me b fv mj mk l ml mm">@Override<br/>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br/>    switch (requestCode) {<br/>        case Config.PERMISSION_LOCATION: {<br/>            if (grantResults.length &gt; 0<br/>                    &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {<br/>                mPresenter.locationPermissionGranted();<br/>            } else {<br/>                mPresenter.locationPermissionRefused();<br/>            }<br/>            return;<br/>        }<br/>    }<br/>}</span></pre><p id="2086" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果用户已经授予了权限，我们就可以开始了，否则，我们需要禁用这个特性。</p><h1 id="03de" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">请求在Android应用程序中启用GPS</h1><p id="6a44" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">撇开运行时权限不谈，我们现在需要用户启用他们的GPS，这样我们就可以访问他们的当前位置并相应地放大地图。</p><p id="447b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">为此，我们需要在应用程序级build.gradle文件中添加另一个依赖项:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="d7ef" class="mi km hu me b fv mj mk l ml mm">implementation 'com.google.android.gms:play-services-location:16.0.0'</span></pre><p id="61a6" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在将项目与gradle文件同步，等待gradle构建完成。一旦完成，我们将开始向用户请求GPS。将以下代码添加到演示者:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="9912" class="mi km hu me b fv mj mk l ml mm">@Override<br/>public void requestGps() {<br/>    GoogleApiClient mGoogleApiClient = new GoogleApiClient.Builder(mView.getViewActivity())<br/>            .addApi(LocationServices.API)<br/>            .addConnectionCallbacks(this)<br/>            .addOnConnectionFailedListener(this).build();<br/>    mGoogleApiClient.connect();</span><span id="789f" class="mi km hu me b fv mn mk l ml mm">    LocationRequest locationRequest = LocationRequest.create()<br/>            .setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY)<br/>            .setNumUpdates(5)<br/>            .setInterval(100);</span><span id="0129" class="mi km hu me b fv mn mk l ml mm">    LocationSettingsRequest.Builder builder = new LocationSettingsRequest.Builder()<br/>            .addLocationRequest(locationRequest).setAlwaysShow(true);<br/>    PendingResult&lt;LocationSettingsResult&gt; result =<br/>            LocationServices.SettingsApi.checkLocationSettings(mGoogleApiClient, builder.build());<br/>    result.setResultCallback(new ResultCallback&lt;LocationSettingsResult&gt;() {<br/>        @Override<br/>        public void onResult(@NonNull LocationSettingsResult locationSettingsResult) {<br/>            final Status status = locationSettingsResult.getStatus();<br/>            switch (status.getStatusCode()) {<br/>                case LocationSettingsStatusCodes.SUCCESS:</span><span id="19f0" class="mi km hu me b fv mn mk l ml mm">                    break;<br/>                case LocationSettingsStatusCodes.RESOLUTION_REQUIRED:<br/>                    try {<br/>                        // Show the dialog by calling startResolutionForResult(),<br/>                        // and check the result in onActivityResult().<br/>                        status.startResolutionForResult(mView.getViewActivity(),<br/>                                Config.CHECK_GPS_ON_SETTING);<br/>                    } catch (IntentSender.SendIntentException e) {<br/>                        e.printStackTrace();<br/>                    }<br/>                    break;<br/>                case LocationSettingsStatusCodes.SETTINGS_CHANGE_UNAVAILABLE:<br/>                    break;<br/>            }<br/>        }<br/>    });<br/>}</span></pre><p id="2d50" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">我来解释一下这是怎么回事！！</strong></p><p id="c281" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv"> GoogleApiClient </strong>用于访问google play服务，如<strong class="ix hv"> Google Sign-In </strong>、<strong class="ix hv"> Google Drive </strong>等。在这种情况下，我们将访问google play服务下提供的定位服务。</p><p id="1962" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">事情是这样的:</p><ul class=""><li id="5062" class="jx jy hu ix b iy iz jc jd ju jz jv ka jw kb js kc kd ke kf dt translated">首先，创建一个<strong class="ix hv">客户端</strong>来建立与定位服务的连接。</li><li id="d72a" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">其次，我们配置<strong class="ix hv">位置服务</strong>的更新频率和服务质量。</li><li id="f5da" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">第三，我们检查我们是否能够从播放服务接收位置更新。如果没有，那么GPS就没有启用，我们就相应地计划下一步行动。</li><li id="39d1" class="jx jy hu ix b iy kg jc kh ju ki jv kj jw kk js kc kd ke kf dt translated">通常，如果用户的<strong class="ix hv"> GPS未启用</strong>，我们会带他们去设置活动，并要求他们启用位置。如果用户启用了位置，我们返回到onActivityResult方法，并获得<strong class="ix hv">成功</strong>，否则我们需要继续，而不进行位置更新。</li></ul><p id="3c4b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">因此，为了检查用户是否最终启用了该位置，请前往MainActivity.java并添加以下代码:</strong></p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="fbb7" class="mi km hu me b fv mj mk l ml mm">@Override<br/>protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {<br/>    switch (requestCode) {<br/>        case Config.CHECK_GPS_ON_SETTING: {<br/>            switch (resultCode) {<br/>                case RESULT_OK:</span><span id="1df6" class="mi km hu me b fv mn mk l ml mm">                case RESULT_CANCELED:</span><span id="c668" class="mi km hu me b fv mn mk l ml mm">                    break;<br/>                default:<br/>                    break;<br/>            }<br/>            break;<br/>        }<br/>    }<br/>}</span></pre><p id="89c4" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果权限被授予，我们调用mpresenter . locationpermissiongranted()，否则调用mpresenter . locationpermissiondenied()。</p><h1 id="e5ef" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">添加用于计算区域面积的自定义设置</h1><p id="a48a" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">不，这是最简单的部分。一旦我们有了<strong class="ix hv">许可</strong>、<strong class="ix hv"> GPS设置</strong>和我们的<strong class="ix hv">地图加载</strong>，我们现在可以继续更多令人兴奋的功能，例如当用户在屏幕上放置标记时绘制一个多边形并计算面积。</p><h1 id="18d0" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">添加/移除标记</h1><p id="a6b3" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">现在，当用户触摸地图上的任何位置时，我们将开始在屏幕上添加标记。要做到这一点，请使用onMapReady回调并将onMapClickListener添加到地图中:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="a8f6" class="mi km hu me b fv mj mk l ml mm">@SuppressLint("MissingPermission")<br/>@Override<br/>public void onMapReady(GoogleMap googleMap) {<br/>    mMap = googleMap;<br/>    mMap.setMyLocationEnabled(true);<br/>    mMap.setOnMapClickListener(new GoogleMap.OnMapClickListener() {<br/>        @Override<br/>        public void onMapClick(LatLng latLng) {<br/>            mPresenter.addMarker(latLng);<br/>        }<br/>    });</span><span id="c0f6" class="mi km hu me b fv mn mk l ml mm">}</span></pre><p id="0b91" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">每当用户<strong class="ix hv">在地图上点击</strong>时，我们要求演示者添加标记，它配置标记并返回配置的标记选项，这些选项可用于在屏幕上放置标记。转到MapsPresenter并添加以下代码:</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="4a7c" class="mi km hu me b fv mj mk l ml mm">@Override<br/>public void addMarker(LatLng latLng) {<br/>    Activity activity = mView.getViewActivity();<br/>    @IdRes int icon = R.drawable.ic_add_location_light_green_500_36dp;<br/>    BitmapDescriptor bitmap = BitmapDescriptorFactory.fromBitmap(getBitmapFromDrawable(activity, icon));<br/>    MarkerOptions options = new MarkerOptions().position(latLng).icon(bitmap).draggable(true);<br/>    mView.addMarkerToMap(options,latLng);<br/>}</span><span id="a834" class="mi km hu me b fv mn mk l ml mm">private static Bitmap getBitmapFromDrawable(Context context, int icon) {<br/>    Drawable drawable = ContextCompat.getDrawable(context, icon);<br/>    Bitmap obm = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);<br/>    Canvas canvas = new Canvas(obm);<br/>    drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());<br/>    drawable.draw(canvas);<br/>    return obm;<br/>}</span></pre><p id="9a84" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">要添加标记，我们使用map对象提供的addMarker方法。然后我们添加标记并指向它们各自的列表，最后在屏幕上画出多边形。</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="d4ff" class="mi km hu me b fv mj mk l ml mm">@Override<br/>public void addMarkerToMap(MarkerOptions options, LatLng latLng) {<br/>    Marker marker = mMap.addMarker(options);<br/>    marker.setTag(latLng);<br/>    markerList.add(marker);<br/>    points.add(latLng);<br/>    drawPolygon();<br/>}</span><span id="42f2" class="mi km hu me b fv mn mk l ml mm">private void drawPolygon() {<br/>    if (polygon != null) {<br/>        polygon.remove();<br/>    }<br/>    PolygonOptions polygonOptions = new PolygonOptions();<br/>    polygonOptions.fillColor(Color.argb(0, 0, 0, 0));<br/>    polygonOptions.strokeColor(Color.argb(255, 0, 0, 0));<br/>    polygonOptions.strokeWidth(10);<br/>    polygonOptions.addAll(points);<br/>    polygon = mMap.addPolygon(polygonOptions);<br/>}</span></pre><p id="6e6b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">现在我们添加一个<strong class="ix hv">拖拽监听器</strong>到标记中，以防用户改变主意，决定改变已经放置的标记的位置。为了更新位置，我们在列表中找到标记，并在点列表中更新它的lat long。</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="a605" class="mi km hu me b fv mj mk l ml mm">@SuppressLint("MissingPermission")<br/>@Override<br/>public void onMapReady(GoogleMap googleMap) {<br/>    mMap = googleMap;<br/>    mMap.setMyLocationEnabled(true);<br/>    mMap.setOnMapClickListener(new GoogleMap.OnMapClickListener() {<br/>        @Override<br/>        public void onMapClick(LatLng latLng) {<br/>            mPresenter.addMarker(latLng);<br/>        }<br/>    });</span><span id="cf3f" class="mi km hu me b fv mn mk l ml mm">    mMap.setOnMarkerDragListener(new GoogleMap.OnMarkerDragListener() {<br/>        @Override<br/>        public void onMarkerDragStart(Marker marker) {</span><span id="389a" class="mi km hu me b fv mn mk l ml mm">        }</span><span id="fbd5" class="mi km hu me b fv mn mk l ml mm">        @Override<br/>        public void onMarkerDrag(Marker marker) {<br/>            updateMarkerLocation(marker,false);<br/>        }</span><span id="69c5" class="mi km hu me b fv mn mk l ml mm">        @Override<br/>        public void onMarkerDragEnd(Marker marker) {<br/>            updateMarkerLocation(marker,true);<br/>        }<br/>    });</span><span id="fe18" class="mi km hu me b fv mn mk l ml mm">}</span><span id="f65e" class="mi km hu me b fv mn mk l ml mm">private void updateMarkerLocation(Marker marker, boolean calculate) {<br/>    LatLng latLng = (LatLng) marker.getTag();<br/>    int position = points.indexOf(latLng);<br/>    points.set(position, marker.getPosition());<br/>    marker.setTag(marker.getPosition());<br/>    drawPolygon();<br/>    if (calculate)<br/>        setAreaLength(points);<br/>}</span></pre><p id="dc0e" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">最后，我们给用户一个选项来移除他们最后放置的标记</strong>。我们在浮动动作按钮上放置一个点击监听器，点击它时，从标记列表中删除标记，并更新点列表。</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="066a" class="mi km hu me b fv mj mk l ml mm">@Override<br/>protected void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    setContentView(R.layout.activity_main);<br/>    mPresenter = new MapsPresenter(this);<br/>    areaTextView = findViewById(R.id.tv_area);<br/>    FloatingActionButton fabundo = findViewById(R.id.fab_undo);<br/>    fabundo.setOnClickListener(new View.OnClickListener() {<br/>        @Override<br/>        public void onClick(View view) {<br/>            if (points.size() &gt; 0) {<br/>                Marker marker = markerList.get(markerList.size() - 1);<br/>                marker.remove();<br/>                markerList.remove(marker);<br/>                points.remove(points.size() - 1);<br/>                if (points.size() &gt; 0) {<br/>                    drawPolygon();<br/>                }<br/>            }<br/>        }<br/>    });<br/>}</span></pre><h1 id="52b2" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">计算面积</h1><p id="ab50" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">这一部分相当简单，我们创建一个名为<strong class="ix hv"> SphericalUtil </strong>和<strong class="ix hv"> MathUtil </strong>的实用程序类。这是它们的代码。</p><pre class="lp lq lr ls fq md me mf mg aw mh dt"><span id="1609" class="mi km hu me b fv mj mk l ml mm">public class SphericalUtil {</span><span id="6dae" class="mi km hu me b fv mn mk l ml mm">    private SphericalUtil() {}</span><span id="dbf7" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the heading from one LatLng to another LatLng. Headings are<br/>     * expressed in degrees clockwise from North within the range [-180,180).<br/>     * @return The heading in degrees clockwise from north.<br/>     */<br/>    public static double computeHeading(LatLng from, LatLng to) {<br/>        // <a class="ae jt" href="http://williams.best.vwh.net/avform.htm#Crs" rel="noopener ugc nofollow" target="_blank">http://williams.best.vwh.net/avform.htm#Crs</a><br/>        double fromLat = toRadians(from.latitude);<br/>        double fromLng = toRadians(from.longitude);<br/>        double toLat = toRadians(to.latitude);<br/>        double toLng = toRadians(to.longitude);<br/>        double dLng = toLng - fromLng;<br/>        double heading = atan2(<br/>                sin(dLng) * cos(toLat),<br/>                cos(fromLat) * sin(toLat) - sin(fromLat) * cos(toLat) * cos(dLng));<br/>        return wrap(toDegrees(heading), -180, 180);<br/>    }</span><span id="346f" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the LatLng resulting from moving a distance from an origin<br/>     * in the specified heading (expressed in degrees clockwise from north).<br/>     * @param from     The LatLng from which to start.<br/>     * @param distance The distance to travel.<br/>     * @param heading  The heading in degrees clockwise from north.<br/>     */<br/>    public static LatLng computeOffset(LatLng from, double distance, double heading) {<br/>        distance /= EARTH_RADIUS;<br/>        heading = toRadians(heading);<br/>        // <a class="ae jt" href="http://williams.best.vwh.net/avform.htm#LL" rel="noopener ugc nofollow" target="_blank">http://williams.best.vwh.net/avform.htm#LL</a><br/>        double fromLat = toRadians(from.latitude);<br/>        double fromLng = toRadians(from.longitude);<br/>        double cosDistance = cos(distance);<br/>        double sinDistance = sin(distance);<br/>        double sinFromLat = sin(fromLat);<br/>        double cosFromLat = cos(fromLat);<br/>        double sinLat = cosDistance * sinFromLat + sinDistance * cosFromLat * cos(heading);<br/>        double dLng = atan2(<br/>                sinDistance * cosFromLat * sin(heading),<br/>                cosDistance - sinFromLat * sinLat);<br/>        return new LatLng(toDegrees(asin(sinLat)), toDegrees(fromLng + dLng));<br/>    }</span><span id="8f56" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the location of origin when provided with a LatLng destination,<br/>     * meters travelled and original heading. Headings are expressed in degrees<br/>     * clockwise from North. This function returns null when no solution is<br/>     * available.<br/>     * @param to       The destination LatLng.<br/>     * @param distance The distance travelled, in meters.<br/>     * @param heading  The heading in degrees clockwise from north.<br/>     */<br/>    public static LatLng computeOffsetOrigin(LatLng to, double distance, double heading) {<br/>        heading = toRadians(heading);<br/>        distance /= EARTH_RADIUS;<br/>        // <a class="ae jt" href="http://lists.maptools.org/pipermail/proj/2008-October/003939.html" rel="noopener ugc nofollow" target="_blank">http://lists.maptools.org/pipermail/proj/2008-October/003939.html</a><br/>        double n1 = cos(distance);<br/>        double n2 = sin(distance) * cos(heading);<br/>        double n3 = sin(distance) * sin(heading);<br/>        double n4 = sin(toRadians(to.latitude));<br/>        // There are two solutions for b. b = n2 * n4 +/- sqrt(), one solution results<br/>        // in the latitude outside the [-90, 90] range. We first try one solution and<br/>        // back off to the other if we are outside that range.<br/>        double n12 = n1 * n1;<br/>        double discriminant = n2 * n2 * n12 + n12 * n12 - n12 * n4 * n4;<br/>        if (discriminant &lt; 0) {<br/>            // No real solution which would make sense in LatLng-space.<br/>            return null;<br/>        }<br/>        double b = n2 * n4 + sqrt(discriminant);<br/>        b /= n1 * n1 + n2 * n2;<br/>        double a = (n4 - n2 * b) / n1;<br/>        double fromLatRadians = atan2(a, b);<br/>        if (fromLatRadians &lt; -PI / 2 || fromLatRadians &gt; PI / 2) {<br/>            b = n2 * n4 - sqrt(discriminant);<br/>            b /= n1 * n1 + n2 * n2;<br/>            fromLatRadians = atan2(a, b);<br/>        }<br/>        if (fromLatRadians &lt; -PI / 2 || fromLatRadians &gt; PI / 2) {<br/>            // No solution which would make sense in LatLng-space.<br/>            return null;<br/>        }<br/>        double fromLngRadians = toRadians(to.longitude) -<br/>                atan2(n3, n1 * cos(fromLatRadians) - n2 * sin(fromLatRadians));<br/>        return new LatLng(toDegrees(fromLatRadians), toDegrees(fromLngRadians));<br/>    }</span><span id="88b0" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the LatLng which lies the given fraction of the way between the<br/>     * origin LatLng and the destination LatLng.<br/>     * @param from     The LatLng from which to start.<br/>     * @param to       The LatLng toward which to travel.<br/>     * @param fraction A fraction of the distance to travel.<br/>     * @return The interpolated LatLng.<br/>     */<br/>    public static LatLng interpolate(LatLng from, LatLng to, double fraction) {<br/>        // <a class="ae jt" href="http://en.wikipedia.org/wiki/Slerp" rel="noopener ugc nofollow" target="_blank">http://en.wikipedia.org/wiki/Slerp</a><br/>        double fromLat = toRadians(from.latitude);<br/>        double fromLng = toRadians(from.longitude);<br/>        double toLat = toRadians(to.latitude);<br/>        double toLng = toRadians(to.longitude);<br/>        double cosFromLat = cos(fromLat);<br/>        double cosToLat = cos(toLat);</span><span id="a896" class="mi km hu me b fv mn mk l ml mm">        // Computes Spherical interpolation coefficients.<br/>        double angle = computeAngleBetween(from, to);<br/>        double sinAngle = sin(angle);<br/>        if (sinAngle &lt; 1E-6) {<br/>            return new LatLng(<br/>                    from.latitude + fraction * (to.latitude - from.latitude),<br/>                    from.longitude + fraction * (to.longitude - from.longitude));<br/>        }<br/>        double a = sin((1 - fraction) * angle) / sinAngle;<br/>        double b = sin(fraction * angle) / sinAngle;</span><span id="a4df" class="mi km hu me b fv mn mk l ml mm">        // Converts from polar to vector and interpolate.<br/>        double x = a * cosFromLat * cos(fromLng) + b * cosToLat * cos(toLng);<br/>        double y = a * cosFromLat * sin(fromLng) + b * cosToLat * sin(toLng);<br/>        double z = a * sin(fromLat) + b * sin(toLat);</span><span id="8ef3" class="mi km hu me b fv mn mk l ml mm">        // Converts interpolated vector back to polar.<br/>        double lat = atan2(z, sqrt(x * x + y * y));<br/>        double lng = atan2(y, x);<br/>        return new LatLng(toDegrees(lat), toDegrees(lng));<br/>    }</span><span id="4657" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns distance on the unit sphere; the arguments are in radians.<br/>     */<br/>    private static double distanceRadians(double lat1, double lng1, double lat2, double lng2) {<br/>        return arcHav(havDistance(lat1, lat2, lng1 - lng2));<br/>    }</span><span id="8d4b" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the angle between two LatLngs, in radians. This is the same as the distance<br/>     * on the unit sphere.<br/>     */<br/>    static double computeAngleBetween(LatLng from, LatLng to) {<br/>        return distanceRadians(toRadians(from.latitude), toRadians(from.longitude),<br/>                toRadians(to.latitude), toRadians(to.longitude));<br/>    }</span><span id="1757" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the distance between two LatLngs, in meters.<br/>     */<br/>    public static double computeDistanceBetween(LatLng from, LatLng to) {<br/>        return computeAngleBetween(from, to) * EARTH_RADIUS;<br/>    }</span><span id="5247" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the length of the given path, in meters, on Earth.<br/>     */<br/>    public static double computeLength(List&lt;LatLng&gt; path) {<br/>        if (path.size() &lt; 2) {<br/>            return 0;<br/>        }<br/>        double length = 0;<br/>        LatLng prev = path.get(0);<br/>        double prevLat = toRadians(prev.latitude);<br/>        double prevLng = toRadians(prev.longitude);<br/>        for (LatLng point : path) {<br/>            double lat = toRadians(point.latitude);<br/>            double lng = toRadians(point.longitude);<br/>            length += distanceRadians(prevLat, prevLng, lat, lng);<br/>            prevLat = lat;<br/>            prevLng = lng;<br/>        }<br/>        return length * EARTH_RADIUS;<br/>    }</span><span id="8c15" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the area of a closed path on Earth.<br/>     * @param path A closed path.<br/>     * @return The path's area in square meters.<br/>     */<br/>    public static double computeArea(List&lt;LatLng&gt; path) {<br/>        return abs(computeSignedArea(path));<br/>    }</span><span id="0dda" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the signed area of a closed path on Earth. The sign of the area may be used to<br/>     * determine the orientation of the path.<br/>     * "inside" is the surface that does not contain the South Pole.<br/>     * @param path A closed path.<br/>     * @return The loop's area in square meters.<br/>     */<br/>    public static double computeSignedArea(List&lt;LatLng&gt; path) {<br/>        return computeSignedArea(path, EARTH_RADIUS);<br/>    }</span><span id="42da" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the signed area of a closed path on a sphere of given radius.<br/>     * The computed area uses the same units as the radius squared.<br/>     * Used by SphericalUtilTest.<br/>     */<br/>    static double computeSignedArea(List&lt;LatLng&gt; path, double radius) {<br/>        int size = path.size();<br/>        if (size &lt; 3) { return 0; }<br/>        double total = 0;<br/>        LatLng prev = path.get(size - 1);<br/>        double prevTanLat = tan((PI / 2 - toRadians(prev.latitude)) / 2);<br/>        double prevLng = toRadians(prev.longitude);<br/>        // For each edge, accumulate the signed area of the triangle formed by the North Pole<br/>        // and that edge ("polar triangle").<br/>        for (LatLng point : path) {<br/>            double tanLat = tan((PI / 2 - toRadians(point.latitude)) / 2);<br/>            double lng = toRadians(point.longitude);<br/>            total += polarTriangleArea(tanLat, lng, prevTanLat, prevLng);<br/>            prevTanLat = tanLat;<br/>            prevLng = lng;<br/>        }<br/>        return total * (radius * radius);<br/>    }</span><span id="5484" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the signed area of a triangle which has North Pole as a vertex.<br/>     * Formula derived from "Area of a spherical triangle given two edges and the included angle"<br/>     * as per "Spherical Trigonometry" by Todhunter, page 71, section 103, point 2.<br/>     * See <a class="ae jt" href="http://books.google.com/books?id=3uBHAAAAIAAJ&amp;pg=PA71" rel="noopener ugc nofollow" target="_blank">http://books.google.com/books?id=3uBHAAAAIAAJ&amp;pg=PA71</a><br/>     * The arguments named "tan" are tan((pi/2 - latitude)/2).<br/>     */<br/>    private static double polarTriangleArea(double tan1, double lng1, double tan2, double lng2) {<br/>        double deltaLng = lng1 - lng2;<br/>        double t = tan1 * tan2;<br/>        return 2 * atan2(t * sin(deltaLng), 1 + t * cos(deltaLng));<br/>    }<br/>}</span><span id="d27f" class="mi km hu me b fv mn mk l ml mm">class MathUtil {<br/>    /**<br/>     * The earth's radius, in meters.<br/>     * Mean radius as defined by IUGG.<br/>     */<br/>    static final double EARTH_RADIUS = 6371009;</span><span id="c7e0" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Restrict x to the range [low, high].<br/>     */<br/>    static double clamp(double x, double low, double high) {<br/>        return x &lt; low ? low : (x &gt; high ? high : x);<br/>    }</span><span id="a4eb" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Wraps the given value into the inclusive-exclusive interval between min and max.<br/>     * @param n   The value to wrap.<br/>     * @param min The minimum.<br/>     * @param max The maximum.<br/>     */<br/>    static double wrap(double n, double min, double max) {<br/>        return (n &gt;= min &amp;&amp; n &lt; max) ? n : (mod(n - min, max - min) + min);<br/>    }</span><span id="dbe6" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns the non-negative remainder of x / m.<br/>     * @param x The operand.<br/>     * @param m The modulus.<br/>     */<br/>    static double mod(double x, double m) {<br/>        return ((x % m) + m) % m;<br/>    }</span><span id="3392" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns mercator Y corresponding to latitude.<br/>     * See <a class="ae jt" href="http://en.wikipedia.org/wiki/Mercator_projection" rel="noopener ugc nofollow" target="_blank">http://en.wikipedia.org/wiki/Mercator_projection</a> .<br/>     */<br/>    static double mercator(double lat) {<br/>        return log(tan(lat * 0.5 + PI/4));<br/>    }</span><span id="29b0" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns latitude from mercator Y.<br/>     */<br/>    static double inverseMercator(double y) {<br/>        return 2 * atan(exp(y)) - PI / 2;<br/>    }</span><span id="7af1" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns haversine(angle-in-radians).<br/>     * hav(x) == (1 - cos(x)) / 2 == sin(x / 2)^2.<br/>     */<br/>    static double hav(double x) {<br/>        double sinHalf = sin(x * 0.5);<br/>        return sinHalf * sinHalf;<br/>    }</span><span id="c451" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Computes inverse haversine. Has good numerical stability around 0.<br/>     * arcHav(x) == acos(1 - 2 * x) == 2 * asin(sqrt(x)).<br/>     * The argument must be in [0, 1], and the result is positive.<br/>     */<br/>    static double arcHav(double x) {<br/>        return 2 * asin(sqrt(x));<br/>    }</span><span id="a53e" class="mi km hu me b fv mn mk l ml mm">    // Given h==hav(x), returns sin(abs(x)).<br/>    static double sinFromHav(double h) {<br/>        return 2 * sqrt(h * (1 - h));<br/>    }</span><span id="9e3b" class="mi km hu me b fv mn mk l ml mm">    // Returns hav(asin(x)).<br/>    static double havFromSin(double x) {<br/>        double x2 = x * x;<br/>        return x2 / (1 + sqrt(1 - x2)) * .5;<br/>    }</span><span id="fcec" class="mi km hu me b fv mn mk l ml mm">    // Returns sin(arcHav(x) + arcHav(y)).<br/>    static double sinSumFromHav(double x, double y) {<br/>        double a = sqrt(x * (1 - x));<br/>        double b = sqrt(y * (1 - y));<br/>        return 2 * (a + b - 2 * (a * y + b * x));<br/>    }</span><span id="a200" class="mi km hu me b fv mn mk l ml mm">    /**<br/>     * Returns hav() of distance from (lat1, lng1) to (lat2, lng2) on the unit sphere.<br/>     */<br/>    static double havDistance(double lat1, double lat2, double dLng) {<br/>        return hav(lat1 - lat2) + hav(dLng) * cos(lat1) * cos(lat2);<br/>    }<br/>}</span></pre><p id="70cc" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这些类实际上是Goolge的另一个库的一部分:<a class="ae jt" href="https://github.com/googlemaps/android-maps-utils" rel="noopener ugc nofollow" target="_blank">https://github.com/googlemaps/android-maps-utils</a></p><p id="0c77" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">这是谷歌定制的一个实用程序库，可以和谷歌地图一起使用。但是由于它包含了许多我们不需要的特性，我们只从库中复制了我们需要的两个文件。导入整个库并膨胀应用程序是没有意义的。</p><p id="b8b9" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">最后，在我们的MainActivity.java中，我们根据存储在数组列表中的lat-long来更新区域。</p><h1 id="0e23" class="kl km hu bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li dt translated">结论</h1><p id="b31b" class="pw-post-body-paragraph iu iv hu ix b iy lj ja jb jc lk je jf ju ll ji jj jv lm jm jn jw ln jq jr js hn dt translated">我们的应用程序已经启动并运行。它可以用来计算谷歌地图上显示的任何地区的面积。</p><p id="8bfa" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><strong class="ix hv">作为该项目的扩展，我把添加手绘等功能来标记该区域的任务留给了你，因为多次点击会很难标记复杂的形状。</strong></p><p id="9548" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">让我知道我是否应该作为一个独立的图书馆出版这😉</p><p id="3f9b" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">另外，<a class="ae jt" href="https://ayusch.com/my-journey-to-become-an-expert-android-developer/" rel="noopener ugc nofollow" target="_blank">看看我的旅程</a>，我会告诉你我是如何开始Android开发的，以及我在这里参考了哪些在线资源和<a class="ae jt" href="http://www.microverse.org" rel="noopener ugc nofollow" target="_blank">在线学校</a>。</p></div><div class="ab cl mo mp hc mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="hn ho hp hq hr"><figure class="lp lq lr ls fq lt fe ff paragraph-image"><a href="http://www.microverse.org"><div class="fe ff lo"><img src="../Images/531f5119563669b3c14ca7d4c56788c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L8S85AXZkyfNKpcr7B77jQ.png"/></div></a><figcaption class="mv mw fg fe ff mx my bd b be z ek">Microverse.org</figcaption></figure><p id="4b35" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><em class="iw">喜欢你读的东西？别忘了把这个帖子分享在</em><a class="ae jt" href="https://www.facebook.com/AndroidVille" rel="noopener ugc nofollow" target="_blank"><strong class="ix hv"><em class="iw"/></strong></a><em class="iw"/><strong class="ix hv"><em class="iw">Whatsapp</em></strong><em class="iw"/><strong class="ix hv"><em class="iw">LinkedIn</em></strong><em class="iw">上。</em></p><p id="ea25" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated"><em class="iw">可以关注我上</em> <a class="ae jt" href="https://www.linkedin.com/in/ayuschjain" rel="noopener ugc nofollow" target="_blank"> <em class="iw"> LinkedIn </em> </a> <em class="iw">，</em> <a class="ae jt" href="https://www.quora.com/profile/Ayusch-Jain" rel="noopener ugc nofollow" target="_blank"> <em class="iw"> Quora </em> </a> <em class="iw">，</em><a class="ae jt" href="https://twitter.com/ayuschjain" rel="noopener ugc nofollow" target="_blank"><em class="iw">Twitter</em></a><em class="iw">，</em><a class="ae jt" href="https://www.instagram.com/androidville/" rel="noopener ugc nofollow" target="_blank"><em class="iw">insta gram</em></a><em class="iw">哪里我</em> <strong class="ix hv"> <em class="iw">回答</em> </strong> <em class="iw">问题相关</em> <strong class="ix hv"> <em class="iw"/></strong></p><p id="071a" class="pw-post-body-paragraph iu iv hu ix b iy iz ja jb jc jd je jf ju jh ji jj jv jl jm jn jw jp jq jr js hn dt translated">如果您想了解所有最新文章，请在本页右上角的表格中输入您的电子邮件地址，订阅每周时事通讯。T41】</p></div></div>    
</body>
</html>