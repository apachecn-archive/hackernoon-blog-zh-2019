<html>
<head>
<title>How to develop Go gRPC microservices and deploy in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何开发 Go gRPC 微服务并在 Kubernetes 中部署</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-develop-go-grpc-microservices-and-deploy-in-kubernates-5eace0425bf8#2019-02-02">https://medium.com/hackernoon/how-to-develop-go-grpc-microservices-and-deploy-in-kubernates-5eace0425bf8#2019-02-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/32d349033ff7b153e6292bc641f6926c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHzWwCWXtgqQ1kImkAH6_g.png"/></div></div></figure><p id="e1b1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几个月前，我开始了学习 gRPC 的旅程。本文将展示我们如何使用 gRPC 来开发使用 Go 的微服务，并在 kubernetes 集群中部署它们。<br/>我们将开发两种微服务。一个微服务将负责计算两个整数和，另一个将服务于一个公共 REST API。</p><h1 id="f39d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">先决条件</h1><p id="3077" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">在本地机器上运行 kubernetes 集群有很多种方法。我将在这篇文章中使用<a class="ae ld" href="https://github.com/kubernetes/minikube" rel="noopener ugc nofollow" target="_blank"> Minikube </a>。我们还需要安装<a class="ae ld" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>、<a class="ae ld" href="https://docs.docker.com/install/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和 Protobuf <a class="ae ld" href="https://github.com/protocolbuffers/protobuf" rel="noopener ugc nofollow" target="_blank">编译器</a>。</p><p id="d2bf" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要启动 Minikube，您必须以 root 权限运行以下命令</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="238e" class="ln kb hu lj b fv lo lp l lq lr">$ minikube start [--vm-driver=&lt;driver&gt;]</span></pre><h1 id="1d3a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">定义通信协议</h1><p id="db40" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">作为底层传输协议，我们将使用 gRPC。为此，我们需要用协议缓冲区的<a class="ae ld" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">接口定义语言</a>编写消息类型和服务的定义，并编译它们。在您的项目根目录中，在<code class="eh ls lt lu lj b">pb</code>目录下创建一个名为<code class="eh ls lt lu lj b">add.proto</code>的文件。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="347a" class="ln kb hu lj b fv lo lp l lq lr">syntax = "proto3";<br/><br/>package pb;<br/><br/>message AddRequest {<br/>    uint64 a = 1;<br/>    uint64 b = 2;<br/>}<br/><br/>message AddResponse {<br/>    uint64 result = 1;<br/>}<br/><br/>service AddService {<br/>    rpc Compute (AddRequest) returns (AddResponse) {}<br/>}</span></pre><p id="1133" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要编译这个<code class="eh ls lt lu lj b">proto</code>文件，导航到<code class="eh ls lt lu lj b">pb</code>目录并运行以下命令</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="076e" class="ln kb hu lj b fv lo lp l lq lr">$ protoc -I . --go_out=plugins=grpc:. ./*.proto</span></pre><p id="313c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编译成功后，会在同一个目录下产生<code class="eh ls lt lu lj b">add.pb.go</code>文件。</p><h1 id="a80d" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">实现总和服务</h1><p id="d7c0" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">为了实现求和服务，我们需要使用自动生成的代码。现在在<code class="eh ls lt lu lj b">add</code>目录下创建<code class="eh ls lt lu lj b">main.go</code>文件，并确保导入正确的包</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="41ca" class="ln kb hu lj b fv lo lp l lq lr">package main<br/><br/>import (<br/>	"fmt"<br/>        "golang.org/x/net/context"<br/>	"google.golang.org/grpc"<br/>	"google.golang.org/grpc/reflection"<br/>	"log"<br/>	"net"<br/>    <br/>        // replace this with your own project<br/>	"github.com/shuza/kubernetes-go-grpc/pd"<br/>)</span></pre><p id="5d74" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在使用自动生成的<code class="eh ls lt lu lj b">pb.AddServiceClient</code>接口实现将两个整数相加的<code class="eh ls lt lu lj b">Compute</code>处理函数。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="80b8" class="ln kb hu lj b fv lo lp l lq lr">func (s *server) Compute(cxt context.Context, r *pb.AddRequest) (*pb.AddResponse, error) {<br/>	result := &amp;pb.AddResponse{}<br/>	result.Result = r.A + r.B<br/><br/>	logMessage := fmt.Sprintf("A: %d   B: %d     sum: %d", r.A, r.B, result.Result)<br/>	log.Println(logMessage)<br/><br/>	return result, nil<br/>}</span></pre><p id="e054" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意，在 main 函数中，注册一个将处理请求的服务器类型。然后启动 gRPC 服务器。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="3a74" class="ln kb hu lj b fv lo lp l lq lr">type server struct{}<br/><br/>func main() {<br/>	lis, err := net.Listen("tcp", ":3000")<br/>	if err != nil {<br/>		log.Fatalf("Failed to listen:  %v", err)<br/>	}<br/><br/>	s := grpc.NewServer()<br/>	pb.RegisterAddServiceServer(s, &amp;server{})<br/>	reflection.Register(s)<br/>	if err := s.Serve(lis); err != nil {<br/>		log.Fatalf("Failed to serve: %v", err)<br/>	}<br/>}</span></pre><h1 id="2e12" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">API 服务</h1><p id="2d51" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated"><code class="eh ls lt lu lj b">API service</code>使用<a class="ae ld" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> Gorilla Mux </a>向客户端提供 REST API 响应并路由它们。创建一个与<code class="eh ls lt lu lj b">Add Service</code>通信的客户端。为了与<code class="eh ls lt lu lj b">Add Service</code>通信，我们将使用服务名<code class="eh ls lt lu lj b">add-service</code>，因为稍后我们将在 kubernetes 集群中部署我们的服务。Kubernetes 有内置的 DNS 服务，所以我们可以通过服务名访问。</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="d3fb" class="ln kb hu lj b fv lo lp l lq lr">func main() {<br/>	//	Connect to Add service<br/>	conn, err := grpc.Dial("add-service:3000", grpc.WithInsecure())<br/>	if err != nil {<br/>		log.Fatalf("Dial Failed: %v", err)<br/>	}<br/>	addClient := pb.NewAddServiceClient(conn)<br/><br/>	routes := mux.NewRouter()<br/>	routes.HandleFunc("/add/{a}/{b}", func(w http.ResponseWriter, r *http.Request) {<br/>		w.Header().Set("Content-Type", "application/json; charset=UFT-8")<br/><br/>		vars := mux.Vars(r)<br/>		a, err := strconv.ParseUint(vars["a"], 10, 64)<br/>		if err != nil {<br/>			json.NewEncoder(w).Encode("Invalid parameter A")<br/>		}<br/>		b, err := strconv.ParseUint(vars["b"], 10, 64)<br/>		if err != nil {<br/>			json.NewEncoder(w).Encode("Invalid parameter B")<br/>		}<br/><br/>		ctx, cancel := context.WithTimeout(context.TODO(), time.Minute)<br/>		defer cancel()<br/><br/>		req := &amp;pb.AddRequest{A: a, B: b}<br/>		if resp, err := addClient.Compute(ctx, req); err == nil {<br/>			msg := fmt.Sprintf("Summation is %d", resp.Result)<br/>			json.NewEncoder(w).Encode(msg)<br/>		} else {<br/>			msg := fmt.Sprintf("Internal server error: %s", err.Error())<br/>			json.NewEncoder(w).Encode(msg)<br/>		}<br/>	}).Methods("GET")<br/><br/>	fmt.Println("Application is running on : 8080 .....")<br/>	http.ListenAndServe(":8080", routes)<br/>}</span></pre><p id="a5a1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里我为<code class="eh ls lt lu lj b">/add/{a}/{b}</code>端点声明了一个处理程序，它读取参数<code class="eh ls lt lu lj b">A</code>和<code class="eh ls lt lu lj b">B</code>，然后调用 Add Service 进行求和。</p><h1 id="2973" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">构建 Docker 图像</h1><p id="f05f" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">现在您的服务已经准备好了，但是需要将它们容器化以部署在 kubernetes 集群中。对于添加服务，在<code class="eh ls lt lu lj b">add</code>目录中创建一个<code class="eh ls lt lu lj b">Dockerfile</code></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="baf0" class="ln kb hu lj b fv lo lp l lq lr">FROM golang<br/>COPY . /go/src/add<br/>WORKDIR /go/src/add<br/>RUN go get .<br/>ENTRYPOINT go run main.go<br/>EXPOSE 3000</span></pre><p id="8312" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要在<a class="ae ld" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> DockerHub </a>中构建并推送<code class="eh ls lt lu lj b">summation-service</code>映像，请导航至<code class="eh ls lt lu lj b">add</code>目录并运行以下命令</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9cef" class="ln kb hu lj b fv lo lp l lq lr">$ docker build . -t shuzasa/summation-service:v1.0<br/>$ docker push shuzasa/summation-service:v1.0</span></pre><p id="6c0f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于 Api 服务，在<code class="eh ls lt lu lj b">api</code>目录中创建<code class="eh ls lt lu lj b">Dockerfile</code></p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9433" class="ln kb hu lj b fv lo lp l lq lr">FROM golang<br/>COPY . /go/src/api<br/>WORKDIR /go/src/api<br/>RUN go get .<br/>ENTRYPOINT go run main.go<br/>EXPOSE 8080</span></pre><p id="8631" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要构建和推送<code class="eh ls lt lu lj b">api-service</code>映像，请导航到<code class="eh ls lt lu lj b">api</code>目录并运行以下命令</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="78c1" class="ln kb hu lj b fv lo lp l lq lr">$ docker build . -t shuzasa/api-service:v1.0<br/>$ docker push shuzasa/api-service:v1.0</span></pre><h1 id="e64f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">部署到 Kubernetes 集群</h1><p id="6fbd" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">对于每个服务，我们需要在 kubernetes <strong class="je hv">部署</strong>和<strong class="je hv">服务</strong>中配置两个对象。<strong class="je hv">部署</strong>将在 kubernetes 集群内创建 poda，并管理这些 poda 的期望状态，以确保我们的应用程序运行以服务流量。<strong class="je hv">服务</strong>将提供固定地址来访问那些 pod。<br/>对于总和服务，创建<code class="eh ls lt lu lj b">add-service.yaml</code>文件并插入以下命令</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="1c4e" class="ln kb hu lj b fv lo lp l lq lr">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: add-deployment<br/>  labels:<br/>    app: add<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: add<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: add<br/>    spec:<br/>      containers:<br/>        - name: add<br/>          image: shuzasa/add-service:v1.2<br/>          ports:<br/>            - name: add-service<br/>              containerPort: 3000<br/><br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: add-service<br/>spec:<br/>  selector:<br/>    app: add<br/>  ports:<br/>    - port: 3000<br/>      targetPort: add-service</span></pre><p id="1e9f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为<code class="eh ls lt lu lj b">api-service</code>创建<code class="eh ls lt lu lj b">api-service.yaml</code>文件</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="979e" class="ln kb hu lj b fv lo lp l lq lr">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: api-deployment<br/>  labels:<br/>    app: api<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: api<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: api<br/>    spec:<br/>      containers:<br/>        - name: api<br/>          image: shuzasa/api-service:v1.0<br/>          ports:<br/>            - name: api-service<br/>              containerPort: 8080<br/><br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: api-service<br/>spec:<br/>  selector:<br/>    app: api<br/>  ports:<br/>    - name: http<br/>      port: 8080<br/>      nodePort: 30080<br/>  type: NodePort</span></pre><p id="f8d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">两个服务定义的主要区别在于<code class="eh ls lt lu lj b">api-service</code>我们将它声明为<code class="eh ls lt lu lj b">NodePort</code>类型，因为它可以从 kubernetes 集群外部访问。<br/>现在，通过运行以下命令来创建这些资源</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="aca1" class="ln kb hu lj b fv lo lp l lq lr">$ kubectl create -f summation-service.yaml<br/>$ kubectl create -f api-service.yaml</span></pre><p id="ca8b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">等到所有单元都可用或处于运行状态</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="01b2" class="ln kb hu lj b fv lo lp l lq lr">$ kubectl get pods -w<br/>NAME                              READY     STATUS    RESTARTS   AGE<br/>add-deployment-66df6c78b6-qcj77   1/1       Running   0          2m<br/>api-deployment-577f4965f5-d2bkd   1/1       Running   0          2m</span></pre><h1 id="46ee" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">结论</h1><p id="2204" class="pw-post-body-paragraph jc jd hu je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz hn dt translated">让我们验证我们的系统。获取我们<code class="eh ls lt lu lj b">api-service</code>跑步的 URL</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="9ad7" class="ln kb hu lj b fv lo lp l lq lr">$ minikube service api-service --url</span></pre><p id="01fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用之前找到的 IP 地址向服务发出请求</p><pre class="le lf lg lh fq li lj lk ll aw lm dt"><span id="8848" class="ln kb hu lj b fv lo lp l lq lr">curl <a class="ae ld" href="http://192.168.99.100:30080/add/1/3" rel="noopener ugc nofollow" target="_blank">http://192.168.99.100:30080/add/1/3</a></span></pre><p id="b199" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它将显示求和结果。</p><p id="a698" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以在 GitHub 上找到完整的源代码。</p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><p id="4db8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="mc">原载于 2019 年 2 月 2 日</em><a class="ae ld" href="https://shuza.ninja/how-to-develop-go-grpc-microservice-and-deploy-in-kubernates/" rel="noopener ugc nofollow" target="_blank"><em class="mc">shuza . ninja</em></a><em class="mc">。</em></p></div></div>    
</body>
</html>