<html>
<head>
<title>How Can Hierarchical Test Structure Absolutely Make a Mess?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分层考试结构怎么绝对乱？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-can-hierarchical-test-structure-absolutely-make-a-mess-f72f47b5bf57#2019-02-18">https://medium.com/hackernoon/how-can-hierarchical-test-structure-absolutely-make-a-mess-f72f47b5bf57#2019-02-18</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ea9182c8c2d523a69c90ea81e0bf4463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G83x_di2BQjDzQIh4zGTrA.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">source: <a class="ae jg" href="https://www.pexels.com/photo/abstract-close-up-cobweb-connection-276502/" rel="noopener ugc nofollow" target="_blank">pexels</a></figcaption></figure><p id="9d67" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你曾经使用一个简单的 xUnit 风格的测试框架编写过你的单元测试吗？</p><p id="0a9f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么你可能知道，随着测试变得越来越复杂，它们收集的样板文件和重复文件越来越多，要么在测试方法中传播，要么在设置函数中传播。</p><p id="a4ef" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，层次化的上下文框架非常健壮，可以减轻这种样板问题并消除这种重复。它们允许您拥有嵌套的上下文，每个上下文都有自己的设置，并“继承”父上下文的设置。</p><p id="6d4e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这样，您可以表达许多不同的场景，而无需在测试设置代码中重复一次。</p><p id="23bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">很棒，不是吗？</p><p id="2c6f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，如果我告诉你，层次化的测试结构会导致更微妙的重复(这本来是应该防止的),很难发现和重构，会怎么样呢？</p><p id="53c7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我给你一个过于简单的例子:</p><h1 id="e386" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">两个骑士，难以捉摸的相似</h1><p id="7fbf" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">前几天，我正在开发两个“fetcher”类，它们与第三方 API 的 HTTP 客户端对话，包含需要完成的业务逻辑，还可以处理即时的“成功”和异步的“接受”响应。</p><p id="906e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">他们的代码非常相似，处理响应和重新调度异步任务的整个逻辑是重复的，所以我们在产品代码中的一个单独的 collaborator 对象中对其进行了重构。</p><p id="e3b3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后我们想:“嗯，我们在产品代码中重构了复制。测试代码中肯定会有重复。我们也把它弄干吧！”</p><p id="c64a" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">没那么快！</p><p id="7dc2" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">当我们开始并排阅读两个测试套件时，发现它们看起来不太像。很难发现和隔离重复。</p><p id="3cec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它们是以分层的风格编写的，并且充分利用了嵌套上下文的全部功能。</p><p id="fda7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是第一个测试的简化示例(在科特林):</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="eeab" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">所以测试套件从根上下文开始。您可以在这里为您的测试套件设置全局默认值，并在嵌套的上下文中覆盖其中的一些。</p><p id="aaed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果您有一个典型的“快乐路径”场景，然后您有更多的“特殊情况”，您将使用嵌套上下文，这是很好的。</p><p id="5960" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请注意，我们正在模拟 HTTP 客户端以“接受”状态进行响应:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="91ff" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">然后在其中一个嵌套上下文中，我们将响应状态覆盖为“成功”:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="91ec" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">记住所有这些，看看第二个测试套件:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="6db8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如您所看到的，这个测试套件的作者选择了不同的响应状态作为默认的“快乐路径”场景——“成功”:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek"><em class="lo">(and used a different mocking style on top of that)</em></figcaption></figure><p id="ad76" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">并且嵌套上下文将响应状态覆盖为“已接受”状态:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="eddd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在，有了这个例子，你就可以在颠倒一个测试套件的默认和定制场景之后，找出如何足够快地重构它，对吗？</p><p id="d4c8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个例子很简单。我们之间的关系更复杂。假设您的异步轮询和重试逻辑(我们试图重构的内容)依赖于 4 个因素:</p><ul class=""><li id="06a0" class="lp lq hu jj b jk jl jo jp js lr jw ls ka lt ke lu lv lw lx dt translated">您将有 4 层嵌套的上下文，将每个元素描述为整个场景的一部分；</li><li id="fb0f" class="lp lq hu jj b jk ly jo lz js ma jw mb ka mc ke lu lv lw lx dt translated">每个上下文可以选择不同的默认情况，而不是应该在内部上下文中覆盖哪些情况。</li></ul><p id="2498" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如您所见，这很快就会变得一团糟，并且很难重构。</p><p id="f8dc" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果我们有一个经典的平面测试结构，我们会在测试套件中有一点重复，但是并排比较测试套件并重构它们会容易得多。</p><p id="2438" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">让我给你看一个例子:</p><figure class="li lj lk ll fq iv"><div class="bz el l di"><div class="lm ln l"/></div></figure><p id="e35d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">第二个测试套件现在看起来非常相似(不值得在这里展示，但是如果你愿意的话，你可以<a class="ae jg" href="https://gist.github.com/waterlink/e26a4dc585b628d6eb6074b9383a209f" rel="noopener ugc nofollow" target="_blank">看到要点</a>)。</p><p id="b85b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如您所见，重构两个测试套件之间的重复几乎是一件容易的事情。</p><blockquote class="md me mf"><p id="714d" class="jh ji mg jj b jk jl jm jn jo jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated"><em class="hu">你想了解更多关于 Kotlin 的测试和 TDD 吗？</em></p><p id="ab34" class="jh ji mg jj b jk jl jm jn jo jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated"><em class="hu">我已经写了一篇 4 部分(共 350 页)的《</em> <a class="ae jg" href="https://iwillteachyoukotlin.com" rel="noopener ugc nofollow" target="_blank"> <em class="hu">终极教程:Kotlin </em> </a> <em class="hu">入门》，(+更多随后)，你可以成为我每月简讯的会员，免费获得它。</em></p><p id="945d" class="jh ji mg jj b jk jl jm jn jo jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated">除了 Kotlin，它还有很多好东西，比如 TDD、干净的代码、软件架构、业务影响、5 个为什么、验收标准、人物角色等等。</p><p id="4a30" class="jh ji mg jj b jk jl jm jn jo jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd ke hn dt translated"><em class="hu"> —在这里注册，然后</em> <a class="ae jg" href="https://iwillteachyoukotlin.com" rel="noopener ugc nofollow" target="_blank"> <em class="hu">开始学习如何使用 TDD </em> </a> <em class="hu">构建成熟的 Kotlin 应用程序！</em></p></blockquote><h1 id="721b" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结论</h1><p id="5cc7" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">现在，我不是想让你相信这种或那种风格。我只是想告诉你，这两种风格各有优缺点。</p><p id="d19c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">正如我们已经注意到的，即使是风格的力量也可能会让你搬起石头砸自己的脚。所以要小心:权力带来责任。</p><p id="9018" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">不要让你的层次测试太复杂，嵌套太多！</p><h1 id="b2e1" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">轮到你了</h1><p id="4486" class="pw-post-body-paragraph jh ji hu jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">如果你喜欢我的想法，可以考虑给这篇文章一些中等的评价😊请在下面的评论中分享你对这两种风格的体验:</p><p id="ca08" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你记得这两种风格都有哪些棘手的情况？🤔</p></div></div>    
</body>
</html>