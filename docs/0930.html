<html>
<head>
<title>NPM Package Verification — Ep. 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NPM包装验证。2</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/npm-package-verification-ep-2-2b2ec66eb610?source=collection_archive---------17-----------------------#2019-02-06">https://medium.com/hackernoon/npm-package-verification-ep-2-2b2ec66eb610?source=collection_archive---------17-----------------------#2019-02-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="1fab" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">最低可行包验证即服务(MVPVaaS)</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/a746f33fc7af1da0a58c837a735cdc70.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*TOWfVGpHDD6Dg4jVUrzf4w.png"/></div></figure><h1 id="0bc3" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">TL；速度三角形定位法(dead reckoning)</h1><p id="8478" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">我构建了一个运行在云中的超级预alpha版本的PVaaS(包验证即服务)。有一个JSON路由显示包的验证数据，还有一个badge路由给你一个badge。</p><p id="c25e" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">包裹可以验证吗？<a class="ae lk" href="https://api.verifynpm.com/v0/packages/tbv" rel="noopener ugc nofollow" target="_blank">https://api.verifynpm.com/v0/packages/tbv</a></p><p id="15c1" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">以前的版本？【https://api.verifynpm.com/v0/packages/tbv@0.3.0 T2】号</p><p id="32c4" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">徽章怎么样:【https://api.verifynpm.com/v0/packages/tbv/badge】T4</p><p id="1fef" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我怎么强调这一切的实验性都不为过！我不会对零版本API做任何突破性的改动，但是，我不能保证这个API是永久的。请随意修改它。所有的源代码都可以在GitHub上找到:<a class="ae lk" href="https://github.com/verifynpm" rel="noopener ugc nofollow" target="_blank">github.com/verifynpm</a>。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="fe ff ll"><img src="../Images/d832cab7044ff7b6734c596eab0dd249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBE9zs2HsuDj5fc95S1ABw.png"/></div></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek">Photo by <a class="ae lk" href="https://unsplash.com/photos/dTp7Kw51g0o?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Linh Nguyen</a> on <a class="ae lk" href="https://unsplash.com/search/photos/neon-green?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="f003" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">回溯一下，我今年的第一个轻率的项目是<a class="ae lk" href="https://hackernoon.com/what-if-we-could-verify-npm-packages-c2a319cff758" rel="noopener ugc nofollow" target="_blank">验证NPM包的概念验证</a>。我构建了一个名为<a class="ae lk" href="https://www.npmjs.com/package/tbv" rel="noopener ugc nofollow" target="_blank"> TBV </a> ( <a class="ae lk" href="https://en.wikipedia.org/wiki/Trust,_but_verify" rel="noopener ugc nofollow" target="_blank">信任但验证</a>)的可全球安装的NPM包，让您检查包的内容是否可以从GitHub上的源代码一致地复制。</p><p id="6639" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">干净利落。</p><p id="357b" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我收到了大量积极的反馈(耶社区！)绝大多数的回答都倾向于将验证结果以各种形式在网上公布，从回购徽章到npmjs.com的实际可见性。因此，为了追求“验证即服务”，我决定第一步是构建一个在云中运行TBV的API。</p><p id="901b" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">算了吧。第一步是购买另一个域名。很明显。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="19b1" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">因此，带着闪亮的新域名，为了追求“验证即服务”，我决定第二步是构建一个API，在云中运行TBV。</p><p id="5880" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">在我出发之前，我想为自己制定一些基本规则，这样我就可以在一个周末内让一些东西在云中运行。我没有完全达到那个目标(好吧，好吧，惨败)，但以下是我给自己定下的规则:</p><h2 id="2681" class="me js hu bd jt mf mg mh jx mi mj mk kb ks ml mm kd kw mn mo kf la mp mq kh mr dt translated">CI/CD:</h2><p id="86e6" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">我个人的理念是，对于任何应用程序，你应该做的第一件事就是部署它。构建它是后来的事。这似乎违反直觉，但这种思维方式在两个方面节省了时间。首先，为“空应用程序”配置构建管道非常容易。我倾向于使用TravisCI和一个基本配置来构建一个“hello world”节点应用程序，并运行类似于YAML的5行代码的测试。随着应用程序的增长，您的构建配置也会随之增长。这比在应用程序进入叛逆期后试图强行加入构建过程要有效得多。第二，自动化节省时间，这是一点。我没有很多空闲时间，所以我需要所有我能得到的帮助。从一开始就实现自动化意味着我要对云进行更改所要做的就是将更改推送到master。</p><h2 id="3b04" class="me js hu bd jt mf mg mh jx mi mj mk kb ks ml mm kd kw mn mo kf la mp mq kh mr dt translated">无服务器</h2><p id="c5db" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">对于这个项目，Kubernetes出局了。我真的认为容器化是PaaS的未来，但我也有亲身经历，知道k8s可以花一分钟来实现积极的ROI。我曾经想过在数字海洋上建立一个小型的虚拟机，但是为部署建立一个CI系统以及配置一个数据库和某种类型的消息队列本身就像是一个周末项目。我可以利用的任何开箱即用的基础架构都将是一个福音。我看了一下TravisCI，发现他们有AWS Lambda的部署配置。AWS DynamoDB是一个东西，它有一个内置的流，用于修改更多的Lambda函数。售出。</p><h2 id="2696" class="me js hu bd jt mf mg mh jx mi mj mk kb ks ml mm kd kw mn mo kf la mp mq kh mr dt translated">规格优先API</h2><p id="8dea" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">在构建基于网络的系统之前进行设计具有巨大的价值。Swagger(又名OpenAPI Spec 2.0)是定义API的极好的DSL。当满足规范时，我的API函数将被认为是“完成”的。</p><h2 id="6d0b" class="me js hu bd jt mf mg mh jx mi mj mk kb ks ml mm kd kw mn mo kf la mp mq kh mr dt translated">没有牦牛毛</h2><p id="6b32" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">尽可能地，我想<a class="ae lk" href="https://hackernoon.com/ignore-nifty-distractions-and-work-on-the-important-things-eed7df8755cb" rel="noopener ugc nofollow" target="_blank">忽略那些有趣的干扰，专注于重要的事情</a>。这意味着集中精力使核查路线尽快发挥作用。我知道让TBV图书馆在云中工作会有挑战，但我不知道挑战在哪里。用精益创业的话说，我想尽快开始验证假设。别给那头牦牛剃毛。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="3d51" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">如果你还没有弄乱它，AWS的无服务器应用模型(SAM)是相当光滑的。Lambda非常直观，我能够非常快速地(大概几十分钟)获得一个内置在Typescript中的函数，并在云中运行。我面对的是用Swagger配置的AWS API网关。API被配置为使用Lambda函数作为其实现。</p><p id="de7a" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我首先用Swagger设计了一条路线，定义了基本的验证响应、设计的标准错误、内容类型和其他基本的API样板文件。</p><p id="40e0" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">接下来，我用一个“什么都不做”的Lambda函数实现了单个API路由。从一开始，我就设置TravisCI在我按下<code class="eh ms mt mu mv b">master</code>时部署该功能。我推的第一个东西是一个简单的hello world函数。花了不到30分钟的时间就弄清楚了AWS IAM权限的事情，看了一眼TravisCI文档，然后让构建工作起来。自动化带来的速度是惊人的。我再重复一遍也不为过:先部署，后构建。</p><p id="bb20" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">到周六午餐时，我已经定义了我的API，配置了API网关，设置了用于部署Lambda函数的CI/CD管道，构建了一个“hello world”函数，并将API网关连接到我闪亮的新域名。我可以点击<code class="eh ms mt mu mv b">https://api.verifynpm.com/v0/package/tbv</code>并得到一个实际的响应。</p><p id="410d" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">干净利落。</p><p id="73da" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">下午，我自学了一些DynamoDB。TBV可能需要一分钟左右时间来运行，尤其是在有准备或预打包脚本的情况下。等待API响应的时间太长了。为了支持更高的API SLAs，我想使用一个主要的请求处理Lambda函数来删除队列上的验证，该验证将由另一个实际运行TBV的Lambda函数读取。</p><p id="2115" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">一旦包被验证一次，所有的消费者可以看到结果，这将直接从数据库中提取。有了这个队列，即使第一次调用也会返回亚秒级的响应时间。后续通话将揭示核查进展情况。</p><p id="a196" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">事实证明，DynamoDB有一个内置的流来观察变化。我所要做的就是向数据库中写入一个带有包名/版本和“未知”状态的条目，然后另一个Lambda函数将被推入这个变更事件。</p><p id="fc3d" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">目标是有一个函数响应API流量，并确保为传入的请求编写DDB项，另一个函数在新的包从DDB流传入时运行TBV。</p><p id="3227" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">这是第一天的结束。我有一个精心安排一切的计划，我有信心在周一早上工作之前我会有一个可用的API和一篇博客文章。</p><p id="d943" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">爱达荷（Idaho的缩写）</p><p id="33f3" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">曾经是。</p><p id="317c" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">不对。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="61b7" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">第二天是“有趣”的开始。事实证明，AWS Lambda非常擅长开箱即用地运行基本的节点功能。但是TBV必须同时执行<code class="eh ms mt mu mv b">git</code>和<code class="eh ms mt mu mv b">npm</code>才能工作。<code class="eh ms mt mu mv b">git</code>用于从源代码控制中获取包源代码，<code class="eh ms mt mu mv b">npm</code>用于安装依赖项并生成一个包来与发布的版本进行比较。</p><p id="9098" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我的假设是运行<code class="eh ms mt mu mv b">npm</code>将是微不足道的，因为Lambda Node 8.10运行时已经包含了它，并且运行<code class="eh ms mt mu mv b">git</code>将是困难的，如果不是不可能的话。竞相验证假设的好处之一是我完全错了。</p><p id="4151" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">事实证明，在去年年底，AWS推出了Lambda层，允许开发人员“从您的功能代码中单独打包和部署库、自定义运行时和其他依赖项。”你知道其他的依赖，比如git。在这个功能上线50天左右的时间里，有人已经创建了我所需要的东西。谢谢，互联网！</p><div class="mw mx fm fo my mz"><a href="https://github.com/lambci/git-lambda-layer" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">λ/git-λ层</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">AWS Lambda的一个层，允许您的函数使用“git”和“ssh”二进制文件</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn jp mz"/></div></div></a></div><p id="cfa5" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">此时，我以为我真的躲过了一劫。我开始在系统中运行像<code class="eh ms mt mu mv b">express</code>这样非常流行的包的实时数据，我知道verify。而且成功了。我干这行已经够久了，知道这么早就成功是可疑的。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff no"><img src="../Images/2e263cbf79f92c59d7079898786808fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*zQe-ur2puj8-WwH_MZUJtg.jpeg"/></div><figcaption class="lq lr fg fe ff ls lt bd b be z ek"><a class="ae lk" href="https://www.google.com/search?q=novice+programmer+vs+experienced+programmer" rel="noopener ugc nofollow" target="_blank">From somewhere online</a></figcaption></figure><p id="d55d" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">所以我开始尝试其他图书馆，比如，哦，TBV。</p><p id="824f" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">失败了。</p><p id="06ec" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">这就是我开始走上牦牛剃毛第一条路的地方。TBV的输出最初是为了便于阅读而优化的。然而，这意味着在AWS中查看日志输出是非常无用的。我在自己的机器上运行了与Lambda相同版本的TBV，它在我的机器上运行正常。</p><p id="52b4" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我向TBV添加了详细日志记录，这样我就可以看到正在运行的命令的原始输出。</p><p id="738f" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">就这样，我开始了一系列不光彩的行为。</p><p id="58aa" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">一旦我有了更好的日志可视性，我注意到<code class="eh ms mt mu mv b">npm ci</code>失败了，因为命令不受支持。是的，AWS Lambda上的Node 8.10运行<code class="eh ms mt mu mv b">npm@5.6.x</code>，我至少需要<code class="eh ms mt mu mv b">npm@5.7.0</code>才能运行<code class="eh ms mt mu mv b">npm ci</code>。我差一个小版本就能运行分布式系统了。</p><p id="5e2b" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">首先，我尝试在Lambda上运行<code class="eh ms mt mu mv b">npm install --global npm@latest</code>，但是失败了，因为Lambda函数对文件系统上除了<code class="eh ms mt mu mv b">/tmp</code>之外的所有内容都是只读的。我预料到了，但是，嘿，试试也无妨。</p><p id="6044" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">接下来，我尝试安装<code class="eh ms mt mu mv b">npm</code>作为我的函数的生产依赖项。让$PATH包含Node，我的NPM版本，但不包含正常安装的NPM版本被证明是困难的。无论如何，将<code class="eh ms mt mu mv b">npm</code>作为生产依赖项安装似乎是错误的。</p><p id="ebf9" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">接下来，我开始钻研NPM的源代码，看看<code class="eh ms mt mu mv b">ci</code>命令是如何工作的。如果实现起来很简单，那么也许我可以只克隆那些代码。开源，诸如此类，麻省理工学院许可证，诸如此类。我认为这将是超级复杂的，因此是一个徒劳的练习。没有。它只是使用了另一个名为<code class="eh ms mt mu mv b">cipm</code>的库。(作为这个过程的一部分，我了解到<a class="ae lk" href="https://github.com/zkat/cipm/issues/34" rel="noopener ugc nofollow" target="_blank"> NPM经常通过引入外部库</a>来引入新功能。)</p><p id="5490" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">部分成功？</p><p id="f253" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">接下来，我尝试安装<code class="eh ms mt mu mv b">cipm</code>作为一个生产依赖。老实说，我忘了为什么这个尝试没有成功。我也觉得用不同的方法安装和建造比在野外使用的方法脏。讽刺的是，我被我试图保护的图书馆打败了，这让我很沮丧。</p><p id="c47a" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">接下来，我试着看网飞。但是这不起作用，因为看电视不是编写有效软件的好方法。</p><p id="ee41" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">星期天来了又走了。我很沮丧。无论如何，我从TBV得到的结果都是劣质的。我已经获得了一些有效的知识，但还没有交付我想要的产品。叹气。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="87c1" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">因为我已经错过了我自己设定的最后期限，所以我决定撤退并疗伤。做一些治疗性的事情怎么样。就像创造另一个NPM套餐。</p><p id="ebb3" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我采用了我目前拼凑的一些函数和运行时，为yeoman构建了银河系最棒的Typescript AWS Lambda生成器。</p><div class="mw mx fm fo my mz"><a href="https://www.npmjs.com/package/generator-lambda-ts" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">发电机-λ-ts</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">银河系最好的打字稿AWS Lambda生成器</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">www.npmjs.com</p></div></div><div class="ni l"><div class="np l nk nl nm ni nn jp mz"/></div></div></a></div><p id="5e1c" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">这个项目成为我为这个项目构建的大多数Lambda函数的脚手架。我有点偏离“不刮牦牛毛”，但我认为这为我节省了一些时间。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="243d" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">接下来的几个晚上花在重建现在TBV处理包装比较。我学到了很多关于tarballs和GZip以及相关流的东西，我将在另一篇文章中阐述。最大的收获是，我最终没有像我在上一篇帖子中谈到的那样查看shasum包。相反，我计算了包中每个文件的sha256，然后进行了比较</p><p id="cf9f" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">最终的结果是，我能够更好地了解<em class="md">为什么</em>一个包没有通过验证，因为我现在可以看到在比较包时添加、修改和删除了什么文件。</p><p id="e0a6" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我还开始尝试一个新的工作流/管道模型来运行验证子任务。它最终非常有前途，但我现在正在努力让它可靠地运行<code class="eh ms mt mu mv b">npm ci</code>，所以它还没有推出。</p><p id="9b80" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">最后，我确保TBV现在删除它创建的任何临时目录。事实证明，即使在两次调用之间，Lambda函数也可能会耗尽磁盘空间。也许以后我会讲到这个。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="d226" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我还意识到Lambda层也可以用来创建定制的运行时。我想详细介绍一下这是如何工作的，以及为什么你想尝试一下。不过，现在，让我们来看看我为用Node 10.15和npm@6.7.0构建自定义AWS Lambda运行时而想到的repo:</p><div class="mw mx fm fo my mz"><a href="https://github.com/skonves/node-custom-runtime" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">skonves/node-custom-runtime</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">AWS Lambda的自定义节点/NPM运行时。通过在……上创建帐户，为skonves/node-custom-runtime开发做出贡献</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="nq l nk nl nm ni nn jp mz"/></div></div></a></div><p id="208a" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我在<a class="ae lk" href="https://rrainn.com/" rel="noopener ugc nofollow" target="_blank"> rrainn </a>找到了另一个类似的定制运行时。然而，我可以让<code class="eh ms mt mu mv b">npm</code>在他们的机器上运行。我利用他们的javascript位来让我的工作。</p><div class="mw mx fm fo my mz"><a href="https://github.com/rrainn/aws-lambda-custom-node-runtime" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">rrainn/AWS-lambda-自定义节点-运行时</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">📦NPM包-创建自定义节点. js AWS Lambda运行时-rrainn/AWS-Lambda-custom-node-Runtime</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="nr l nk nl nm ni nn jp mz"/></div></div></a></div><p id="079d" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">这是理解Lambda函数内部如何工作的一次奇妙的练习。这也是我第一次真正使用docker来实现构建过程。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="4b7b" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">又一个周末来了又走了，但我终于能够在Lambda跑TBV了。最后一步是构建最后一个服务徽章的函数。在这一点上，我只是从<a class="ae lk" href="https://shields.io" rel="noopener ugc nofollow" target="_blank"> https://shields.io </a>返回自定义徽章。</p><p id="7203" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">老实说，在花了这么多时间学习香肠是如何制作的之后，我发现仅仅构建一个在标准运行时上运行的普通函数而不在幕后添加任何异国情调是非常令人耳目一新的。</p></div><div class="ab cl lu lv hc lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hn ho hp hq hr"><p id="92a0" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">我简单看了一下用Gatsby搭建一个基本的网站。那被证明是一座太远的桥。我最终会完成的。现在，我想把重点放在API上。</p><h1 id="6c06" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">我需要你的帮助！</h1><p id="e9a6" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">我认为下一步是让社区开始将TBV作为一个库和一个API。我很有兴趣看看是什么打破了。(哦耶，要破了！)</p><p id="628e" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">如果有些事情看起来不对劲，请在TBV回购上打开一个问题:</p><div class="mw mx fm fo my mz"><a href="https://github.com/verifynpm/tbv" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hv fv z el ne eo ep nf er et ht dt translated">验证npm/tbv</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">npm的包装验证。在GitHub上创建一个帐户，为verifynpm/tbv开发做出贡献。</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="ns l nk nl nm ni nn jp mz"/></div></div></a></div><p id="6443" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">打开问题时，请使用<code class="eh ms mt mu mv b">--verbose</code>选项在本地运行TBV，并将输出包含在问题中。另外，请注意，您还可以在docker容器中运行TBV。有关说明，请参见repo自述文件。</p><p id="0220" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">有想法或者评论？随意打开一个问题。</p><p id="31e5" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">此外，如果你想卷起袖子，帮助编写代码，我将不胜荣幸！真的！要贡献，分叉回购并提交拉请求。</p><h1 id="2708" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">等等，还有更多！</h1><p id="6b9b" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">这个项目我还没做完呢！我可能会休息几周，但我正在开发新的功能和博客文章。如果你不想错过更新，请点击“关注”</p><p id="162d" class="pw-post-body-paragraph kj kk hu kl b km lf iv ko kp lg iy kr ks lh ku kv kw li ky kz la lj lc ld le hn dt translated">给这个帖子都一些👏如果你认为这是我应得的，别忘了去GitHub上验证npm和<a class="ae lk" href="https://github.com/verifynpm" rel="noopener ugc nofollow" target="_blank"> ⭐明星⭐每个⭐单曲⭐回购⭐ </a></p></div></div>    
</body>
</html>