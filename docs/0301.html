<html>
<head>
<title>Unpacking JavaScript classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解包JavaScript类</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/unpacking-javascript-classes-81d32804c978?source=collection_archive---------16-----------------------#2019-01-12">https://medium.com/hackernoon/unpacking-javascript-classes-81d32804c978?source=collection_archive---------16-----------------------#2019-01-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bde2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们开门见山吧。那么，JavaScript中的类是什么意思呢？</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/7e593f2918c6d4c37585b8bfa28d2d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*6RLDvrrz3aQtzXIG"/></div></figure><p id="9d30" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要理解<a class="ae jx" href="https://hackernoon.com/tagged/classes" rel="noopener ugc nofollow" target="_blank">类</a>，我们必须深入挖掘，从<strong class="it hv">开始<em class="jy">对象构造器</em>开始</strong></p><p id="80a5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对象构造器是所有<a class="ae jx" href="https://hackernoon.com/tagged/javascript" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>对象的根。您可以使用对象构造函数创建任何类型的对象。让我给你这个故事的第一个剧透。</p><p id="1afc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jy">“需要注意的是，JavaScript中的所有对象都是Object的实例。将JavaScript中的任何对象都看作是通过调用对象构造函数“</em> </strong>创建的实例</p><pre class="jq jr js jt fq jz ka kb kc aw kd dt"><span id="9fda" class="ke kf hu ka b fv kg kh l ki kj">// Object('k1':'v1', 'k2':'v2')<br/>console.log(new Object({'k1':'v1', 'k2':'v2'}))</span><span id="f3f7" class="ke kf hu ka b fv kk kh l ki kj">// Array[1 ,2, 3]<br/>console.log(new Object([1, 2, 3])</span></pre><p id="e2bd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以，现在我们清楚了对象构造函数的用途，让我们看看对象构造函数的属性。</p><pre class="jq jr js jt fq jz ka kb kc aw kd dt"><span id="1838" class="ke kf hu ka b fv kg kh l ki kj">// Print Object's properties<br/>console.dir(Object)</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff kl"><img src="../Images/3f0a784c12beb9faa93549d4a39369be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LYapWuvG7EAliDH4vT1VQ.png"/></div></div></figure><p id="9a3c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">除了长长的属性列表，我们还看到一个名为<strong class="it hv">‘prototype’的属性。现在，这给了我们一个在JavaScript中解构类的起点。</strong></p><p id="8d7c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么，这个'<strong class="it hv">原型</strong>'属性是什么？它在其他常规属性之上有一个“构造函数”属性。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kq"><img src="../Images/cd8aa6b2259a8eb8673f4a830686b549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*EJY6R6PKHGD2UkKB1fsh6w.png"/></div></figure><p id="e447" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">为了理解它的意义，让我们写一个函数，看看它的属性。记住，函数也是一个JavaScript对象，它从对象构造函数继承属性。</p><pre class="jq jr js jt fq jz ka kb kc aw kd dt"><span id="37a7" class="ke kf hu ka b fv kg kh l ki kj">// foo function<br/>function foo() {}<br/>console.dir(foo)</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/dfd8296483fcde19c3cf8d2d7c1a1ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*8UYGSdO8bog64CP0dEfdzw.png"/></div></figure><p id="b848" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">正如我们所料，函数foo()有一个原型属性。这是我的第二个剧透，</p><p id="e95a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"> <em class="jy">“原型属性是唯一的。它从</em> </strong> ' <strong class="it hv"> <em class="jy">对象传递给所有JS对象，我们称之为原型链“</em> </strong></p><p id="9e59" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着什么？为了理解这一点，让我们理解当类不是JS的一部分时，我们是如何设法模仿类的。我们做了我们称之为构造函数的事情，通过在“new”关键字前加上前缀来创建特定类型的对象。</p><pre class="jq jr js jt fq jz ka kb kc aw kd dt"><span id="0a5f" class="ke kf hu ka b fv kg kh l ki kj">// constructor function<br/>function foo(a) {<br/>  this.a = a<br/>}</span><span id="98d9" class="ke kf hu ka b fv kk kh l ki kj">// Add class method<br/><strong class="ka hv">foo.prototype.print = function() { console.log(this.a)}</strong></span><span id="8852" class="ke kf hu ka b fv kk kh l ki kj">var foo1 = new foo("hello")<br/>foo1.print() // hello</span><span id="75b9" class="ke kf hu ka b fv kk kh l ki kj">var foo2 = new foo("world")<br/>foo2.print() // world</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/8e8c73c22a4f08c423d8cee63b3640ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*IFdcIVsmLdf9wRgdBvOo6w.png"/></div></figure><p id="35b6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们刚刚做了什么？我们通过将新方法“print()”直接附加到函数的prototype属性来添加类方法。但是，我们如何能够在实例foo1和foo2上直接调用' print()'神奇！</p><p id="f384" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当我们调用一个前缀为“new”的函数时，JS通过将函数的prototype属性复制到实例的__proto__属性上来进行戏剧性的窃取。而__proto__ property是什么？向上滚动，查看所有图像。它也是JS中所有对象的属性，这就把我们带到了第三个剧透，</p><p id="8b91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh kt ku kv ka b"><strong class="it hv"><em class="jy">__proto__</em></strong></code> <strong class="it hv"> <em class="jy">是查找链中使用的实际对象解析方法等。</em> </strong> <code class="eh kt ku kv ka b"><strong class="it hv"><em class="jy">prototype</em></strong></code> <strong class="it hv"> <em class="jy">是当你用</em> </strong> <code class="eh kt ku kv ka b"><strong class="it hv"><em class="jy">new</em></strong></code>创建一个对象时用来构建  <code class="eh kt ku kv ka b"><strong class="it hv"><em class="jy">__proto__</em></strong></code> <strong class="it hv"> <em class="jy">的对象</em></strong></p><p id="288f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这就解释了为什么__proto__一直保持沉默。现在，当我们用' new '调用一个函数时，就会发生这种情况。</p><pre class="jq jr js jt fq jz ka kb kc aw kd dt"><span id="0d79" class="ke kf hu ka b fv kg kh l ki kj">var foo1 = new foo("hello")<br/>console.dir(foo)<br/>console.dir(foo1)<br/>foo1.print() // hello</span></pre><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/7c515e5d04a01ff2ac77c9b9988dad9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*zV79DA0yx-HD-geFTxG30A.png"/></div></figure><p id="e74c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们走吧！实例foo1的__proto__现在有了print()函数，当我们这样做的时候，foo1.print()就可以被解析，而且它工作得非常好。</p><p id="e818" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">但是，WTH是阶级吗？</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff jp"><img src="../Images/27c911e95f215f421a6d9e77b083b76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Rv5M1GwO-M2aaZmK9kQjJw.jpeg"/></div></figure><p id="a717" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">好的，我们有诚实的<strong class="it hv"> console.dir() </strong>它告诉我们真相，而且只告诉我们真相。让我们看一个例子。</p><pre class="jq jr js jt fq jz ka kb kc aw kd dt"><span id="3851" class="ke kf hu ka b fv kg kh l ki kj">// constructor function 'foo' with a method, print<br/>function foo(a) {<br/>  this.a = a<br/>}<br/>// Add class method<br/>foo.prototype.print = function() { console.log(this.a) }</span><span id="41e1" class="ke kf hu ka b fv kk kh l ki kj">// class 'bar' with a class method, print<br/>class bar {<br/> constructor(a) {<br/>  this.a = a<br/> }<br/> print() {<br/>  console.log(this.a)<br/> }<br/>}</span><span id="ef4f" class="ke kf hu ka b fv kk kh l ki kj">console.dir(foo)<br/>console.dir(bar)</span></pre><p id="e1a6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最终剧透:</p><p id="ed94" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"><em class="jy">“foo和bar一样！!"</em> </strong></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="ab fr cl kx"><img src="../Images/65fc42f7ce271540d9bf4f093f0697d0.png" data-original-src="https://miro.medium.com/v2/format:webp/0*0EgTT_6IFoXhsdyx.png"/></div></figure><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff ky"><img src="../Images/ad4bce96cc8e27fe4ad08dbe356bb84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*X6SVXopJxPKS8UhqHMu7iA.png"/></div></figure><p id="e402" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"><em class="jy">“JavaScript类是JavaScript构造函数的语法糖，是利用JavaScript的原型属性和原型链对传统类的伪实现”</em> </strong></p><p id="c038" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我认为，为了理解JavaScript中的任何概念，理解这种语言的组成部分以及一个特性是如何和为什么以一种特定的方式被实现是很重要的。这不仅能让你对主题有一个具体的理解，还能帮助你在解决具体问题时应用这些概念。</p><p id="5c6a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你喜欢读我的故事，如果你能请我喝杯咖啡，我将不胜感激:)</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><a href="http://buymeacoff.ee/oejUJyBsO"><div class="fe ff kz"><img src="../Images/83dc7212ef8502659c81086ad58b8d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*bk_C8Um34KavCkO2yzMCZg.png"/></div></a></figure><p id="b428" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">另外，别忘了按一下“鼓掌”按钮来给我鼓掌。这有助于其他人发现这个故事，他们可能会觉得有帮助。谢谢大家！</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="fe ff la"><img src="../Images/90ee8953299f5ca7f963caf2b6c66886.png" data-original-src="https://miro.medium.com/v2/resize:fit:292/1*qelSgiz0fORUzoJvicD7Pw.gif"/></div></div></figure><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="lb lc l"/></div></figure></div></div>    
</body>
</html>