<html>
<head>
<title>Build a Chat App with Twilio and KendoReact</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Twilio 和 KendoReact 构建一个聊天应用</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/chat-app-twilio-kendoreact-40da290d17b2#2019-01-31">https://medium.com/hackernoon/chat-app-twilio-kendoreact-40da290d17b2#2019-01-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/538255a32df90ffab141874f8bcd4f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1UchglvwR7SaYLh2wsqSoA.png"/></div></div></figure><p id="a5dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><a class="ae ka" href="https://www.twilio.com/docs/chat" rel="noopener ugc nofollow" target="_blank"> Twilio 可编程聊天</a>为实时聊天应用提供了 SDK 和强大的后端，但它缺少前端。如果你需要一个聊天界面，以及一大堆其他有用的组件，那么<a class="ae ka" href="https://www.telerik.com/kendo-ui#react" rel="noopener ugc nofollow" target="_blank"> KendoReact </a>可能就是你要找的。</p><p id="8c32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">剑道 UI 提供了精心设计和测试的组件，你可以在你的<a class="ae ka" href="https://www.telerik.com/kendo-react-ui/" rel="noopener ugc nofollow" target="_blank">反应</a>、<a class="ae ka" href="https://www.telerik.com/kendo-angular-ui" rel="noopener ugc nofollow" target="_blank">角度</a>、<a class="ae ka" href="https://www.telerik.com/kendo-vue-ui" rel="noopener ugc nofollow" target="_blank"> Vue </a>和<a class="ae ka" href="https://www.telerik.com/kendo-jquery-ui" rel="noopener ugc nofollow" target="_blank"> jQuery </a>应用中使用。在这篇文章中，我们将使用 React 和<a class="ae ka" href="https://www.telerik.com/kendo-react-ui/components/conversationalui/" rel="noopener ugc nofollow" target="_blank"> KendoReact 对话 UI </a>组件构建一个 Twilio 聊天应用程序。</p><h1 id="2166" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">你需要什么</h1><p id="9bd4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果您想按照本教程进行构建，那么您需要一些东西:</p><ul class=""><li id="7adf" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">一个 Twilio 账户(你可以<a class="ae ka" href="https://www.twilio.com/try-twilio" rel="noopener ugc nofollow" target="_blank">在这里</a>免费注册一个 Twilio 账户)</li><li id="bf8c" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">一个<a class="ae ka" href="https://www.twilio.com/console/chat/services" rel="noopener ugc nofollow" target="_blank"> Twilio 聊天服务</a>和一个<a class="ae ka" href="https://www.twilio.com/console/chat/runtime/api-keys" rel="noopener ugc nofollow" target="_blank"> API 密匙和秘密</a>，这两个你都可以在<a class="ae ka" href="https://www.twilio.com/console/chat" rel="noopener ugc nofollow" target="_blank"> Twilio 控制台</a>中创建(把它们放在附近，你很快就会需要它们)</li><li id="416d" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated"><a class="ae ka" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>构建我们的 React 应用程序并运行我们的服务器(我们需要一个服务器来生成访问令牌，以便通过 Twilio 可编程聊天验证我们的用户)</li></ul><p id="9dd9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想跳过前面，你可以在这个 GitHub repo 中查看这个应用程序的代码<a class="ae ka" href="https://github.com/philnash/twilio-chat-kendo-react" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="a123" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">我们开始吧</h1><p id="b74a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们将使用<a class="ae ka" href="https://github.com/philnash/react-express-starter/tree/twilio" rel="noopener ugc nofollow" target="_blank"> React 和 Express starter 应用程序</a>，它是我在<a class="ae ka" href="https://www.twilio.com/blog/react-app-with-node-js-server-proxy" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中构建的，是这个应用程序的基础。这个应用程序为我们提供了一种简单的方法来运行 Node.js 服务器，并通过一个命令对前端做出反应，并且附带了准备为 Twilio 可编程聊天创建访问令牌的端点。<a class="ae ka" href="https://github.com/philnash/react-express-starter/archive/twilio.zip" rel="noopener ugc nofollow" target="_blank">下载</a>或克隆应用程序，进入目录，安装依赖项:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="e79e" class="mb kc hu lx b fv mc md l me mf">git clone -b twilio https://github.com/philnash/react-express-starter.git twilio-chat-kendo<br/>cd twilio-chat-kendo<br/>npm install</span></pre><p id="8066" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将<code class="eh mg mh mi lx b">.env.example</code>文件复制到<code class="eh mg mh mi lx b">.env</code>，然后在空白处填入您的 Twilio 帐户 SID、聊天服务和您之前生成的 API 密钥。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="0e08" class="mb kc hu lx b fv mc md l me mf">cp .env.example .env</span></pre><p id="3717" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">运行应用程序以确保到目前为止一切正常。在命令行上运行:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="a0a2" class="mb kc hu lx b fv mc md l me mf">npm run dev</span></pre><p id="a957" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您将在您的浏览器 localhost:3000 中看到一个类似这样的应用程序。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mj"><img src="../Images/1165613e47a976abfd68a5775c4f101e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhBYlaPBbNf9QtKP2gnWfw.png"/></div></div></figure><p id="6fba" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们已经准备好了 Twilio 聊天应用程序，React 应用程序也已安装完毕。让我们开始建造吧。</p><h1 id="d527" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">准备聊天</h1><p id="394d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在开始聊天集成之前，我们还需要做一些工作。我们需要安装一些依赖项，删除示例应用程序，并添加一点风格。让我们从这些依赖项开始。</p><p id="e14b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将需要<code class="eh mg mh mi lx b">twilio-chat</code>模块来连接 Twilio Chat，然后需要几个 KendoReact 模块来提供我们将要使用的组件:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="692e" class="mb kc hu lx b fv mc md l me mf">npm install twilio-chat @progress/kendo-react-conversational-ui \<br/>  @progress/kendo-react-inputs @progress/kendo-react-buttons \<br/>  @progress/kendo-react-intl @progress/kendo-theme-material</span></pre><p id="fe02" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，剥离<code class="eh mg mh mi lx b">src/App.js</code>回到基础，包括 KendoReact 材质主题的 CSS:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="c696" class="mb kc hu lx b fv mc md l me mf">import React, { Component } from 'react';<br/>import '@progress/kendo-theme-material/dist/all.css';<br/><br/>class App extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>  }<br/><br/>  render() {<br/>    return &lt;p&gt;Hello world&lt;/p&gt;;<br/>  }<br/>}<br/><br/>export default App;</span></pre><p id="1540" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了让应用程序更有风格和布局(不需要太多的努力)，将引导 CSS 添加到<code class="eh mg mh mi lx b">public/index.html</code>的<code class="eh mg mh mi lx b">&lt;head&gt;</code>中:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="d748" class="mb kc hu lx b fv mc md l me mf">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;!-- rest of the head --&gt;<br/>    &lt;title&gt;React App&lt;/title&gt;<br/>    &lt;link<br/>      rel="stylesheet"<br/>      href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"<br/>          integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"<br/>      crossorigin="anonymous"<br/>    /&gt;<br/>  &lt;/head&gt;</span></pre><p id="7e32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成后，是时候构建我们的第一个组件了。</p><h1 id="4d1c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">构建登录表单</h1><p id="5539" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">为了让用户加入我们的聊天，我们需要他们登录并选择一个用户名。如果您正在将它构建到现有的应用程序中，那么您可能已经有了用户和登录系统。在这篇文章中，我们将通过显示一个要求输入用户名的登录表单来伪装它。</p><p id="9873" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建一个新文件<code class="eh mg mh mi lx b">src/Login.js</code>，并打开它。由于登录表单本身不需要存储任何状态，我们将把它作为一个<a class="ae ka" href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" rel="noopener ugc nofollow" target="_blank">功能组件</a>。从以下样板文件开始:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="da1c" class="mb kc hu lx b fv mc md l me mf">import React from 'react';<br/><br/>const Login = props =&gt; {<br/>  return;<br/>};<br/>export default Login;</span></pre><p id="89a7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使我们的登录表单适合我们的对话式 UI，我们将使用 KendoReact 组件。在顶部导入<code class="eh mg mh mi lx b">Button</code>和<code class="eh mg mh mi lx b">Input</code>组件:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="5956" class="mb kc hu lx b fv mc md l me mf">import React from 'react';<br/>import { Button } from '@progress/kendo-react-buttons';<br/>import { Input } from '@progress/kendo-react-inputs';</span></pre><p id="66ea" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">修改<code class="eh mg mh mi lx b">Login</code>函数以返回以下 JSX:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="e887" class="mb kc hu lx b fv mc md l me mf">const Login = props =&gt; {<br/>  return (<br/>    &lt;form className="k-form" onSubmit={props.handleLogin}&gt;<br/>      &lt;fieldset&gt;<br/>        &lt;legend&gt;Log in&lt;/legend&gt;<br/>        &lt;div className="mb-3"&gt;<br/>          &lt;Input<br/>            name="username"<br/>            label="Username"<br/>            required={true}<br/>            style={{ width: '100%' }}<br/>            value={props.username}<br/>            onChange={props.handleUsernameChange}<br/>          /&gt;<br/>        &lt;/div&gt;<br/>        &lt;div&gt;<br/>          &lt;Button type="submit" primary={true}&gt;<br/>            Sign in<br/>          &lt;/Button&gt;<br/>        &lt;/div&gt;<br/>      &lt;/fieldset&gt;<br/>    &lt;/form&gt;<br/>  );<br/>};</span></pre><p id="c568" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这相当于 JSX 的一大块，所以让我们来分解一下。整个事情就是一个<code class="eh mg mh mi lx b">&lt;form&gt;</code>包含一个<code class="eh mg mh mi lx b">&lt;fieldset&gt;</code>和<code class="eh mg mh mi lx b">&lt;legend&gt;</code>。然后在里面有一个<code class="eh mg mh mi lx b">&lt;Input&gt;</code>组件和一个<code class="eh mg mh mi lx b">&lt;Button&gt;</code>组件。这些是我们进口的 KendoReact 组件。它们的行为就像常规的<code class="eh mg mh mi lx b">&lt;input&gt;</code>和<code class="eh mg mh mi lx b">&lt;button&gt;</code>元素，但是符合 KendoReact 风格。</p><p id="953d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">JSX 还包括一些我们需要向组件提供的属性；一个用户名和两个处理事件的函数。我们将把这些添加到<code class="eh mg mh mi lx b">&lt;App&gt;</code>组件中，这样我们就可以把它们作为属性传入。</p><p id="a668" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">打开<code class="eh mg mh mi lx b">src/App.js</code>，开始导入新的<code class="eh mg mh mi lx b">&lt;Login&gt;</code>组件。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="b839" class="mb kc hu lx b fv mc md l me mf">import React, { Component } from 'react';<br/>import '@progress/kendo-theme-material/dist/all.css';<br/>import Login from './Login';</span></pre><p id="b947" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">定义我们将传递给<code class="eh mg mh mi lx b">&lt;Login&gt;</code>组件的两个函数。一个函数需要处理用户输入，并更新存储在状态中的用户名。另一个处理提交的表单，并将状态设置为显示用户已登录。将这些添加到<code class="eh mg mh mi lx b">src/App.js</code>中<code class="eh mg mh mi lx b">&lt;App&gt;</code>组件的构造函数下面:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="1bdd" class="mb kc hu lx b fv mc md l me mf">  handleLogin(event) {<br/>    event.preventDefault();<br/>    this.setState({ loggedIn: true });<br/>  }<br/>  handleUsernameChange(event) {<br/>    this.setState({ username: event.target.value });<br/>  }</span></pre><p id="ff60" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在构造函数中，我们需要初始化状态并将这些函数绑定到组件:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="f21c" class="mb kc hu lx b fv mc md l me mf">  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      username: '',<br/>      loggedIn: false<br/>    };<br/>    this.handleLogin = this.handleLogin.bind(this);<br/>    this.handleUsernameChange = this.handleUsernameChange.bind(this);<br/>  }</span></pre><p id="8972" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们更新<code class="eh mg mh mi lx b">render</code>函数，如果状态显示用户已登录，则显示用户名，否则显示<code class="eh mg mh mi lx b">&lt;Login&gt;</code>组件。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="6bd4" class="mb kc hu lx b fv mc md l me mf">  render() {<br/>    let loginOrChat;<br/>    if (this.state.loggedIn) {<br/>      loginOrChat = &lt;p&gt;Logged in as {this.state.username}&lt;/p&gt;;<br/>    } else {<br/>      loginOrChat = (<br/>        &lt;Login<br/>          handleLogin={this.handleLogin}<br/>          handleUsernameChange={this.handleUsernameChange}<br/>          username={this.state.username}<br/>        /&gt;<br/>      );<br/>    }<br/>    return (<br/>      &lt;div className="container"&gt;<br/>        &lt;div className="row mt-3 justify-content-center"&gt;{loginOrChat}&lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</span></pre><p id="0541" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您的应用程序仍在运行，请返回浏览器，您将看到登录表单。否则用<code class="eh mg mh mi lx b">npm run dev</code>启动 app，打开<code class="eh mg mh mi lx b">localhost:3000</code>。在表格中输入您的姓名，然后按 Enter 或单击“登录”。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div class="fe ff mk"><img src="../Images/431ddd1534759f0f08ef4094670e8f11.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*fBZSDyIroagqGg09"/></div></figure><h1 id="4c19" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">连接可编程聊天</h1><p id="db6b" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在，我们可以使用用户名生成一个访问令牌，并将登录的用户与 chat 连接起来。创建一个名为<code class="eh mg mh mi lx b">src/ChatApp.js</code>的新文件并打开它。我们将为聊天应用程序创建一个基于类的组件，因此添加以下样板文件:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="d59e" class="mb kc hu lx b fv mc md l me mf">import React, { Component } from 'react';<br/><br/>class ChatApp extends Component {<br/>}<br/><br/>export default ChatApp;</span></pre><p id="3fc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个组件中，我们需要做几件事情:</p><ul class=""><li id="c878" class="le lf hu je b jf jg jj jk jn lg jr lh jv li jz lj lk ll lm dt translated">从服务器检索访问令牌并初始化 Twilio 聊天客户端</li><li id="4ef4" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">设置一个聊天频道并加入它，加载任何现有的消息</li><li id="a262" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">创建一个发送消息的函数</li><li id="b41f" class="le lf hu je b jf ln jj lo jn lp jr lq jv lr jz lj lk ll lm dt translated">呈现 KendoReact 对话式用户界面</li></ul><p id="a51f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在此之前，我们需要导入两个模块；twilio-chat 和 KendoReact 会话 UI。在<code class="eh mg mh mi lx b">src/ChatApp.js</code>顶部添加:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="1f27" class="mb kc hu lx b fv mc md l me mf">import React, { Component } from 'react';<br/>import Chat from 'twilio-chat';<br/>import { Chat as ChatUI } from '@progress/kendo-react-conversational-ui';</span></pre><p id="a4dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们也在构造函数中设置一些初始状态。我们需要一个消息列表，一个出错时的错误状态，以及一个显示聊天是否正在加载的布尔值，它将以<code class="eh mg mh mi lx b">true</code>开始。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="9dc4" class="mb kc hu lx b fv mc md l me mf">class ChatApp extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      error: null,<br/>      isLoading: true,<br/>      messages: []<br/>    };<br/>  }<br/>}</span></pre><h2 id="d22f" class="mb kc hu bd kd ml mm mn kh mo mp mq kl jn mr ms kp jr mt mu kt jv mv mw kx mx dt translated">获取访问令牌</h2><p id="210a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">当我们向端点<code class="eh mg mh mi lx b">/chat/token</code>传递一个身份时，starter 项目已经设置为返回一个令牌。我们将使用<code class="eh mg mh mi lx b">fetch</code> API 发出请求，作为<code class="eh mg mh mi lx b">componentDidMount</code>生命周期事件的一部分。我们在这里使用<code class="eh mg mh mi lx b">componentDidMount</code>,因为 React 文档告诉我们这是加载外部数据的好地方。</p><p id="64c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">带有访问令牌的响应将是 JSON，因此我们需要使用响应对象的<code class="eh mg mh mi lx b">json</code>方法来解析它，一旦解析完毕，我们就可以使用令牌来初始化聊天客户端。</p><p id="718b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建聊天客户端返回一个承诺，因此我们可以链接所有这些方法。一旦创建了聊天客户端，我们将使用另一种方法来完成设置。我们还应该用一个<code class="eh mg mh mi lx b">catch</code>方法来处理任何错误。</p><p id="8dfc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将这段代码添加到构造函数下面的<code class="eh mg mh mi lx b">ChatApp</code>类中:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="6721" class="mb kc hu lx b fv mc md l me mf">  componentDidMount() {<br/>    fetch('/chat/token', {<br/>      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },<br/>      method: 'POST',<br/>      body: `identity=${encodeURIComponent(this.props.username)}`<br/>    })<br/>      .then(res =&gt; res.json())<br/>      .then(data =&gt; Chat.create(data.token))<br/>      .then(this.setupChatClient)<br/>      .catch(this.handleError);<br/>  }</span></pre><p id="e65c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">编写处理错误的方法。我们将在状态中设置一条消息，并记录完整的错误，以便在遇到任何问题时可以进行调试。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="41df" class="mb kc hu lx b fv mc md l me mf">  handleError(error) {<br/>    console.error(error);<br/>    this.setState({<br/>      error: 'Could not load chat.'<br/>    });<br/>  }</span></pre><h2 id="18e7" class="mb kc hu bd kd ml mm mn kh mo mp mq kl jn mr ms kp jr mt mu kt jv mv mw kx mx dt translated">设置聊天频道</h2><p id="299a" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们已经用访问令牌初始化了我们的聊天客户端，但还有更多工作要做。一旦承诺兑现，我们需要使用新的聊天客户端加入频道。由于这是我们第一次完成该过程，我们将检查该通道是否存在。如果是这样，我们将尝试加入它；否则，我们将创建它，然后加入它。</p><p id="afe3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将下面的<code class="eh mg mh mi lx b">setupChatClient</code>方法添加到该类中:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="f736" class="mb kc hu lx b fv mc md l me mf">  setupChatClient(client) {<br/>    this.client = client;<br/>    this.client<br/>      .getChannelByUniqueName('general')<br/>      .then(channel =&gt; channel)<br/>      .catch(error =&gt; {<br/>        if (error.body.code === 50300) {<br/>          return this.client.createChannel({ uniqueName: 'general' });<br/>        } else {<br/>          this.handleError(error);<br/>      }<br/>    })<br/>      .then(channel =&gt; {<br/>       this.channel = channel;<br/>       return this.channel.join().catch(() =&gt; {});<br/>      })<br/>      .then(() =&gt; {<br/>        // Success!<br/>      })<br/>      .catch(this.handleError);<br/>   }</span></pre><p id="9203" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们捕捉中间的错误，以防通道不存在(50300 错误)并创建通道。此外，如果加入一个频道抛出一个错误，我们捕捉它，什么也不做。这将处理用户已经是通道成员的情况。</p><p id="d548" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果一切正常，代码将进入成功注释。在这个阶段，通道已经加载，因此我们可以将状态变量<code class="eh mg mh mi lx b">isLoading</code>设置为<code class="eh mg mh mi lx b">false</code>。我们还需要加载现有的消息，并为新消息设置一个监听器。</p><p id="96a6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将上面的<code class="eh mg mh mi lx b">// Success!</code>注释替换为:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="a2af" class="mb kc hu lx b fv mc md l me mf">      .then(() =&gt; {<br/>        this.setState({ isLoading: false });<br/>        this.channel.getMessages().then(this.messagesLoaded);<br/>        this.channel.on('messageAdded', this.messageAdded);<br/>      })</span></pre><h2 id="93d9" class="mb kc hu bd kd ml mm mn kh mo mp mq kl jn mr ms kp jr mt mu kt jv mv mw kx mx dt translated">接收消息</h2><p id="4da4" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们需要编写上面提到的<code class="eh mg mh mi lx b">messagesLoaded</code>和<code class="eh mg mh mi lx b">messageAdded</code>方法，但在此之前，我们需要考虑 KendoReact 对话式 UI 想要的消息的<a class="ae ka" href="https://www.telerik.com/kendo-react-ui/components/conversationalui/api/Message/" rel="noopener ugc nofollow" target="_blank">格式。我们需要将消息对象从 Twilio 提供的格式转换成对话式 UI 组件可以使用的格式。</a></p><p id="23dc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们编写一个函数，它可以从聊天服务获取<a class="ae ka" href="http://media.twiliocdn.com/sdk/js/chat/releases/3.0.2/docs/Message.html" rel="noopener ugc nofollow" target="_blank">消息，并为 KendoReact 返回一个消息对象:</a></p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="058d" class="mb kc hu lx b fv mc md l me mf">  twilioMessageToKendoMessage(message) {<br/>    return {<br/>      text: message.body,<br/>      author: { id: message.author, name: message.author },<br/>      timestamp: message.timestamp<br/>    };<br/>  }</span></pre><p id="3f21" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在我们可以编写<code class="eh mg mh mi lx b">messagesLoaded</code>和<code class="eh mg mh mi lx b">messageAdded</code>方法了。<code class="eh mg mh mi lx b">messagesLoaded</code>在我们第一次将现有消息加载到通道时运行，因此我们用收到的所有消息填充<code class="eh mg mh mi lx b">state.messages</code>。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="a32c" class="mb kc hu lx b fv mc md l me mf">  messagesLoaded(messagePage) {<br/>    this.setState({<br/>      messages: messagePage.items.map(this.twilioMessageToKendoMessage)<br/>    });<br/>  }</span></pre><p id="5f8e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mg mh mi lx b">messageAdded</code>将接收一条消息作为它的参数，所以我们使用<code class="eh mg mh mi lx b"><a class="ae ka" href="https://reactjs.org/docs/react-component.html#setstate" rel="noopener ugc nofollow" target="_blank">setState</a></code>的回调版本将消息添加到列表中。注意，我们还使用 spread 操作符(<code class="eh mg mh mi lx b">...</code>)将现有消息复制到新状态中。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="df6b" class="mb kc hu lx b fv mc md l me mf">  messageAdded(message) {<br/>    this.setState(prevState =&gt; ({<br/>      messages: [<br/>        ...prevState.messages,<br/>        this.twilioMessageToKendoMessage(message)<br/>      ]<br/>    }));<br/>  }</span></pre><h2 id="85ed" class="mb kc hu bd kd ml mm mn kh mo mp mq kl jn mr ms kp jr mt mu kt jv mv mw kx mx dt translated">发送消息</h2><p id="ba80" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们还需要一个向通道发送消息的函数。当用户在消息框中键入消息并通过单击 send 按钮或按 enter 键发送消息时，KendoReact 对话式 UI 将调用该函数。为了处理它，我们需要将消息文本发送到通道上。消息的显示将由我们在频道上监听的现有<code class="eh mg mh mi lx b">messageAdded</code>事件来处理。</p><p id="6009" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">将以下函数添加到<code class="eh mg mh mi lx b">ChatApp</code>类中:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="4479" class="mb kc hu lx b fv mc md l me mf">  sendMessage(event) {<br/>    this.channel.sendMessage(event.message.text);<br/>  }</span></pre><h2 id="fac5" class="mb kc hu bd kd ml mm mn kh mo mp mq kl jn mr ms kp jr mt mu kt jv mv mw kx mx dt translated">整理和呈现对话式用户界面</h2><p id="bc8d" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在我们可以看到实际的聊天之前，我们还有一些最后的部分要完成。我们应该处理被卸载的组件。我们可以通过关闭聊天客户端实例来做到这一点。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="17e7" class="mb kc hu lx b fv mc md l me mf">  componentWillUnmount() {<br/>    this.client.shutdown();<br/>  }</span></pre><p id="fbf0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对话式 UI 需要一个用户对象，我们将使用我们的用户身份来创建它。我们还需要将所有回调函数绑定到组件。将以下内容添加到构造函数中:</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="14f2" class="mb kc hu lx b fv mc md l me mf">  constructor(props) {<br/>    super(props);<br/><br/>    this.state = {<br/>      error: null,<br/>      isLoading: true,<br/>      messages: []<br/>    };<br/>    this.user = {<br/>      id: props.username,<br/>      name: props.username<br/>    };<br/><br/>    this.setupChatClient = this.setupChatClient.bind(this);<br/>    this.messagesLoaded = this.messagesLoaded.bind(this);<br/>    this.messageAdded = this.messageAdded.bind(this);<br/>    this.sendMessage = this.sendMessage.bind(this);<br/>    this.handleError = this.handleError.bind(this);<br/>  }</span></pre><h1 id="ab5f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">渲染聊天</h1><p id="a346" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在一切就绪，我们可以呈现对话式 UI 了。在<code class="eh mg mh mi lx b">src/ChatApp.js</code>中创建一个处理组件各种状态的<code class="eh mg mh mi lx b">render</code>方法。如果有错误或者聊天仍在加载，我们将呈现一条消息，否则我们将呈现 KendoReact 对话式 UI 组件，传递用户对象、消息和用户发送消息时要运行的回调方法。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="09f6" class="mb kc hu lx b fv mc md l me mf">  render() {<br/>    if (this.state.error) {<br/>      return &lt;p&gt;{this.state.error}&lt;/p&gt;;<br/>    } else if (this.state.isLoading) {<br/>      return &lt;p&gt;Loading chat...&lt;/p&gt;;<br/>    }<br/>    return (<br/>      &lt;ChatUI<br/>        user={this.user}<br/>        messages={this.state.messages}<br/>        onMessageSend={this.sendMessage}<br/>        width={500}<br/>      /&gt;<br/>    );<br/>  }</span></pre><p id="d2c2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们需要渲染来自<code class="eh mg mh mi lx b">&lt;App&gt;</code>组件的整个组件。导入<code class="eh mg mh mi lx b">src/App.js</code>顶部的<code class="eh mg mh mi lx b">&lt;ChatApp&gt;</code>组件。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="3c32" class="mb kc hu lx b fv mc md l me mf">import React, { Component } from 'react';<br/>import Login from './Login';<br/>import ChatApp from './ChatApp';<br/>import '@progress/kendo-theme-material/dist/all.css';</span></pre><p id="60c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在更新<code class="eh mg mh mi lx b">&lt;App&gt; component</code>的<code class="eh mg mh mi lx b">render</code>函数，在用户登录时返回<code class="eh mg mh mi lx b">&lt;ChatApp&gt;</code>组件。</p><pre class="ls lt lu lv fq lw lx ly lz aw ma dt"><span id="b1fa" class="mb kc hu lx b fv mc md l me mf">render() {<br/>  let loginOrChat;<br/>  if (this.state.loggedIn) {<br/>    loginOrChat = &lt;ChatApp username={this.state.username} /&gt;;<br/>  } else {<br/>    loginOrChat = (<br/>      &lt;Login<br/>        handleLogin={this.handleLogin}<br/>        handleUsernameChange={this.handleUsernameChange}<br/>        username={this.state.username}<br/>      /&gt;<br/>    );<br/>  }<br/>  return (<br/>    &lt;div className="container"&gt;<br/>      &lt;div className="row mt-3"&gt;{loginOrChat}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );</span></pre><p id="55fe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">重新加载应用程序，登录并开始聊天。您可以打开另一个浏览器窗口，用不同的名称登录，查看来回传递的信息。</p><figure class="ls lt lu lv fq iv fe ff paragraph-image"><div class="fe ff my"><img src="../Images/b3139411579723859bf3b94cce3dc8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*L4sQhfvBoWfFWLB4"/></div></figure><h1 id="5b01" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">这仅仅是开始</h1><p id="4034" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://www.twilio.com/docs/chat" rel="noopener ugc nofollow" target="_blank"> Twilio 可编程聊天</a>是一个功能强大的聊天 SDK，而<a class="ae ka" href="https://www.telerik.com/kendo-react-ui/components/conversationalui/" rel="noopener ugc nofollow" target="_blank"> KendoReact 的对话式 UI </a>使得在 React 应用程序中显示聊天内容变得非常容易。我们要做的大部分工作是生成一个访问令牌并设置 Twilio 聊天。一旦我们编写了几个将消息从 Twilio 翻译成 KendoReact 和从 KendoReact 翻译成 Twilio 的函数，UI 就就位了。</p><p id="82d6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可以在<a class="ae ka" href="https://github.com/philnash/twilio-chat-kendo-react" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中获得该应用程序的所有代码。</p><p id="eec5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">查看<a class="ae ka" href="https://www.telerik.com/kendo-react-ui" rel="noopener ugc nofollow" target="_blank"> KendoReact 文档</a>了解该 UI 的其他功能，例如<a class="ae ka" href="https://www.telerik.com/kendo-react-ui/components/conversationalui/suggested-actions/" rel="noopener ugc nofollow" target="_blank">建议操作</a>，当对方是机器人时很有用，以及<a class="ae ka" href="https://www.telerik.com/kendo-react-ui/components/conversationalui/attachments/" rel="noopener ugc nofollow" target="_blank">消息附件</a>，了解在您的聊天中显示媒体消息或其他视图(如列表或传送带)的方式。</p><p id="dd0c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢不同的框架，KendoReact 对话式用户界面也可用于 jQuery T1、T2 角 T3 和 T4 Vue T5，还有很多其他有用的组件可以用来构建你的应用。</p><p id="326d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你以前用过 KendoReact 吗？或者你正在你的应用程序中构建聊天功能，并寻找一个可爱的用户界面？请在@philnash 的评论或<a class="ae ka" href="https://twitter.com/philnash" rel="noopener ugc nofollow" target="_blank"> Twitter 上告诉我你的想法。</a></p></div><div class="ab cl mz na hc nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="hn ho hp hq hr"><p id="aa7a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="ng">最初发表于</em><a class="ae ka" href="https://www.twilio.com/blog/chat-app-twilio-kendoreact" rel="noopener ugc nofollow" target="_blank"><em class="ng">www.twilio.com</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>