<html>
<head>
<title>Moving from multiple repositories to a lerna-js mono-repo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从多个存储库转移到一个lerna-js单一存储库</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/moving-from-multiple-repositories-to-a-lerna-js-mono-repo-d0fff3538c7e?source=collection_archive---------12-----------------------#2019-01-22">https://medium.com/hackernoon/moving-from-multiple-repositories-to-a-lerna-js-mono-repo-d0fff3538c7e?source=collection_archive---------12-----------------------#2019-01-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="ab fr cl iv"><img src="../Images/2a4a18ca7e6af4f1bdacc2ea5d22259d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wKLWcOLePsxtKArBC0k8eA.jpeg"/></div></figure><p id="ba8f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在<a class="ae jw" href="http://mitter.io/" rel="noopener ugc nofollow" target="_blank"> mitter.io </a>中，我们有几个面向公众的<code class="eh jx jy jz ka b">npm</code>包需要发布，我们最近转移到了由Lerna管理的单一回购结构，而不是为每个包都有单独的存储库。今天，我想分享一下我们在这一迁移过程中的经验，以及我们对新monorepo结构的设置。我们的所有软件包要么是SDK目标，要么是SDK目标的依赖项:</p><ul class=""><li id="53a7" class="kb kc hu ja b jb jc jf jg jj kd jn ke jr kf jv kg kh ki kj dt translated"><code class="eh jx jy jz ka b">@mitter-io/core</code>—<a class="ae jw" href="http://mitter.io/" rel="noopener ugc nofollow" target="_blank">mitter . io</a>SDK的核心功能</li><li id="7e57" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated"><code class="eh jx jy jz ka b">@mitter-io/models</code> -类型脚本模型(类、类型别名、接口等。)对于SDK</li><li id="61b3" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated"><code class="eh jx jy jz ka b">@mitter-io/web</code>-web SDK</li><li id="e4a7" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated"><code class="eh jx jy jz ka b">@mitter-io/react-native</code>-React原生SDK</li><li id="ba7c" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated"><code class="eh jx jy jz ka b">@mitter-io/node</code>-node.js SDK(用于node . js后端)</li><li id="6268" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated"><code class="eh jx jy jz ka b">@mitter-io/react-scl</code>-react js应用的标准组件库</li></ul><p id="2638" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们所有的包都是用TypeScript编写的，类型与包本身捆绑在一起，我们不分发单独的类型包(你通常看到的以<code class="eh jx jy jz ka b">@types/</code>开头的包)。我们使用<a class="ae jw" href="https://rollupjs.org/guide/en" rel="noopener ugc nofollow" target="_blank"> rollup </a>以UMD和ES5模块格式捆绑这些包。除此之外，我们使用<a class="ae jw" href="https://typedoc.org/" rel="noopener ugc nofollow" target="_blank"> TypeDoc </a>生成我们的文档，然后在<strong class="ja hv"> AWS S3 </strong>的公共桶上发布。</p><p id="1f8e" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在使用Lerna之前，我们的每个包都有一个单独的存储库，当我们只有web SDK时，它工作得很好。随着我们的发展，越来越多的开发人员开始开发SDK，我们的设置开始面临一些问题:</p><ol class=""><li id="a94b" class="kb kc hu ja b jb jc jf jg jj kd jn ke jr kf jv kp kh ki kj dt translated">鉴于大多数SDK逻辑驻留在<code class="eh jx jy jz ka b">@mitter-io/core</code>中，几乎所有发生在<code class="eh jx jy jz ka b">core</code>包和所有其他包中的更改都必须更新以指向新版本。因此，即使有一个bug需要修复，比如说React Native，更改也会在<code class="eh jx jy jz ka b">core</code>中进行，但更新现在需要反映在所有其他目标中，即<code class="eh jx jy jz ka b">web</code>、<code class="eh jx jy jz ka b">node</code>和<code class="eh jx jy jz ka b">react-native</code>。开发人员错过目标是很常见的。</li><li id="d426" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kp kh ki kj dt translated">几乎SDK中的每个变化都会导致5个包中至少3个的变化。</li><li id="ad4d" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kp kh ki kj dt translated">我们看到了跨包保持相同版本的巨大好处(使开发人员更容易猜测目标的最新版本)，但是手动跟踪变得很麻烦。</li><li id="014a" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kp kh ki kj dt translated"><code class="eh jx jy jz ka b">npm link</code>(或者<code class="eh jx jy jz ka b">yarn link</code>，如果你喜欢的话)有自己的一套问题，确保所有的依赖关系都被链接，然后取消链接以使用来自<code class="eh jx jy jz ka b">npm</code>的正确链接，并返回到本地链接进行开发。</li><li id="8422" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kp kh ki kj dt translated">跨包运行脚本(例如，发布typescript文档)是很常见的，我们使用脆弱的符号链接和bash脚本来管理它们。</li></ol><p id="8797" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">大约在那个时候，我们遇到了L <a class="ae jw" href="https://lernajs.io/" rel="noopener ugc nofollow" target="_blank"> erna </a>，它似乎非常适合我们的要求。</p><p id="79d0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们决定遵循最简单的方法，尽量使用默认值。根据我们的经验，迁移到Lerna是一件轻而易举的事。首先创建一个新的Lerna repo:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="12c9" class="ky kz hu ka b fv la lb l lc ld">mkdir my-new-monorepo &amp;&amp; cd my-new-monorepo<br/>git init .<br/>lerna init</span></pre><p id="9da6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">回答几个简单的问题(我们总是使用默认设置)，就万事俱备了。将我们的旧包从它们的回购转移到新包(我们担心这会是一个巨大的痛苦)比预期的要容易得多:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="28b1" class="ky kz hu ka b fv la lb l lc ld">lerna import ~/projects/my-single-repo-package-1 --flatten</span></pre><blockquote class="le lf lg"><p id="44ce" class="iy iz lh ja b jb jc jd je jf jg jh ji li jk jl jm lj jo jp jq lk js jt ju jv hn dt translated"><strong class="ja hv"> <em class="hu">注意</em></strong><em class="hu"/><code class="eh jx jy jz ka b"><em class="hu">--flatten</em></code><em class="hu">可能需要，也可能不需要，但是我们面临没有它的问题。</em></p></blockquote><p id="2b24" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Lerna的神奇之处在于它带来了所有的git提交(你可能会丢失一些关于<code class="eh jx jy jz ka b">--flatten</code>的历史)，因此对于新的repo，历史看起来像是一直在这个monorepo中进行开发。这是绝对必要的，因为在转移到monorepo之后，你将需要为你发现的一个bug找个人。</p><p id="ff6b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">有了Lerna，我们现在可以管理所有软件包的单一存储库，其目录结构如下所示:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="5ca4" class="ky kz hu ka b fv la lb l lc ld">packages/<br/> core/<br/> models/<br/> node/<br/> react-native/<br/> web/<br/>lerna.json<br/>package.json</span></pre><p id="8e41" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">要发布已更改的包，我们现在只需:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="72b4" class="ky kz hu ka b fv la lb l lc ld">lerna boostrap<br/>lerna publish</span></pre><p id="eaa6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你不必每次都做<code class="eh jx jy jz ka b">lerna bootstrap</code>；除非这是你第一次检查回购。它所做的只是在这个repo下安装每个包的所有依赖项。</p><p id="ed32" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">与此同时，我们还决定简化我们的流程，并在<code class="eh jx jy jz ka b">npm</code>生命周期本身中添加了所有打包任务。一定要注意，这和Lerna没有任何关系；无论回购结构如何，这都是任何npm包中应该有的东西。对于每个包，以下脚本出现在单独的<code class="eh jx jy jz ka b">pacakge.json</code>中:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="2ee5" class="ky kz hu ka b fv la lb l lc ld">"scripts": {<br/> ...<br/> "prepare": "yarn run build",<br/> "prepublishOnly": "./../../ci-scripts/publish-tsdocs.sh"<br/> ...<br/>}</span></pre><p id="9c54" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这用<strong class="ja hv"> typescript </strong>编译器构建了这个包，用<strong class="ja hv"> rollup </strong>捆绑它，并用<strong class="ja hv"> typedoc </strong>生成文档:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="677a" class="ky kz hu ka b fv la lb l lc ld">"scripts": {<br/> ...<br/> "build": "tsc --module commonjs &amp;&amp; rollup -c rollup.config.ts &amp;&amp; typedoc --out docs --target es6 --theme minimal --mode file src"<br/> ...<br/>}</span></pre><p id="e20a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">拥有一个单一的repo结构还允许您将公共脚本保存在一个地方，以便更改可以应用于所有的包(我们还应该将构建脚本移动到一个单独的脚本中，因为它现在已经变成了一个相当复杂的bash命令)。</p><p id="c779" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">除了发布之外的开发人员流程是不变的。开发人员在GitLab上创建一个问题(或被分配一个问题)，为该问题创建一个新的分支，然后在代码审查后将更改合并到master。发布生命周期现在遵循一个非常结构化的过程:</p><ol class=""><li id="f5ea" class="kb kc hu ja b jb jc jf jg jj kd jn ke jr kf jv kp kh ki kj dt translated">当一个里程碑完成后，我们计划发布一个新的版本，其中一个开发人员(负责那个特定的版本)通过运行<code class="eh jx jy jz ka b">lerna version</code>创建一个新版本。</li><li id="32a4" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kp kh ki kj dt translated">Lerna为确定下一个版本提供了一个非常有用且易于使用的提示</li></ol><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="99a7" class="ky kz hu ka b fv la lb l lc ld">(master) mitter-js-sdk ツ lerna version --force-publish<br/> lerna notice cli v3.8.1<br/> lerna info current version 0.6.2<br/> lerna info Looking for changed packages since v0.6.2<br/> ? Select a new version (currently 0.6.2) (Use arrow keys)<br/> ❯ Patch (0.6.3)<br/> Minor (0.7.0)<br/> Major (1.0.0)<br/> Prepatch (0.6.3-alpha.0)<br/> Preminor (0.7.0-alpha.0)<br/> Premajor (1.0.0-alpha.0)<br/> Custom Prerelease<br/> Custom Version</span></pre><p id="bbc6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">一旦选择了新版本，Lerna就会更改包的版本，在远程repo中创建一个标记，并将更改推送到我们的GitLab实例。除此之外，开发人员不需要做任何其他事情。我们的CI设置为构建所有名称类似于语义版本号的标记。</p><blockquote class="le lf lg"><p id="3961" class="iy iz lh ja b jb jc jd je jf jg jh ji li jk jl jm lj jo jp jq lk js jt ju jv hn dt translated"><strong class="ja hv"> <em class="hu">注意</em> </strong> <em class="hu">我们用</em> <code class="eh jx jy jz ka b"><em class="hu">--force-publish</em></code> <em class="hu">运行</em> <code class="eh jx jy jz ka b"><em class="hu">lerna version</em></code> <em class="hu">，因为我们希望所有的包都有完全相同的版本血统。所以有时我们会有不同版本之间没有区别的包。根据您的偏好，您可以选择不这样做。</em></p></blockquote><p id="f178" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们使用GitLab的集成CI来构建、测试和发布我们所有的项目(JS和Java)。对于新的JS monorepo，我们有两个阶段:</p><p id="6df8" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">构建阶段非常简单，运行以下两个脚本:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="f26a" class="ky kz hu ka b fv la lb l lc ld">lerna bootstrap<br/>lerna run build</span></pre><p id="4bd4" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个阶段在每一次提交时运行，从本质上验证包的健全性。另一方面，发布阶段运行以下内容:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="b715" class="ky kz hu ka b fv la lb l lc ld">git checkout master<br/>lerna bootstrap<br/>git reset --hard<br/>lerna publish from-package --yes</span></pre><blockquote class="le lf lg"><p id="5da4" class="iy iz lh ja b jb jc jd je jf jg jh ji li jk jl jm lj jo jp jq lk js jt ju jv hn dt translated"><em class="hu">我们发现我们必须做一个</em> <code class="eh jx jy jz ka b"><em class="hu">git checkout master</em></code> <em class="hu">和一个</em> <code class="eh jx jy jz ka b"><em class="hu">git reset --hard</em></code> <em class="hu">因为GitLab克隆(或获取，取决于配置)了回购，然后检查将要构建的提交。这将工作目录设置为“分离头”模式，即ref </em> <code class="eh jx jy jz ka b"><em class="hu">HEAD</em></code> <em class="hu">不指向任何地方。Lerna使用</em> <code class="eh jx jy jz ka b"><em class="hu">HEAD</em></code> <em class="hu">计算出当前版本的包，并在分离的head状态下出错。</em></p></blockquote><p id="9690" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们还需要运行<code class="eh jx jy jz ka b">lerna publish from-package</code>而不是<code class="eh jx jy jz ka b">lerna publish</code>，因为执行简单的<code class="eh jx jy jz ka b">lerna publish</code>会让Lerna抱怨当前版本已经发布，因为元数据是在开发者本地运行<code class="eh jx jy jz ka b">lerna version</code>时更新的。<code class="eh jx jy jz ka b">from-package</code>参数告诉Lerna为给定的包发布npm中当前没有的所有版本。如果由于某种原因发布失败，并且您正在重试管道，这也会有所帮助。</p><p id="cd26" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">发布阶段被配置为仅在匹配以下regex <a class="ae jw" href="https://github.com/semver/semver/issues/232" rel="noopener ugc nofollow" target="_blank"> credit </a>的标签上运行:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="c6f2" class="ky kz hu ka b fv la lb l lc ld">^v(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?$</span></pre><p id="a9c2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这有点花哨，对于大多数团队和大多数目的来说，简单的<code class="eh jx jy jz ka b">^v*$</code>应该就可以了。:)</p><blockquote class="le lf lg"><p id="182d" class="iy iz lh ja b jb jc jd je jf jg jh ji li jk jl jm lj jo jp jq lk js jt ju jv hn dt translated"><strong class="ja hv"/></p></blockquote><p id="791b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">你可以在<a class="ae jw" href="https://github.com/mitterio/js-sdk" rel="noopener ugc nofollow" target="_blank">https://github.com/mitterio/js-sdk</a>查看我们的monorepo(这是我们内部GitLab repo的镜像)。</p><p id="1fbd" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当运行公共脚本时(就像我们发布typescript文档一样)，了解运行脚本的包的细节是非常有用的。这适用于npm生命周期中的脚本，以及可能使用<code class="eh jx jy jz ka b">lerna run</code>或<code class="eh jx jy jz ka b">lerna exec</code>运行的脚本。对于npm中给定的包，npm使用环境变量使整个<code class="eh jx jy jz ka b">package.json</code>对脚本可用。因此，对于具有以下<code class="eh jx jy jz ka b">package.json</code>的给定包:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="57cf" class="ky kz hu ka b fv la lb l lc ld">{<br/> "name": "@mitter-io/core",<br/> "version": "0.6.28",<br/> "repository": {<br/> "type": "git"<br/> }<br/>}</span></pre><p id="6e43" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">运行任何生命周期脚本时，以下变量将可用:</p><pre class="kq kr ks kt fq ku ka kv kw aw kx dt"><span id="9472" class="ky kz hu ka b fv la lb l lc ld">npm_package_name=@mitter-io/core<br/>npm_package_version=0.6.28<br/>npm_package_repository_type=git</span></pre><p id="4404" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><strong class="ja hv">怪癖/问题</strong></p><p id="df94" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在新的设置中，我们仍然在做一些事情(其中一些是问题，而另一些我们可能不知道得更好):</p><ul class=""><li id="21a1" class="kb kc hu ja b jb jc jf jg jj kd jn ke jr kf jv kg kh ki kj dt translated">不确定这是否可能，但我们希望能够为我们所有的软件包提供通用的生命周期脚本。在根目录<code class="eh jx jy jz ka b">package.json</code>中声明这些是不起作用的。</li><li id="c4d9" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated">在没有向npm发布任何东西的情况下，完全测试您的Lerna设置是非常困难的。不确定某处是否有<code class="eh jx jy jz ka b">--dry-run</code>。</li><li id="7709" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated">Lerna有办法为<code class="eh jx jy jz ka b">devDependencies</code>保留一个公共的配置块，这样所有的<code class="eh jx jy jz ka b">devDependencies</code>对于每个子包都是相同的版本。这是一个很酷的功能，但我们需要一些时间来剔除所有常见的功能。</li><li id="5b55" class="kb kc hu ja b jb kk jf kl jj km jn kn jr ko jv kg kh ki kj dt translated">同样的情况也适用于其他依赖项，所以虽然我们不想要一个通用的<code class="eh jx jy jz ka b">dependencies</code>配置块，但是有一种方法来表达跨项目可用的变量会很好。例如，在我们的Java/Kotlin monorepo中，我们使用<code class="eh jx jy jz ka b">gradle.properties</code>来包含像<code class="eh jx jy jz ka b">springBootVersion</code>、<code class="eh jx jy jz ka b">springCoreVersion</code>等变量。，然后由各个gradle脚本使用。</li></ul><p id="837f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们对monorepos的看法最近在monorepos上有一场相当激烈的辩论，我们是否会看到大量的人再次加入这一潮流，这很容易让人想起微服务风靡一时的时代。</p><p id="d35c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们在这里遵循的结构是拥有多个单一回购，这并不是我们第一次管理单一回购。我们的整个平台和后端是一个monorepo，包含私有的、可部署的代码和发布到bintray的多个面向公众的包。我们的主网站也运行在Spring后端，前端捆绑了支持热重装的web pack(<code class="eh jx jy jz ka b">webpack watch</code>)等等。我们从未决定在整个组织内采用单一回购，因为工具根本不存在。</p><p id="c34c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">将我们的大部分Java代码放在单个repo中非常有用，因为<code class="eh jx jy jz ka b">gradle</code>提供了Java monorepo所需的所有工具，而<code class="eh jx jy jz ka b">lerna</code>和npm生命周期为JS SDK的monorepo提供了工具。因此，简单地说，一旦你确定了回购中的变化范围，单一回购就很棒。对于我们的Java后端，我们看到一个特性有多个跨项目的MRs，这使我们倾向于只为这个特定的项目转移到monorepo，而我们所有的其他代码仍然在单独的repos中。一旦我们看到JS SDKs也出现了类似的模式，我们就转向了Lerna。</p><p id="2c7f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">请注意，我们是一个大约9名工程师的小团队；所以对我们有效的方法可能对不同规模的团队无效。我们最想指出的是，采用任何解决方案都不必是二元的，要么我们按规定做，要么根本不做。</p><p id="e529" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我们看到的单一回购的一些动机肯定适用于我们，但很多动机并不适用。例如，如果我们的整个代码库被转移到一个单独的repo中，我们就不能抽出时间来构建工具——不管我们可能体验到或没有体验到好处。因此，这场辩论实际上并不是关于“单一回购”——就其本身而言，它只不过是一种新的目录结构。它们的处方是缓解某些问题，就像每一个“银弹”一样，也有警告。</p><p id="a1e9" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这场辩论是关于软件行业面临的共同问题以及通常采取的解决方案；“普通”是关键词。你偏离“普通”应用程序的地方是你开始创新、改变和构建的地方。</p></div><div class="ab cl ll lm hc ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hn ho hp hq hr"><p id="149c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="lh">原载于2019年1月22日</em><a class="ae jw" rel="noopener" href="/mitterio/multirepo-to-lerna-js-monorepo-80f6657cb443"><em class="lh">【medium.com】</em></a><em class="lh">。</em></p></div></div>    
</body>
</html>