<html>
<head>
<title>Unified Application Framework for Larger-scale Apps: Alibaba’s Fish Redux Moves to Open Source</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大型应用的统一应用框架:阿里巴巴的 Fish Redux 转向开源</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/unified-application-framework-for-larger-scale-apps-alibabas-fish-redux-moves-to-open-source-b520bd9bdbbb#2019-03-08">https://medium.com/hackernoon/unified-application-framework-for-larger-scale-apps-alibabas-fish-redux-moves-to-open-source-b520bd9bdbbb#2019-03-08</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4705" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">Fish Redux 为阿里巴巴的鲜鱼交易平台消除了痛点，实现了可配置组装</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/743ea276e2bd0a7216638ed03b22dae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lurxzg8AXe7Bs8BCIsaoeg.png"/></div></div></figure><p id="d857" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kr">本文是</em> <a class="ae ks" rel="noopener" href="/@alitech_2017/alibaba-open-source-series-6ec06ca2a402"> <strong class="jx hv"> <em class="kr">阿里巴巴开源</em> </strong> </a> <em class="kr">系列的一部分。</em></p><p id="f915" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt">During its early stages, Alibaba’s Xianyu( 闲鱼) second-hand trading platform relied heavily on the Flutter mobile app SDK for its development. Developers encountered a number of persistent difficulties, especially strong business code coupling and poor code maintainability. To support its business scenarios, Xianyu needed a unified application framework capable of solving development dilemmas.</p><p id="9e92" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">作为一个基于 Redux 数据管理的高级组装式 Flutter 应用程序框架，Fish Redux 为 Xianyu 早期的问题提供了一个理想的解决方案，证明特别适合于中型和大型复杂应用程序。由于可配置汇编的主要特性，它易于编写，易于维护，并使协作变得容易。受包括 Redux、React、Elm 和 Dva 在内的著名框架的启发，Fish Redux 改进了 Redux 的焦点、划分、重用和隔离功能。</p><p id="e2ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">由于它很快将被开源，本文将详细研究 Fish Redux 的架构、组件、字典和其他机制，以说明它对于应用程序开发的价值。</p><h1 id="ef37" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">Fish Redux 的架构概述</h1><p id="5975" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">如下图所示，Fish Redux 自下而上分为三层。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lq"><img src="../Images/614ce66e45a7de2e4fbf26741275da6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tV4-5yi1D3Fr1_70cstHrw.jpeg"/></div></div></figure><p id="ae45" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">每一层都是用来解决问题，解决特定层面的矛盾。以下部分将详细讨论这些层。</p><h2 id="cd76" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">冗余层</h2><p id="095d" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Redux 是由前端开发社区创建的状态管理框架，它是可预测的、集中的、易于调试的、灵活的。Redux 处理所有操作，如添加、删除、修改和查询数据。</p><p id="cc47" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在设计和实现方面，Redux 是一个功能性的状态管理框架。传统上，面向对象编程(OOP)使用 bean 处理状态管理，每个 bean 公开几个公共 API 来操作内部数据(充血模型)。功能方法更抽象。数据被定义为 struct(贫血模型),操作数据的方法被统一到一个具有相同函数签名的 reducer 中:</p><p id="f996" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">(T，Action) =&gt; T. FP: Struct(贫血模型)+ reducer = OOP: bean(充血模型)。</p><p id="5dfc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">同时，Redux 增加了 FP 中常用的中间件(AOP)模式和“订阅”机制，赋予了框架很强的灵活性和可扩展性。(关于贫血和充血模型的更多信息可在<a class="ae ks" href="https://en.wikipedia.org/wiki/PlainoldJava_object" rel="noopener ugc nofollow" target="_blank">维基百科</a>上获得。</p><p id="4b72" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最初的 Redux 有许多缺点。首先是 Redux 的中心化和组件划分的矛盾。第二，Redux 的减速器需要人工一层一层的组装，比较繁琐，容易出错。</p><p id="9059" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Fish Redux 解决了这些问题。它只与数据管理相关，不考虑具体的使用场景，通过 Redux 提供集中的、可观察的数据管理。除此之外，在客户端 Flutter 页面的横向开发场景中，它提供了比原始 Redux 更好、更高的抽象。</p><p id="f758" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">每个组件由一个数据点(结构)和缩减器组成。同时，不同组件之间存在父子依赖关系。Fish Redux 利用这种依赖关系来解决集中化和分区化之间的冲突。Fish Redux 还转换了 reducer 的逐层手动合并功能，以提供自动框架完成，大大简化了 Redux 的使用。最后，这有助于在使用分区代码时实现集中化的结果。</p><p id="9e72" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">上面提到的状态、动作、缩减器、存储和中间件的概念与社区的 ReduxJS 是一致的，保留了原来 Redux 的所有优点。关于 Redux 的更多信息可在<a class="ae ks" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux Github 页面</a>获得。</p><h2 id="8a48" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">组件层</h2><p id="109e" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">组件是用于本地表示和功能的包。基于 Redux 的原则，函数被细分为两种，一种修改数据(reducers ),另一种不修改数据(副作用)。结果包含三个部分:1)视图；2)效果；和 3)减速器，它们被称为组件的三个元素。它们分别负责组件的显示、不修改数据的行为和修改数据的行为。</p><p id="21d1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">这种细分既面向现在，也面向未来。现在的 Redux 把细分看做“数据管理”和“其他”，面向未来的 UI-automation 把细分看做“UI 表达”和“其他”。就程序员而言，UI 表达式现在即将进入一个黑盒时代，导致 R&amp;D 工程师越来越关注不修改数据和修改数据的行为。</p><p id="f7c3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">组件是视图的划分和数据的划分。通过层层分割，将复杂的页面和数据分割成相互独立的小模块，便于团队内部的协同开发。</p><h2 id="fb95" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">1.景色</h2><p id="eccc" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">视图只是一个函数签名:(T，Dispatch，ViewService) = &gt;小部件。它主要包含具有三个特征的信息。</p><p id="9d1c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，视图完全是数据驱动的。</p><p id="3fc9" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第二，视图生成的事件/回调是通过 dispatch 带着“意图”发出的，没有具体的实现。</p><p id="4026" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，它需要组件依赖，这些依赖是以标准化的方式调用的，例如通过 ViewService(在一个典型的视图签名兼容函数中)。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mf"><img src="../Images/c1acac13cebe91a7ab70e6ca717ab402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAzJr4LX-lVsaum9pIl-Mg.png"/></div></div></figure><h2 id="578e" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">2.效果</h2><p id="c1f0" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">作为非修改数据行为的标准定义，效果是函数签名:(Context，Action) =&gt; Object。它主要包含具有四个特征的信息。</p><p id="b82c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，效果接收来自视图的“意图”，包括相应的生命周期回调，然后做出具体的执行。</p><p id="9459" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第二，它的处理可能是一个异步函数，在这个过程中数据可能被修改。这意味着不应持有数据；相反，应该通过上下文获取最新数据。</p><p id="52c1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第三，它不修改数据，如果需要的话，应该发送一个动作给 reducer 进行处理。</p><p id="c86b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，它的返回值仅限于 bool 或 future，这对应于支持同步函数和协程(比如良好的协程支持)的处理流。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mg"><img src="../Images/16033f4611dd892cf5a8bb27b717a37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GPhbNXrwd42Avrr_D253vQ.png"/></div></div></figure><h2 id="5b5d" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">3.该减速器</h2><p id="5cf4" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">缩减器是一个完全符合 Redux 规范的函数签名:(T，Action) =&gt; T。下面显示了一个符合签名的缩减器:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mh"><img src="../Images/6d531b10661d115562641679631641b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BOFAzHNBjoiaTLaesF5aSg.png"/></div></div></figure><p id="4db2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">同时，大型组件所依赖的小部件和适配器是在显式配置中注册的；这种依赖关系配置称为依赖关系。</p><p id="62ad" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">以下公式结果:组件=视图+效果(可选)+缩减器(可选)+依赖项(可选)。典型组件如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mi"><img src="../Images/de3a049fd19276c137b1c1a973051074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gcv8EH7OwTddCXSjtCGpOg.png"/></div></div></figure><p id="b476" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">通过组件的抽象，实现了完全的划分、多纬度的重用和更好的解耦。</p><h2 id="03c8" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">适配器层</h2><p id="6c5a" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">适配器也是一个用于本地表示和功能的包。它是为 ListView 的高性能场景创建的，是组件实现中的一个变化，旨在解决组件模型在 flutter-ListView 场景中面临的三个问题。</p><p id="6ce5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第一个问题是，在组件中放置“大单元格”意味着无法享受 ListView 代码的性能优化。</p><p id="85c2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">其次，组件不能区分出现/消失和初始化/释放。</p><p id="a345" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，效果的生命周期和视图之间的耦合不符合 ListView 场景中的直观预期。简而言之，我们需要的是本地表示和功能封装的抽象，从逻辑上来说是一个 ScrollView，从性能上来说是一个 ListView。这样一个单独的抽象层，只从它的实际效果来考虑。框架不用于页面，而是用于组件和组件+适配器基线性能比较。</p><p id="a8f7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">减速器是长寿命的，而效果的寿命是中等范围的，视图是短寿命的。持续测试用于进行比较，如以下 android 设备示例所示:</p><p id="b053" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在使用该框架之前，详细信息页面中的基线 FPS 为 52FPS。在只使用组件抽象的情况下使用框架，FPS 下降到 40 并遇到“大单元”陷阱。随着框架和适配器抽象的使用，FPS 上升到 53，这高于基线，并且有一个小的改进。</p><h1 id="1b11" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">词典</h1><p id="11e1" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Fish Redux 中推荐的目录结构如下所示:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/b039d4a011b55eb13c0de24e1d6467f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*G5Pun2V1FctaZ-YtNn776A.png"/></div></figure><p id="ea44" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">上层负责组装，下层负责实现。同时，提供了一个插件来快速填充。以下来自仙寓平台的场景提供了一个装配示例:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mk"><img src="../Images/b85d97d2a3d996ef981cd75407208012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztoLpHWakYOopNAw5sXOYg.png"/></div></div></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ml"><img src="../Images/3872e3e9a4562524f8f60dad747afa95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2l0prpuNfY_RtF6leJ_cAQ.png"/></div></div></figure><p id="bf6c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在这里，组件和其他组件之间以及组件和容器之间是完全独立的。</p><h1 id="3455" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">沟通机制</h1><p id="9e5a" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Fish Redux 的通信机制提供了适配器内部的组件通信和适配器之间的组件通信。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mm"><img src="../Images/d2eca00d33880d91359f47d7dd6e131b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxlLIzLqUAvT5z7vlYPGbw.png"/></div></div></figure><p id="fe29" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在上面，使用了具有优先处理的广播剪辑。发出的动作将首先被自处理，或者它将被广播到其他组件并被 Redux 处理。最后，组件内部和组件之间(父-子、子-父、兄弟-兄弟等)的所有通信请求都将通过一个简单、直观的分派来完成。</p><h1 id="dc5d" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">刷新机制</h1><p id="359b" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Fish Redux 的刷新机制同时提供了数据刷新和视图刷新。</p><h2 id="6bdb" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">数据刷新</h2><p id="0490" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">数据刷新包括本地数据修改和逐层数据复制。</p><p id="fa8f" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在本地数据修改中，逐层自动触发上层数据的浅层拷贝。这些数据对上层业务代码是透明的。</p><p id="41e5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">逐层数据复制一方面严格遵从 Redux 的数据修改，另一方面严格遵从数据驱动的表示。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mn"><img src="../Images/12254006be889e6e1edaa38842090cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_kUuB_4stTcqgrMttEGahA.png"/></div></div></figure><h2 id="f7e6" class="lr ku hu bd kv ls lt lu kz lv lw lx ld ke ly lz lf ki ma mb lh km mc md lj me dt translated">视图刷新</h2><p id="a1de" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">视图刷新将所有扁平化通知发送给所有组件，而组件通过 shouldUpdate 确定是否需要刷新。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mo"><img src="../Images/edb78bdc96ea546a11099146e7e270ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F5pSXuo33ZVIBt7nS_TxHA.png"/></div></div></figure><h1 id="d1a3" class="kt ku hu bd kv kw kx ky kz la lb lc ld ja le jb lf jd lg je lh jg li jh lj lk dt translated">Fish Redux 的主要优势</h1><p id="6732" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">Fish Redux 的第一个优点是通过 Redux 对数据进行集中的、可观察的管理，其中保留了 Redux 的所有原有优点。在 reducer 合并过程中，Redux 操作被转换成由框架自动完成，极大地简化了使用 Redux 的繁琐过程。</p><p id="471c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">其次，它擅长组件的划分管理。组件不仅作为视图的划分而存在，也作为数据的划分而存在。通过将复杂的页面和数据逐层划分，Fish redux 将这些划分为独立的小模块，实现团队内部的协作开发。</p><p id="8053" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第三，它提供了视图、效果和缩减器之间的隔离，将组件分成三个无状态的、不相关的功能。因为这些是无状态函数，所以它们更容易编写、调试、测试和维护。同时，这为组合、重用和创新带来了更大的可能性。</p><p id="9226" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第四，它提供了声明性配置程序集。组件和适配器通过自由配置组装，包括组件的视图、缩减器、效果和它所依赖的子关系。</p><p id="afc2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">第五，它提供了强大的可扩展性。核心框架维护它自己单独关心的三层核心焦点，同时为上层维护灵活的可扩展性。该框架没有一行打印的代码，但是数据流和组件的变化仍然可以通过标准的中间件观察到。除了框架的三个核心层，mixins 还可以通过“dart”添加到组件和适配器层，以灵活地增强其上层应用程序的定制和功能。此外，该框架连接到 SDK。SDK 和框架之间没有壁垒，由上层自由组装。</p><p id="94e3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，Fish Redux 简单易用，只需要大约 1000 行代码。在一些小的函数和汇编任务之后，代码运行完毕，然后就可以使用了。</p><p id="bbed" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">鱼 Redux 的价值在仙鱼的发展中得到了很好的展现。Fish Redux 提供了一个统一的应用程序框架，能够解决持续的困境。</p><p id="f799" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt"><strong class="jx hv">(Original article by Wu Jifeng 邬吉风)</strong></p></div><div class="ab cl mp mq hc mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hn ho hp hq hr"><h1 id="c0ca" class="kt ku hu bd kv kw mw ky kz la mx lc ld ja my jb lf jd mz je lh jg na jh lj lk dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph jv jw hu jx b jy ll iv ka kb lm iy kd ke ln kg kh ki lo kk kl km lp ko kp kq hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae ks" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">“阿里巴巴科技”</strong> </a>。推特:<a class="ae ks" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">【阿里巴巴技术】</strong> </a>。</p></div></div>    
</body>
</html>