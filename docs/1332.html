<html>
<head>
<title>Automate Your Workflow with Git Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Git 挂钩自动化您的工作流程</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/automate-your-workflow-with-git-hooks-fef5d9b2a58c#2019-02-25">https://medium.com/hackernoon/automate-your-workflow-with-git-hooks-fef5d9b2a58c#2019-02-25</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/12f96a2b4d83d29c15d76a7c9db1086d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1iDclyih0VroVGqzdewhA.png"/></div></div></figure><p id="4826" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Git 挂钩是最被低估的 git 特性之一，它有可能提高开发人员的工作效率。你有没有想过每次<code class="eh ka kb kc kd b">commit</code>或者<code class="eh ka kb kc kd b">push</code>的时候都要运行一个命令？幸运的是，这正是 git 挂钩所做的——它们是在 git 命令之前或之后运行的定制脚本，用于自动化手动任务。请继续阅读，了解 hooks 如何改进您的工作流程。</p><h1 id="8db6" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">为什么要使用 git 钩子？</h1><p id="08e2" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">在开始追求我自己的工作流程自动化之后，我开始了解 hooks。你看，不管是好是坏，我在代码中使用了<code class="eh ka kb kc kd b">FIXME:</code>注释来提醒自己重温一些东西。我通常的过程是在提交之前对“<code class="eh ka kb kc kd b">FIXME:</code>”进行全局搜索，但是我确信你已经看到了人为错误的大量空间。</p><p id="ba10" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">胡克斯来救我了。我能够创建一个简单的<em class="lh">预提交</em>钩子(代码在文章底部),它在我尝试提交的内容中寻找<code class="eh ka kb kc kd b">FIXME:</code>注释，如果有注释，就停止提交。</p><p id="2367" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果我<em class="lh">想让</em>提交其中一条评论，该怎么办？如果钩子变成了阻挡者，它很容易被超越。通过向命令提供<code class="eh ka kb kc kd b">--no-verify</code>参数(例如<code class="eh ka kb kc kd b">git push --no-verify</code>，相关的钩子将被完全跳过，允许命令继续。</p><blockquote class="li"><p id="33ed" class="lj lk hu bd ll lm ln lo lp lq lr jz ek translated">因为钩子很容易被跳过，如果你有一个<em class="ls">必须</em>执行的进程，那么最好使用构建管道。</p></blockquote><p id="8fec" class="pw-post-body-paragraph jc jd hu je b jf lt jh ji jj lu jl jm jn lv jp jq jr lw jt ju jv lx jx jy jz hn dt translated">总共有 17 个钩子——一些在命令之前执行，一些在命令之后执行。您可以使用钩子来强制提交消息长度，确保足够的测试覆盖率，防止秘密被提交，或者只是打印出有趣的 ASCII 艺术。</p><h1 id="481a" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">设置挂钩</h1><p id="8d48" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">挂钩可以通过两种方式设置——它们可以为机器上的每个回购运行，或者只在特定的回购中运行。这两种方法都有好处:</p><p id="c315" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">全局钩子</strong></p><p id="3132" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">git 2 . 9 . 0 版本中添加了全局钩子，可以为每个存储库执行。如果您有适用于您所交互的每个存储库的个人工作流，这些是一个很好的选择。Git 将自动在配置好的<code class="eh ka kb kc kd b">hooks</code>文件夹中寻找全局钩子，并调用它找到的任何钩子。</p><p id="cbc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">全局钩子的默认位置是:<code class="eh ka kb kc kd b">$GIT_DIR/hooks</code>。如果您想改变该文件夹的位置，您可以运行以下命令(用您想要的路径替换<code class="eh ka kb kc kd b">~/.githooks</code>):</p><figure class="ly lz ma mb fq iv"><div class="bz el l di"><div class="mc md l"/></div></figure><p id="5be0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">回购挂钩</strong></p><p id="90ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">回购挂钩只为它们所在的回购运行，如果存在相同类型的全局挂钩，将被跳过。这些钩子应该放在 repo 中的<code class="eh ka kb kc kd b">.git/hooks</code>目录中。如果你有专门针对某个项目的钩子，它们是一个很好的选择。</p><p id="4c34" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">请记住，您不能提交与您的回购挂钩—它们留在您的本地机器上。但是如果你仔细想想，使用钩子将会是一个安全噩梦。每当您克隆一个新的 repo 时，它可能会让潜在的攻击者在您不知情的情况下完全有权在您的机器上运行恶意脚本。</p><h1 id="560a" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">创建挂钩</h1><p id="2962" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">现在是有趣的部分。如上所述，您可以实现 17 个挂钩。我最喜欢的一些是:</p><ul class=""><li id="71c1" class="me mf hu je b jf jg jj jk jn mg jr mh jv mi jz mj mk ml mm dt translated"><strong class="je hv">预提交</strong>:在执行<code class="eh ka kb kc kd b">git commit</code>之前发生，可以阻止提交的发生。</li><li id="2c34" class="me mf hu je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated"><strong class="je hv">提交后</strong>:发生在<code class="eh ka kb kc kd b">git commit</code>之后，主要用于通知，因为它不会影响执行的结果。</li><li id="2b89" class="me mf hu je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated"><strong class="je hv">预推送</strong>:发生在<code class="eh ka kb kc kd b">git push</code>之前，可以阻止推送的发生。</li><li id="cf4e" class="me mf hu je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm dt translated"><strong class="je hv"> prepare-commit-msg </strong>:出现在<code class="eh ka kb kc kd b">git commit</code>之前，可以在提交消息应用之前对其进行编辑。</li></ul><p id="1cad" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建一个钩子就像创建一个与你希望实现的钩子同名的文件(例如<code class="eh ka kb kc kd b">.git/hooks/pre-commit</code>)并使其可执行(<code class="eh ka kb kc kd b">chmod +x pre-commit</code>)一样简单。← <em class="lh">可执行部分是关键，否则 git 会忽略文件继续前进。</em></p><p id="1a4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如上所述，如果钩子出现在操作之前<em class="lh">(如<code class="eh ka kb kc kd b">pre-commit</code>、<code class="eh ka kb kc kd b">pre-push</code>)，你有权力阻止命令的操作。要停止执行，钩子必须以非零状态退出(例如<code class="eh ka kb kc kd b">exit 1</code>)。否则，你可以自由地记录信息，或者做任何你想做的事情。</em></p><h1 id="0cf5" class="ke kf hu bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">挂钩示例</h1><p id="b996" class="pw-post-body-paragraph jc jd hu je b jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv lg jx jy jz hn dt translated">总而言之，我向您展示我创建的 shell 脚本，以解决本文开头的<code class="eh ka kb kc kd b">FIXME:</code>困境。任何语言都可以用来编写钩子，但是 Shell 和 Python 是常见的选择。</p><p id="7191" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您想重新使用这个脚本来搜索不应该提交的不同字符串，那么您可以修改<code class="eh ka kb kc kd b">SEARCH_TERM</code>变量来查找传入提交中的任何子字符串。</p><figure class="ly lz ma mb fq iv"><div class="bz el l di"><div class="mc md l"/></div></figure></div><div class="ab cl ms mt hc mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hn ho hp hq hr"><p id="a693" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你认为 git 挂钩对你的工作流有用吗？欢迎在下面的评论中分享你正在使用的钩子。</p><p id="8e9b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你觉得这篇文章很有帮助，并希望看到更多类似的文章，请留下一些掌声让我知道。👏</p></div></div>    
</body>
</html>