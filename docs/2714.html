<html>
<head>
<title>Implementing Different Variants of Gradient Descent Optimization Algorithm in Python using Numpy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Numpy 在 Python 中实现梯度下降优化算法的不同变体</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/implementing-different-variants-of-gradient-descent-optimization-algorithm-in-python-using-numpy-809e7ab3bab4#2019-04-27">https://medium.com/hackernoon/implementing-different-variants-of-gradient-descent-optimization-algorithm-in-python-using-numpy-809e7ab3bab4#2019-04-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><h2 id="8a75" class="hs ht hu bd b gc hv hw hx hy hz ia ek ib translated" aria-label="kicker paragraph"><a class="ae gr" rel="noopener" href="https://medium.com/towards-data-science/in-depth-analysis/home">深入分析</a></h2><div class=""/><div class=""><h2 id="4b3f" class="pw-subtitle-paragraph ja id hu bd b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ek translated">了解 tensorflow 或 pytorch 如何使用 numpy 实现优化算法，并使用 matplotlib 创建漂亮的动画</h2></div><p id="8b8c" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在这篇文章中，我们将讨论如何实现梯度下降优化技术的不同变体，并使用 matplotlib 可视化这些变体的更新规则的工作。这是我之前关于<a class="ae ko" href="https://hackernoon.com/demystifying-different-variants-of-gradient-descent-optimization-algorithm-19ae9ba2e9bc" rel="noopener ugc nofollow" target="_blank">优化算法</a>的帖子的后续。</p><blockquote class="kp kq kr"><p id="ce4a" class="js jt ks ju b jv jw je jx jy jz jh ka kt kc kd ke ku kg kh ki kv kk kl km kn hn dt translated">引用说明:本文的内容和结构基于四分之一实验室——<a class="ae ko" href="https://padhai.onefourthlabs.in" rel="noopener ugc nofollow" target="_blank">Padh</a>AI 的深度学习讲座。</p></blockquote><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff kw"><img src="../Images/ebbf670f6e4a5b7ab29a51a98b1144c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ruyuUc2JYab5JS9CwLJ4A.png"/></div></div></figure><p id="ef8b" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">梯度下降是优化神经网络最常用的优化技术之一。梯度下降算法通过相对于网络参数在与目标函数的梯度相反的方向上移动来更新参数。</p><div class="li lj fm fo lk ll"><a href="https://hackernoon.com/demystifying-different-variants-of-gradient-descent-optimization-algorithm-19ae9ba2e9bc" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd ie fv z el lq eo ep lr er et id dt translated">揭秘梯度下降优化算法的不同变体</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">了解对梯度下降的不同改进，并使用 2D 等高线图比较它们的更新规则。</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">hackernoon.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz lg ll"/></div></div></a></div><h1 id="9d6f" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">使用 Numpy 在 Python 中实现</h1><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff ms"><img src="../Images/fa757abed7ffdf9da2efd7d1943b3cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aw0LaUsoYXplWTc2"/></div></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Photo by <a class="ae ko" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Gower</a> on <a class="ae ko" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="393d" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在编码部分，我们将涉及以下主题。</p><ul class=""><li id="0429" class="mx my hu ju b jv jw jy jz kb mz kf na kj nb kn nc nd ne nf dt translated"><strong class="ju ie">乙状结肠神经元类</strong></li><li id="d3d8" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie">整体设置—什么是数据、模型、任务</strong></li><li id="dda6" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie">绘图功能— 3D &amp;等高线图</strong></li><li id="8e07" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie">单个算法及其执行方式</strong></li></ul><p id="5222" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">单独的算法包括，</p><ul class=""><li id="9787" class="mx my hu ju b jv jw jy jz kb mz kf na kj nb kn nc nd ne nf dt translated"><strong class="ju ie">批量梯度下降</strong></li><li id="08bf" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie">气势 GD </strong></li><li id="e856" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie">内斯特罗夫加速 GD </strong></li><li id="0f6a" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie">小批量和随机 GD </strong></li><li id="5b3b" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated">阿达格拉德 GD </li><li id="04e6" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie"> RMSProp GD </strong></li><li id="e1e1" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><strong class="ju ie">亚当 GD </strong></li></ul><p id="553e" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">如果你想跳过理论部分，直接进入代码，</p><div class="li lj fm fo lk ll"><a href="https://github.com/Niranjankumar-c/GradientDescent_Implementation" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd ie fv z el lq eo ep lr er et id dt translated">niranjankumar-c/GradientDescent _ 实现</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">使用 numpy-Niranjankumar-c/GradientDescent _ Implementation 在 python 中实现梯度下降的不同变体</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">github.com</p></div></div><div class="lu l"><div class="nl l lw lx ly lu lz lg ll"/></div></div></a></div><p id="a138" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在我们开始实现梯度下降之前，首先我们需要导入所需的库。我们正在从<code class="eh nm nn no np b">mpl_toolkits.mplot3d</code>导入<code class="eh nm nn no np b">Axes3D</code>提供一些基本的 3D 绘图(散点，表面，线条，网格)工具。不是最快或功能最全的 3D 库，但它附带了 Matplotlib。我们还从 matplotlib 导入了<code class="eh nm nn no np b">colors</code>和<code class="eh nm nn no np b">colormap(cm)</code>。我们希望有动画图来展示每个优化算法是如何工作的，所以我们正在导入<code class="eh nm nn no np b">animation</code>和<code class="eh nm nn no np b">rc</code>来使图形看起来更好。在 jupyter 笔记本导入<code class="eh nm nn no np b">HTML</code>中内联显示/呈现 HTML 内容。最后，导入<code class="eh nm nn no np b">numpy</code>用于计算目的，这是我们最繁重的工作。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><h1 id="0f7a" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">乙状结肠神经元实现</h1><p id="0f4c" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">为了实现梯度下降优化技术，我们将采用 sigmoid 神经元(逻辑函数)的简单情况，并查看梯度下降的不同变体如何学习参数'<strong class="ju ie"> w </strong>和'<strong class="ju ie"> b </strong>'。</p><h2 id="35f4" class="nx mb hu bd mc ny nz oa mg ob oc od mk kb oe of mm kf og oh mo kj oi oj mq ia dt translated">乙状结肠神经元概述</h2><p id="1c0f" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">一个 sigmoid 神经元类似于感知器神经元，对于每个输入<code class="eh nm nn no np b">xi</code>，它都有与该输入相关联的权重<code class="eh nm nn no np b">wi</code>。权重表明决策过程中输入的重要性。与感知器模型不同，sigmoid 的输出不是 0 或 1，而是 0-1 之间的真实值，可以解释为概率。最常用的 sigmoid 函数是逻辑函数，它具有“<strong class="ju ie"> S </strong>形曲线的特征。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/55096c9f08a702529cac584e0deafb49.png" data-original-src="https://miro.medium.com/v2/format:webp/1*N7dfPwbiXC-Kk4TCbfRerA.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Sigmoid Neuron Representation (logistic function)</figcaption></figure><h2 id="220d" class="nx mb hu bd mc ny nz oa mg ob oc od mk kb oe of mm kf og oh mo kj oi oj mq ia dt translated">学习算法</h2><p id="f30f" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">学习算法的目标是确定参数(<strong class="ju ie"> w </strong>和<strong class="ju ie"> b </strong>)的最佳可能值，使得模型的总损失(平方误差损失)尽可能最小。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/506613cc4f1547ad02a8fca85cecef1e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fBxEzbzP1KkqR7PTexJZdw.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Learning Algorithm</figcaption></figure><p id="78ee" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">我们随机初始化<strong class="ju ie"> w </strong>和<strong class="ju ie"> b </strong>。然后，我们迭代数据中的所有观察值，对于每个观察值，使用 sigmoid 函数找到相应的预测结果，并计算均方误差损失。基于损失值，我们将更新权重，使得模型在新参数下的总损失将比模型的当前损失小<strong class="ju ie">。</strong></p><p id="67ff" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">要理解梯度下降优化技术背后的数学原理，请浏览我以前关于 sigmoid 神经元学习算法的文章——链接在本文末尾。</p><h2 id="b6da" class="nx mb hu bd mc ny nz oa mg ob oc od mk kb oe of mm kf og oh mo kj oi oj mq ia dt translated">乙状结肠神经元类</h2><p id="b4e2" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">在我们开始分析梯度下降算法的不同变体之前，我们将在一个名为<em class="ks"> SN 的类中构建我们的模型。</em></p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><p id="0c63" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在<code class="eh nm nn no np b">SN</code>类中，我们有 7 个函数，我将一个接一个地向你介绍这些函数，并解释它们在做什么。</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="37c1" class="nx mb hu np b fv op oq l or os">#constructor  <br/>def __init__(self, w_init, b_init, algo):    <br/>    self.w = w_init    <br/>    self.b = b_init    <br/>    self.w_h = []    <br/>    self.b_h = []    <br/>    self.e_h = []    <br/>    self.algo = algo</span></pre><p id="13e6" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated"><code class="eh nm nn no np b">__init__</code>函数(构造函数)帮助初始化 sigmoid 神经元<strong class="ju ie"> w </strong>权重和<strong class="ju ie"> b </strong>偏差的参数。该函数有三个参数，</p><ul class=""><li id="44f4" class="mx my hu ju b jv jw jy jz kb mz kf na kj nb kn nc nd ne nf dt translated"><code class="eh nm nn no np b">w_init,b_init</code> —这些参数采用参数'<strong class="ju ie"> w </strong>'和'<strong class="ju ie"> b </strong>'的初始值，而不是随机设置参数，我们将其设置为特定值。这使我们能够通过可视化不同的初始点来理解算法是如何执行的。一些算法在某些参数上陷入局部极小值。</li><li id="a49b" class="mx my hu ju b jv ng jy nh kb ni kf nj kj nk kn nc nd ne nf dt translated"><code class="eh nm nn no np b">algo</code> —告知使用哪种梯度下降算法来寻找最佳参数。</li></ul><p id="cdd0" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在此函数中，我们初始化参数，并定义了三个新的数组变量，后缀为“_h ”,表示它们是历史变量，以跟踪 sigmoid 神经元学习参数时权重(w_h)、偏差(b_h)和误差(e_h)值如何变化。</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="1f4e" class="nx mb hu np b fv op oq l or os">def sigmoid(self, x, w=None, b=None):<br/>    if w is None:<br/>      w = self.w<br/>    if b is None:<br/>      b = self.b<br/>    return 1. / (1. + np.exp(-(w*x + b)))</span></pre><p id="b087" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">我们有<code class="eh nm nn no np b">sigmoid</code>函数，它接受输入<strong class="ju ie"> x — </strong>强制参数，并计算输入的逻辑函数和参数。该函数还接受另外两个可选参数。</p><ul class=""><li id="db2c" class="mx my hu ju b jv jw jy jz kb mz kf na kj nb kn nc nd ne nf dt translated"><code class="eh nm nn no np b">w &amp; b</code>—通过将“<strong class="ju ie"> w </strong>”和“<strong class="ju ie"> b </strong>”作为参数，它帮助我们计算特定参数值下的 sigmoid 函数值。如果这些参数没有通过，它将采用学习参数的值来计算逻辑函数。</li></ul><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="d551" class="nx mb hu np b fv op oq l or os">def error(self, X, Y, w=None, b=None):<br/>    if w is None:<br/>      w = self.w<br/>    if b is None:<br/>      b = self.b<br/>    err = 0<br/>    for x, y in zip(X, Y):<br/>      err += 0.5 * (self.sigmoid(x, w, b) - y) ** 2<br/>    return err</span></pre><p id="6d6f" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">接下来，我们有<code class="eh nm nn no np b">error</code>函数，它将输入<strong class="ju ie"> X </strong>和<strong class="ju ie"> Y </strong>作为强制参数和可选参数，就像在<code class="eh nm nn no np b">sigmoid</code>函数中一样。在这个函数中，我们遍历每个数据点，并使用 sigmoid 函数计算实际特征值和预测特征值之间的累积均方误差。就像我们在<code class="eh nm nn no np b">sigmoid</code>函数中看到的，它支持计算指定参数值的误差。</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="5aa3" class="nx mb hu np b fv op oq l or os">def grad_w(self, x, y, w=None, b=None):<br/>   .....</span><span id="ce69" class="nx mb hu np b fv ot oq l or os">def grad_b(self, x, y, w=None, b=None):<br/>   .....</span></pre><p id="243b" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">接下来，我们将定义两个函数<code class="eh nm nn no np b">grad_w</code>和<code class="eh nm nn no np b">grad_b</code>，将输入“<strong class="ju ie"> x </strong>和“<strong class="ju ie"> y </strong>”作为强制参数，这有助于分别计算参数“<strong class="ju ie"> w </strong>”和“<strong class="ju ie"> b </strong>”相对于输入的 sigmoid 的梯度。同样，我们有两个可选参数，允许我们计算指定参数值的梯度。</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="b4af" class="nx mb hu np b fv op oq l or os">def fit(self, X, Y, epochs=100, eta=0.01, gamma=0.9, mini_batch_size=100, eps=1e-8,beta=0.9, beta1=0.9, beta2=0.9):<br/>    self.w_h = []<br/>    .......</span></pre><p id="7f98" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">接下来，我们定义“fit”方法，该方法接受输入“<strong class="ju ie"> X </strong>”、“<strong class="ju ie"> Y </strong>”和一系列其他参数。每当它被用于梯度下降算法的特定变体时，我将解释这些参数。该功能首先初始化历史变量，并设置本地输入变量以存储输入参数数据。</p><p id="b012" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">然后，我们为它支持的每个算法准备了一堆不同的“if-else”语句。根据我们选择的算法，我们将在<code class="eh nm nn no np b">fit</code>函数中实现梯度下降。我将在本文的后面部分详细解释这些实现。</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="d048" class="nx mb hu np b fv op oq l or os">def append_log(self):<br/>    self.w_h.append(self.w)<br/>    self.b_h.append(self.b)<br/>    self.e_h.append(self.error(self.X, self.Y))</span></pre><p id="07c7" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">最后，我们使用<code class="eh nm nn no np b">append_log</code>函数来存储梯度下降的每个变量中每个时期的参数值和损失函数值。</p><h1 id="5b6d" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">为打印设置</h1><p id="ece1" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">在本节中，我们将使用一个简单的 2D 玩具数据集定义一些配置参数来模拟梯度下降更新规则。我们还定义了一些函数来创建 3D 和 2D 图并制作动画，以可视化更新规则的工作。这种设置有助于我们使用不同的起点、不同的超参数设置以及梯度下降的不同变量的绘图/动画更新规则来运行不同的实验。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><p id="333e" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">首先，我们取一个简单的 2D 玩具数据集，它有两个输入和两个输出。在第 5 行，我们定义了一个字符串变量<code class="eh nm nn no np b">algo</code>，它接受我们想要执行的算法类型。我们初始化第 6 — 7 行中的参数'<strong class="ju ie"> w </strong>和'<strong class="ju ie"> b </strong>'，以指示算法开始的位置。</p><p id="d6bb" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">从第 9 行到第 12 行，我们正在设置参数的限制，即 sigmoid neuron 在指定范围内搜索最佳参数的范围。这些数字被特别选择来说明工作梯度下降更新规则。接下来，我们设置超参数的值，一些变量将特定于一些算法，当我们讨论算法的实现时，我将讨论它们。最后，在第 19–22 行，我们声明了动画或绘制更新规则所需的变量。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><p id="8fb6" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">一旦我们设置了配置参数，我们将初始化我们的<em class="ks"> SN </em>类，然后使用配置参数调用 fit 方法。我们还绘制了三个历史变量，以显示参数和损失函数值在不同时期的变化。</p><h1 id="f138" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">3D 和 2D 绘图设置</h1><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><p id="0079" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">为了首先创建 3D 绘图，我们通过在'<strong class="ju ie"> w </strong>和'<strong class="ju ie"> b </strong>'的最小值和最大值之间创建 256 个等距值来创建网格，如第 2–5 行所示。使用 mesh grid 将通过调用 sigmoid 类<code class="eh nm nn no np b">SN</code>中的<code class="eh nm nn no np b">error</code>函数来计算这些值的误差(第 5 行)。在第 8 行，我们创建一个轴句柄来创建一个 3D 绘图。</p><p id="9189" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">为了创建一个 3D 图，我们使用<code class="eh nm nn no np b">ax.plot_surface</code>功能，通过设置<code class="eh nm nn no np b">rstride</code>和<code class="eh nm nn no np b">cstride</code>来指定我们想要采样点和数据的频率，从而创建一个关于重量和偏差的误差的表面图。接下来，我们通过将误差值指定为“Z”方向(第 9-10 行),使用<code class="eh nm nn no np b">ax.contourf</code>函数在表面顶部绘制相对于重量和偏差的误差轮廓。在第 11–16 行，我们设置了每个轴的标签和所有三个维度的轴限制。因为我们正在绘制 3D 图，所以我们需要定义视点。在第 17–18 行中，我们在“z”轴的 25 度仰角和 12 个单位的距离处为我们的绘图设置了一个视点。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><p id="0f57" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在我们的静态 3D 图的顶部，我们想要可视化算法正在动态地做什么，这是由我们算法的每个时期的参数和误差函数的历史变量捕获的。为了创建我们的梯度下降算法的动画，我们将通过传递我们的自定义函数<code class="eh nm nn no np b">plot_animate_3d</code>作为参数之一来使用<code class="eh nm nn no np b">animation.FuncAnimation</code>函数，并指定创建动画所需的帧数。函数<code class="eh nm nn no np b">plot_animate_3d</code>更新‘w’和‘b’各自的参数值和误差值。在第 7 行的同一个函数中，我们设置文本来显示特定时期的误差值。最后，为了以内联方式显示动画，我们调用<code class="eh nm nn no np b">rc</code>函数来呈现 jupyter 笔记本中的 HTML 内容。</p><p id="3a10" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">与 3D 绘图类似，我们可以创建一个函数来绘制 2D 等值线图。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><h1 id="0e68" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">算法实现</h1><p id="f733" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">在这一节中，我们将实现梯度下降算法的不同变体，并生成 3D 和 2D 动画情节。</p><h1 id="c942" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">香草梯度下降</h1><p id="69e0" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">梯度下降算法通过相对于网络参数在与目标函数的梯度相反的方向上移动来更新参数。</p><p id="8d9a" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">参数更新规则将由下式给出:</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/662579c7f651a351e8964b68953b2017.png" data-original-src="https://miro.medium.com/v2/format:webp/1*232NNP054vumijGc3BFpVQ.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Gradient Descent Update Rule</figcaption></figure><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="bb8f" class="nx mb hu np b fv op oq l or os">for i in range(epochs):<br/>        dw, db = 0, 0<br/>        for x, y in zip(X, Y):<br/>          dw += self.grad_w(x, y)<br/>          db += self.grad_b(x, y)<br/>        self.w -= eta * dw / X.shape[0]<br/>        self.b -= eta * db / X.shape[0]<br/>        self.append_log()</span></pre><p id="7632" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在批量梯度下降中，我们迭代所有训练数据点，并计算参数‘w’和‘b’的梯度累积和。然后根据累积梯度值和学习率更新参数值。</p><p id="114e" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">要执行梯度下降算法，请按如下所示更改配置设置。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="nq nr l"/></div></figure><p id="6e6c" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在配置设置中，我们将变量<code class="eh nm nn no np b">algo</code>设置为‘GD ’,以指示我们想要在我们的 sigmoid 神经元中执行普通梯度下降算法，以找到最佳参数值。在我们设置好配置参数之后，我们将继续执行<em class="ks">SN</em>class‘fit’方法来训练玩具数据上的 sigmoid neuron。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="fe ff ou"><img src="../Images/b5120e3f400e3a9d13d1272f6a13c98e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*x3LrbdTxRMVQTQeVamSZwQ.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Gradient Descent History</figcaption></figure><p id="27ca" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">上图显示了算法学习最佳参数时，误差、权重和偏差的历史值在不同时期的变化情况。从图中要注意的重要一点是，在初始时期误差值徘徊在接近 0.5，但是在 200 个时期之后，误差值几乎达到零。</p><p id="c862" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">如果你想绘制 3D 或 2D 动画，你可以设置布尔变量<code class="eh nm nn no np b">plot_2d</code>和<code class="eh nm nn no np b">plot_3d</code>。我将展示对于'<strong class="ju ie"> w </strong>'和'<strong class="ju ie"> b </strong>'的相应值，3D 误差表面将会是什么样子。学习算法的目标是向误差/损失最小的深蓝色区域移动。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff ov"><img src="../Images/074558eee166154e32d5af61395bab14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWnx8H-I2n4uVHz3AgD1tg.png"/></div></div></figure><p id="d71e" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">为了可视化算法动态地做什么，我们可以使用函数<code class="eh nm nn no np b">plot_animate_3d</code>生成一个动画。播放动画时，您可以看到纪元编号和该纪元的相应误差值。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff ow"><img src="../Images/e471512602e8d679bae9ce1f8597c9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mINB8h-ifWiQgfWY42b_YA.gif"/></div></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Gradient Descent Animation</figcaption></figure><p id="32b7" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">如果你想减慢动画的速度，你可以点击视频控件中的减号，如上图所示。类似地，您可以为 2D 等高线图生成动画，以查看算法如何向全局最小值移动。</p><h1 id="f918" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">基于动量的梯度下降</h1><p id="224e" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">在动量 GD 中，我们以先前梯度和当前梯度的指数衰减累积平均值移动。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/e20f888805c0b9d38f90e251576b101a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*CfP-qLaE7BPjboCPMdoGrA.png"/></div></figure><p id="ca0d" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">动量 GD 的代码在下面给出，</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="c71f" class="nx mb hu np b fv op oq l or os">v_w, v_b = 0, 0<br/>for i in range(epochs):<br/>  dw, db = 0, 0<br/> for x, y in zip(X, Y):<br/>   dw += self.grad_w(x, y)<br/>   db += self.grad_b(x, y)<br/> v_w = gamma * v_w + eta * dw <br/> v_b = gamma * v_b + eta * db<br/> self.w = self.w - v_w<br/> self.b = self.b - v_b<br/> self.append_log()</span></pre><p id="2725" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在基于动量的 GD 中，我们已经包括了历史变量来跟踪先前梯度的值。变量 gamma 表示我们需要赋予算法多少动量。变量<code class="eh nm nn no np b">v_w</code>和<code class="eh nm nn no np b">v_b</code>将用于基于历史和当前梯度计算梯度的移动。在每个时期结束时，我们调用<code class="eh nm nn no np b">append_log</code>函数来存储参数和损失函数值的历史。</p><p id="4737" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">为了对我们的 sigmoid 神经元执行 Momentum GD，您需要对配置设置做一些修改，如下所示，</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="a95b" class="nx mb hu np b fv op oq l or os">X = np.asarray([0.5, 2.5])<br/>Y = np.asarray([0.2, 0.9])</span><span id="d8cb" class="nx mb hu np b fv ot oq l or os">algo = 'Momentum'</span><span id="c94d" class="nx mb hu np b fv ot oq l or os">w_init = -2<br/>b_init = -2</span><span id="ec11" class="nx mb hu np b fv ot oq l or os">w_min = -7<br/>w_max = 5</span><span id="6188" class="nx mb hu np b fv ot oq l or os">b_min = -7<br/>b_max = 5</span><span id="39f3" class="nx mb hu np b fv ot oq l or os">epochs = 1000<br/>mini_batch_size = 6<br/>gamma = 0.9<br/>eta = 1</span><span id="91b5" class="nx mb hu np b fv ot oq l or os">animation_frames = 20</span><span id="c92d" class="nx mb hu np b fv ot oq l or os">plot_2d = True<br/>plot_3d = True</span></pre><p id="352e" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">变量<code class="eh nm nn no np b">algo</code>被设置为“动量”,以指示我们想要使用动量 GD 来为我们的乙状结肠神经元找到最佳参数，另一个重要的变化是<code class="eh nm nn no np b">gamma</code>变量，它用于控制我们需要向学习算法传递多少动量。伽玛值在 0-1 之间变化。在我们设置好配置参数之后，我们将继续执行<em class="ks">SN</em>class‘fit’方法来训练玩具数据上的 sigmoid neuron。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="fe ff ox"><img src="../Images/73c69a24e9b034fd31bcb93e0205620b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*lxATc_k0UtjC_va5s5kyIw.png"/></div></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Variation for Momentum GD</figcaption></figure><p id="dc1c" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">从图中，我们可以看到，由于累积的历史动量 GD 在极小值内外振荡，所以权重和偏置项的值有很多振荡。</p><h1 id="2d7c" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">内斯特罗夫加速梯度下降</h1><p id="4368" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">在内斯特罗夫加速梯度下降中，我们期待在基于当前梯度值采取另一步骤之前看到我们是否接近最小值，以便我们可以避免超调的问题。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/72d17bf8d949a540f28ff3325cdbe732.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EyCpeHyZf4H_kixkXgcCRg.png"/></div></figure><p id="96b0" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">动量 GD 的代码在下面给出，</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="ad3c" class="nx mb hu np b fv op oq l or os">v_w, v_b = 0, 0<br/>for i in range(epochs):<br/>  dw, db = 0, 0<br/> v_w = gamma * v_w<br/> v_b = gamma * v_b<br/> for x, y in zip(X, Y):<br/>   dw += self.grad_w(x, y, self.w - v_w, self.b - v_b)<br/>   db += self.grad_b(x, y, self.w - v_w, self.b - v_b)<br/> v_w = v_w + eta * dw<br/> v_b = v_b + eta * db<br/> self.w = self.w - v_w<br/> self.b = self.b - v_b<br/> self.append_log()</span></pre><p id="8e99" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">NAG GD 代码的主要变化是<code class="eh nm nn no np b">v_w</code>和<code class="eh nm nn no np b">v_b</code>的计算。在动量 GD 中，我们一步计算这些变量，但是在 NAG 中，我们分两步计算。</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="9889" class="nx mb hu np b fv op oq l or os">v_w = gamma * v_w<br/>v_b = gamma * v_b<br/>for x, y in zip(X, Y):<br/>   dw += self.grad_w(x, y, self.w - v_w, self.b - v_b)<br/>   db += self.grad_b(x, y, self.w - v_w, self.b - v_b)<br/> v_w = v_w + eta * dw<br/> v_b = v_b + eta * db</span></pre><p id="ce06" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在第一部分中，在我们迭代数据之前，我们将伽马乘以我们的历史变量，然后通过使用从<code class="eh nm nn no np b">self.w</code>和<code class="eh nm nn no np b">self.b</code>减去的历史值计算梯度。为了执行 NAG GD，我们只需要将<code class="eh nm nn no np b">algo</code>变量设置为‘NAG’。您可以生成 3D 或 2D 动画来查看 NAG GD 在达到全局最小值方面与 Momentum GD 有何不同。</p><h1 id="42ab" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">小批量和随机梯度下降</h1><p id="c385" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">我们不是一次性查看所有数据点，而是将整个数据分成若干子集。对于每个数据子集，计算子集中每个点的导数，并更新参数。我们没有根据损失函数计算整个数据的导数，而是将其近似为更少的点或更小的批量。这种批量计算梯度的方法称为<strong class="ju ie">小批量梯度下降</strong></p><p id="aeaf" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">下面给出了小批量 GD 的代码，</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="8645" class="nx mb hu np b fv op oq l or os">for i in range(epochs):<br/>dw, db = 0, 0<br/>points_seen = 0<br/>for x, y in zip(X, Y):<br/>  dw += self.grad_w(x, y)<br/>  db += self.grad_b(x, y)<br/>  points_seen += 1<br/>  if points_seen % mini_batch_size == 0:<br/>     self.w -= eta * dw / mini_batch_size<br/>     self.b -= eta * db / mini_batch_size<br/>     self.append_log()<br/>     dw, db = 0, 0</span></pre><p id="0c12" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在 Mini Batch 中，我们循环遍历整个数据，并通过使用变量<code class="eh nm nn no np b">points_seen</code>跟踪我们看到的点数。如果看到的点的数量是小批量的倍数，那么我们正在更新乙状结肠神经元的参数。在特殊情况下，当小批量等于 1 时，就变成了随机梯度下降。为了执行小批量 GD，我们只需要将<code class="eh nm nn no np b">algo</code>变量设置为‘Mini Batch’。您可以生成 3D 或 2D 动画来查看小批量 GD 在达到全局最小值方面与动量 GD 有何不同。</p><h1 id="4bf9" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">阿达格拉德梯度下降</h1><p id="dced" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">AdaGrad 背后的主要动机是针对数据集中不同要素的自适应学习率的想法，即，我们可能需要针对不同要素的不同学习率，而不是针对数据集中的所有要素使用相同的学习率。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/efa4eff10e6cf43d6461b329c523735a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*zKXHX8zZhzX2ust-Ua9ICQ.png"/></div></figure><p id="7e27" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">阿达格拉德的代码如下所示，</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="6a68" class="nx mb hu np b fv op oq l or os">v_w, v_b = 0, 0<br/>for i in range(epochs):<br/> dw, db = 0, 0<br/> for x, y in zip(X, Y):<br/>   dw += self.grad_w(x, y)<br/>   db += self.grad_b(x, y)<br/> v_w += dw**2<br/> v_b += db**2<br/> self.w -= (eta / np.sqrt(v_w) + eps) * dw<br/> self.b -= (eta / np.sqrt(v_b) + eps) * db<br/> self.append_log()</span></pre><p id="686e" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在 Adagrad 中，我们保持梯度的运行平方和，然后通过将学习率除以历史值的平方根来更新参数。这里不是静态学习率，而是针对密集和稀疏特征的动态学习。生成图/动画的机制与上面相同。这里的想法是玩不同的玩具数据集和不同的超参数配置。</p><h1 id="5b3d" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">RMSProp 梯度下降</h1><p id="938a" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">与 AdaGrad 中的梯度总和不同，RMSProp 使用指数衰减平均值计算梯度历史，这有助于防止密集要素分母的快速增长。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/3e422be8640a90e0db6dac43655c2efe.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9v4BxT8pWHwJfbNXGqi7lQ.png"/></div></figure><p id="077d" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">RMSProp 的代码如下所示，</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="6331" class="nx mb hu np b fv op oq l or os">v_w, v_b = 0, 0<br/>for i in range(epochs):<br/> dw, db = 0, 0<br/> for x, y in zip(X, Y):<br/>   dw += self.grad_w(x, y)<br/>   db += self.grad_b(x, y)<br/> v_w = beta * v_w + (1 - beta) * dw**2<br/> v_b = beta * v_b + (1 - beta) * db**2<br/> self.w -= (eta / np.sqrt(v_w) + eps) * dw<br/> self.b -= (eta / np.sqrt(v_b) + eps) * db<br/> self.append_log()</span></pre><p id="0891" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">我们在 AdaGrad 代码中需要做的唯一改变是如何更新变量<code class="eh nm nn no np b">v_w</code>和<code class="eh nm nn no np b">v_b</code>。在 AdaGrad <code class="eh nm nn no np b">v_w</code>和<code class="eh nm nn no np b">v_b</code>中，从第一个历元开始，每个参数总是以梯度的平方递增，但是在 RMSProp <code class="eh nm nn no np b">v_w</code>和<code class="eh nm nn no np b">v_b</code>中，通过使用称为“伽马”的超参数，梯度的加权和呈指数衰减。要执行 RMSProp GD，我们只需要将<code class="eh nm nn no np b">algo</code>变量设置为‘rms prop’。您可以生成 3D 或 2D 动画来查看 RMSProp GD 在达到全局最小值方面与 AdaGrad GD 有何不同。</p><h1 id="7348" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">亚当梯度下降</h1><p id="f33b" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">Adam 维护了两个历史，'mₜ'类似于 Momentum GD 中使用的历史，'vₜ'类似于 RMSProp 中使用的历史。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/abbc33072b0c2e328f322c246c2dd43c.png" data-original-src="https://miro.medium.com/v2/format:webp/1*t4Y72jekWclyPpAENAIaAQ.png"/></div></figure><p id="3684" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">实际上，亚当做了一些被称为偏差修正的事情。它对'mₜ'和'vₜ'使用以下等式，</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="ab fr cl ok"><img src="../Images/1886f5e942b9237279837270adf661d9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*fOF5P0CWqI0yBWNrtngOxg.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Bias Correction</figcaption></figure><p id="83e4" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">偏差校正确保在训练更新开始时不会以奇怪的方式运行。Adam 中的关键点在于它结合了 Momentum GD(在平缓区域移动更快)和 RMSProp GD(调整学习速率)的优点。</p><p id="df1c" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">Adam GD 的代码如下所示，</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="e5ec" class="nx mb hu np b fv op oq l or os">v_w, v_b = 0, 0<br/>m_w, m_b = 0, 0<br/>num_updates = 0<br/>for i in range(epochs):<br/>dw, db = 0, 0<br/> for x, y in zip(X, Y):<br/>   dw = self.grad_w(x, y)<br/>   db = self.grad_b(x, y)<br/>   num_updates += 1<br/>   m_w = beta1 * m_w + (1-beta1) * dw<br/>   m_b = beta1 * m_b + (1-beta1) * db<br/>   v_w = beta2 * v_w + (1-beta2) * dw**2<br/>   v_b = beta2 * v_b + (1-beta2) * db**2<br/>   m_w_c = m_w / (1 - np.power(beta1, num_updates))<br/>   m_b_c = m_b / (1 - np.power(beta1, num_updates))<br/>   v_w_c = v_w / (1 - np.power(beta2, num_updates))<br/>   v_b_c = v_b / (1 - np.power(beta2, num_updates))<br/>   self.w -= (eta / np.sqrt(v_w_c) + eps) * m_w_c<br/>   self.b -= (eta / np.sqrt(v_b_c) + eps) * m_b_c<br/>   self.append_log()</span></pre><p id="42ff" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在 Adam optimizer 中，我们计算<code class="eh nm nn no np b">m_w &amp; m_b</code>来跟踪动量历史，计算<code class="eh nm nn no np b">v_w &amp; v_b</code>来衰减分母，防止其快速增长，就像在 RMSProp 中一样。之后，我们对基于动量的历史变量和基于 RMSProp 的历史变量实施偏差校正。一旦我们计算出参数'<strong class="ju ie"> w </strong>和'<strong class="ju ie"> b </strong>'的修正值，我们将使用这些值来更新参数值。</p><p id="9f0d" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">要执行 Adam 梯度下降算法，请按如下所示更改配置设置。</p><pre class="kx ky kz la fq ol np om on aw oo dt"><span id="f6f1" class="nx mb hu np b fv op oq l or os">X = np.asarray([3.5, 0.35, 3.2, -2.0, 1.5, -0.5])<br/>Y = np.asarray([0.5, 0.50, 0.5,  0.5, 0.1,  0.3])</span><span id="a969" class="nx mb hu np b fv ot oq l or os">algo = 'Adam'</span><span id="8cb0" class="nx mb hu np b fv ot oq l or os">w_init = -6<br/>b_init = 4.0</span><span id="9106" class="nx mb hu np b fv ot oq l or os">w_min = -7<br/>w_max = 5</span><span id="0d4c" class="nx mb hu np b fv ot oq l or os">b_min = -7<br/>b_max = 5</span><span id="26e7" class="nx mb hu np b fv ot oq l or os">epochs = 200<br/>gamma = 0.9<br/>eta = 0.5<br/>eps = 1e-8</span><span id="4cc8" class="nx mb hu np b fv ot oq l or os">animation_frames = 20</span><span id="27d3" class="nx mb hu np b fv ot oq l or os">plot_2d = True<br/>plot_3d = False</span></pre><p id="5b9c" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">变量<code class="eh nm nn no np b">algo</code>被设置为‘Adam ’,以表明我们想要使用 Adam GD 来为我们的 sigmoid 神经元找到最佳参数，另一个重要的变化是<code class="eh nm nn no np b">gamma</code>变量，它用于控制我们需要向学习算法传递多少动量。伽玛值在 0-1 之间变化。在我们设置好配置参数后，我们将继续执行<em class="ks">SN</em>class‘fit’方法，根据 toy 数据训练 sigmoid neuron。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="fe ff oy"><img src="../Images/3a0523425fe18073156164728f25ecfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*xDpBYvwgOqTlurVNbHyd0g.png"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Variation of Parameters in Adam GD</figcaption></figure><p id="6059" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">我们还可以创建 2D 等高线图动画，显示亚当 GD 是如何学习全局极小值的路径。</p><figure class="kx ky kz la fq lb fe ff paragraph-image"><div class="fe ff oz"><img src="../Images/230233ab907db4cc345705f8b485d3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/1*g0LrZM3dxCFrOGR_N1Q5kA.gif"/></div><figcaption class="mt mu fg fe ff mv mw bd b be z ek">Adam GD Animation</figcaption></figure><p id="d44b" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">与 RMSProp 的情况不同，我们没有太多的振荡，而是更加确定地向最小值移动，尤其是在最初的几个时期之后。</p><p id="280a" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">这就结束了我们关于如何使用 Numpy 实现优化技术的讨论。</p><h1 id="a587" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">下一步是什么？</h1><blockquote class="pa"><p id="742d" class="pb pc hu bd pd pe pf pg ph pi pj kn ek translated">通过实践学习</p></blockquote><p id="85ce" class="pw-post-body-paragraph js jt hu ju b jv pk je jx jy pl jh ka kb pm kd ke kf pn kh ki kj po kl km kn hn dt translated">在本文中，我们已经看到了不同的静态初始化点的玩具数据集，但你可以做的是，采取不同的初始化点，对于这些初始化点的每一个，玩不同的算法，看看什么样的调整需要在超参数中完成。</p><p id="a7e8" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">本文中讨论的全部代码都在这个 GitHub 存储库中。随意叉或者下载。<strong class="ju ie">最棒的是，你可以直接运行 google colab 中的代码，不需要担心安装包</strong>。</p><div class="li lj fm fo lk ll"><a href="https://github.com/Niranjankumar-c/GradientDescent_Implementation" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd ie fv z el lq eo ep lr er et id dt translated">niranjankumar-c/GradientDescent _ 实现</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">使用 numpy-Niranjankumar-c/GradientDescent _ Implementation 在 python 中实现梯度下降的不同变体</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">github.com</p></div></div><div class="lu l"><div class="nl l lw lx ly lu lz lg ll"/></div></div></a></div><p id="7094" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated"><em class="ks"> PS:如果你有兴趣把代码转换成</em> <strong class="ju ie"> <em class="ks"> R，</em> </strong> <em class="ks">一旦完成就给我发消息。我会在这里和 GitHub 页面上展示你的作品。</em></p><h1 id="8142" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">结论</h1><p id="4100" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">在这篇文章中，我们看到了如何通过一个简单的 sigmoid 神经元来实现不同的梯度算法。此外，我们还看到了如何为每一种变体创建漂亮的 3D 或 2D 动画，展示学习算法如何找到最佳参数。</p><h1 id="8ac3" class="ma mb hu bd mc md me mf mg mh mi mj mk jj ml jk mm jm mn jn mo jp mp jq mq mr dt translated">下一步是什么？</h1><p id="22ca" class="pw-post-body-paragraph js jt hu ju b jv ns je jx jy nt jh ka kb nu kd ke kf nv kh ki kj nw kl km kn hn dt translated">反向传播是神经网络如何学习它们所学内容的支柱。如果你有兴趣了解更多关于神经网络的知识，请查看来自<a class="ae ko" href="https://courses.starttechacademy.com/full-site-access/?coupon=NKSTACAD" rel="noopener ugc nofollow" target="_blank"> Starttechacademy </a>的 Abhishek 和 Pukhraj 的<a class="ae ko" href="https://courses.starttechacademy.com/full-site-access/?coupon=NKSTACAD" rel="noopener ugc nofollow" target="_blank">人工神经网络</a>。本课程将使用最新版本的 Tensorflow 2.0 (Keras 后端)进行教学。</p></div><div class="ab cl pp pq hc pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="hn ho hp hq hr"><p id="0a8f" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated"><em class="ks">推荐阅读</em></p><div class="li lj fm fo lk ll"><a href="https://hackernoon.com/demystifying-different-variants-of-gradient-descent-optimization-algorithm-19ae9ba2e9bc" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd ie fv z el lq eo ep lr er et id dt translated">揭秘梯度下降优化算法的不同变体</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">了解对梯度下降的不同改进，并使用 2D 等高线图比较它们的更新规则。</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">hackernoon.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz lg ll"/></div></div></a></div><div class="li lj fm fo lk ll"><a href="https://hackernoon.com/building-a-feedforward-neural-network-from-scratch-in-python-d3526457156b" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab ej"><div class="ln ab lo cl cj lp"><h2 class="bd ie fv z el lq eo ep lr er et id dt translated">用 Python 从头开始构建前馈神经网络</h2><div class="ls l"><h3 class="bd b fv z el lq eo ep lr er et ek translated">在没有任何框架的情况下，构建您的第一个通用前馈神经网络</h3></div><div class="lt l"><p class="bd b gc z el lq eo ep lr er et ek translated">hackernoon.com</p></div></div><div class="lu l"><div class="pw l lw lx ly lu lz lg ll"/></div></div></a></div><p id="aaa3" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">在我的下一篇文章中，我们将讨论不同的激活函数，如逻辑、ReLU、LeakyReLU 等，以及一些最好的初始化技术，如 Xavier 和 He 初始化。因此，请确保您跟随媒体上的<a class="ae ko" rel="noopener" href="/@niranjankumarc"> me </a>，以便在它下跌时得到通知。</p><p id="28e0" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">直到那时和平:)</p><p id="55cb" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">NK。</p></div><div class="ab cl pp pq hc pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="hn ho hp hq hr"><p id="64d8" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated">Niranjan Kumar 是汇丰银行分析部门的实习生。他对深度学习和人工智能充满热情。他是<a class="px py gr" href="https://medium.com/u/504c7870fdb6?source=post_page-----809e7ab3bab4--------------------------------" rel="noopener" target="_blank"> Medium </a>在<a class="ae ko" rel="noopener" href="/tag/artificial-intelligence/top-writers">人工智能</a>的顶尖作家之一。在<a class="ae ko" href="https://www.linkedin.com/in/niranjankumar-c/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，或者在<a class="ae ko" href="https://twitter.com/Nkumar_283" rel="noopener ugc nofollow" target="_blank"> twitter </a>上关注我，了解关于深度学习和人工智能的最新文章。</p><p id="ff3c" class="pw-post-body-paragraph js jt hu ju b jv jw je jx jy jz jh ka kb kc kd ke kf kg kh ki kj kk kl km kn hn dt translated"><strong class="ju ie">免责声明</strong> —这篇文章中可能有一些相关资源的附属链接。你可以以尽可能低的价格购买捆绑包。如果你购买这门课程，我会收到一小笔佣金。</p><figure class="kx ky kz la fq lb"><div class="bz el l di"><div class="pz nr l"/></div></figure></div></div>    
</body>
</html>