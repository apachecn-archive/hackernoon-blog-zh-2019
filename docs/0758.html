<html>
<head>
<title>Querying the Blockchain: Why The Graph Might Become One of the Important Protocols of the Web3 Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">质疑区块链:为什么图可能成为Web3栈的重要协议之一</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/querying-the-blockchain-why-the-graph-might-become-one-of-the-important-protocols-of-the-web3-eb77673bc967?source=collection_archive---------7-----------------------#2019-01-31">https://medium.com/hackernoon/querying-the-blockchain-why-the-graph-might-become-one-of-the-important-protocols-of-the-web3-eb77673bc967?source=collection_archive---------7-----------------------#2019-01-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c70989ec2782ecdb04a1a12e9e37a963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYROkY1Vo7QBGs63lq81uQ.png"/></div></div></figure><p id="d1e2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">数据访问在软件历史上的任何技术趋势中都扮演着重要的角色。数据库、搜索引擎或查询API等数据访问技术无处不在，以至于我们在设计软件解决方案时很少想到它们。随着Web 3.0、由区块链技术支持的分散式应用的发展，数据访问等基础设施块将变得更加重要。然而，解决区块链的数据访问已被证明是一项非常具有挑战性的工作，迫使开发人员花费大量时间编写基础设施代码。在市场上的Web3数据访问解决方案中，<a class="ae ka" href="https://thegraph.com/" rel="noopener ugc nofollow" target="_blank">Graph Protocol</a>是我特别喜欢的一个，因为它的简单性和对现代技术的巧妙利用。</p><p id="1226" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">几个月前，在我们的一个区块链实现中，我们偶然发现了<a class="ae ka" href="https://thegraph.com/" rel="noopener ugc nofollow" target="_blank">图</a>，从那以后我们一直在测试和跟踪这个项目。该图背后的主要思想是通过利用已有的数据访问协议(如GraphQL)使区块链数据可查询。虽然这种想法听起来在概念上微不足道，但其实现充满了不小的挑战。</p><h1 id="7ad5" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">查询区块链数据的挑战</h1><p id="ec35" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在软件行业的过去50年中，每一种技术趋势都经历了数据访问技术的改进，因为它们能够建立在以前趋势所创建的基础设施之上。从文件系统到最近的大数据运动，数据访问技术的生产周期越来越短，功能越来越复杂。随着区块链技术的出现，这种发展趋势完全改变了，因为与其他技术运动不同，区块链空间从存储和网络协议级别开始重新设想数据访问。从这个角度来看，以前技术发展中的大多数数据访问技术和最佳实践在应用到区块链时都不切实际。简单明了地说，Web 3.0应该有一个Web 3.0数据访问协议。</p><p id="9753" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">是什么让区块链数据访问如此具有挑战性？在我看来，这一挑战有三个根本原因:</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/14bcd6835f87f11e56e9577907cef62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKyYV8YF7QlurEzzlBI72w.png"/></div></div></figure><p id="cdf3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">去中心化:</strong>区块链的数据存在于一个去中心化的节点网络中，这些节点不断地在它们之间复制记录。从数据访问的角度来看，这种模型比集中式数据库基础设施复杂得多。</p><p id="85ca" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不透明:区块链的数据受到不同程度的加密和混淆，这使得数据很难解读。显然，查询协议的全部意义在于知道要查询什么属性，而这些信息在区块链堆栈中是不容易访问的。</p><p id="6afd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">顺序数据存储:</strong>区块链的数据是在事务中捕获的，存储在一个顺序的块组中。这种块事务数据结构提供了非常差的导航能力，而这正是实现可靠的数据查询协议所需要的。</p><p id="1ad9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对上述三个挑战的相反解释表明，一个健壮的Web 3.0数据访问堆栈应该具有三个主要功能:</p><p id="b4ef" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">I .访问信息的能力，就像信息存储在中央存储库中一样。</p><p id="220d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">二。基于属性查询记录的能力。</p><p id="7566" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">三。能够根据特定标准高效浏览区块链数据。</p><p id="0b33" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些挑战中的一些已经通过孤立的技术解决了，我们还没有一个一致的堆栈来将它们放在一起。</p><h1 id="352a" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">进入图表</h1><p id="dab9" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">从概念上讲，该图是一个用于索引和查询区块链数据的分散式协议。该图从创建描述区块链数据表示的清单开始。清单可以指定DApp的特定协议的属性。创建清单后，该图从特定协议或应用程序中捕获链上事件，并使用清单作为指导将它们索引到IPFS中。最后，数据由基于流行的<a class="ae ka" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>协议的API公开。图形端点将把GraphQL查询翻译成用于访问数据的IPFS命令。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lj"><img src="../Images/31111b8618afc8206cee5a064a51f2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*winrsB4vSk93rOL9ADONrg.png"/></div></div></figure><p id="bdeb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从体系结构的角度来看，该图基于以下组件:</p><ul class=""><li id="f16e" class="lk ll hu je b jf jg jj jk jn lm jr ln jv lo jz lp lq lr ls dt translated">Graph CLI:一个基于JavaScript的工具，允许开发人员定义描述区块链结构的子图，这些子图将被图形索引。子图由子图清单、模式和映射组成。子图清单指向要索引的数据源(例如智能合同)和任何解码信息(ABI)。描述如何转换或聚合数据的TypeScript函数。Graph CLI将所有这些编译到一个WASM模块中，该模块可以由Graph节点执行</li><li id="9340" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated"><strong class="je hv"> Postgres Store </strong>:基于Postgres的数据库，基于(实体、属性、值)元组将区块链数据存储并索引到特定的表中。该结构有效地映射到GraphQL语法。</li><li id="e542" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated"><strong class="je hv"> GraphQL服务器</strong>:graph QL API和堆栈其他组件的主机。</li><li id="3d5c" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated"><strong class="je hv">以太坊适配器</strong>:使用IPC或RPC订阅以太坊事件并访问智能合约存储的组件。</li><li id="aecb" class="lk ll hu je b jf lt jj lu jn lv jr lw jv lx jz lp lq lr ls dt translated"><strong class="je hv"> WASM运行时主机</strong>:执行映射以将区块链数据翻译成可索引和可查询的数据结构的模块。</li></ul><p id="68dd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了简单起见，跳过几个步骤，让我们来说明图协议是如何工作的。第一步是使用YAML语法定义子图清单，如下所示:</p><pre class="lf lg lh li fq ly lz ma mb aw mc dt"><span id="4008" class="md kc hu lz b fv me mf l mg mh">specVersion: 0.0.1<br/>schema:<br/>  file: ./schema.graphql<br/>dataSources:<br/>- kind: ethereum/contract<br/>  name: MyERC721Contract<br/>  source:<br/>    address: "0x06012c8cf97BEaD5deAe237070F9587f8E7A266d"<br/>    abi: ERC721<br/>  mapping:<br/>    kind: ethereum/events<br/>    apiVersion: 0.0.1<br/>    language: wasm/assemblyscript<br/>    entities:<br/>    - Token<br/>    abis:<br/>    - name: ERC721<br/>      file: ./abis/ERC721ABI.json<br/>    eventHandlers:<br/>    - event: Transfer(address,address,uint256)<br/>      handler: handleTransfer<br/>    file: ./mapping.ts</span></pre><p id="141b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从定义中可以看出，前面的子图捕获了特定智能合约(MyERC721Contract)的Transfer事件中的数据。要捕获的具体数据由合同ABI JSON文件定义:</p><pre class="lf lg lh li fq ly lz ma mb aw mc dt"><span id="806e" class="md kc hu lz b fv me mf l mg mh">[{<br/>    "anonymous": false,<br/>    "inputs": [<br/>      {<br/>        "indexed": true,<br/>        "name": "_from",<br/>        "type": "address"<br/>      },<br/>      {<br/>        "indexed": true,<br/>        "name": "_to",<br/>        "type": "address"<br/>      },<br/>      {<br/>        "indexed": true,<br/>        "name": "_tokenId",<br/>        "type": "uint256"<br/>      }<br/>    ],<br/>    "name": "Transfer",<br/>    "type": "event"<br/>  }]</span></pre><p id="7b3f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下一步是编写一个映射函数，根据特定的子图转换来自以太坊区块链的数据:</p><pre class="lf lg lh li fq ly lz ma mb aw mc dt"><span id="b613" class="md kc hu lz b fv me mf l mg mh">import { Transfer } from './types/abis/SomeContract'<br/><br/>// This is an example of an entity type generated from a<br/>// subgraph's GraphQL schema<br/>import { Token } from './types/schema'<br/><br/>export function handleTransfer(event: Transfer): void {<br/>    let tokenID = event.params.tokenID.toHex()<br/>    let token = new Token(tokenID)<br/>    token.currentOwner = event.params.to<br/><br/>    token.save()<br/>}</span></pre><p id="6e7e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此时，子图可以展开，我们可以开始监听以太坊区块链的事件。当前版本的图形支持使用Infura收集以太坊数据，托管本地以太坊节点或Ganache。以下代码启动一个图形节点，通过Infura API监听数据:</p><pre class="lf lg lh li fq ly lz ma mb aw mc dt"><span id="e0fc" class="md kc hu lz b fv me mf l mg mh">cargo run -p graph-node --release -- \<br/>  --postgres-url postgresql://&lt;USERNAME&gt;&lt;:PASSWORD&gt;@localhost:5432/&lt;POSTGRES_DB_NAME&gt; \<br/>  --ethereum-rpc &lt;ETHEREUM_NETWORK_NAME&gt;:https://mainnet.infura.io \<br/>  --ipfs 127.0.0.1:5001 \<br/>  --debug</span></pre><p id="b9f3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，我们可以使用典型的GraphQL语法来查询数据:</p><pre class="lf lg lh li fq ly lz ma mb aw mc dt"><span id="28f3" class="md kc hu lz b fv me mf l mg mh">{<br/>  tokens {<br/>    id<br/>    currentOwner<br/>  }<br/>}</span></pre><p id="2492" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">开发人员已经使用该图为流行的协议和DApps部署了子图。您可以看到他们中的许多人<a class="ae ka" href="https://thegraph.com/explorer/" rel="noopener ugc nofollow" target="_blank">使用图形浏览器</a>，它提供了一个灵活的用户界面来针对特定的智能合同或DApps执行GraphQL查询。</p><p id="930e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">该图是解决Web 3.0应用程序最重要的挑战之一的非常好的迭代。通过利用IPFS、Postgress或GraphQL等成熟技术，Graph降低了开发人员查询区块链数据的门槛。让事情变得更加令人兴奋的是，当前版本的图形<a class="ae ka" href="https://github.com/graphprotocol" rel="noopener ugc nofollow" target="_blank">最近被开源</a>，并且正在积极地版本化。尽管仍处于非常早期的阶段，但该图似乎已经具备了成为Web 3.0运动中最重要的协议之一的技术基础。</p></div></div>    
</body>
</html>