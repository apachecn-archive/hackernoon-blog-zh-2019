<html>
<head>
<title>How to FaaS like a pro: 12 less common ways to invoke your serverless functions on AWS [Part 1]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何像专家一样 FaaS:在 AWS 上调用无服务器函数的 12 种不常用方法[第 1 部分]</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-faas-like-a-pro-12-uncommon-ways-to-invoke-your-serverless-functions-on-aws-part-1-dca1078f0c80#2019-04-02">https://medium.com/hackernoon/how-to-faas-like-a-pro-12-uncommon-ways-to-invoke-your-serverless-functions-on-aws-part-1-dca1078f0c80#2019-04-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/71689f1f7161aa061aecf3793ba94e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqBI4iCRMqrHsC0LCSFO4g.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Yes, this is you at the end of this article, contemplating new possibilities! [Photo by <a class="ae jg" href="https://unsplash.com/photos/etsVKbvxhCc" rel="noopener ugc nofollow" target="_blank">Joshua Earle</a> on <a class="ae jg" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank">Unsplash</a>]</figcaption></figure></div><div class="ab cl jh ji hc jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hn ho hp hq hr"><p id="dd5b" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">如果您想跳过下面的简短介绍，您可以通过这些快捷链接直接跳到前四个触发器:</p><ol class=""><li id="5d4d" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl kr ks kt ku dt translated"><a class="ae jg" href="#42f2" rel="noopener ugc nofollow">亚马逊认知用户池</a> —用户管理&amp;定制工作流</li><li id="5a9e" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated"><a class="ae jg" href="#1741" rel="noopener ugc nofollow"> AWS 配置</a> —事件驱动的配置检查</li><li id="147c" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated"><a class="ae jg" href="#e008" rel="noopener ugc nofollow">亚马逊 Kinesis 数据消防软管</a> —数据摄取&amp;验证</li><li id="dace" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated"><a class="ae jg" href="#6835" rel="noopener ugc nofollow"> AWS CloudFormation </a> — IaC，宏&amp;自定义转换</li></ol></div><div class="ab cl jh ji hc jj" role="separator"><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm jn"/><span class="jk bw bk jl jm"/></div><div class="hn ho hp hq hr"><h2 id="4233" class="la lb hu bd lc ld le lf lg lh li lj lk jz ll lm ln kd lo lp lq kh lr ls lt lu dt translated">先讲一点历史</h2><p id="1c5f" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated">当 AWS Lambda <a class="ae jg" href="https://aws.amazon.com/it/blogs/compute/aws-lambda-is-generally-available/" rel="noopener ugc nofollow" target="_blank">于 2015 年 4 月 9 日正式发布时</a>，它成为了第一个功能即服务，除了直接调用之外，只有几种方式可以触发您的功能:亚马逊 S3、亚马逊 Kinesis 和亚马逊社交网络。三个月后，我们获得了 Amazon API 网关支持，这为 web 和 REST 兼容的客户端开启了一个全新的浪潮。</p><p id="fbaa" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">到 2015 年底，你已经可以通过亚马逊 DynamoDB 流、Kinesis 流、S3 对象、SNS 主题和 CloudWatch 事件(预定调用)触发功能。</p><p id="6505" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">就我个人而言，我在 2016 年初左右开始用 AWS Lambda <a class="ae jg" href="https://aws.amazon.com/it/blogs/aws/machine-learning-recommendation-systems-and-data-analysis-at-cloud-academy/" rel="noopener ugc nofollow" target="_blank">做一个简单的机器学习用例</a>的实验。几个月后，我发布了第一个关于我 Lambda 体验的视频，其中涵盖了当时所有可用的触发器和配置；嗯，视频仍然可以在这里<a class="ae jg" href="https://www.youtube.com/watch?v=NhGEik26324" rel="noopener ugc nofollow" target="_blank">获得</a>，但是 AWS 控制台现在已经非常不同了，所以我建议你只有在怀旧的时候才观看它=)</p><p id="3337" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><strong class="jq hv">回到历史… </strong></p><p id="07cf" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在接下来的几个月里，AWS Lambda 变得非常受欢迎，许多其他 AWS 服务开始集成它，并允许您以许多新的方式触发功能。这些集成非常适合处理/验证数据，以及定制和扩展这些服务的行为。</p><p id="e95e" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">你可能已经意识到(或者凭直觉猜测)AWS Lambda 是如何与诸如<a class="ae jg" href="https://docs.aws.amazon.com/en_us/lambda/latest/dg/invoking-lambda-function.html#supported-event-source-s3" rel="noopener ugc nofollow" target="_blank"> S3 </a>、<a class="ae jg" href="https://docs.aws.amazon.com/en_us/lambda/latest/dg/invoking-lambda-function.html#supported-event-source-dynamo-db" rel="noopener ugc nofollow" target="_blank"> DynamoDB </a>、<a class="ae jg" href="https://docs.aws.amazon.com/en_us/lambda/latest/dg/invoking-lambda-function.html#supported-event-source-kinesis-streams" rel="noopener ugc nofollow" target="_blank"> Kinesis 数据流</a>、<a class="ae jg" href="https://docs.aws.amazon.com/en_us/lambda/latest/dg/invoking-lambda-function.html#supported-event-source-ses" rel="noopener ugc nofollow" target="_blank"> SES </a>、<a class="ae jg" href="https://docs.aws.amazon.com/en_us/lambda/latest/dg/invoking-lambda-function.html#supported-event-source-sqs" rel="noopener ugc nofollow" target="_blank"> SQS </a>、<a class="ae jg" href="https://docs.aws.amazon.com/en_us/iot/latest/developerguide/iot-lambda-rule.html" rel="noopener ugc nofollow" target="_blank">物联网核心</a>、<a class="ae jg" href="https://docs.aws.amazon.com/en_us/step-functions/latest/dg/connectors-lambda.html" rel="noopener ugc nofollow" target="_blank">步骤功能</a>和<a class="ae jg" href="https://docs.aws.amazon.com/en_us/lambda/latest/dg/services-alb.html" rel="noopener ugc nofollow" target="_blank"> ALB </a>等服务集成的。有大量的文章和入门指南将这些集成作为无服务器之旅的良好起点。</p><p id="502c" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在本文中，我想与您分享一些其他不太常见、不太为人所知、甚至是更新的在 AWS 上调用 Lambda 函数的方法。其中一些集成甚至没有出现在官方的<a class="ae jg" href="https://docs.aws.amazon.com/en_us/lambda/latest/dg/invoking-lambda-function.html" rel="noopener ugc nofollow" target="_blank">支持的事件源</a>文档页面上，我相信它们值得一提和尝试。</p><p id="7a01" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">对于每个服务/集成，我将分享有用的链接、代码片段和云信息模板和参考。如果您认为缺少了什么，或者您需要更多的资源/细节，请随时在下面添加评论。即使你不懂 Python 或 JavaScript，代码也是不言自明的，并带有有用的注释。如果你有问题或疑问，请在本文底部发表评论。</p><p id="67cb" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们从 AWS Lambda 的前 4 个触发器开始。</p><h1 id="42f2" class="ma lb hu bd lc mb mc md lg me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq dt translated">1.Amazon Cognito 用户池(自定义工作流)</h1><p id="ef06" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated"><a class="ae jg" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> Cognito 用户池</a>允许您将<strong class="jq hv">认证和用户管理</strong>添加到您的应用程序中。借助 AWS Lambda，您可以<a class="ae jg" href="https://docs.aws.amazon.com/en_us/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html" rel="noopener ugc nofollow" target="_blank">定制您的用户池工作流</a>并在 Cognito 运行期间触发您的功能，以便定制您的用户池行为。</p><figure class="ms mt mu mv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff mr"><img src="../Images/956307a24e6bbafca96b36d1d7a1ccef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaalQzSye2VTOIhMfcJz6w.png"/></div></div></figure><p id="68be" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">以下是可用触发器的列表:</p><ul class=""><li id="a6e9" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated"><strong class="jq hv">预注册</strong> —在 Cognito 注册新用户(或管理员)之前触发，允许您执行自定义验证以接受/拒绝</li><li id="3788" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">发布确认</strong> —在新用户(或管理员)注册后触发，允许您发送自定义消息或添加自定义逻辑</li><li id="b5f2" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">预认证</strong> —当用户尝试登录并允许自定义验证接受/拒绝时触发</li><li id="7d2d" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">认证后</strong> —在用户登录后触发，允许您在认证后添加自定义逻辑</li><li id="286f" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">自定义认证</strong> —当您使用<a class="ae jg" href="https://docs.aws.amazon.com/en_us/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html#amazon-cognito-user-pools-custom-authentication-flow" rel="noopener ugc nofollow" target="_blank">自定义认证流程</a>时触发定义、创建和验证自定义质询</li><li id="3e74" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">预令牌生成</strong> —在每次令牌生成之前触发，允许您自定义身份令牌声明(例如，新密码和刷新令牌)</li><li id="6a4d" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">迁移用户</strong> —当用户在使用密码登录时不在用户池中或在忘记密码流中时触发</li><li id="68ff" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">自定义消息</strong> —在发送电子邮件、电话验证消息或 MFA 代码之前触发，允许您自定义消息</li></ul><p id="5ae2" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">所有这些触发器都允许您实现无状态逻辑，并使用您喜欢的编程语言个性化 Cognito 用户池的工作方式。请记住，您的函数是同步调用的，需要在 5 秒钟内完成，只需返回带有附加的<code class="eh mx my mz na b">response</code>属性的传入的<code class="eh mx my mz na b">event</code>对象。</p><p id="005c" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">从同一个 Lambda 函数处理多个事件可能会很方便，因为 Cognito 总是会提供一个名为<code class="eh mx my mz na b">event.triggerSource</code>的属性来帮助你为每个事件实现正确的逻辑。</p><p id="92e7" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">例如，下面是如何在 Node.js 中为一个<code class="eh mx my mz na b">Custom Message</code>实现 Lambda 函数代码:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="c668" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">正如您所看到的，逻辑是完全无状态的，最好的做法是总是检查<code class="eh mx my mz na b">triggerSource</code>值，以确保您正在处理正确的事件——并最终在未处理的源的情况下引发错误/警告。</p><p id="ff49" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">下面的代码片段展示了如何在 CloudFormation 模板中定义 Lambda 函数和 Cognito 用户池(这里我使用的是<a class="ae jg" href="https://github.com/awslabs/serverless-application-model" rel="noopener ugc nofollow" target="_blank"> AWS SAM </a>语法，但是您也可以使用普通的 CloudFormation):</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="095c" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">您所需要做的就是向您的用户池定义添加一个<code class="eh mx my mz na b">LambdaConfig</code>属性，并引用一个 Lambda 函数。</p><p id="3405" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">你可以在<a class="ae jg" href="https://docs.aws.amazon.com/en_us/AWSCloudFormation/latest/UserGuide/aws-properties-cognito-userpool-lambdaconfig.html" rel="noopener ugc nofollow" target="_blank">文档页面</a>找到<code class="eh mx my mz na b">LambdaConfig</code>的所有属性。</p><h1 id="1741" class="ma lb hu bd lc mb mc md lg me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq dt translated">2.AWS 配置(事件驱动的配置检查)</h1><p id="497c" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated"><a class="ae jg" href="https://aws.amazon.com/config/" rel="noopener ugc nofollow" target="_blank"> AWS 配置</a>允许您跟踪 AWS 资源的配置如何随时间变化。它对记录历史值特别有用，还允许您将历史配置与所需配置进行比较。例如，您可以使用 AWS Config 来确保您的帐户中启动的所有 EC2 实例都是<code class="eh mx my mz na b">t2.micro</code>。</p><p id="aef9" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">作为一名开发人员，有趣的是您可以用 AWS Lambda 实现这种符合性检查。换句话说，您可以定义一个定制规则，并将其与<strong class="jq hv">一个 Lambda 函数相关联，该函数将在响应每一个配置更改</strong>时被调用(或者定期调用)。</p><p id="97a1" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">此外，您的代码可以决定新配置是否有效:)</p><figure class="ms mt mu mv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nd"><img src="../Images/b4dbb17a2ff35b690334ab9e15d265d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LClwdQ7lgpJdzhwfkkezw.png"/></div></div></figure><p id="8ce3" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">当然，你不必监听你所有资源的每一个可能的配置变化。事实上，<strong class="jq hv">您可以根据以下内容收听特定资源</strong>:</p><ul class=""><li id="c5cb" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated"><strong class="jq hv">标签</strong>(例如，带有环境或项目特定标签的资源)</li><li id="bcbf" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">资源类型</strong>(例如，仅<code class="eh mx my mz na b">AWS::EC2::Instance</code>)</li><li id="07db" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><strong class="jq hv">资源类型+标识符</strong>(例如，一个特定的 EC2 实例 ARN)</li><li id="9ffa" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated">所有<strong class="jq hv">变化</strong></li></ul><p id="acd1" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">有很多 AWS Lambda 蓝图可以让你快速入门，而不需要自己编码所有东西(比如<code class="eh mx my mz na b">config-rule-change-triggered</code>)。但我认为理解整体逻辑和移动部分很重要，所以在接下来的几段中我们将深入学习如何从头开始编写一个新的 Lambda 函数。</p><p id="179e" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">实际上，您的函数将接收四条非常重要的信息作为输入<code class="eh mx my mz na b">event</code>的一部分:</p><ul class=""><li id="da0f" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated"><code class="eh mx my mz na b">invokingEvent</code>表示触发此 Lambda 调用的配置更改；它包含一个名为<code class="eh mx my mz na b">messageType</code>的字段，告诉您当前的有效负载是否与定期调度的调用相关(<code class="eh mx my mz na b">ScheduledNotification</code>)，是否是常规的配置更改(<code class="eh mx my mz na b">ConfigurationItemChangeNotification</code>)，或者更改内容是否太大而无法包含在 Lambda 事件有效负载中(<code class="eh mx my mz na b">OversizedConfigurationItemChangeNotification</code>)；在第一种情况下，<code class="eh mx my mz na b">invokingEvent</code>还将包含一个名为<code class="eh mx my mz na b">configurationItem</code>的当前配置字段，而在其他情况下，我们将需要通过 AWS 配置历史 API 获取当前配置</li><li id="2a66" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">ruleParameters</code>是创建自定义规则时可选定义的键/值对的集合；它们代表您的配置的(不)理想状态(例如，<code class="eh mx my mz na b">desiredInstanceType=t2.small</code>)，您可以随意使用它的值；假设这是参数化 Lambda 函数代码并在多个规则中重用它的聪明方法</li><li id="283f" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">resultToken</code>是我们将在通知 AWS Config 配置评估结果时使用的令牌(参见下面三种可能的结果)</li><li id="20d4" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">eventLeftScope</code>告诉您要评估的 AWS 资源是否已经从规则范围中删除，在这种情况下，我们将跳过评估</li></ul><p id="2e7b" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">基于上面的输入，我们的 lambda 函数将评估配置合规性，它将能够调用具有三种可能结果的<code class="eh mx my mz na b">PutEvaluations</code> API:</p><ul class=""><li id="3c80" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated"><code class="eh mx my mz na b">COMPLIANT</code>如果当前配置<em class="ne">正常</em></li><li id="aed9" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">NON_COMPLIANT</code>如果当前配置<em class="ne">不正常</em></li><li id="76c7" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">NOT_APPLICABLE</code>如果这种配置变化可以忽略</li></ul><p id="2133" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">好了，理论够了:)</p><p id="b35b" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我们编写一些代码，看看 AWS 配置的运行情况。</p><p id="383b" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">例如，让我们实现一个定制规则来检查在我们的帐户中启动的所有 EC2 实例都是使用 Node.js 的<code class="eh mx my mz na b">t2.small</code>:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="6417" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在上面的代码片段中，我导入了一个简单的实用模块(<a class="ae jg" href="https://gist.github.com/alexcasalboni/60a3b45017ad3d44f052c2dd3c1661e4" rel="noopener ugc nofollow" target="_blank">，你可以在这里找到</a>)，以使整体逻辑更具可读性。</p><p id="9358" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">大多数神奇的事情发生在名为<code class="eh mx my mz na b">evaluateChangeNotificationCompliance</code>的 JavaScript 函数中。它的逻辑是基于<code class="eh mx my mz na b">ruleParameters</code>和<code class="eh mx my mz na b">desiredInstanceType</code>的值进行参数化的——我们将在下面的 CloudFormation 模板中定义——以便我们可以为不同的规则重用相同的 Lambda 函数。</p><p id="fa7a" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在，让我们在 CloudFormation 中定义我们的 AWS 配置自定义规则和 Lambda 函数:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="2e6c" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">定义自定义规则相当直观。在<code class="eh mx my mz na b">Scope</code>属性中，我只选择了<code class="eh mx my mz na b">AWS::EC2::Instance</code>资源，并将<code class="eh mx my mz na b">t2.small</code>作为自定义规则的输入参数进行传递。然后，我定义了<code class="eh mx my mz na b">Source</code>属性并引用了我的 Lambda 函数。</p><p id="d34a" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">您可以在这里找到关于 AWS 配置自定义规则的完整文档<a class="ae jg" href="https://docs.aws.amazon.com/en_us/AWSCloudFormation/latest/UserGuide/aws-resource-config-configrule.html" rel="noopener ugc nofollow" target="_blank"/>，其中有关于预定规则、标签过滤等的良好参考。</p><h1 id="e008" class="ma lb hu bd lc mb mc md lg me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq dt translated">3.亚马逊 Kinesis 数据消防软管(数据验证)</h1><p id="f7f0" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated"><a class="ae jg" href="https://aws.amazon.com/kinesis/data-firehose/" rel="noopener ugc nofollow" target="_blank"> Kinesis Data Firehose </a>允许您将流数据导入标准目的地进行分析，如亚马逊 S3、亚马逊红移、亚马逊弹性搜索服务和 Splunk。</p><p id="e1a0" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">您可以让多个数据生产者<code class="eh mx my mz na b">PutRecords</code>进入您的交付流。Kinesis Firehose <strong class="jq hv">将负责缓冲、压缩、加密，甚至可选地重塑和优化您的数据</strong>以提高查询性能(例如，以拼花列格式)。</p><p id="cab4" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">此外，您可以将 Lambda 函数附加到交付流。该功能将能够在 Kinesis Firehose 继续之前<a class="ae jg" href="https://docs.aws.amazon.com/en_us/firehose/latest/dev/data-transformation.html" rel="noopener ugc nofollow" target="_blank">验证、操作或丰富输入记录</a>。</p><figure class="ms mt mu mv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff nf"><img src="../Images/8b014eb45959b9bc6fe79774b3adf028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AA4liD2WecpsVr2JIwZpVg.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">(Optionally, you might have API Gateway or CloudFront in front of Kinesis Firehose for RESTful data ingestion)</figcaption></figure><p id="f9dc" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">您的 Lambda 函数将接收<strong class="jq hv">一批记录</strong>，并将需要返回带有附加<code class="eh mx my mz na b">result</code>字段的相同记录列表，该字段的值可以是以下值之一:</p><ul class=""><li id="a7d6" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated"><code class="eh mx my mz na b">Ok</code>如果记录已成功处理/验证</li><li id="1760" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">Dropped</code>如果记录不需要存储(消防软管将跳过它)</li><li id="c73c" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">ProcessingFailed</code>如果记录无效或在处理/操作过程中出错</li></ul><p id="60a4" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在让我们用 Python 实现一个通用的、可重用的验证和操作逻辑:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="39ba" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">上面的代码片段是结构化的，因此您只需要实现自己的<code class="eh mx my mz na b">transform_data</code>逻辑。在这里，您可以添加新的字段，操作现有的字段，或者通过引发一个<code class="eh mx my mz na b">DroppedRecordException</code>来决定跳过/删除当前记录。</p><p id="6e15" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">值得一提的几个实现细节:</p><ul class=""><li id="a783" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated">传入和传出的记录都必须是<strong class="jq hv"> base64 编码的</strong>(上面的代码片段已经解决了这个问题)</li><li id="b1c8" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated">我假设传入的记录是 JSON 格式的，但是您也可以接收 CSV 数据，甚至是您自己定制的格式；只要确保正确地序列化记录，因为 Kinesis Firehose 总是希望使用普通字符串</li><li id="0a25" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated">我在每个编码记录后添加了一个尾随的<code class="eh mx my mz na b">\n</code>字符，这样 Kinesis Firehose 将在交付目的地的每行序列化一个 JSON 对象(这是亚马逊 S3 和雅典娜正确工作所必需的)</li></ul><p id="0570" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">当然，您可以在 AWS Lambda 支持的任何编程语言中实现自己的数据操作逻辑，在一些更高级的用例中，您可能需要从 Amazon DynamoDB 或其他数据源获取额外的数据。</p><p id="e150" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在让我们定义 CloudFormation 中的数据摄取应用程序。</p><p id="220d" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">您可以通过定义<code class="eh mx my mz na b">ProcessingConfiguration</code>属性将 Lambda 函数附加到 Kinesis Firehose 交付流。</p><p id="6a54" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">除此之外，让我们设置 Firehose，每 60 秒(或者一旦<strong class="jq hv"> 10MB 被收集</strong>)<strong class="jq hv">用 GZIP </strong>压缩，将传入的记录传送到亚马逊 S3 <strong class="jq hv">。我们还需要一个专门的 IAM 角色来为 Firehose 定义细粒度的权限，以调用我们的 Lambda 并写入 S3。</strong></p><p id="3e9c" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">以下是完整的 CloudFormation 模板供您参考:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="1d14" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在我看来，这种架构最好的一点是，它是 100%无服务器的，如果没有数据被接收，你不会被收费。因此，它允许您拥有多个 24x7 全天候的开发和测试环境，而且几乎不需要任何成本。</p><p id="18fd" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">你可以在这里找到完整的云信息文档。此外，你还会在这里找到<a class="ae jg" href="https://github.com/alexcasalboni/serverless-data-pipeline-sam" rel="noopener ugc nofollow" target="_blank">一个端到端的管道，包括 Amazon API Gateway 和 Amazon Athena</a>。</p><h1 id="6835" class="ma lb hu bd lc mb mc md lg me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq dt translated">4.自动气象站云形成(宏)</h1><p id="51e7" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated">到目前为止，我们已经在本文中看到了许多<a class="ae jg" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>模板。这就是在 JSON 或 YAML 模板中定义应用程序和资源的方式。CloudFormation 允许您将同一个堆栈部署到多个 AWS 帐户、区域或环境，如<code class="eh mx my mz na b">dev</code>和<code class="eh mx my mz na b">prod</code>。</p><p id="7fda" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">几个月前——2018 年 9 月——AWS 宣布了一项名为 Macros 的新云形成功能。</p><p id="becf" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">CloudFormation 带有内置转换，如<code class="eh mx my mz na b">AWS::Include</code>和<code class="eh mx my mz na b">AWS::Serverless</code>，它们通过压缩资源定义表达式和支持组件重用来简化模板创作。这些转换在部署时应用于您的 CloudFormation 模板。</p><p id="91b3" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">类似地，<a class="ae jg" href="https://docs.aws.amazon.com/en_us/AWSCloudFormation/latest/UserGuide/template-macros.html" rel="noopener ugc nofollow" target="_blank"> CloudFormation 宏</a>是由您自己的 Lambda 函数支持的<strong class="jq hv">自定义转换</strong>。</p><figure class="ms mt mu mv fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ng"><img src="../Images/625f6341e6e7d72bfda34d1b1298a61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGwvps2dSW6Rsw002rwMQg.png"/></div></div></figure><p id="8ff6" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">创建和使用宏有三个主要步骤:</p><ol class=""><li id="5748" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl kr ks kt ku dt translated">创建一个 Lambda 函数来处理原始模板</li><li id="d93f" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated">定义一个<code class="eh mx my mz na b">AWS::CloudFormation::Macro</code>类型的资源(这里的<a class="ae jg" href="https://docs.aws.amazon.com/en_us/AWSCloudFormation/latest/UserGuide/aws-resource-cloudformation-macro.html" rel="noopener ugc nofollow" target="_blank">资源引用</a>)，将它映射到上面的 Lambda 函数，并部署堆栈</li><li id="6271" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated">在 CloudFormation 模板中使用宏</li></ol><p id="fc74" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">宏特别强大，因为您可以使用<code class="eh mx my mz na b">Transform</code>属性将它们应用于整个 CloudFormation 模板，或者使用固有的<a class="ae jg" href="https://docs.aws.amazon.com/en_us/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-transform.html" rel="noopener ugc nofollow" target="_blank"> Fn::Transform 函数</a>将它们应用于一个子部分，可选地使用参数。</p><p id="a849" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">例如，您可以定义一个宏，将一个简单的资源<code class="eh mx my mz na b">MyCompany::StaticWebsite</code>扩展成一组适当的资源和相应的默认值，包括 S3 桶、CloudFront 分发、IAM 角色、CloudWatch 警报等。</p><p id="036c" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">记住只能在创建宏的帐户中使用宏，并且宏名在给定的帐户中必须是唯一的，这一点也很有用。如果启用对处理函数的跨帐户访问，则可以在多个帐户中定义同一个宏，以便于重用。</p><h2 id="73cf" class="la lb hu bd lc ld le lf lg lh li lj lk jz ll lm ln kd lo lp lq kh lr ls lt lu dt translated">如何实现 CloudFormation 宏</h2><p id="c184" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated">现在让我们关注执行模板处理的 Lambda 函数的实现细节。</p><p id="abe2" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">当您的函数被调用时，它将接收以下内容作为输入:</p><ul class=""><li id="a7fa" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated"><code class="eh mx my mz na b">region</code>是宏所在的区域</li><li id="2c7c" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">accountID</code>是调用该函数的账户的账户 ID</li><li id="55ef" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">fragment</code>模板中可用于 JSON 格式处理的部分(可以是整个模板，也可以是它的一个子部分)，包括兄弟模板</li><li id="ae13" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">params</code>仅当您正在处理模板的子部分，并且它包含目标堆栈提供的自定义参数(未评估)时可用</li><li id="715e" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">templateParameterValues</code>包含目标堆栈的模板参数(已经评估)</li><li id="f672" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">requestId</code>是当前函数调用的 ID(仅用于匹配响应)</li></ul><p id="eafd" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">一旦处理逻辑完成，Lambda 函数将需要返回以下三个属性:</p><ul class=""><li id="13d8" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl mw ks kt ku dt translated"><code class="eh mx my mz na b">requestId</code>必须与作为输入提供的相同请求 ID 相匹配</li><li id="8985" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">status</code>应该设置为字符串<code class="eh mx my mz na b">"success"</code>(其他任何内容都将被视为处理失败)</li><li id="195d" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl mw ks kt ku dt translated"><code class="eh mx my mz na b">fragment</code>是已处理的模板，包括兄弟姐妹</li></ul><p id="574c" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">有趣的是，在某些情况下，处理过的<code class="eh mx my mz na b">fragment</code>将与您作为输入接收到的<code class="eh mx my mz na b">fragment</code>相同。</p><p id="a3f5" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我可以想到四种可能的操纵/处理场景:</p><ol class=""><li id="2ee9" class="km kn hu jq b jr js jv jw jz ko kd kp kh kq kl kr ks kt ku dt translated">您的函数处理一些资源，<strong class="jq hv">定制它们的属性</strong>(不添加或删除其他资源)</li><li id="c1f5" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated">您的函数<strong class="jq hv">通过创建新的资源</strong>来扩展输入片段</li><li id="82f0" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated">您的函数<strong class="jq hv">将一些资源</strong>——可能是您自己的定制类型——替换为其他真实的 CloudFormation 资源(注意:这也是 AWS SAM 所做的！)</li><li id="132f" class="km kn hu jq b jr kv jv kw jz kx kd ky kh kz kl kr ks kt ku dt translated">您的函数不会改变输入片段，但是如果出现错误或者缺少(例如，如果加密被禁用或者被授予的权限过于开放)，那么<strong class="jq hv">就会故意失败</strong></li></ol><p id="c309" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">当然，您的宏可能是以下四种情况的混合。</p><p id="49a6" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在我看来，<em class="ne">场景(4 </em>)特别强大，因为相对于我们在本文开头讨论的 AWS 配置解决方案，它允许您在实际部署和供应资源之前<strong class="jq hv">实现定制配置检查</strong>。</p><p id="8091" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><em class="ne">场景(3) </em>可能是最常用的，因为它允许您定义自己的个性化资源，如<code class="eh mx my mz na b">MyCompany::StaticWebsite</code>(使用 S3 桶、CloudFront 发行版或 Amplify 控制台应用程序)或<code class="eh mx my mz na b">MyCompany::DynamoDB::Table</code>(启用自动缩放、按需容量，甚至是主键和索引的复杂共享配置)等。</p><p id="5019" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">一些更复杂的宏混合使用了无状态处理和由附加 Lambda 函数支持的<a class="ae jg" href="https://docs.aws.amazon.com/en_us/AWSCloudFormation/latest/UserGuide/template-custom-resources.html" rel="noopener ugc nofollow" target="_blank"> CloudFormation 定制资源</a>。</p><p id="1d68" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated"><a class="ae jg" href="https://github.com/awslabs/aws-cloudformation-templates/tree/master/aws/services/CloudFormation/MacrosExamples" rel="noopener ugc nofollow" target="_blank">在这里，您可以找到 CloudFormation 宏</a>的实际实现示例、相应的宏模板以及一些示例模板。我相信你会特别喜欢下面的宏:<code class="eh mx my mz na b">AWS::S3::Object</code>、<code class="eh mx my mz na b">Count</code>、<code class="eh mx my mz na b">StackMetrics</code>、<code class="eh mx my mz na b">StringFunctions</code>等等！</p><h2 id="275e" class="la lb hu bd lc ld le lf lg lh li lj lk jz ll lm ln kd lo lp lq kh lr ls lt lu dt translated">如何部署云形成宏</h2><p id="152c" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated">一旦实现了处理函数，就可以用它来部署一个新宏。</p><p id="22e9" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">以下是定义新宏资源的方法:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="62e4" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">就是这样！</p><p id="91fd" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">每当我们在 CloudFormation 模板中引用名为<code class="eh mx my mz na b">MyUniqueMacroName</code>的宏时，AWS CloudFormation 都会调用处理函数。</p><h2 id="699d" class="la lb hu bd lc ld le lf lg lh li lj lk jz ll lm ln kd lo lp lq kh lr ls lt lu dt translated">如何使用云形成宏</h2><p id="29a9" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated">对于大多数开发人员来说，使用宏是最有可能的情况。</p><p id="fb0d" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">很常见的是，宏由您的组织或另一个团队拥有和管理，您只需在您的 CloudFormation 模板中使用/引用一个宏。</p><p id="7ec6" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">下面是如何使用上面定义的宏并将其应用于整个模板:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="9877" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">如果您想将同一个宏仅应用于模板的一个子部分，您可以通过使用<code class="eh mx my mz na b">Fn::Transform</code>内在函数来实现:</p><figure class="ms mt mu mv fq iv"><div class="bz el l di"><div class="nb nc l"/></div></figure><p id="18b5" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">让我知道你将构建什么样的 CloudFormation 宏，以及它们为你的团队解决了什么样的挑战！</p><h1 id="6383" class="ma lb hu bd lc mb mc md lg me mf mg lk mh mi mj ln mk ml mm lq mn mo mp lt mq dt translated">结论</h1><p id="14a7" class="pw-post-body-paragraph jo jp hu jq b jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh lz kj kk kl hn dt translated">第 1 部分到此为止:)</p><p id="0491" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">我希望你已经了解了一些关于<a class="ae jg" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank">亚马逊认知</a>、<a class="ae jg" href="https://aws.amazon.com/config/" rel="noopener ugc nofollow" target="_blank"> AWS 配置</a>、<a class="ae jg" href="https://aws.amazon.com/kinesis/data-firehose/" rel="noopener ugc nofollow" target="_blank">亚马逊 Kinesis 数据消防软管</a>和<a class="ae jg" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank">亚马逊云信息</a>的新知识。</p><p id="d5f1" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">现在，您可以定制您的 Cognito 用户池工作流，实时验证您的配置，在 Kinesis 将数据交付到目的地之前处理和验证数据，并实施宏来丰富您的 CloudFormation 模板。</p><p id="cfdc" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">在本系列的下两部分中，我们将了解更多关于服务的其他不太常见的 Lambda 集成，如 AWS IoT 1-Click、Amazon Lex、Amazon CloudWatch Logs、AWS CodeDeploy 和 Amazon Aurora。</p><p id="defa" class="pw-post-body-paragraph jo jp hu jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hn dt translated">感谢您花时间阅读这么长的文章。<br/>欢迎在下面分享和/或发表评论。</p></div></div>    
</body>
</html>