<html>
<head>
<title>How to Pin Mobile gRPC Connections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何固定移动gRPC连接</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-pin-mobile-grpc-connections-fd3ff1143dda?source=collection_archive---------4-----------------------#2019-03-14">https://medium.com/hackernoon/how-to-pin-mobile-grpc-connections-fd3ff1143dda?source=collection_archive---------4-----------------------#2019-03-14</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="adc4" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">gRPC连接的移动API的最后一英里安全性</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/90ebc97c334bffcf6e7440b545bf2cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gm5FfUkx7PNbtSq_"/></div></div></figure><p id="994d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在<a class="ae kr" href="https://blog.approov.io/consider-grpc-for-mobile-apis" rel="noopener ugc nofollow" target="_blank">考虑用于移动API的gRPC</a>中，我们评估了用于移动应用的<a class="ae kr" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>。我们看了一下常见的操作，例如:</p><ul class=""><li id="db11" class="ks kt hu jx b jy jz kb kc ke ku ki kv km kw kq kx ky kz la dt translated">一个基本的请求-响应API调用</li><li id="0f2f" class="ks kt hu jx b jy lb kb lc ke ld ki le km lf kq kx ky kz la dt translated">基于令牌的认证</li><li id="d1b4" class="ks kt hu jx b jy lb kb lc ke ld ki le km lf kq kx ky kz la dt translated">单个请求、流响应API调用</li></ul><p id="8b46" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我的结论是，对我来说，RPC函数调用范例比设计和实现一个<em class="lg">完全RESTful </em> API实现更自然，并且我说过，当API是静态的并且很好理解时，我会毫不犹豫地将gRPC用于移动客户端。</p><p id="afa2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">对于移动应用，<a class="ae kr" href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank">证书锁定</a>是加强API安全性的一项重要功能，在这个续集中，我们将研究Android上gRPC的证书锁定。剧透警告——最后，它非常类似于固定一个restful连接。</p><h1 id="7626" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">证书锁定</h1><p id="5f69" class="pw-post-body-paragraph jv jw hu jx b jy lz iv ka kb ma iy kd ke mb kg kh ki mc kk kl km md ko kp kq hn dt translated"><a class="ae kr" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank">传输层安全性(TLS) </a>是一项广为接受且不断发展的标准，旨在加强隐私和消息完整性。建立连接时，服务器端点将其公钥证书发送给发出请求的客户端。客户端遵循信任的证书链，直到它到达它隐式信任的根证书。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff me"><img src="../Images/4a30d05d0b0f66ebc5f66c141fbc2554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*895j7GGAloRXkfPf"/></div></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Source: <a class="ae kr" href="https://en.wikipedia.org/wiki/Public_key_certificate#/media/File:Chain_of_trust.svg" rel="noopener ugc nofollow" target="_blank">Wikipedia — chain of trust</a>: image originally via Gary Stevens of <a class="ae kr" href="https://hostingcanada.org/" rel="noopener ugc nofollow" target="_blank">HostingCanada.org</a></figcaption></figure><p id="a6b2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Android和iOS设备维护着一套它们绝对信任的证书。不幸的是，欺骗移动设备信任由意想不到的证书颁发机构签署的证书太容易了。诊断工具，如<a class="ae kr" href="https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/" rel="noopener ugc nofollow" target="_blank"> mitmproxy </a>，使用同样的技术来拦截和潜在地干扰加密的HTTPS流。</p><p id="8d80" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在移动设备上，应使用<a class="ae kr" href="https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank">证书锁定</a>来限制对网站叶证书的信任，或仅限于应用程序本身信任的中间或根授权机构。您可以对证书、它们的公钥或它们的公钥散列进行pin。存储这些证书或密钥pin的选项包括:</p><ul class=""><li id="85ea" class="ks kt hu jx b jy jz kb kc ke ku ki kv km kw kq kx ky kz la dt translated">预加载:在分布式应用程序包中嵌入pin通常是最容易实现的。不过，升级引脚集需要现场升级应用程序，因此建议在每个版本中安装多个叶引脚和中间引脚。</li><li id="9940" class="ks kt hu jx b jy lb kb lc ke ld ki le km lf kq kx ky kz la dt translated">第一次使用时的信任(豆腐):端点的公钥在安装或升级后第一次使用时确定。安全性取决于首次使用时环境的安全性。</li><li id="6037" class="ks kt hu jx b jy lb kb lc ke ld ki le km lf kq kx ky kz la dt translated">Pin服务器:从受信任的服务器请求pin。您如何信任pin服务器？也许你pin pin服务器！如果pin服务器是稳定的，这允许您管理一组动态的端点，而不需要为所服务的pin的每次改变进行应用程序升级。仅当pin服务器的证书发生变化时，才需要升级。这是一个有趣的权衡，也是未来文章的主题。</li></ul><p id="45b4" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">验证锁定证书时，客户端会验证证书的签名和请求的主机名。因为同一个IP地址可能共享多个主机名，<a class="ae kr" href="https://en.wikipedia.org/wiki/Server_Name_Indication" rel="noopener ugc nofollow" target="_blank">服务器名称指示</a>是一个TLS扩展，它使客户端能够通过虚拟主机名请求特定的证书。除了在虚拟主机中使用之外，这种技术还简化了从本地主机提供的自签名证书的调试。</p><h1 id="c9a0" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">锁定gRPC管理的渠道</h1><p id="ee05" class="pw-post-body-paragraph jv jw hu jx b jy lz iv ka kb ma iy kd ke mb kg kh ki mc kk kl km md ko kp kq hn dt translated">使用gRPC，客户端对<em class="lg">存根</em>接口进行<em class="lg"> rpc调用</em>，存根接口通过<em class="lg">通道</em>向服务器发送一个或多个proto请求消息，并从服务器接收一个或多个响应消息。在<a class="ae kr" href="https://blog.approov.io/consider-grpc-for-mobile-apis" rel="noopener ugc nofollow" target="_blank">中，考虑用于移动API的gRPC</a>，我们使用一个简单的管理通道进行传输。为了锁定通道，我们将启用TLS (SSL)并创建我们自己的一组可信证书，与设备上已安装的证书分开。我们将使用Android作为例子。</p><p id="2558" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，我们将在演示应用程序中构建自己的密钥库。为了方便起见，我们将一组公钥证书存储为原始资源，并在certs.xml资源文件中标识这些资源:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="9c42" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">当启动<code class="eh ml mm mn mo b">ShapesActivity</code>时，创建密钥库，并且密钥库和服务器名称覆盖被传递给我们固定的受管通道<code class="eh ml mm mn mo b">PinnedChannelBuilder</code>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="24a5" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们覆盖了服务器名称，这样服务器将响应一个终端实体证书，该证书的公共名称(CN)与我们固定的名称相匹配。</p><p id="36b2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们正在构建的<code class="eh ml mm mn mo b">PinnedChannelBuilder</code>将使用定制的<code class="eh ml mm mn mo b">SSLSocketFactory</code>进行连接。Java的安全和网络堆栈让这变得有些乏味，需要1)构建一个包含我们的<code class="eh ml mm mn mo b">java.security.KeyStore</code>的<code class="eh ml mm mn mo b">javax.net.ssl.TrustManagerFactory</code>，2)创建一个包含这个<code class="eh ml mm mn mo b">TrustManagerFactory</code>的<code class="eh ml mm mn mo b">javax.net.ssl.SSLContext</code>，以及3)从<code class="eh ml mm mn mo b">SSLContext</code>中公开<code class="eh ml mm mn mo b">javax.net.ssl.SSLSocketFactory</code>:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="3f3e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">虽然很麻烦，但这与为restful HTTPS连接构建自定义套接字工厂没有太大区别，尽管许多网络堆栈和Android N有方便的方法来隐藏这种复杂性。</p><h1 id="99ae" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">尝试一下</h1><p id="2207" class="pw-post-body-paragraph jv jw hu jx b jy lz iv ka kb ma iy kd ke mb kg kh ki mc kk kl km md ko kp kq hn dt translated">为了进行测试，我们使用了之前使用的相同的shapes演示应用程序。我们在本地主机上运行一个gRPC服务器，为运行在本地Android模拟器上的shapes应用程序提供一个<code class="eh ml mm mn mo b">shapes.proto</code> API。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/d1c33b9d7c9fedd7fdd3c433322b0287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/0*VYA01ocT9aFkdABf"/></div></figure><p id="da56" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">首先，我们将使用<a class="ae kr" href="https://www.openssl.org/" rel="noopener ugc nofollow" target="_blank"> openssl </a>为本地主机生成一个自签名私钥、公钥证书对:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mj mk l"/></div></figure><p id="568e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">应该将localhost.crt证书文件复制到shape应用程序的原始资源目录中(<code class="eh ml mm mn mo b">app/src/main/res/raw/</code>)。类似地，我们生成一个<code class="eh ml mm mn mo b">otherhost.crt</code>证书文件，并将其复制到原始资源目录中。</p><p id="8698" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">我们将把<code class="eh ml mm mn mo b">localhost.key</code>私钥和<code class="eh ml mm mn mo b">localhost.crt</code>证书文件安装到我们的gRPC服务器中。gRPC服务器通常配置为双向SSL。我们的客户正在锁定gRPC服务器，而不是反过来，所以确保禁用了相互SSL。</p><p id="b406" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">现在我们启动应用程序。被管通道向服务器请求<code class="eh ml mm mn mo b">localhost</code>证书，通道连接成功。点击<code class="eh ml mm mn mo b">Stream</code>按钮，我们看到预期的响应:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/cb33e85184631fcfa80edf4bdcafdee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*bCarf1LPZPwUEqzPFEzjqA.png"/></div></figure><p id="502b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了测试锁定，我们从应用程序中删除localhost证书并重新启动。这一次，服务器传送本地主机证书，但是信任管理器没有找到匹配的固定证书，因此通道连接失败:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/6dfd48428392339e08f4072bfb94f89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:228/format:webp/1*agb3rI3cVx7Nz2_m-I2qHg.png"/></div></figure><p id="51a0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">为了简单起见，我们只展示了自签名的叶证书。一个更好的做法是把中级证书固定下来。Square的<a class="ae kr" href="https://github.com/square/certstrap" rel="noopener ugc nofollow" target="_blank"> certstrap工具</a>是一个很好的资源，可以用来生成您自己的测试证书授权和更长的密钥链，如果您想探索这些场景的话。</p><h1 id="ae6d" class="lh li hu bd lj lk ll lm ln lo lp lq lr ja ls jb lt jd lu je lv jg lw jh lx ly dt translated">包扎</h1><p id="6428" class="pw-post-body-paragraph jv jw hu jx b jy lz iv ka kb ma iy kd ke mb kg kh ki mc kk kl km md ko kp kq hn dt translated">在Android上，我们能够演示一个固定的gRPC通道，这并不比固定一个restful HTTPS连接更困难。包括<a class="ae kr" href="https://blog.approov.io/consider-grpc-for-mobile-apis" rel="noopener ugc nofollow" target="_blank">考虑用于移动API的gRPC】，我们已经展示了:</a></p><ul class=""><li id="a5f3" class="ks kt hu jx b jy jz kb kc ke ku ki kv km kw kq kx ky kz la dt translated">一个基本的请求-响应API调用</li><li id="b7f1" class="ks kt hu jx b jy lb kb lc ke ld ki le km lf kq kx ky kz la dt translated">基于令牌的认证</li><li id="7260" class="ks kt hu jx b jy lb kb lc ke ld ki le km lf kq kx ky kz la dt translated">单个请求、流响应API调用</li><li id="bb78" class="ks kt hu jx b jy lb kb lc ke ld ki le km lf kq kx ky kz la dt translated">到服务器的固定TLS连接</li></ul><p id="b077" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">gRPC的函数调用范例，以及gRPC从单个原型文件为许多目标语言生成客户端和服务器API接口的能力，以及我们对基本和安全API功能的演示，使gRPC成为移动API开发的合理方法。</p></div></div>    
</body>
</html>