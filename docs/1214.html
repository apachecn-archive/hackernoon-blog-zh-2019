<html>
<head>
<title>Security in your OpenAPI Specification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenAPI规范中的安全性</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/security-in-your-openapi-specification-94d081603950?source=collection_archive---------4-----------------------#2019-02-20">https://medium.com/hackernoon/security-in-your-openapi-specification-94d081603950?source=collection_archive---------4-----------------------#2019-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/0c70f6c294f031234e212797120c179b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-U2Y7IMmnqT845i3"/></div></div></figure><h2 id="5f5a" class="jc jd hu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">了解OpenAPI 2.0和3.0如何在API开发的设计阶段将API安全性作为头等大事来宣传和强调。</h2><p id="60b6" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">这已经不是什么秘密了，原料药正在吞噬世界。今天有许多公司提供他们的API作为与系统交互的主要媒介，用户界面只是副产品，或者，无论如何，不是销售的主要产品。Stripe和Twilio等公司在2012年引领了这场运动。</p><p id="e17b" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">鉴于这种转变(顺便说一下，这种转变仍在发生)，API已经开始变得越来越复杂，因此API开发过程也需要发展。API已经成为一个产品，因此所有典型的团队成员和方法都被用来使产品成功。</p><p id="9a9b" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">基于API的产品相关性的增加需要新的工具来支持用于实现产品的人员和方法。你将如何设计一个API，以便你可以在真正构建它之前回顾和迭代设计？设计移动应用程序时，您可以使用工具轻松创建模型，以确保在投入资源创建真正的应用程序之前，组织中的每个人都在同一页面上。</p><p id="5638" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">多年来，这不是API的事情。直到OpenAPI规范(以及一堆其他标准)问世。</p><p id="93de" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">在本文中，我们将从安全的角度回顾OpenAPI可以提供什么，您今天如何能够接受这些特性，并展示一些在这个领域做得非常酷的公司！</p><h1 id="6dc2" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">OpenAPI历史:什么，为什么，什么时候</h1><p id="600c" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">open API——以前称为Swagger——在2010年开始时是一个简单的开源规范，用于设计RESTful APIs，尽管在接下来的几年里出现了其他API规范格式(如RAML和APIBlueprint ),但Swagger项目成为了最受欢迎的一个。</p><p id="cbe5" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">2015年，Swagger项目被捐赠给Linux基金会，并更名为OpenAPI规范，微软和IBM加入该基金会，帮助推动该格式向前发展。他们的第一个版本是OpenAPI 2.0，只不过是将原来的Swagger格式改头换面；几年后，OpenAPI 3.0发布了一些重要的更新。</p><p id="d6b2" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">今天，OpenAPI倡议包括了10多家公司，他们认识到共同努力产生一个描述API的标准化文档的高价值和重要性。</p><h1 id="bafc" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">OpenAPI 2.0</h1><h1 id="8b0a" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">格式概述</h1><p id="9522" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">OpenAPI 2.0只不过是旧的Swagger格式，在捐赠给Linux基金会后更名。</p><p id="06af" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">OpenAPI 2.0文档可以编写为JSON或YAML文件，它们允许您根据端点、接受和返回的有效负载、媒体类型、返回的状态代码以及可以访问API的服务器来定义公开的API。</p><p id="7a08" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">我们不会在这里查看所有这些部分。相反，我们将关注规范提供的安全特性。</p><h1 id="58a2" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">OpenAPI 2.0的安全特性</h1><p id="2f20" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">OpenAPI 2.0提供了一个专门的部分来声明API的安全特性和要求，然后在路径和操作中适当的地方使用它们。</p><p id="21c3" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated"><a class="ae lr" href="https://gist.github.com/01e78b4c3e70102063a8ce3ca1f70459" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/01e78b4c3e70102063a8ce3ca1f70459</a></p><p id="98aa" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">在这个例子中，我们声明了两个安全定义:第一个将在指定的头中寻找API键(在这个例子中是api_key)，而第二个声明了一个隐式的oAuth2流，需要一些特定的作用域。</p><p id="3400" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">OpenAPI 2.0支持另一种称为basic的安全定义类型，它本质上是旧的普通HTTP认证格式。</p><p id="0e23" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">OpenAPI 2.0没有其他内置的安全定义，如果不使用供应商提供的扩展，就不可能定义自定义的安全定义。虽然这三个选项涵盖了现实世界中的大部分用例，但对于特殊情况来说，它们可能还不够。</p><h1 id="117b" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">OpenAPI 3.0</h1><h1 id="ac16" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">OpenAPI 2.0的格式概述和改进</h1><p id="2bab" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">OpenAPI 3.0于2017年发布，旨在解决2.0版面临的一些缺点和限制。</p><p id="0539" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">我们不打算把重点放在OpenAPI 3.0规范上，也不打算强调这两种格式之间的所有差异:互联网上有很多详细介绍这些变化的链接。相反，我们将把重点放在新版本规范中引入的安全性变化上。</p><h1 id="7178" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">OpenAPI 3.0的安全特性</h1><p id="9cf4" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">同样，OpenAPI 2.0在文档中有一个专用部分来声明安全定义，OpenAPI 3.0也有一个。不同之处在于，OpenAPI 3.0将术语改为了“安全方案”。该规范还标准化了声明规范中可以跨多条路径重用的所有部分的方式。虽然以前共享组件是开发人员的常识，但现在它们都被分组到组件键下。</p><p id="9359" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">此外，还添加了OpenID Connect支持，以及安全定义包含多个oAuth2流的能力(这是目前常用的功能)。</p><p id="2d50" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">为了让大家了解安全声明是如何从OAS2.0变为OAS 3.0的，我们在前面提到过这个例子，它是为OAS 3编写的:</p><p id="2c66" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">https://gist.github.com/728cfd90abf698b9b62f774ed3954831<a class="ae lr" href="https://gist.github.com/728cfd90abf698b9b62f774ed3954831" rel="noopener ugc nofollow" target="_blank"/></p><p id="4d0a" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">您可以看到，现在oAuth2定义支持多个流，这是由security部分中的一个新键定义的。</p><h1 id="9973" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">实践:设计安全的API</h1><p id="36a6" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">现在，让我们动手创建一个表示将在公共互联网上公开的API的文档。我们将经历设计阶段，以及实现代码和合同测试。</p><p id="499e" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">由于大多数围绕OpenAPI的工具仍然坚持使用2.0版本，这就是我们将要使用的版本。然而，我们今天将在这里展示的所有概念仍然有效。</p><h1 id="f736" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">创建一个OpenAPI规范</h1><p id="73a8" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">OpenAPI规范文档无非是YAML或JSON文件。尽管这有效地降低了愿意写文档的新手的门槛(每个人都可以写JSON或YAML文档)，但这隐藏了规范本身的复杂性。这就是视觉设计师或其他工具真正有用的地方。</p><p id="7849" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">市场上有很多这样的东西。即<a class="ae lr" href="https://stoplight.io/" rel="noopener ugc nofollow" target="_blank">红绿灯</a>、<a class="ae lr" href="https://apiary.io/" rel="noopener ugc nofollow" target="_blank">蜂场</a>、<a class="ae lr" href="https://swagger.io/tools/swaggerhub/" rel="noopener ugc nofollow" target="_blank">转运站</a>。选择哪一个真的取决于你和你的需求。在任何情况下，他们都提供一个免费的计划，所以你不必支付开始。</p><p id="4daf" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">我们将只编写一个简单的API，它是众所周知的PetStore示例的精简版本。该API是<a class="ae lr" href="https://github.com/OAI/OpenAPI-Specification/blob/master/examples/v2.0/yaml/petstore.yaml" rel="noopener ugc nofollow" target="_blank">OAS 2</a>0和<a class="ae lr" href="https://github.com/OAI/OpenAPI-Specification/blob/master/examples/v3.0/petstore.yaml" rel="noopener ugc nofollow" target="_blank"> 3.0 </a>中官方示例的一部分。我选择这一个是因为内容本身的简单性。</p><h1 id="8beb" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">写代码</h1><p id="d7cb" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">在API的世界里，编写代码确实是最琐碎的部分。构建一个API更多的是一个概念性的工作和协作努力，而不是在你的存储库上提交东西。</p><p id="0197" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">出于这个原因，我们将坚持一个非常基本的例子，其代码托管在<a class="ae lr" href="https://glitch.com/edit/#!/petstore-backend" rel="noopener ugc nofollow" target="_blank"> Glitch </a>上。对于那些不知道的人来说，Glitch是NodeJS应用程序的免费托管服务。它非常适合以非常快的方式构建和发布小型应用程序。</p><h1 id="0a36" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">测试您的API</h1><p id="7fdc" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">现在，我们真正想做的是，在开发服务器时，不断检查我们刚刚编写的实现是否与我们存储库中的规范文档同步。这就是契约测试工具发挥作用的地方；它们启动服务器的一个实例，通过浏览OpenAPI文档，它们向服务器发送HTTP请求，服务器检查状态代码和返回的有效负载。如果其中任何一项不匹配，就会导致CI/CD步骤失败，并且不会部署API。你也可以把这看作TDD开发，最初你只有一个OpenAPI文档，所有的测试都失败了，因为你没有任何代码。</p><p id="c6f8" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">随着您开发API并添加越来越多的端点，您将开始看到测试的更多部分通过，直到您处于绿色(这意味着您覆盖了OpenAPI文档中声明的整个API表面)。</p><p id="9038" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">在我们刚刚做的例子中，我决定使用<a class="ae lr" href="https://github.com/stoplightio/prism" rel="noopener ugc nofollow" target="_blank">棱镜</a>，但是<a class="ae lr" href="https://dredd.com/en/latest" rel="noopener ugc nofollow" target="_blank">德雷德</a>是另一个你可以使用的棱镜。它们都支持OpenAPI 2.0，但不幸的是，它们都不支持OpenAPI 3.0。</p><p id="eaa2" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">这些工具的设置通常很简单，不需要任何特别的努力。</p><p id="f5a7" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">我们要做的第一件事是在机器上下载Prism服务器:</p><p id="8d0d" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated"><code class="eh ls lt lu lv b">curl -L https://github.com/stoplightio/prism/releases/download/v2.0.16/prism_linux_amd64 -o prism &amp;&amp; chmod +x ./prism</code></p><p id="d5d1" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">完成后，我们需要在本地启动我们的应用服务器，然后运行Prism，提供用于发送请求的监听URL和用作事实来源的OpenAPI文档:</p><p id="c2d5" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated"><a class="ae lr" href="https://gist.github.com/c62745e77453b74ef6b40150f1a7737c" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/c62745e77453b74ef6b40150f1a7737c</a></p><p id="b513" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">Prism现在将读取OpenAPI规范文件，遍历所有路径，并按照提供的示例开始创建HTTP请求，或者使用JSON模式作为参考创建有效负载，并将它们发送到您的应用服务器。一旦响应到来，Prism将验证状态代码以及响应的形状是否与声明的一致。如果其中任何一项不匹配，服务器将报告错误并将测试标记为失败。</p><p id="caa1" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">注意:这些命令也应该适用于CI/CD环境。</p><h1 id="207e" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">在Auth0中集成您的OpenAPI安全规范</h1><p id="903f" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">现在我们有了一个设计规范与实现相匹配的API，是时候部署它了。很可能我们想要保护API，Auth0显然是选择之一。</p><p id="adde" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">Auth0当前并不支持所有的流。以下是目前情况的分类:</p><ul class=""><li id="a55b" class="lw lx hu kc b kd kv kh kw jn ly jr lz jv ma ku mb mc md me dt translated"><strong class="kc hv"> oAuth2 </strong>:所有的流都被支持，这是处理认证/授权的推荐方式。也可以发出基于JSON的令牌，而不是不透明的令牌，从而支持其他场景(比如在web应用程序之间传递令牌)</li><li id="089d" class="lw lx hu kc b kd mf kh mg jn mh jr mi jv mj ku mb mc md me dt translated"><strong class="kc hv"> openIdConnect </strong>:由Auth0支持所有标准声明</li><li id="276a" class="lw lx hu kc b kd mf kh mg jn mh jr mi jv mj ku mb mc md me dt translated"><strong class="kc hv"> basic/http </strong>:作为oAuth 2.0流的一种特殊类型得到支持。任何拥有客户端密码的客户端都可以使用HTTP基本身份验证方案发送此消息。公平地说，这是一种发送客户端密码的方式，而不是对该方案的完全支持；因为当你试图找到目标路径时，你的浏览器不会有任何提示</li><li id="d9e3" class="lw lx hu kc b kd mf kh mg jn mh jr mi jv mj ku mb mc md me dt translated"><strong class="kc hv"> apiKey </strong>:不支持。这本身并没有正式的标准，但是这是一种通过网络发送预共享凭证的常见方式。最接近API密钥的身份验证方法是使用客户端凭据授予请求。</li></ul><p id="cbb7" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">你可以看到，只要你使用的是oAuth2.0或者openIdConnect，就没什么好担心的。如果你想坚持使用一些“旧”的方法，你可能会遇到麻烦，这些方法在一定程度上可以被模仿。</p><h1 id="34b8" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">运行时集成</h1><p id="c98e" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">在这个阶段，<a class="ae lr" href="https://glitch.com/edit/#!/petstore-backend" rel="noopener ugc nofollow" target="_blank">我们有一个后端服务器实现我们的API，还有一个身份提供者</a>(在这个例子中是Auth0)存储我们所有的用户，并提供必要的基础设施在我们的平台上对他们进行认证和授权。我们遗漏了两个部分之间的粘合剂:一个愿意在我的应用程序中进行身份验证的用户如何被重定向到Auth0的服务？</p><p id="206f" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">您可以在您的应用程序代码中做到这一点，但是在这种情况下，它不再是声明性的，并且您的OpenAPI文档中关于安全性需求的更改也需要您的代码进行更改。</p><p id="4911" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">在API网关的帮助下，有可能自动化这个阶段。考虑到这个软件通常是以声明的方式配置的，并且事实上大多数时候你的OpenAPI文档与公开的API相匹配，所以在规范和API网关配置之间几乎有一个完美的匹配。不幸的是，到目前为止，市场上没有一个网关达到这样的集成水平。</p><p id="f3bb" class="pw-post-body-paragraph ka kb hu kc b kd kv kf kg kh kw kj kk jn kx km kn jr ky kp kq jv kz ks kt ku hn dt translated">对于对这个话题感兴趣的人，我去年12月做了一个演示，他的<a class="ae lr" href="http://youtube.com/watch?v=_bt1r_SHfaU" rel="noopener ugc nofollow" target="_blank">视频发布在网上</a></p><h1 id="18da" class="la jd hu bd je lb lc ld ji le lf lg jm lh li lj jq lk ll lm ju ln lo lp jy lq dt translated">结论</h1><p id="770f" class="pw-post-body-paragraph ka kb hu kc b kd ke kf kg kh ki kj kk jn kl km kn jr ko kp kq jv kr ks kt ku hn dt translated">我们已经了解了作为OpenAPI 2.0和3.0规范一部分的安全特性，它们可以帮助API用户和开发人员在使用和构建API时清楚地设定期望。然后我们稍微了解了一下API的生命周期，正如你可能注意到的，它更多的是关于沟通，在同一页面上，关于你想要公开什么，而不是简单地写代码。这只是整个过程中的一个步骤。最后，我们探索了与身份提供者进行运行时集成的机会，现在还没有。</p></div></div>    
</body>
</html>