# JavaScript 中的无限数据结构

> 原文：[https://medium.com/hackernoon/infinite-data-structures-in-javascript-eb67ecbccdb#2019-01-02](https://medium.com/hackernoon/infinite-data-structures-in-javascript-eb67ecbccdb#2019-01-02)

像 Haskell 这样的语言能够直接处理无限列表，但是这种能力能够应用到 JavaScript 的世界中吗？

![](../Images/26cde2ee7aaecc36e7783c0cdb57ce96.png)

[https://codepen.io/fstokesman/pen/maBBQG](https://codepen.io/fstokesman/pen/maBBQG)

在现实世界中，我们一直在处理“无限”的想法。所有的正数是一个我们连眼睛都不会眨一下的无限概念的例子。但是通常当我们编程时，我们必须以一种*有限*的方式来考虑这些*无限*的概念。你不能拥有所有正数的数组(至少在 JavaScript 中不能！).

本文中我要介绍的是一个**无限** **列表**数据结构的思想，它可以表示一些永无止境的序列，让我们使用常见的操作如 ***映射*** 和 ***过滤*** 来修改和创建新的序列。

当我们想*实际使用*的数据时，我们只需 ***取*** 的一些具体量即可。

# 创建无限列表

为了创建上面定义的那种结构，我们首先需要某种方法来描述一个无限的东西，而不需要实际评估它(这会让计算机很快死亡)。为此，我们首先需要了解两件事:

*   *迭代器*模式*模式*
*   *发电机*功能

## 迭代器模式

先从*迭代器* *模式*说起。*迭代器模式*是一种设计模式，在这种模式下，你可以一次产生一个值。它基本上只是一个带有 ***的物体。*下()**方法。当该方法被调用时，它返回另一个带有 2 个键的对象: ***value*** 和 ***done*** 。我们称之为 ***。接下来()，******done***属性表示迭代器是否有更多的值给我们， ***value*** 当然是值。下面是一个简单的迭代器，返回值 0 到 3:

这种模式在 JavaScript 中有一流的地位。 ***数组、对象、映射、*** 和 ***集合*** 都可以通过符合一个名为[***Iterable***](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterables)的接口来实现*迭代器模式*。

## 发电机功能

生成器函数是 JavaScript 中一种特殊的函数，它是用 ***函数**** 语法声明的。生成器函数用于创建*迭代器*对象(带有 ***的对象)。next()*** 方法)，但以更清晰、更简洁的方式。下面是一个*有限*生成器，它创建了一个等价的迭代器:

这里， ***yield*** 关键字用来表示每次调用迭代器时返回的值。你可以想到函数*在每次 ***产生*** 后暂停*，并在*迭代器*的 ***时从它停止的地方继续。下一个()*再调用**方法。

要使这个*无限*生成器，只需将***while(x<4)***循环变成 ***while (true)*** 循环。为了更好的感受，这里有一个著名的斐波那契数列的无限生成器:

## 把它放在一起

迭代器看起来像是无限事物的一种表示，因为它让我们请求**。next()** 元素无限期。此外， ***生成器*** 似乎是指定迭代器的好方法，因为我们可以为无穷级数编写简洁的算法，而无需手动制作迭代器的模板。

但这仍然不够，因为尽管 ***发生器*** 功能强大，但它们并不是真正的*合成*。如果我想创建一个生成器，在那里我用*过滤*到所有以 5 结尾的斐波那契数，我不能轻易使用我现有的***createfibsequiterator()***来做这件事——也就是说，我不能在上面组合*原始生成器* + *一些新操作*的想法。

为了解决这个问题，我们首先需要将生成器封装成一个数据类型，我们可以用一个类来完成:

正是在这个类上，我们将实现类似于 ***滤镜*** 、 ***贴图*** 、 ***取*** 的操作。

## 无限懒惰

当你想到我们如何实现一个像 ***过滤*** 这样的操作时，你可能会感到困惑。答案很简单:我们懒洋洋地做*。实际上，我们并没有试图过滤我们的列表，我们只是在 ***无限*** 类中做了一个注释。然后当用户想要具体的 ***。取()*** 它的一些元素，我们就可以做实际业务中的 ***过滤*** ing 了。*

*Infinite 类得到一个新的 ***变换*** 属性，而 ***滤镜*** 用相同的生成器和 ***变换*** 数组创建一个新的 Infinite，并将一个*变换*推入列表。*

*我们现在拥有了编写 ***所需的所有组件。take()*** 这将使列表具体化。*

*当我们称**为*时。取(n)*** ，我们可以从生成器中创建一个迭代器，然后用 ***n*** 元素初始化一个定长数组。这将是我们的具体清单。一个 ***索引*** 变量可以用来记录到目前为止我们已经收集了多少具体值。使用 while 循环，我们可以从迭代器中获取一个值，然后在其上运行我们的 ***转换*** 列表。如果其中一个转换是过滤器，并且它没有通过测试，我们简单地不把它添加到我们的*具体的*列表中，并且重复这个循环。当我们收集完 ***n*** 元素后，我们就完成了，可以返回具体的列表了。*

*让我们看看前面的斐波纳契例子是怎样的:*

*为了实现 ***贴图*** ，我们可以使用与 ***滤镜*** 相同的方法。map 方法本身只是克隆当前的 ***无限的*** 并将一个新的变换添加到列表中。在 ***里面取*** ，只要在变换循环里面加一个*else——if*就够了。*

## *结论*

*在本文中，我们探索了*迭代器模式*和*生成器函数*，以便构建一个*组合*和*延迟求值* **无限列表**数据结构。*

*然而，本文中的**无限列表**有一点局限性，因为它缺少一些真正有用的操作，比如地图实现、相关过滤或者将**无限列表**组合在一起的能力(比如，将每个斐波那契数与一个质数配对)。*

*针对这些我创建了[](https://github.com/francisrstokes/Lazy-Infinite-List)****一个更强大的无限链表结构，这符合[幻境规范](https://github.com/fantasyland/fantasy-land)。[我很想让你看看 github](https://github.com/francisrstokes/Lazy-Infinite-List) ，或者在你的下一个项目中尝试一下*****

*****[***npm 我懒-无限***](https://www.npmjs.com/package/lazy-infinite)*****

*****如果你喜欢这种对无限数据结构的探究，请在 twitter @fstokesman 上联系我，并考虑给这篇文章一个👏。*****