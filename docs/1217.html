<html>
<head>
<title>A Brief History of Flink: Tracing the Big Data Engine’s Open-source Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flink简史:追踪大数据引擎的开源开发</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-brief-history-of-flink-tracing-the-big-data-engines-open-source-development-87464fd19e0f?source=collection_archive---------7-----------------------#2019-02-20">https://medium.com/hackernoon/a-brief-history-of-flink-tracing-the-big-data-engines-open-source-development-87464fd19e0f?source=collection_archive---------7-----------------------#2019-02-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4070" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">从版本1.1.0到1.6.0，Apache Flink的不懈改进是开源开发的典范。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/128de275c536e8f399c47566b9dfd9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*de8eyV17UZMxTyWyHoloRg.jpeg"/></div></div></figure><p id="166d" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kr">本文是</em> <a class="ae ks" rel="noopener" href="/@alitech_2017/a-flink-series-from-the-alibaba-tech-team-b8b5539fdc70"> <strong class="jx hv"> <em class="kr">阿里巴巴旗下Flink系列</em> </strong> </a> <em class="kr">的一部分。</em></p><p id="f8e8" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">近年来，开源大数据计算引擎Apache Flink(简称Flink)作为批处理和流处理的强大框架越来越受欢迎，可用于创建许多基于事件的应用程序。</p><p id="2d2e" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink首先是一个纯流计算引擎，有数据流基础数据模型。流可以是无限的和无边界的，这描述了一般意义上的流处理，或者可以是有边界的有限流，如在批处理的情况下。因此，Flink使用单一架构来支持流处理和批处理。</p><p id="8b82" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">正如其口号“基于流的有状态计算”所传达的，Flink具有支持有状态计算的额外优势。当处理一个事件或一段数据的结果只与该事件本身的内容相关时，处理就被称为无状态。或者，如果结果与先前处理的事件相关，则称为有状态处理。一些复杂的数据处理，比如聚合，将两个都是有状态处理的流连接起来。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff kt"><img src="../Images/61cfa382fb89d3df791abd4a3719d5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*to6GMwCdjY60qqMw97WP0A.png"/></div></div></figure><p id="2441" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">除了依靠其对大规模数据操作的支持，阿里巴巴集团在过去几年中对Flink的发展做出了重大贡献，包括添加了异步I/O功能等重要组件。本文借鉴了阿里巴巴开发人员Chong (Jark) Wu的见解，首先介绍了该框架当前版本中可用的关键功能，然后介绍了该框架为改进特定性能领域而经历的历史变化。</p><h1 id="e8fe" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">Apache Flink的构建模块</h1><p id="9824" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">Flink越来越受欢迎主要是基于四个构建模块组件，即它的检查点、状态、时间和窗口机制。</p><p id="8ec2" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">检查点机制是Flink最重要的特性之一。Flink基于Chandy-Lamport算法实现分布式一致性快照，提供恰好一次语义；相比之下，以前的流计算系统，如Strom和Samza，不能有效地解决恰好一次的问题。</p><p id="0605" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在提供一致的语义之后，Flink引入了一个托管状态，并提供了API接口，用户可以在编程时使用这些接口管理状态，使编程像使用Java集一样简单。</p><p id="8429" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink还实现了水印机制，解决了在基于事件时间的处理中出现的数据无序和数据迟到问题。</p><p id="845c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，由于流计算一般基于windows，Flink提供了一套包括翻滚、滑动、会话窗口在内的开箱即用的窗口操作，并支持灵活的自定义窗口以满足特殊需求。</p><h1 id="78a6" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">Flink API的历史变化</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lr"><img src="../Images/00ca038eae631b94ab11d63772d18723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TFEItDcCCul2N5AZ47czw.png"/></div></div></figure><p id="82b0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink强大的框架受益于对其以前版本的许多突破性的API增强。</p><p id="05d0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在其1.0.0阶段，Flink引入了State API，由ValueState、ReducedState、ListState等组成。状态API可以认为是Flink最大的创新。它允许用户使用Flink的托管状态作为Java集合API，并自动享受状态一致的保证，而不会因为失败而丢失任何状态。作为其重要性的标志，甚至后来的Apache Beam State API也大量借鉴了这个组件。</p><p id="d857" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink的1.1.0版本开始支持会话窗口，并正确处理无序和迟到的数据，确保最终结果的准确性。</p><p id="1adb" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在1.2.0时期，提供了Flink的ProcessFunction API，这是一个更低级的API，用于实现更高级更复杂的功能。除了能够注册各种状态类型，它还支持注册计时器(EventTime和ProcessingTime ),通常用于开发基于事件、基于时间的应用程序。</p><p id="6593" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">1.3.0时期，Flink收到了侧面输出功能。这一点很重要，因为通常只有一种操作符输出类型，而有时可能需要另一种类型。例如，除了输出主流数据之外，以副流的形式输出一定量的异常和迟到的数据，然后将它们交给不同的下游节点进行处理也是有利的。侧输出特别支持这种多路复用输出。</p><p id="a4a0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink的1.5.0阶段增加了BroadcastState，这是一个状态API扩展，用于存储从上游广播的数据。因为是从上游广播的，所以这个运算符的每个任务中的BroadcastState数据是完全相同的。基于这种状态，可以更有效地解决CEP中的动态规则函数和SQL中的不等连接场景。</p><p id="9f3a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，在其1.6.0版本中，Flink接收了其状态TTL和数据流间隔Join函数。状态TTL实现了在申请某个状态时对生存时间参数(TTL)的指定，并确保该状态可以被指定在给定的时间间隔后由系统自动清除。在此版本之前，用户必须在ProcessFunction中注册一个计时器，然后使用计时器的回调手动清除状态。从1.6.0开始，Flink框架基于TTL解决了这个问题。数据流区间连接使区间连接成为可能。例如，五分钟间隔联接意味着左流中的每个记录都将联接位于联接前后五分钟内的右流数据。</p><h1 id="304c" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">Flink高级API的历史变化</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ls"><img src="../Images/5d4730bd34dec1ca2d92585250187312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UZUe-8cmzgxBwvPuPIMOyw.png"/></div></div></figure><p id="6aae" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">与上一节讨论的变化类似，随着版本的发展，Flink的高级API也经历了许多变化。</p><p id="c4d3" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在Flink的1.0.0时期，其表API(或结构化数据处理API)和CEP(复杂事件处理API)框架被添加到库中。Table API是一个结构化的高级API，以类似于Spark的DataFrame API的方式支持Java和Scala语言。它也与SQL高度相似。表API和SQL都是关系API，可以共享许多实现。因此，在Flink 1.1.0中，社区基于Apache方解石重构了整个表模块，它同时支持表API和SQL，并允许它们共享大部分代码。</p><p id="f7fa" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在1.2.0时期，Flink社区支持对表API和SQL进行丰富的内置窗口操作，包括翻滚窗口、滑动窗口和会话窗口。</p><p id="0dfd" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在1.3.0期间，Flink社区提出了动态表的概念。有了它，流和表是双重的，可以在不丢失任何信息的情况下相互转换。这为流和批的统一提供了基础。实现动态表的核心是收回机制，只有收回机制才能让多级聚合和多级连接正确实现，只有收回机制才能保证流SQL的语义和结果的正确性。此外，在这个版本中，Flink还支持CEP运算符的可伸缩性——换句话说，CEP运算符的并行性现在可以在不丢失状态的情况下进行更改。</p><p id="38f6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，在Flink 1 . 5 . 0版本中，表API和SQL上支持连接，包括常规流连接和时间窗流连接。此外，还添加了SQL客户端。SQL客户端提供了一种简单的方式来编写、调试和提交表程序到Flink集群，而不需要一行Java或Scala代码。SQL客户端CLI允许在命令行上检索和可视化正在运行的分布式应用程序的实时结果。</p><h1 id="c877" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">Flink检查点和恢复的历史更改</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lt"><img src="../Images/8b274980c53c8194803006cbfa18b60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cH6PMn5FjVP5hUYEJ9J8A.png"/></div></div></figure><p id="ea5c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink的检查点机制从早期开始就得到支持，此后成为核心特性，Flink社区也一直在努力提高检查点和恢复的效率。</p><p id="daa6" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink的1.0.0时期支持RocksDB statebackend。在此版本之前，所有状态数据只能存储在内存中。因为JVM内存的大小是固定的，数据大小的增加会导致FullGC和OOM问题。这使得Flink很难在生产环境中稳定使用。要存储更多数据或更大的状态，需要RocksDB statebackend。RocksDB是一个基于文件的嵌入式数据库，它将数据存储到磁盘，同时提供高效的读写性能。因此，使用RocksDB可以避免OOM问题。</p><p id="6661" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在其1.1.0版本中，Flink获得了对RocksDB快照的异步支持。在以前的版本中，RocksDB的快照过程是同步的，这会阻塞主数据流的处理并影响吞吐量。有了异步支持，Flink的吞吐量从此有了很大的提高。</p><p id="c2b0" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在1.2.0版本中，通过引入KeyGroup机制，增加了对可重缩放的KeyedState和OperatorState的支持。这就是说，可以在不丢失状态的情况下改变运算符的并行性。</p><p id="e8cc" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在其1.3.0版本中，Flink增加了对其增量检查点机制的支持，这表明Flink的流计算已经完全达到了生产就绪状态。增量检查点仅存储和保存新的增量状态快照。对于一般的流计算，吉字节级甚至太字节级的状态是很常见的，如果所有数据的状态每次都存储到分布式存储，那么网络的成本将变得非常高。在这个版本中，Flink还支持细粒度恢复功能。Flink不是在任务失败时重新启动完整的ExecutionGraph，而是只重新启动受影响的子图，从而大大减少了恢复时间。</p><p id="9f00" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">最后，在Flink 1.5.0版本中，引入了本地状态恢复机制。由于检查点机制，状态将被持久地存储在分布式存储中。以HDFS为例，发生故障切换时，需要从远程HDFS重新下载数据。如果状态特别大，下载时间将会很长，花费在故障转移恢复上的时间也会延长。本地状态恢复机制预先在本地备份状态文件，以便当作业经历故障转移时，可以在本地恢复它，而不是从远程HDFS下载状态文件，从而提高恢复效率。</p><h1 id="740b" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">Flink运行时的历史更改</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff lu"><img src="../Images/2a891ff0af5138d5802dd09479940826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9Td7ESA1-IIURXsN639Lg.png"/></div></div></figure><p id="903a" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink运行时的显著发展始于版本1.2.0时期，当时阿里巴巴直接向Flink社区贡献了备受瞩目的异步I/O功能。异步I/O的主要目的是解决与外部系统交互时由网络延迟引起的系统瓶颈，例如当查询外部HBase表以填充某些列时。同步方法会导致每个查询操作被阻塞，并且数据流会由于频繁的I/O请求而停滞。使用异步I/O，可以在不阻塞主数据流的情况下同时发起N个异步查询请求，从而提高整个作业的吞吐量和CPU的利用率。</p><p id="f04b" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">flink 1 . 3 . 0版引入了HistoryServer组件。HistoryServer允许用户查询由JobManage归档的已完成作业的状态和统计信息，这在作业完成后进行深入故障排除时非常有用。</p><p id="47f7" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在Flink 1.4.0时期，增加了端到端恰好一次的语义保证。“恰好一次”意味着即使软件或硬件发生故障，输入数据的每条记录也将恰好对最终结果产生一次影响，从而确保数据不会丢失或被计算两次。在1.4.0版之前，Flink在Flink程序中提供了“恰好一次”的保证，但不包括对外部系统的输出，因此如果发生故障转移，可能会将重复数据写入外部系统。当时，一般的解决方案是使用一个幂等的外部数据库。在1.4.0中，Flink通过两阶段提交算法支持端到端恰好一次的语义保证。它通过内置的方法进一步支持Kafka的端到端保证，并为用户提供TwoPhaseCommitSinkFunction来创建他们自己的恰好一次数据接收器。</p><p id="278c" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">在其1.5.0期间，Flink发布了新的部署模型和处理模型。Flink部署和流程模型(内部称为FLIP-6)的重写工作已经进行了一年多，是Flink社区的一项重大努力。这是自项目开始以来对Flink核心组件最重大的改进。简而言之，这些改进增加了对YARN和Mesos调度程序上的动态资源分配和动态资源释放的支持，以实现更好的资源利用、故障恢复和动态伸缩。</p><p id="2171" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">版本1.5.0还重构了网络堆栈，因为在旧版本中，多个上游和下游任务之间的通信共享一个TCP连接。当一个任务被反压时，所有共享其连接的任务都将被阻塞。对于Flink 1.5，社区致力于两项工作来改进Flink的网络堆栈:基于信用的流量控制和改进的传输延迟。基于信用的流量控制将“线上”数据量降至最低，同时保持高吞吐量。这大大减少了在背压情况下完成检查点的时间。此外，Flink现在能够在不降低吞吐量的情况下实现更低的延迟。</p><h1 id="d347" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">外卖食品</h1><p id="ab27" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">Flink最大的优势之一是它对流和批处理的统一。当前的发展趋势倾向于将流计算作为更成熟的领先模型，这种方法已经在众多公司的大规模生产环境中得到了验证。</p><p id="58ba" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated">Flink社区将继续改进流计算的性能和功能，包括为Flink SQL扩展更丰富的功能和引入新的优化。加入这些努力，社区将致力于增强其生态能力，从批处理到机器学习等等。</p><p id="a844" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt"><strong class="jx hv">(Original article by Wu Chong伍翀)</strong></p><p id="77d1" class="pw-post-body-paragraph jv jw hu jx b jy jz iv ka kb kc iy kd ke kf kg kh ki kj kk kl km kn ko kp kq hn dt translated"><em class="kr">本文是</em> <a class="ae ks" rel="noopener" href="/@alitech_2017/a-flink-series-from-the-alibaba-tech-team-b8b5539fdc70"> <strong class="jx hv"> <em class="kr">阿里巴巴旗下Flink系列</em> </strong> </a> <em class="kr">的一部分。</em></p></div><div class="ab cl lv lw hc lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="hn ho hp hq hr"><h1 id="8d20" class="ku kv hu bd kw kx mc kz la lb md ld le ja me jb lg jd mf je li jg mg jh lk ll dt translated">阿里巴巴科技</h1><p id="01dc" class="pw-post-body-paragraph jv jw hu jx b jy lm iv ka kb ln iy kd ke lo kg kh ki lp kk kl km lq ko kp kq hn dt translated">关于阿里巴巴最新技术的第一手深度资料→脸书:<a class="ae ks" href="http://www.facebook.com/AlibabaTechnology" rel="noopener ugc nofollow" target="_blank"> <strong class="jx hv">《阿里巴巴技术》</strong> </a>。Twitter:<a class="ae ks" href="https://twitter.com/AliTech2017" rel="noopener ugc nofollow" target="_blank"><strong class="jx hv">【AlibabaTech】</strong></a>。</p></div></div>    
</body>
</html>