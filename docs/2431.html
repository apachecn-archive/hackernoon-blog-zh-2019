<html>
<head>
<title>A Guide to Post-Quantum Cryptography</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后量子密码术指南</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-guide-to-post-quantum-cryptography-d785a70ea04b?source=collection_archive---------6-----------------------#2019-04-16">https://medium.com/hackernoon/a-guide-to-post-quantum-cryptography-d785a70ea04b?source=collection_archive---------6-----------------------#2019-04-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f6f04dd7ecdf787a529689b8ad9aa09b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Z9YrYXjJ4mBNZoRN9Zv3w.jpeg"/></div></div></figure><blockquote class="jc jd je"><p id="86c3" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">这篇文章由本·佩雷兹撰写，最初发表在比特博客的T2小道上。在作者的许可下，它被重新出版，并包含了来自国际扶轮实验室研究人员的附加注释。</p></blockquote><p id="1349" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">对于许多高保证应用程序，如TLS流量、医疗数据库和区块链，前向保密是绝对必要的。这不足以阻止攻击者立即解密敏感信息。在这里，威胁模型包括这样的情况，其中对手可能在收集密文后花费许多年来解密密文。一个潜在的破解秘密的方法是，计算能力的提高和数论的突破相结合，使得攻击当前的密码学变得容易。然而，除非有人找到分解大整数的多项式时间算法，否则这种风险对于当前的最佳实践来说是最小的。我们应该更关心量子计算机的成功开发，因为这样的突破会让我们今天使用的大部分加密技术变得不安全。</p><h1 id="98bd" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">量子计算入门</h1><p id="7e11" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated"><a class="ae ke" href="https://www.scottaaronson.com/papers/npcomplete.pdf" rel="noopener ugc nofollow" target="_blank">量子计算机不仅仅是大规模并行经典计算机</a>。人们通常认为，由于一个量子位可以同时占据0和1，那么一台n位量子计算机可以同时处于2n个状态，因此可以极快地计算NP完全问题。事实并非如此，因为测量一个量子态会破坏许多原始信息。例如，一个量子系统完全知道一个物体的动量和位置，但是任何动量的测量都会破坏关于位置的信息，反之亦然。这就是所谓的<a class="ae ke" href="https://en.wikipedia.org/wiki/Uncertainty_principle" rel="noopener ugc nofollow" target="_blank">海森堡测不准原理</a>。因此，成功的量子算法由一系列量子位的转换组成，这样，在计算结束时，测量系统的状态不会破坏所需的信息。事实上，<a class="ae ke" href="https://arxiv.org/pdf/quant-ph/9701001.pdf" rel="noopener ugc nofollow" target="_blank">已经证明</a>不可能存在一个量子算法同时尝试一些NP完全问题的所有解并输出正确的输入。换句话说，任何解决经典难题的量子算法都必须利用手头问题的特定结构。今天，有两种这样的算法可以用于密码分析。</p><p id="8312" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">快速分解大数的能力将会破坏RSA和基于离散对数的密码术。整数因式分解最快的算法是通用数域筛，它以亚指数时间运行。然而，在1994年，Peter Shor开发了一种用于整数因式分解的量子算法(<a class="ae ke" href="https://www.scottaaronson.com/blog/?p=208" rel="noopener ugc nofollow" target="_blank"> Shor的算法</a>),该算法在多项式时间内运行，因此能够破解任何RSA或基于离散对数的密码系统(包括那些使用椭圆曲线的系统)。这意味着，如果有人要建造量子计算机，所有广泛使用的公钥密码学都是不安全的。</p><p id="4352" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">第二种是Grover算法，能够在O(√n)时间内求逆函数。该算法将通过一个根因子来降低对称密钥加密的安全性，因此AES-256将仅提供128位的安全性。类似地，寻找一个256位散列函数的前映像只需要2128次。由于将散列函数或AES的安全性提高两倍并不是很麻烦，因此Grover的算法不会对对称加密造成严重威胁。此外，除了Grover算法导致的O(√n)因子之外，量子计算机的发明不会影响任何一个建议用于加密的伪随机数发生器。</p><h1 id="309d" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">后量子算法的类型</h1><p id="9882" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">后量子密码术是对可以在经典计算机上运行，但是即使对手拥有量子计算机也是安全的密码系统的研究。最近，<a class="ae ke" href="https://csrc.nist.gov/Projects/Post-Quantum-Cryptography" rel="noopener ugc nofollow" target="_blank"> NIST启动了</a>后量子加密标准化进程，目前正在审核第一轮申请。其中最有前途的包括基于格、同源、散列函数和代码的密码系统。</p><p id="dadc" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在更深入地研究每一类提交之前，我们简要总结了每种类型的密码系统固有的权衡，并与当前(非后量子时代)的椭圆曲线密码系统进行了比较。请注意，代码和同源能够产生数字签名，但没有向NIST提交这种方案。</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ll"><img src="../Images/4e94ea708db4f4a56f894a668e9e240d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MmuUIiFrVwpB0OVOAWLv0w.png"/></div></div></figure><p id="0357" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在安全性证明方面，上述密码系统都没有归结为NP难(或NP完全)问题。在格和码的情况下，这些密码系统是基于NP困难问题的轻微修改。基于散列的构造依赖于好的散列函数的存在，并且不做任何其他加密假设。最后，基于同源的密码学是基于一个被推测为困难的问题，但与NP困难问题或先验密码学假设不同。然而，值得一提的是，正如我们无法证明任何经典算法在多项式时间内是不可破解的(因为P可能等于NP)，被认为对量子计算机来说很难的问题可能并不是如此。此外，一个密码系统不能归结为某个NP难或完全问题，本质上不应该成为反对它的标志，因为整数因式分解和离散对数问题不被认为是NP完全的。</p><h1 id="5158" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">格子</h1><p id="b8a5" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">在后量子密码术的所有方法中，格是研究最活跃和最灵活的。它们具有很强的安全性，能够进行密钥交换、数字签名和更复杂的结构，如<a class="ae ke" href="https://blog.cryptographyengineering.com/2012/01/02/very-casual-introduction-to-fully/" rel="noopener ugc nofollow" target="_blank">全同态加密</a>。尽管格密码系统的优化和安全证明都需要极其复杂的数学，但基本思想只需要基本的线性代数。假设你有一个形式的线性方程组</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lq"><img src="../Images/41e38e5f1ab4f7e826c045df956eb490.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/0*JMmiHkIFrpAAQK0M"/></div></div></figure><p id="aa01" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">求解<code class="eh lr ls lt lu b"><strong class="ji hv">x</strong></code>是一个经典的线性代数问题，可以使用高斯消去法快速求解。另一种思考方式是我们有一个神秘的函数，</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/79624c8881b69020b7deba87fa096479.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/0*jXIq56jlxMspb6_M"/></div></figure><p id="ef92" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在给定一个向量<code class="eh lr ls lt lu b"><strong class="ji hv">a</strong></code>的地方，我们看到了<code class="eh lr ls lt lu b"><strong class="ji hv">ax</strong></code>的结果，而不知道<code class="eh lr ls lt lu b"><strong class="ji hv">x</strong></code>。查询这个函数足够多次后，我们可以在短时间内学习<code class="eh lr ls lt lu b">f</code>(通过求解上面的方程组)。这样我们就可以把一个线性代数问题重新架构成一个机器学习问题。</p><p id="3323" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">现在，假设我们在函数中引入少量噪声，这样在将<code class="eh lr ls lt lu b"><strong class="ji hv">x</strong></code>和<code class="eh lr ls lt lu b"><strong class="ji hv">a</strong></code>相乘后，我们会添加一个误差项<code class="eh lr ls lt lu b"><strong class="ji hv">e</strong></code>，并对一个(中等大小的)质数<code class="eh lr ls lt lu b">q</code>取模，从而减少整个运算。那么我们嘈杂的神秘函数看起来像</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/da90bc63365de35f1bb56f30a1091699.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*AwjJpEsTbopn8RQQ"/></div></figure><p id="65b5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">学习这个嘈杂的神秘函数已经被数学证明是极其困难的。直觉上，我们在无噪声情况下使用的高斯消去法中的每一步，误差项都会变得越来越大，直到它掩盖了关于函数的所有有用信息。在密码学文献中，这被称为带有错误的<a class="ae ke" href="https://cims.nyu.edu/~regev/papers/lwesurvey.pdf" rel="noopener ugc nofollow" target="_blank">学习</a>问题(LWE)。</p><p id="7e3c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">基于LWE的密码术被称为基于格的密码术的原因是因为LWE是困难的证明依赖于这样一个事实，即在称为格的东西中寻找最短向量是NP困难的。我们不会在这里深入研究格子的数学，但是我们可以把格子想象成n维空间的镶嵌</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff lx"><img src="../Images/d8d7ac4bd4d58b557bcc9ddb1c7cb25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/0*8cJDU3CwqOSirmU7"/></div></figure><p id="abec" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">格子由坐标向量表示。在上面的例子中，通过组合<code class="eh lr ls lt lu b"><strong class="ji hv">e1</strong></code>、<code class="eh lr ls lt lu b"><strong class="ji hv">e2</strong></code>和<code class="eh lr ls lt lu b"><strong class="ji hv">e3</strong></code>(通过法向量加法)可以到达网格中的任何一点。最短向量问题(SVP)说:给定一个格，找出作为向量的长度最短的元素。这很难的直观原因是，对于一个给定的晶格，并不是所有的坐标系都同样容易处理。在上面的例子中，我们可以用三个坐标向量来表示晶格，这三个坐标向量非常长并且非常靠近，这使得寻找靠近原点的向量更加困难。事实上，有一种规范的方法可以找到一个格的“最坏可能”表示。当使用这种表示时，最短向量问题被认为是NP难的。</p><p id="fc99" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在讨论如何使用LWE制造抗量子密码之前，我们应该指出LWE本身并不是NP难的。它不是直接还原到SVP，而是还原到SVP的近似值，这实际上被推测为<em class="jh">而不是</em>是NP难的。尽管如此，目前还没有多项式(或次指数)算法来求解LWE。</p><p id="55e1" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">现在让我们用LWE问题来创建一个实际的密码系统。最简单的方案是由Oded Regev在他的<a class="ae ke" href="https://cims.nyu.edu/~regev/papers/qcrypto.pdf" rel="noopener ugc nofollow" target="_blank">原始论文</a>中创建的，证明了LWE问题的难度。这里，密钥是一个n维向量，具有整数项mod <code class="eh lr ls lt lu b">q</code>，即上面提到的LWE秘密。公钥是前面讨论的矩阵<code class="eh lr ls lt lu b"><strong class="ji hv">A</strong></code>，以及LWE函数的输出向量</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/fbc2ed172108bc1c962716e296f4e7fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/0*zl4WW3Mn8ZSQ9v7l"/></div></figure><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/f30e27743e2d10a38afc2ad4bd9b8853.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/0*2ZM7mmWxmyaQtIK-"/></div></figure><p id="1968" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这个公钥的一个重要属性是，当它乘以向量<code class="eh lr ls lt lu b">(<strong class="ji hv">-sk</strong>,1)</code>时，我们得到的是误差项，大概是<code class="eh lr ls lt lu b">0</code>。</p><p id="1d41" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">为了加密一位信息<code class="eh lr ls lt lu b">m</code>，我们取<code class="eh lr ls lt lu b"><strong class="ji hv">A</strong></code>的随机列之和，如果<code class="eh lr ls lt lu b">m</code>为<code class="eh lr ls lt lu b">0</code>则加0，如果<code class="eh lr ls lt lu b">m</code>为<code class="eh lr ls lt lu b">1</code>则加<code class="eh lr ls lt lu b">q/2</code>，将<code class="eh lr ls lt lu b">m</code>编码在结果的最后一个坐标中。换句话说，我们选择一个0或1的随机向量<code class="eh lr ls lt lu b"><strong class="ji hv">x</strong></code>,然后计算</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/7018b3e2b8cd8ab7a64b88186b7d58ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/0*VUE20eRb3Zk4czXx"/></div></figure><p id="6994" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">直观地说，我们刚刚计算了LWE函数(我们知道它很难破解),并在这个函数的输出中编码了我们的位。</p><p id="f998" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">解密之所以有效，是因为知道了LWE秘密，接收者就能得到消息，外加一个小的误差项</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/9d9a7efcdb29a596b8db07b34f0feb01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*X02ofMu-qNqjDcbI"/></div></figure><p id="bf1e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">当误差分布选择正确时，它绝不会使信息失真超过<code class="eh lr ls lt lu b">q/4</code>。接收器可以测试输出是否更接近<code class="eh lr ls lt lu b">0</code>或<code class="eh lr ls lt lu b">q/2 mod q</code>，并相应地解码该位。</p><p id="6281" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">这个系统的一个主要问题是它有非常大的密钥。仅加密一位信息需要安全参数中大小为n2的公钥。然而，格密码系统的一个吸引人的方面是它们非常快。</p><p id="7119" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">自从Regev的原始论文以来，围绕基于格的密码系统已经有了大量的工作。提高其实用性的一个关键突破是环LWE的发展，这是LWE问题的一个变种，其中密钥由某些多项式表示。这导致了密钥大小的二次减少，加速了加密和解密，只使用<code class="eh lr ls lt lu b">n*log(n)</code>操作(使用快速傅立叶技术)。</p><p id="8229" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在NIST PQC标准考虑的许多基于格的密码系统中，两个特别值得一提的是Crystals构造，<a class="ae ke" href="https://pq-crystals.org/kyber/" rel="noopener ugc nofollow" target="_blank"> Kyber </a>和<a class="ae ke" href="https://pq-crystals.org/dilithium/index.shtml" rel="noopener ugc nofollow" target="_blank"> Dilithium </a>。</p><p id="ff34" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">Kyber是一种密钥封装机制(KEM ),它遵循与上述系统类似的结构，但使用一些奇特的代数数论来获得比环LWE更好的性能。对于合理的安全参数，密钥大小约为1kb(仍然很大！)但是加密和解密时间大约为0.075毫秒。考虑到这个速度是在软件中实现的，凯伯KEM似乎有希望用于后量子密钥交换。</p><p id="890b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">Dilithium是一种基于类似于Kyber技术的数字签名方案。它的细节超出了这篇博文的范围，但值得一提的是，它也实现了相当好的性能。公钥大小约为1kb，签名为2kb。它也很有表现力。在Skylake处理器上，计算一个签名所需的平均周期数约为200万。验证平均花费390，000个周期。</p><h1 id="2c62" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">编码</h1><p id="77f1" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">纠错码的研究在计算机科学文献中有很长的历史，可以追溯到Richard Hamming和Claude Shannon的开创性工作。虽然在一篇简短的博客文章中，我们甚至不能开始触及这个<a class="ae ke" href="https://www.cs.cmu.edu/~venkatg/teaching/codingtheory/" rel="noopener ugc nofollow" target="_blank">深层领域</a>的表面，但我们给出了一个快速的概述。</p><p id="0a44" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">当传送二进制消息时，错误可能以比特翻转的形式出现。纠错码以牺牲消息的紧凑性为代价，提供了承受一定数量的比特翻转的能力。例如，我们可以通过将0编码为000，将1编码为111来防止单比特翻转。这样，接收方可以通过三位的多数表决来确定101实际上是111，或者001是0。不过，这种代码不能纠正两位翻转的错误，因为111变成001将被解码为0。</p><p id="5869" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">最主要的纠错码类型被称为线性码，可以用<code class="eh lr ls lt lu b">k x n</code>矩阵表示，其中<code class="eh lr ls lt lu b">k</code>是原始消息的长度，<code class="eh lr ls lt lu b">n</code>是编码消息的长度。一般来说，在不知道基本线性码的情况下，解码消息在计算上是困难的。这种硬度支撑着<a class="ae ke" href="http://www.math.unl.edu/~s-jeverso2/McElieceProject.pdf" rel="noopener ugc nofollow" target="_blank"> McEliece公钥密码系统</a>的安全性。</p><p id="aae9" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">在高层次上，McEliece系统中的密钥是一个随机码(表示为矩阵<code class="eh lr ls lt lu b"><strong class="ji hv">G</strong></code>),来自一类称为<a class="ae ke" href="https://en.wikipedia.org/wiki/Goppa_code" rel="noopener ugc nofollow" target="_blank"> Goppa码</a>的码。公钥是矩阵<code class="eh lr ls lt lu b"><strong class="ji hv">SGP</strong></code>，其中<code class="eh lr ls lt lu b"><strong class="ji hv">S</strong></code>是具有二进制元素的可逆矩阵，<code class="eh lr ls lt lu b"><strong class="ji hv">P</strong></code>是置换。为了加密消息<code class="eh lr ls lt lu b"><strong class="ji hv">m</strong></code>，发送者计算<code class="eh lr ls lt lu b"><strong class="ji hv">c = m(SGP) + e</strong></code>，其中<code class="eh lr ls lt lu b"><strong class="ji hv">e</strong></code>是一个随机错误向量，精确地表示代码能够纠正的错误数量。为了解密，我们计算<code class="eh lr ls lt lu b"><strong class="ji hv">cP-1 = mSG + eP-1</strong></code>，使得<code class="eh lr ls lt lu b"><strong class="ji hv">mS</strong></code>是<code class="eh lr ls lt lu b"><strong class="ji hv">G</strong></code>的码字，它可以纠正添加的误差项<code class="eh lr ls lt lu b"><strong class="ji hv">e</strong></code>。通过计算<code class="eh lr ls lt lu b"><strong class="ji hv">mSS-1</strong></code>可以很容易地恢复该消息。</p><p id="7e10" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">像格子一样，基于代码的密码术受到密钥是大矩阵的事实的影响。使用<a class="ae ke" href="http://pqcrypto.eu.org/docs/initial-recommendations.pdf" rel="noopener ugc nofollow" target="_blank">推荐的安全参数</a>，McEliece公钥大约为1 mb，私钥为11 kb。目前<a class="ae ke" href="https://eprint.iacr.org/2012/409.pdf" rel="noopener ugc nofollow" target="_blank">正在进行的工作</a>试图使用一类特殊的码，称为准循环中密度奇偶校验码，它可以比Goppa码更简洁地表示，但是这些码的安全性不如Goppa码研究得好。</p><h1 id="cd27" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">同源基因</h1><p id="38ff" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">椭圆曲线加密领域因使用了相当多的神秘数学而有些臭名昭著。同源基因把这带到了一个全新的水平。在椭圆曲线加密中，我们使用Diffie-Hellman类型的协议来获取共享的秘密，但是我们不是将群元素提升到某个幂，而是遍历椭圆曲线上的点。在基于同源的密码术中，我们再次使用Diffie-Hellman类型的协议，但是不是遍历椭圆曲线上的点，而是遍历椭圆曲线本身的序列。</p><figure class="lm ln lo lp fq iv fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/d15c32f767fe47529a238146153fe8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*k3_IEwiFmbNwUk16"/></div></figure><p id="b8fb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><em class="jh">出自</em> <a class="ae ke" href="https://ecc2017.cs.ru.nl/slides/ecc2017school-costello.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="jh">基于超奇异同源的密码学介绍</em> </a></p><p id="c964" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated"><em class="jh">同源</em>是将一条椭圆曲线转换成另一条椭圆曲线的函数，使得第一条曲线的群结构反映在第二条曲线中。对于那些熟悉群论的人来说，它是一个群同态，带有一些<a class="ae ke" href="https://en.wikipedia.org/wiki/Morphism_of_algebraic_varieties" rel="noopener ugc nofollow" target="_blank">添加的结构来处理每条曲线</a>的几何形状。当我们把注意力限制在<a class="ae ke" href="https://en.wikipedia.org/wiki/Supersingular_elliptic_curve" rel="noopener ugc nofollow" target="_blank">超奇异椭圆曲线</a>(这里不做定义)时，保证每条曲线都有固定数量的从它到其他超奇异曲线的同源。</p><p id="226e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">现在，考虑通过从我们的起始曲线检查这个形式的所有同源，然后从那些曲线检查所有同源，等等而创建的图。这个图被证明是高度结构化的，如果我们从第一条曲线开始随机行走，碰到其他特定曲线的概率可以忽略不计(除非我们采取指数级的许多步骤)。在数学术语中，我们说通过检查所有这些同源生成的图是一个<a class="ae ke" href="https://people.seas.harvard.edu/~salil/pseudorandomness/expanders.pdf" rel="noopener ugc nofollow" target="_blank">扩展图</a>(也是<a class="ae ke" href="https://mast.queensu.ca/~murty/ramanujan.pdf" rel="noopener ugc nofollow" target="_blank"> Ramanujan </a>)。这种扩展特性正是基于同源的密码术安全的原因。</p><p id="0066" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">对于<a class="ae ke" href="https://en.wikipedia.org/wiki/Supersingular_isogeny_key_exchange" rel="noopener ugc nofollow" target="_blank">超奇异同源Diffie-Hellman </a> (SIDH)方案，密钥是同源链，公钥是曲线。当Alice和Bob组合这些信息时，他们获得不同的曲线，但是具有相同的<a class="ae ke" href="https://en.wikipedia.org/wiki/J-invariant" rel="noopener ugc nofollow" target="_blank"> j不变量</a>。对于密码学来说，j不变量是什么并不重要，重要的是，一旦Alice和Bob完成了密钥交换，他们就可以很容易地计算出j不变量。</p><p id="dcb5" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">与其他后量子方案相比，基于同源的密码术具有极小的密钥大小，仅使用330字节的公钥。不幸的是，在本文讨论的所有技术中，它们是最慢的，<a class="ae ke" href="https://blog.cloudflare.com/sidh-go/" rel="noopener ugc nofollow" target="_blank">密钥生成和共享秘密计算都需要11-13毫秒</a>。然而，它们支持完美的前向保密性，这是其他后量子密码系统所不具备的。</p><h1 id="a188" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">基于哈希的签名</h1><p id="56be" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">已经有许多<a class="ae ke" href="https://blog.cryptographyengineering.com/2018/04/07/hash-based-signatures-an-illustrated-primer/" rel="noopener ugc nofollow" target="_blank">友好地介绍了基于散列的签名</a>，所以我们保持对它们的讨论在相当高的层次上。简而言之，散列签名使用散列函数的输入作为秘密密钥，输出作为公共密钥。这些密钥只对一个签名有效，因为签名本身揭示了部分密钥。这种基于哈希的签名的极端低效导致了使用<a class="ae ke" href="https://en.wikipedia.org/wiki/Merkle_tree" rel="noopener ugc nofollow" target="_blank"> Merkle树</a>来减少空间消耗(是的，比特币中使用的是相同的Merkle树)。</p><p id="531c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">不幸的是，不可能从散列中构造出KEM或公钥加密方案。因此，基于哈希的签名不是一个完整的后量子密码解决方案。此外，它们不节省空间；一个更有前途的签名方案，<a class="ae ke" href="https://sphincs.cr.yp.to/sphincs-20150202.pdf" rel="noopener ugc nofollow" target="_blank"> SPHINCS </a>，产生41kb的签名和1kb的公钥/私钥。另一方面，基于散列的方案速度极快，因为它们只需要计算散列函数。它们还具有非常强的安全性证明，仅仅基于存在抗冲突和抗原像的散列函数的假设。由于没有迹象表明当前广泛使用的散列函数(如SHA3或BLAKE2)容易受到这些攻击，因此基于散列的签名是安全的。</p><h1 id="60a4" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated">外卖食品</h1><p id="e8ec" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">后量子密码术是一个令人难以置信的令人兴奋的研究领域，在过去的十年里取得了巨大的发展。虽然这篇文章中描述的四种类型的密码系统已经得到了很多学术上的关注，但没有一种被NIST批准，因此还不推荐普遍使用。许多方案在其原始形式下并不具有高性能，并且已经进行了各种优化，这些优化可能会也可能不会影响安全性。事实上，为McEliece系统使用更节省空间的代码的几次尝试已经被证明是不安全的。照目前的情况来看，要从后量子密码系统获得最佳的安全性，需要牺牲一些空间或时间。就灵活性而言，基于环格的加密是最有前途的工作方式(签名和KEM，以及全同态加密)，但它所基于的假设只是在几年前才得到深入研究。现在，最安全的赌注是使用McEliece和Goppa码，因为它经受住了几十年的密码分析。</p><p id="3f40" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">然而，每个用例都是独特的。如果你认为你可能需要后量子密码学，<a class="ae ke" href="https://www.trailofbits.com/contact/" rel="noopener ugc nofollow" target="_blank">与你友好的邻居密码学家联系</a>。其他人应该等到NIST完成标准化进程。</p><p id="be31" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt">— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><h1 id="daf1" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated"><strong class="ak">注意事项</strong></h1><p id="b966" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">不仅如此，关键不是量子计算和计算机，而是后量子密码术，它依赖于经典计算，在今天也非常适用(作为一种预防措施，这样量子计算机的可能出现就不会危及密码术)。在这篇文章中，格、码、同源、基于散列的签名都得到了很好的解释，但是，有几个问题我们觉得应该提出来。</p><h1 id="7f20" class="ki kj hu bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf dt translated"><strong class="ak">评论</strong></h1><p id="fb3b" class="pw-post-body-paragraph jf jg hu ji b jj lg jl jm jn lh jp jq kf li jt ju kg lj jx jy kh lk kb kc kd hn dt translated">1.“量子系统完全知道物体的动量和位置”——这似乎是一个可疑的说法。这个想法在20世纪20-30年代确实存在，它被称为隐藏变量理论，但是，有大量的实验表明这些理论不起作用。根据更现代的观点，关于动量和位置的完整知识是不存在的。</p><p id="df4f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">2.“除非有人找到分解大整数的多项式时间算法，否则对于当前的最佳实践来说，这种风险是最小的”——现在很少使用加密分解(RSA)。几乎所有的非对称加密都与离散对数化问题有关。</p><p id="8112" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">3.“快速分解大数的能力会破坏RSA和基于离散对数的密码学”——这与上一段中的观点一致。快速看了一下，好像没那么简单(可能有我们不知道的)。从参考文献中，我们找到了Eric Bach的作品“离散对数和因式分解”，他在其中做出了类似的陈述，但关于不同的事情:因式分解，从我们的理解来看，并没有解决一般情况下(如实践中)群序是大素数的情况。因此，在讨论这个问题时，也许需要稍微谨慎一点。在量子计算的情况下，你真的可以使用相同算法(Shor算法)的修改来寻找周期例程，但是对于一般的经典任务简化来说，这是值得怀疑的。</p><p id="886e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq kf js jt ju kg jw jx jy kh ka kb kc kd hn dt translated">4.作者经常提到NP-hard类和关于多项式计算时间的推理。这些结构很漂亮，但现在或多或少地清楚了，在密码学中应该小心使用它们。我们对一般复杂的问题更感兴趣，而不是那些复杂的问题只是偶尔出现。此外，即使问题可以在多项式时间内解决，但多项式的次数非常大，在实践中问题仍然是不可解的，可以用于密码学。</p></div></div>    
</body>
</html>