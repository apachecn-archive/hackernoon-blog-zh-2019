<html>
<head>
<title>DIY Redux with RxJS: Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS的DIY Redux:第3部分</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/diy-redux-with-rxjs-part-3-87eaf23d4092?source=collection_archive---------24-----------------------#2019-01-15">https://medium.com/hackernoon/diy-redux-with-rxjs-part-3-87eaf23d4092?source=collection_archive---------24-----------------------#2019-01-15</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/8404a87ec09016c896904ead515ef2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBO29FpCIE8eeZ_hhBhVSA.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://unsplash.com/photos/iVGevPcaJzk?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steve Halama</a> on <a class="ae jg" href="https://unsplash.com/search/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7887" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><em class="kf">到目前为止，在之前的两篇帖子中，我已经涵盖了“如何用RxJS创建Redux库”和“如何编写Redux中间件”这两个主题。在开始这个系列的第三部分也是最后一部分之前，我建议你检查一下下面的前两部分:</em></p><div class="kg kh fm fo ki kj"><a href="https://hackernoon.com/diy-redux-with-rxjs-rxdx-23163a87ade1" rel="noopener  ugc nofollow" target="_blank"><div class="kk ab ej"><div class="kl ab km cl cj kn"><h2 class="bd hv fv z el ko eo ep kp er et ht dt translated">带RxJS的DIY Redux with RxJS</h2><div class="kq l"><h3 class="bd b fv z el ko eo ep kp er et ek translated">一个结合RxJS和所有Redux助手库的实验，创建一个“具有与Redux相似指纹的React的状态管理”。</h3></div><div class="kr l"><p class="bd b gc z el ko eo ep kp er et ek translated">hackernoon.com</p></div></div><div class="ks l"><div class="kt l ku kv kw ks kx ja kj"/></div></div></a></div><div class="kg kh fm fo ki kj"><a href="https://hackernoon.com/diy-redux-with-rxjs-part-2-f9d4c53fa230" rel="noopener  ugc nofollow" target="_blank"><div class="kk ab ej"><div class="kl ab km cl cj kn"><h2 class="bd hv fv z el ko eo ep kp er et ht dt translated">使用RxJS的DIY Redux:第2部分</h2><div class="kq l"><h3 class="bd b fv z el ko eo ep kp er et ek translated">将RxJS和所有广泛使用的Redux中间件合并为一个库的尝试</h3></div><div class="kr l"><p class="bd b gc z el ko eo ep kp er et ek translated">hackernoon.com</p></div></div><div class="ks l"><div class="ky l ku kv kw ks kx ja kj"/></div></div></a></div></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="235f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这一部分，我将创建一个<strong class="jj hv"> HOC </strong>(高阶组件)来连接<strong class="jj hv"> RxDx </strong>和<strong class="jj hv"> React。组件</strong>。我假设你已经知道反应。组件，所以我不会再解释了。但是我需要解释一下特殊情况，这是我将在下面演示的核心。</p><h1 id="56fb" class="lg lh hu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">这些高阶组件到底是什么？</h1><p id="583f" class="pw-post-body-paragraph jh ji hu jj b jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka mi kc kd ke hn dt translated">基本上，HOC是一个类<strong class="jj hv">装饰器</strong>。但是什么是班级装饰者呢？有时当我们编码时，我们开始觉得我们创建的所有类都有相同的基本属性。在那一点上，我们意识到我们在重复自己，这完全违背了<strong class="jj hv">干</strong>法则。所以我们开始试图找到一种方法来分离重复的部分。或者当我们编码时，我们需要在不改变实现的情况下向类中添加一个特性。在这两种情况下，我们的目的是实现类之间的代码共享。所以对我们上面描述的问题最好的答案是一个<strong class="jj hv">类工厂函数</strong>。</p><p id="03e0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">类工厂函数是返回类的函数。(欢迎来到javascript世界的怪异之处)。</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="9ddd" class="ms lh hu mo b fv mt mu l mv mw">// the most primitive description of a class factory function<br/>function <strong class="mo hv">giveMeClass</strong>(someArguments) {<br/>   return class <strong class="mo hv">SomeDynamicallyGeneratedClass</strong> {}<br/>}</span></pre><p id="7e62" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">原始的类工厂函数还不是类装饰器。作为一个类装饰器，类工厂函数需要一个类作为参数，返回/产生的类将是输入类的扩展版本:</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="325b" class="ms lh hu mo b fv mt mu l mv mw">//enhance decorator<br/>function <strong class="mo hv">ehance</strong>(targetClass) {<br/>   return class <strong class="mo hv">EnhancedClass</strong> extends <strong class="mo hv">targetClass</strong> {<br/>      constructor() {<br/>         this.isEnhanced = true;<br/>      }<br/>}</span><span id="c6fa" class="ms lh hu mo b fv mx mu l mv mw">//usage in enviroment where experimental decorators allowed<br/>@enhace<br/>class <strong class="mo hv">Normal</strong> {}</span><span id="cb24" class="ms lh hu mo b fv mx mu l mv mw">console.log(new Normal().isEnhanced) // true</span><span id="2e71" class="ms lh hu mo b fv mx mu l mv mw">//usage in enviroment where experimental decorators not allowed<br/>class <strong class="mo hv">Normal</strong> {}</span><span id="93bf" class="ms lh hu mo b fv mx mu l mv mw">const <strong class="mo hv">Enhanced</strong> = enhance(Normal);</span><span id="e22d" class="ms lh hu mo b fv mx mu l mv mw">console.log(new Enhanced().isEnhanced) // true</span></pre><p id="5d85" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如前所述，特设也是装饰者，其工作方式与类装饰者完全相同。一个<strong class="jj hv"> HOC </strong>接受一个<strong class="jj hv"> React </strong>组件——它是一个类——并返回另一个<strong class="jj hv"> React </strong>组件。关于特设的详细文档，您可以点击下面的链接，但是如果您有心情TL；我将继续对它进行总结:</p><div class="kg kh fm fo ki kj"><a href="https://reactjs.org/docs/higher-order-components.html" rel="noopener  ugc nofollow" target="_blank"><div class="kk ab ej"><div class="kl ab km cl cj kn"><h2 class="bd hv fv z el ko eo ep kp er et ht dt translated">高阶组件-反应</h2><div class="kq l"><h3 class="bd b fv z el ko eo ep kp er et ek translated">高阶组件(HOC)是React中重用组件逻辑的一种高级技术。hoc不属于…</h3></div><div class="kr l"><p class="bd b gc z el ko eo ep kp er et ek translated">reactjs.org</p></div></div><div class="ks l"><div class="my l ku kv kw ks kx ja kj"/></div></div></a></div><p id="676d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在是时候扩展上面的装饰器示例了，通过用一个<strong class="jj hv"> React组件</strong>替换类输入和输出，使其成为一个<strong class="jj hv">特设的</strong>。我必须提到，使用React组件作为输入/输出为我们提供了两个机会，但是我将继续使用推荐的一个，用另一个组件包装原始组件:</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="054a" class="ms lh hu mo b fv mt mu l mv mw">// a primitive HOC which makes A component great nothing :)<br/>function <strong class="mo hv">makeGreat</strong>(WrappedComponent) {<br/>   return class <strong class="mo hv">EnhancedComponent</strong> extends <strong class="mo hv">React.Component</strong> {<br/>      constructor() {<br/>         this.state = {isGreat: true}<br/>      }</span><span id="5407" class="ms lh hu mo b fv mx mu l mv mw">      render() {<br/>         return &lt;<strong class="mo hv">WrappedComponent</strong> {...this.props, ...this.state} /&gt;<br/>      }<br/>   }<br/>}</span><span id="e8c8" class="ms lh hu mo b fv mx mu l mv mw">// usage<br/>class <strong class="mo hv">LameComponent</strong> extends <strong class="mo hv">React.Component</strong> {<br/>   render() {<br/>      return &lt;div&gt;{this.props.isGreat? 'Great': 'Lame'}&lt;/div&gt;<br/>   }<br/>}</span><span id="671f" class="ms lh hu mo b fv mx mu l mv mw">const <strong class="mo hv">GreatComponent</strong> = <strong class="mo hv">makeGreat</strong>(LameComponent);</span><span id="bcda" class="ms lh hu mo b fv mx mu l mv mw">&lt;<strong class="mo hv">LameComponent</strong> /&gt; // this will render &lt;div&gt;Lame&lt;/div&gt;<br/>&lt;<strong class="mo hv">GreatComponent</strong> /&gt; // this will render &lt;div&gt;Great&lt;/div&gt;</span><span id="fcf9" class="ms lh hu mo b fv mx mu l mv mw">// alternative usage if experimental decorators are allowed<br/>@makeGreat<br/>class <strong class="mo hv">LameComponent</strong> extends <strong class="mo hv">React.Component</strong> {<br/>   render() {<br/>      return &lt;div&gt;{this.props.isGreat? 'Great': 'Lame'}&lt;/div&gt;<br/>   }<br/>}</span><span id="614b" class="ms lh hu mo b fv mx mu l mv mw">&lt;<strong class="mo hv">LameComponent</strong> /&gt; // this will render &lt;div&gt;Great&lt;/div&gt;</span></pre><p id="1e59" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我相信我们现在需要更深入，所以系好安全带。在这一点上，你仍然不知道<strong class="jj hv"> RxDx </strong>你可以从这个<a class="ae jg" href="https://github.com/onerzafer/rxdx" rel="noopener ugc nofollow" target="_blank">链接</a>来检查它，因为我将解释如何连接<strong class="jj hv"> RxDx </strong>到<strong class="jj hv"> React。组件</strong>。</p><h1 id="2354" class="lg lh hu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">用React组件缝合RxDx:一个真实的HOC示例</h1><p id="22e0" class="pw-post-body-paragraph jh ji hu jj b jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka mi kc kd ke hn dt translated">你还记得<a class="ae jg" href="https://hackernoon.com/diy-redux-with-rxjs-part-2-f9d4c53fa230" rel="noopener ugc nofollow" target="_blank">零件2 </a>和<strong class="jj hv">商店的<strong class="jj hv">选择器</strong>吗？这是它们派上用场的时刻，因为我们将使用它们作为<strong class="jj hv"> RxDx </strong>和<strong class="jj hv"> React之间的粘合剂。组件</strong>。获取一个选择器或一系列字符串，并返回一个可观察值，以允许我们在状态更新时得到通知。我们可以在<strong class="jj hv"> componentDidMount </strong>中订阅所有这些可观测量，并且在每次更新时，我们可以使用<strong class="jj hv"> forceUpdate </strong>重新呈现组件，为了防止内存泄漏，我们必须取消订阅<strong class="jj hv"> componentWillUnmount: </strong>中的所有订阅</strong></p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="fd04" class="ms lh hu mo b fv mt mu l mv mw">class <strong class="mo hv">SomeUglyComponent</strong> extends <strong class="mo hv">Component</strong> {<br/>   <strong class="mo hv">componentDidMount</strong>() {<br/>      this.subscription = store<br/>          .select(someSelector)<br/>          .subscribe((update) =&gt; {<br/>             this.setState({data: update});<br/>             this.forceUpdate();<br/>   }<br/>   <strong class="mo hv">componentWillUnmount</strong>() {<br/>      this.subscription.unsubscribe();<br/>   }<br/>   <strong class="mo hv">render</strong>() {<br/>      return (&lt;div&gt;{ this.state.data }&lt;/div&gt;);<br/>   }<br/>}</span></pre><p id="7fb3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">好吧，我不得不承认这是可行的，但是<strong class="jj hv">有些难看的组件</strong>并不难看，因为我们只有一个。让我们想象一下，我们必须实现这样的组件几十次，几百次。现在看起来更丑了吧？这个重复任务需要一个通用的解决方案，并且<strong class="jj hv"> SomeUglyComponent </strong>应该尽可能简单，这样我们就可以把它叫做<strong class="jj hv"> SimpleAndNiceComponent </strong>。期望的<strong class="jj hv"> SimpleAndNiceComponent </strong>如下:</p><pre class="mj mk ml mm fq mn mo mp mq aw mr dt"><span id="6992" class="ms lh hu mo b fv mt mu l mv mw">const <strong class="mo hv">SimpleAndNiceComponent</strong> = <strong class="mo hv">connect</strong>({<br/>   data: store.select(someSlector)<br/>})(({data}) =&gt; &lt;div&gt; {data} &lt;/div&gt;);</span><span id="047e" class="ms lh hu mo b fv mx mu l mv mw">//or<br/>@<strong class="mo hv">connect</strong>({<br/>   data: store.select(someSlector),<br/>})<br/>class <strong class="mo hv">SimpleAndNiceComponent</strong> extends <strong class="mo hv">Component</strong> {<br/>   <strong class="mo hv">render</strong>() {<br/>      const {data} = this.props;<br/>      return &lt;div&gt; {data} &lt;/div&gt;;<br/>   }<br/>}</span></pre><p id="13ed" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么，我们如何实现这种简单性，以及如何将可观察物与道具联系起来呢？答案就藏在<strong class="jj hv"> HOC </strong> s里面，我们需要比简单的<strong class="jj hv"> HOC </strong>更进一步，我们需要的是<strong class="jj hv"> HOC </strong>工厂。我将实现一个<strong class="jj hv"> connect </strong>函数，它接受观察值并返回一个<strong class="jj hv"> HOC </strong>，后者接受<strong class="jj hv"> React。组件</strong>并返回一个增强/包装的<strong class="jj hv"> React。组件:</strong></p><figure class="mj mk ml mm fq iv"><div class="bz el l di"><div class="mz na l"/></div></figure><p id="dfa6" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了清楚起见，上面的例子被简化了。当然，如果我们需要将它用于生产，我们必须更多地考虑<em class="kf">边缘用例</em>和<em class="kf">可调试性</em>以及<em class="kf">错误预防和恢复</em>策略。尽管这是一个简化，但这段代码将会完成这个任务，并允许我们用一个通用的连接机制编写更简单的组件，该机制具有observables的异步特性和<strong class="jj hv"> React的同步特性。组件</strong>。</p><h1 id="18f3" class="lg lh hu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md dt translated">最后，最后，最后的话</h1><p id="34b0" class="pw-post-body-paragraph jh ji hu jj b jk me jm jn jo mf jq jr js mg ju jv jw mh jy jz ka mi kc kd ke hn dt translated">是的，我们终于有了一个完全相同的库。我只能说，我在这个实验中学到了很多，我想分享它，希望我的旅程能帮助别人。下一步将是使用它，种植它，爱它！</p><p id="e932" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你能读到这一点，并和我一起完成这个实验，我将非常高兴。非常感谢你！请不要忘记<strong class="jj hv">鼓掌</strong>或在下方留下你的<strong class="jj hv">评论。</strong></p></div><div class="ab cl kz la hc lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="hn ho hp hq hr"><p id="8a7f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你想为我的实验做贡献，并帮助我把它变成一个真正的图书馆，可以解决现实生活中的问题，不要犹豫，点击下面的链接，并作出贡献。你只会受到欢迎！</p><div class="kg kh fm fo ki kj"><a href="https://github.com/onerzafer/rxdx" rel="noopener  ugc nofollow" target="_blank"><div class="kk ab ej"><div class="kl ab km cl cj kn"><h2 class="bd hv fv z el ko eo ep kp er et ht dt translated">onerzafer/rxdx</h2><div class="kq l"><h3 class="bd b fv z el ko eo ep kp er et ek translated">基于rxjs的react类redux库。在GitHub上创建帐户，为onerzafer/rxdx开发做出贡献。</h3></div><div class="kr l"><p class="bd b gc z el ko eo ep kp er et ek translated">github.com</p></div></div><div class="ks l"><div class="nb l ku kv kw ks kx ja kj"/></div></div></a></div></div></div>    
</body>
</html>