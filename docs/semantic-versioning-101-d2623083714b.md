# 语义版本 101

> 原文：<https://medium.com/hackernoon/semantic-versioning-101-d2623083714b>

[语义](https://hackernoon.com/tagged/semantic)版本 2 . 0 . 0(【semver.org】T2)是一个健壮的基本标准，它封装了关于你正在发布或消费的[软件](https://hackernoon.com/tagged/software)的大量信息。

开源老手知道并理解这个标准的重要性。如果你已经在长期维护模式下运行了一个项目，你会以某种方式意识到它的力量。尽管如此，热情的、快速行动的开发团队喜欢找到绕过这个标准的方法。我见过不少工程师决定围绕主要、次要和补丁增量发明他们自己的想法。他们的基本原理植根于美学或他们自己的发布时间表。

![](img/7cc04da38ea1a917b7e0503401c156b1.png)

# 一个关键原则

除了在[semver.org](https://semver.org/)获得简明完整的信息外，了解以下内容也很重要:

## 语义版本化是为你的消费者准备的。这不是为了你的发布时间表或你的营销计划。

这说明了语义版本化的一个最大的误用。开发人员和产品经理真的想等待 X.Y 的大发布，尽管事实上他们几个月来一直在引入突破性的变化并增加补丁。

*注意:围绕发布时间表计划突破性的变化是不同的事情。这是很好的项目管理。我说的是那些破坏功能并增加补丁的团队，因为这种突破性的改变不会“影响太多的消费者”或者“没有那么重要”*

下面是一些例子，说明您将会遇到的一些棘手的版本控制情况。

# 主要版本

[semver.org](http://semver.org)摘要中的第 1 条:**当您做出不兼容的 API 更改时的主要版本。**

这里有三个模块变化的例子。其中只有一项是主要增量:

![](img/afd966b369595b6a57c845cbff5ca462.png)

Major version examples

## 模块的 API 中添加了一个新的公共方法。

*为了便于讨论，我们假设顶部>底部>没有为这个公共方法*引入突破性的变化。这是次要版本增量的规范定义。我理解来自沟通方面的压力。如果你做了巨大的、不间断的改变，宣传 2.0.0 版本比 1.3.0 版本听起来要好得多。代表你的消费者，最好知道有一个安全的升级途径。对于处于维护模式的应用程序来说尤其如此。

## 现有 API 方法的默认参数已从 true 更改为 false。

这是一个微小的变化。与上一个例子相反，您的直觉可能不想引起对主要版本增量的微小变化的注意。作为一个心理测试，任何可能打破现有消费者正在进行的用例的东西都应该是一个主要的版本增量。不要落入陷阱，把这个偷偷放进补丁或次要版本。

## 上一个次要版本中的一个问题得到了修复:文件创建方法抛出了空指针错误。

这是一个典型的补丁增量示例。新功能是对现有功能的回归。我们将在下一节详细讨论补丁版本。

# 次要版本

semver.org[总结中的第 2 点:**以向后兼容的方式添加功能时的次要版本。**](http://semver.org)

![](img/4d700b004f88043ff244202d8977bd82.png)

Minor version examples

## 一个新的外部配置生成器可用于简化 API 设置。

新功能，无重大变化。我曾设想这是一个帮助消费者构建复杂配置的方法或构造器。然后，该配置以完全向后兼容的方式传递。假设你已经满足兼容性栏，这是一个很好的次要版本。

## API 的配置过程已经简化，几个关键属性已经重命名。

更名、变更、精简>>所有预示着可能的重大增量的词。对于公共方法来说，显然就是这样。当您只重构了内部功能时，也有例外。配置属性是公共的。这不是向后兼容的更改。这是一个重大的进步。

## 一些内部功能已经过优化，以提高 API 性能。

Semver.org 说“私有代码中大量的新功能或改进”可能是小版本增加的原因。他们把决策权留给了开发商。我不会害怕使用较小的版本增量来表示性能的提高。我总是希望我的消费者感觉到**需要**升级到最新的补丁。他们应该**希望**升级到最新的次要版本。

# 补丁版本

来自[semver.org](http://semver.org)的总结中的第 3 点:**当你做向后兼容的错误修复时的补丁版本。**

![](img/07e835afd597144efb2b7b25a14a9029.png)

Patch version examples

## 修复一个已经存在了几个次要发布周期的问题:。csv 文件是用。txt 扩展名。

这不是倒退。完全有可能一些消费者已经将这种公共行为融入到他们的工作流程中(参见 [xkcd](https://xkcd.com/1172/) )。虽然从项目计划的角度来看这是一个 bug。这是一个大幅度增加的例子。我建议将这样的变化与其他“必要的”功能中断捆绑到一个版本中。

## 修复最新主要版本引入的配置属性中的一个拼写错误。

这是一个非常讨厌的问题。根据标准的严格定义，这是一个重大的发布。想象一下，您可能因为一些草率的输入和审查而在一夜之间从 2.0.0 >> 3.0.0。尽管如此，一个有适当测试的项目应该能捕捉到这样的事情。那是一个单独的话题，但是这个例子应该作为一个警告。

## 修正了最近的一个问题，当请求法语时，意外地将英语翻译成西班牙语。

到目前为止，有些东西一直在按预期工作。或大或小的增量出现了，现在法国消费者看到了西班牙语。这是一个补丁的好例子。没有消费者选择这种错误的行为。这不是新功能(除非你一开始就不支持法语)。这是一个补丁的好例子。

# 平静地走出去做版本

本周，我正在编写一个一次性脚本，需要一个可以将 JSON 写入文件的日志记录器。我通过 npm 抢到了流行的[温斯顿](https://www.npmjs.com/package/winston)图书馆。最新的 3.2.1 库已自动安装。我从一个 2-3 年前的项目中复制了一个现有的安装脚本。

旧项目已被锁定在 2.x.x 版本中。我的伐木机结构坏了。没关系，我将我的依赖性降级到 2.x.x，并继续我的一次性脚本。

我看了**号**的发行说明。我做了**而不是**去堆栈溢出。我没有**而不是**去浏览代码。正确应用的语义版本告诉了我我需要知道的一切。

我在我的@Trello 板上添加了一个任务，以便将来升级我的日志程序(以及为什么不把它做得更好，等等。).现在，我可以平静地回去工作了。