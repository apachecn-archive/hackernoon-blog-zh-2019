<html>
<head>
<title>Building a Twitter Bot Tracking ERC-20 Token Transfers with Node.js, Heroku and crypto APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Node.js、Heroku 和 crypto APIs 构建一个跟踪 ERC-20 令牌传输的 Twitter Bot</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-twitter-bot-tracking-erc-20-token-transfers-with-node-js-heroku-and-crypto-apis-8cf618a3f287#2019-02-03">https://medium.com/hackernoon/building-a-twitter-bot-tracking-erc-20-token-transfers-with-node-js-heroku-and-crypto-apis-8cf618a3f287#2019-02-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/317652983baecf9b87a74623d3621c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rUUW2gNEJh4FUijf"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Photo by <a class="ae ih" href="https://unsplash.com/@hauntedeyes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lukas</a> on <a class="ae ih" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="034d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">一个推特机器人在推特上发布重大的 ERC-20 代币转让怎么样？这些信息可能会引起交易者的兴趣，或者对黑客攻击和退出骗局发出实时警报。</p><p id="bdde" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在本指南中，我们将了解如何跟踪代币转账，如何在推特上发布相关信息，以及如何在 Heroku 上免费托管机器人。</p><p id="6faa" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该机器人在<a class="ae ih" href="https://twitter.com/erc20events" rel="noopener ugc nofollow" target="_blank"> @erc20events </a>运行，源代码可在<a class="ae ih" href="https://github.com/borxes/erc20transfers-bot" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><h1 id="1cbd" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">先决条件</h1><p id="7b42" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">为了遵循这个指南，你需要为你的机器人准备一个 Twitter 账户，一个免费的<a class="ae ih" href="https://heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a>账户和<a class="ae ih" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node.js </a>在你的开发机器上。</p><h1 id="659b" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">获得一个 Twitter 开发者账户</h1><p id="0e37" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在你创建了一个新的 Twitter 账户后，<a class="ae ih" href="https://developer.twitter.com/en/apply-for-access.html" rel="noopener ugc nofollow" target="_blank">申请访问</a>开发者平台。填写所有必要的细节，然后等待 Twitter 批准你。通常需要 24-48 小时。一旦获得批准，<a class="ae ih" href="https://developer.twitter.com/en/apps/create" rel="noopener ugc nofollow" target="_blank">创建一个新的应用程序</a>，以便生成 API 密钥和令牌。</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff li"><img src="../Images/237b806363f496f59cd382c0ce94ec4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZMLbWSegiW-Dgs_WvrZxw.jpeg"/></div></div></figure></div><div class="ab cl ln lo hc lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hn ho hp hq hr"><h1 id="68c9" class="kf kg ik bd kh ki lu kk kl km lv ko kp kq lw ks kt ku lx kw kx ky ly la lb lc dt translated">检测 ERC-20 令牌传输</h1><p id="6734" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">在这个项目中，我选择了市值最高的 12 个 ERC 20 强股票，并将它们保存在一个 Javascript 数组中:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="81a2" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于名单很短，我只是从<a class="ae ih" href="https://etherscan.io" rel="noopener ugc nofollow" target="_blank"> Etherscan </a>上复制粘贴了他们的合同地址。</p><p id="ba3d" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">那么我们如何跟踪这些代币的转移呢？每次 ERC-20 令牌传输都会发出一个 transfer()事件。自然的方法是使用 web3.js 库来<a class="ae ih" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#contract-events" rel="noopener ugc nofollow" target="_blank">订阅</a>这些事件，并在每次被跟踪的 ERC-20 契约发出事件时，直接由区块链(通过 Infura 的基础设施)通知，如下所示:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="89d4" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这种方法只有一个问题。首先，我们必须通过 web 套接字连接到 Infura:</p><pre class="lj lk ll lm fq mb mc md me aw mf dt"><span id="fb1e" class="mg kg ik mc b fv mh mi l mj mk">const web3 = new Web3(<br/> new Web3.providers.WebsocketProvider(‘wss://mainnet.infura.io/ws’)<br/>);</span></pre><p id="0ee5" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">根据我的经验，这种连接对于频繁获得通知来说并不是最可靠的。由于我们的机器人将被托管在 Heroku 上(Heroku 每天重新启动它的实例)，我们需要一个更可靠的解决方案。</p><p id="eb9c" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这个解决方案就是<a class="ae ih" href="https://ethplorer.io" rel="noopener ugc nofollow" target="_blank"> Ethplorer.io </a>提供的免费<a class="ae ih" href="https://github.com/EverexIO/Ethplorer/wiki/Ethplorer-API" rel="noopener ugc nofollow" target="_blank"> API </a>。具体来说，<code class="eh ml mm mn mc b">getTokenHistory</code>端点返回任何令牌操作的数组。它可以按操作类型(在我们的例子中是转移)和时间进行过滤。</p><p id="022b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">比如这个调用<a class="ae ih" href="http://api.ethplorer.io/getTokenHistory/0xB8c77482e45F1F44dE1745F52C74426C631bDD52?apiKey=freekey&amp;type=transfer&amp;limit=5" rel="noopener ugc nofollow" target="_blank">http://API . eth plorer . io/getTokenHistory/0 XB 8 c 77482 e 45 f1 f 44 de 1745 f 52 c 74426 c 631 BDD 52？API key = free key&amp;type = transfer&amp;limit = 5</a>将返回最近五次 BNB 令牌传输。这正是我们所需要的。</p><h1 id="5a40" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">计算 ERC-20 令牌传输的价值</h1><p id="daa6" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们已经看到了如何轮询 Ethplorer API，并获得每个令牌协定地址的最新 ERC-20 令牌传输。但我们只对大额转账感兴趣，比如价值超过 25，000 美元的代币转账。</p><p id="4b13" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了计算转让的价值，我们需要将转让的代币数量乘以代币的现行汇率。</p><p id="049b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">方便的是，Ethplorer 的 API 在响应<code class="eh ml mm mn mc b">getTokenHistory</code> API 调用时返回一个<code class="eh ml mm mn mc b">tokenInfo</code>对象。该对象包含令牌的更新价格信息。但是有一个问题。对于一些有趣的令牌，如 REP(auger)和 HOT(赫萝)，价格信息不会返回。</p><p id="08f6" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">为了解决这个问题，我们可以使用<a class="ae ih" href="https://min-api.cryptocompare.com" rel="noopener ugc nofollow" target="_blank"> CryptoCompare API </a>。免费层每月为您提供 100，000 次通话，这足以每天检索我们的代币当前价格。</p><p id="e3d1" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在初始化我们的 bot 时，我们将简单地为令牌数组中的每个令牌调用 CryptoCompare API 的<code class="eh ml mm mn mc b">/data/price</code>端点，并保存我们得到的价格。我们只需要做一次，因为 Heroku 每天都会重启实例，所以价格会每 24 小时更新一次。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="8006" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们有了所有的代币利率，我们可以很容易地计算出我们检测到的每笔代币交易的价值，并只在推特上发布重要的交易。</p><h1 id="7117" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">使用 setInterval()进行连续传输跟踪</h1><p id="000f" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">知道了如何询问代币转账并计算其价值，我们现在可以将它们联系起来:</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="c854" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这段代码完成了持续跟踪特定 ERC-20 令牌传输的所有工作。我们调用 Ethplorer API 并询问最近一分钟发生的所有传输，然后我们将每个接收到的<em class="mo">操作</em>发送给提供的回调。</p><p id="fc15" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">对 Ethplorer API 的调用被包装在<code class="eh ml mm mn mc b">setInterval</code>中，以执行以固定时间延迟重复的调用。时间间隔是随机的，这样我们就不会用大量的调用来轰炸 API。</p><h1 id="8bb5" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">过滤重要的传输</h1><p id="744d" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我们已经看到，对于每个检测到的令牌传输，都会调用一个回调。这个回调函数需要计算一次转移的价值，并且只有当这个价值超过我们的阈值时才发布消息。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><p id="ea95" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在这里，我们将转移的代币的数量转换为规范化的形式，同时考虑到每个代币定义的小数。大多数 ERC-20 代币有 18 位小数(就像以太坊本身一样)，但有些没有:USDC 稳定硬币只定义了 6 位，而 Zilliqa 有 12 位，所以我们必须考虑这一点。</p><p id="ce24" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">接下来，我们将转移的代币数量乘以价格并获得值。如果它超过了阈值(目前是 50000 美元),我们就构造一个消息字符串并发布出去。</p><p id="d313" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们还保存了交易散列，这样我们就不会不止一次地发布关于同一笔转账的消息。</p><h1 id="dae6" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">简单的推特行为</h1><p id="1514" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">请看这篇关于如何用 node.js 连接 Twitter API 的信息丰富的<a class="ae ih" href="https://codeburst.io/build-a-simple-twitter-bot-with-node-js-in-just-38-lines-of-code-ed92db9eb078" rel="noopener" target="_blank">文章</a></p><p id="e11b" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">它简明地描述了如何生成 Twitter API 键并在我们的 bot 中使用它们。一旦我们有了这些，我们就可以简单地在推特上发布任何消息(为了更好地衡量，还可以将它记录到控制台上):</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><h1 id="772b" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">将这一切结合在一起</h1><p id="7f84" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">要连接所有这些部分，我们需要做的就是从。env 文件，用它们的价格初始化令牌并开始跟踪它们。</p><figure class="lj lk ll lm fq hw"><div class="bz el l di"><div class="lz ma l"/></div></figure><h1 id="90aa" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">在 Heroku 上部署 Twitter 机器人</h1><p id="76c5" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">我已经在<a class="ae ih" href="https://heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a>上注册了这个机器人，创建了一个新的应用程序，并将其连接到机器人的 Github repo。</p><p id="4a00" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">Heroku 需要做两处修改:</p><ol class=""><li id="37b4" class="mp mq ik jj b jk jl jo jp js mr jw ms ka mt ke mu mv mw mx dt translated">将“Procfile”添加到 repo 的根目录。这个<a class="ae ih" href="https://heroku.com" rel="noopener ugc nofollow" target="_blank">文件</a>让 Heroku 知道这是一个工作进程，而不是一个 web 应用程序，它只有一行代码:</li></ol><pre class="lj lk ll lm fq mb mc md me aw mf dt"><span id="27b2" class="mg kg ik mc b fv mh mi l mj mk">worker: node app.js</span></pre><p id="d394" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.我们不能再使用<code class="eh ml mm mn mc b">dotenv</code>模块从。环境文件。很自然。env 文件不会上传到 Github，也不会部署到 Heroku。简单的解决方案是在 Heroku 的应用程序设置页面上手动将秘密定义为配置变量:</p><figure class="lj lk ll lm fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff my"><img src="../Images/8978e1d046e820631701409205ebf17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BpHF3knRC8Ep4Rgdf-zaQ.jpeg"/></div></div></figure><h1 id="f67e" class="kf kg ik bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">结果</h1><p id="e993" class="pw-post-body-paragraph jh ji ik jj b jk ld jm jn jo le jq jr js lf ju jv jw lg jy jz ka lh kc kd ke hn dt translated">ERC-20 转会追踪器<a class="ae ih" href="https://twitter.com/erc20events" rel="noopener ugc nofollow" target="_blank">机器人</a>已经运行了几天，发了 301 条推文，已经有了 10 个追随者。</p><p id="eeec" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">可以做一些事情来改善它，例如使推文在视觉上更具吸引力，并过滤掉稳定的币币转账。</p><p id="969a" class="pw-post-body-paragraph jh ji ik jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">如果你有任何问题或建议，请在评论中告诉我。</p></div></div>    
</body>
</html>