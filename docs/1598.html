<html>
<head>
<title>Make Illegal States Unrepresentable: Kotlin Data Class Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使非法状态不可再现:科特林数据类版</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/make-illegal-states-unrepresentable-kotlin-data-class-edition-96ec84ad4e29?source=collection_archive---------10-----------------------#2019-03-07">https://medium.com/hackernoon/make-illegal-states-unrepresentable-kotlin-data-class-edition-96ec84ad4e29?source=collection_archive---------10-----------------------#2019-03-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="ef97" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">因为墨菲定律是一种软件工程技术</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/f14d3d2a42582f272f48f0382be3263c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v5W-lpKS7eoTwjic"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Photo by <a class="ae jz" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SpaceX</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="d89f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">墨菲定律和软件工程</h2><p id="18be" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">墨菲定律通常被引用为:“任何可能出错的事情都会出错。”我们当中的学究们会知道，这实际上不是墨菲定律。这是欺诈法则。或Sod的法律。墨菲的实际法则更好地表述为:“如果有两种或更多种方式来做某事，其中一种方式可能导致灾难，那么有人会以那种方式来做。”</p><p id="2e18" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">墨菲定律的起源通常归因于爱德华·a·墨菲，他是1949年美国空军MX981项目的一名工程师。空军想知道如果将脆弱的人体加速到可笑的速度，会发生什么。显然，测试这一点的最佳方法是让人体加速到可笑的速度。所以他们把一个可怜的测试对象绑在雪橇上，把火箭绑在背上，然后发射出去。我敢肯定<em class="lw">我在一部漫步者卡通片里见过。</em></p><p id="29ec" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">为了将这个“实验”从幸灾乐祸转化为科学，他们在测试对象身上安装了16个加速度计。有两种可能的方式来连接传感器。正确的方式，和错误的方式。每个传感器都装错了。所以这毕竟是幸灾乐祸。</p><p id="765a" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">但这也是工程学上的一课，因为如果传感器没有被设计成有两种可能的安装方式，并且其中一种不正确，灾难就不会发生。这个原则可以被推广，当然也适用于软件工程。</p><p id="f37f" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">特别是，如果我们有幸使用类型化语言——让类型尽可能地做更多的工作。编写您的代码，这样就不可能以错误的方式构造对象或调用方法。这不是一个新的想法，但在具有表达类型系统的语言中更容易做到，如OCaml、F#、Scala和<a class="ae jz" href="https://www.idris-lang.org/" rel="noopener ugc nofollow" target="_blank"> Idris </a>。</p><p id="d9a9" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">在这篇文章中，我们将看看科特林。特别是如何简单而有力地将数据类、密封类和空安全结合起来，以消除通常困扰Java程序(以及具有类似特性的语言)的一类错误。</p><h2 id="8004" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">用例:订购信用报告</h2><p id="08a9" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">澳大利亚的企业可以通过澳大利亚企业编号(ABN)或澳大利亚公司编号(ACN)进行唯一识别。所有注册企业都将有一个ACN。首选标识符是ABN，但不是所有的企业都有ABN。由于商业实体和信用报告的复杂性，我们需要通过ABN或ACN识别业务的能力。</p><p id="3f42" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">因为我们是优秀的开发人员，喜欢验证，讨厌<a class="ae jz" href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html" rel="noopener ugc nofollow" target="_blank">字符串类型的</a>编程，所以我们为ABN和ACN创建值类型，就像这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Value classes with validation</figcaption></figure><p id="5f04" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">接下来假设我们需要一个为公司购买报告的方法。我们可以提供ABN或ACN。孤立地考虑，首先想到的可能是重载方法，比如:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="23f0" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">然而，让我们假设我们正在构建一个管道，它需要我们的业务密钥通过多个处理步骤来传递。这很快使重载方法站不住脚。你可能会考虑的下一件事是把两者放在一个参数类中。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Data class with nullable types</figcaption></figure><p id="4d4e" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">就目前而言，那很好。但是如果它们都是空的呢？无论我们的业务关键字放在哪里，我们都会得到这样的代码:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Famous last words…</figcaption></figure><p id="453b" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">你写过这样的代码吗？我当然有。在Java中，这被认为是很好的实践！防御性编程。覆盖你所有的基地。即使是不可能发生的事情。因为，记住墨菲定律，如果它可能以错误的方式发生——它就会发生。通常在凌晨2:00当你需要帮助的时候。</p><p id="cc1c" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">科特林给了我们更好的选择。让我们试着消除那些讨厌的无效支票。</p><h2 id="03a1" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">尝试1:构造函数验证</h2><p id="555f" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">当我们构造一个<code class="eh lz ma mb mc b">OrganizationKey</code>时，我们可以验证至少有一个ACN或ABN存在。它看起来会像这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Constructor validation</figcaption></figure><p id="fcfc" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">老实说，也没好多少。我把这种解决方案称为“把食物铲到你的盘子里”。有时你可以将问题转移到其他地方，但它仍然存在。</p><p id="1269" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">实际上，由于我们使用的是Kotlin数据类，所以一点好处也没有。Kotlin数据类公开了一个“复制”操作符，这使得睡眠不足的开发人员可以做错误的事情，绕过构造函数验证。像这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Damaged data class</figcaption></figure><h2 id="4b1a" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">尝试2:工厂方法</h2><p id="7d70" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">如果您从Java进入Kotlin，另一种可能出现的方法是使用工厂方法。</p><p id="6e1e" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">在科特林，它看起来像下面这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Factory methods</figcaption></figure><p id="ea77" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">事实上，如果你在IntelliJ中尝试这样做，IDE本身会给你一个难看的黄色曲线，说明“copy”方法允许你绕过私有构造函数。所以实际上这个解决方案并不比上面的好。</p><p id="0221" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">您可以将其更改为非数据类，以避免暴露复制方法，但这只是一个遗憾。幸运的是，我们的问题确实有一个简单的解决方案。</p><h2 id="18cb" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">尝试3:密封类</h2><p id="2823" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">让我们子类化<code class="eh lz ma mb mc b">OrganizationKey</code>，给每个子类一个ABN或者一个ACN。然后我们可以使它们不可空。我们应该让它成为一个“密封的”类——原因稍后会解释。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Sealed data class</figcaption></figure><p id="b200" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">那更好！我想我们可能已经破解了。当我们需要使用我们的密钥时，它看起来像这样:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="8d8a" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">请注意这里的“智能转换”。与Java不同，在类型检查之后，您不需要将organization键转换成子类。此外，现在我们已经消除了在ABN或ACN周围有一个可空类型的需要，我们不能意外地构造一个无效的键。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">ABN is no longer nullable.</figcaption></figure><p id="c9b6" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">上面的代码无法编译。任务完成。</p><p id="479a" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">请注意，这并不能保护您免受试图注入bug的恶意参与者的攻击。同样，反射，或者任何进出Java库的东西，尤其是像Hibernate、GSON、Jackson这样的编组和解组的库，都可能让你的战舰沉没。但是您有更强的编译时保证，防止有人意外地以错误的方式使用该对象。</p><p id="280f" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">但是为什么我们需要把<code class="eh lz ma mb mc b">OrganizationKey</code>做成一个密封的类呢？因为有了这个小小的关键词，我们就多了一层保护。</p><h2 id="503f" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">有人多加了一种类型怎么办？</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="e465" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">啊哦。现在我们要在使用密钥的地方添加一个额外的分支。希望我们有好的测试！</p><p id="20be" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">实际上，我们这样更好。将<code class="eh lz ma mb mc b">OrganizationKey</code>标记为sealed允许编译器在表达式中使用when语句时进行穷举检查。</p><p id="9e0e" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">我们将不得不改变'<code class="eh lz ma mb mc b">purchaseReport</code>'来返回一些东西而不是返回单元，但是编译器将会捕捉任何没有检查所有可能类型的<code class="eh lz ma mb mc b">when</code>语句。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff md"><img src="../Images/9f727843d48286b8855051ae0a081a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o9iYh5rJAjIdk4MN"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Screenshot from IntelliJ, showing compile error due to missing check for KeyedByCRN</figcaption></figure><h2 id="9b3e" class="ka kb hu bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">额外提示:解包“联合”类型</h2><p id="bb4f" class="pw-post-body-paragraph ky kz hu la b lb lc iv ld le lf iy lg kl lh li lj kp lk ll lm kt ln lo lp lq hn dt translated">当我们在应用程序内部传递它时，我们的<code class="eh lz ma mb mc b">OrganizationKey</code>工作得非常好。如果我们需要再次通过网络将它发送给另一个服务，我们可能需要弄清楚我们正在处理哪个键，这样我们就可以适当地构建一个d to或JSON表示。下面的代码展示了如何使用空安全强制转换和析构赋值来再次解包您的业务密钥。</p><p id="d689" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">请注意，与上面的代码不同，如果添加新类型，下面的代码不会显示任何编译器错误或警告。所以最好保留这样的方法(如果你真的需要的话！)非常接近类型定义。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="lx ly l"/></div></figure><p id="c71f" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">总之，Kotlin的空安全、数据类和密封类可以用来提供一种优雅的方式来消除经常困扰其他语言的防御性“这永远不会发生”分支。(看你的，Java！)以此为具体例子，寻找其他机会来构建您的代码，这样就不可能做错事情。我们可以一起创造墨菲定律的历史！</p></div><div class="ab cl me mf hc mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hn ho hp hq hr"><p id="6173" class="pw-post-body-paragraph ky kz hu la b lb lr iv ld le ls iy lg kl lt li lj kp lu ll lm kt lv lo lp lq hn dt translated">[1]<a class="ae jz" href="https://www.neatorama.com/2007/05/10/the-real-story-of-murphys-law/" rel="noopener ugc nofollow" target="_blank">https://www . neatorama . com/2007/05/10/the-real-story-of-the-murphys-law/</a></p></div></div>    
</body>
</html>