<html>
<head>
<title>Object Detection :Theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">物体检测:理论</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/object-detection-theory-69a01db5aab4?source=collection_archive---------6-----------------------#2019-03-02">https://medium.com/hackernoon/object-detection-theory-69a01db5aab4?source=collection_archive---------6-----------------------#2019-03-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="c5f0" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">曾经想检测图像或视频中的物体…可能是的！这就是你在这里的原因！这个故事分为两部分。这一部分涉及目标检测背后的主要理论。在下一部分中，我们将编写我们在这里看到的对象检测组件，并让它们工作(检测图像中的对象)。我们将不使用Tensorflow对象检测API，而是使用YOLO(你只看一次)算法编写我们自己的对象检测程序。我将分享我从Coursera课程学到的东西。现在，这个故事可能会很长(大事情需要更多的努力)。我想这将是介绍部分。</h2></div><p id="3942" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们来看看要求:</p><ol class=""><li id="b7f9" class="kg kh hu jm b jn jo jq jr jt ki jx kj kb kk kf kl km kn ko dt translated">YOLO v2型号重量</li><li id="6748" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated">Tensorflow(当然！)</li></ol><p id="de3a" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">物体检测顾名思义就是检测图像或视频中的物体等等。我认为谷歌在这方面已经足够了。让我们不要浪费时间，直接进入一些真正重要的组件，让这个东西工作起来！</p><p id="7444" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们将了解物体检测的一些关键组件:</p><ol class=""><li id="5b93" class="kg kh hu jm b jn jo jq jr jt ki jx kj kb kk kf kl km kn ko dt translated">滑动窗口算法</li><li id="0753" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated">装订的盒子</li><li id="08f3" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated">并集上的交集</li><li id="c9d6" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated">非最大抑制</li><li id="d328" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated">锚箱</li></ol><p id="dd50" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">就是这样！最后，我们将使用这些概念来理解为什么YOLO算法工作得这么好。我们将研究滑动窗口算法，然后看看YOLO如何解决我们在滑动窗口中遇到的问题。</p><p id="197f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">假设我们想要检测图像中的狗。因此，为了这个目的，我们建立了一个紧密裁剪的狗的图像(X)和相应的标签(Y)的训练数据集，标签为0(没有狗)或1(是的，一只狗！).</p><h1 id="e562" class="ku kv hu bd kw kx ky kz la lb lc ld le ja lf jb lg jd lh je li jg lj jh lk ll dt translated">滑动窗口算法</h1><p id="a3d6" class="pw-post-body-paragraph jk jl hu jm b jn lm iv jp jq ln iy js jt lo jv jw jx lp jz ka kb lq kd ke kf hn dt translated">现在，假设我们在上述数据集上训练了一个卷积神经网络，如果dog检测到，则输出1，否则输出0。现在我们想在真实的狗的图像上测试它们。因为我们的训练集有经过精密裁剪的狗的图像，我们的CNN从这些图像中学会了辨别是否有狗。这很好，因为我们有紧密裁剪的图像，但现实生活中的图像呢(假设我们从手机上点击一张照片)，这个图像不是紧密裁剪的。那么，我们如何让我们的有线电视新闻网告诉是否有一只狗。这就是滑动窗口发挥作用的地方。</p><p id="6013" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们定义一个大小为w的窗口，并把它放在一个区域上(当然是覆盖区域w！)上图。然后，将这个输入区域输入到我们训练好的CNN，并让它输出(0或1)。同样，我们在图像的每个区域重复这个过程(以一定的步幅)。因此，称之为滑动窗口。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/d18728ef7c65c2958a643e6da9ea7164.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*mRNqtlKRbw9YNodjnt61jg.jpeg"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Sliding Window</figcaption></figure><p id="9777" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">现在，一旦完成，我们就选择一个更大的窗口，并将其滑动到整个图像上，希望通过一次又一次地重复这个过程(增加窗口大小)，我们可能会在图像中得到一个狗大小的窗口，并让我们的CNN输出1，这意味着我们在特定区域检测到了一只狗。这都是关于滑动窗口算法。</p><p id="d863" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">滑动窗口的缺点之一是计算成本。因为我们在图像中裁剪出如此多的正方形区域，并通过CNN独立运行每张图像。我们可以考虑使用更大的窗口，因为这将减少计算量，但以准确性为代价，小窗口将是准确的，但计算量很大。解决这个问题的一种方法是卷积实现滑动窗口。滑动窗口也不能精确定位目标，除非步距和窗口尺寸很小。</p><p id="f1f6" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">让我们看看YOLO如何帮助预测准确的边界框。</p><h2 id="eb15" class="md kv hu bd kw me mf mg la mh mi mj le jt mk ml lg jx mm mn li kb mo mp lk mq dt translated">包围盒预测</h2><p id="ba2e" class="pw-post-body-paragraph jk jl hu jm b jn lm iv jp jq ln iy js jt lo jv jw jx lp jz ka kb lq kd ke kf hn dt translated">边界框是包围图像中对象的框。如前所述，滑动窗口输出不太精确的边界框(因为它取决于窗口的大小)。现在，让我们看看另一种预测包围盒的方法。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/8cb029d4cd5be1fb8403ad085e3a9ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*K83H1mddeKxtXoSnBGYwKA.jpeg"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Bounding Boxes (I know they are not dogs,but I guess fox or something else!)</figcaption></figure><p id="2cf3" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">想法是将图像分成网格(比如w乘w ),然后为每个网格定义我们的Y标签，之前是(0或1)如下:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff ms"><img src="../Images/c73187fdf52fc3c279a7590d600b4306.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*2Jz9Kr2SUmojQXDdOAR6dA.png"/></div></figure><p id="4ead" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">Pc:是网格单元内有物体的概率。它或者是0表示没有对象，或者是1表示有对象。</p><p id="bc3f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">Bx:如果Pc是1，那么Bx是边界框的x坐标。</p><p id="3c7c" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">By:如果Pc为1，则By是边界框的y坐标。</p><p id="088e" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">Bh:如果Pc是1，那么Bh是边界框的高度。</p><p id="2541" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">Bw:如果Pc是1，那么Bw是边界框的宽度。</p><p id="c8bb" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">C1 : C1指的是物体属于C1类的概率。</p><p id="2eb1" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">C2 : C2指的是物体属于C2类的概率。</p><p id="35e8" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这里需要注意的一点是<strong class="jm hv">类的数量可能会有所不同</strong>，这取决于它是<strong class="jm hv">二元分类</strong>还是<strong class="jm hv">多类分类。</strong></p><p id="cc81" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">总的来说，如果一个网格包含一个对象(即Px =1)，那么我们查看对象的类别，然后查看网格中该对象的边界框。</p><p id="13f5" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">现在，有几个问题我们应该解决。</p><ol class=""><li id="ccd9" class="kg kh hu jm b jn jo jq jr jt ki jx kj kb kk kf kl km kn ko dt translated">要使用的网格大小是多少？</li><li id="41a7" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated">哪个网格负责输出跨越多个网格对象的边界框？</li></ol><p id="b323" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">通常，在实践中使用19乘19的网格，并且负责输出特定对象的边界框的网格是包含对象中点的网格。此外，使用19乘19网格的另一个优点是，对象的中点出现在两个网格单元中的机会更小。</p><p id="b663" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这都是关于包围盒的预测。现在，让我们来谈谈另一个组件，称为并集上的交集。</p><h2 id="e9e6" class="md kv hu bd kw me mf mg la mh mi mj le jt mk ml lg jx mm mn li kb mo mp lk mq dt translated">并集上的交集</h2><p id="4362" class="pw-post-body-paragraph jk jl hu jm b jn lm iv jp jq ln iy js jt lo jv jw jx lp jz ka kb lq kd ke kf hn dt translated">现在，早先我们谈论预测包围盒，但是这些预测有多精确。这就是交集大于并集的概念的由来。现在，我们可能想重温一下集合论。让我们快速浏览一下交集和并集:</p><p id="d98f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">假设，如果我们有两个集合A和B，A是一个机构中教师的集合，B是同一机构中学生的集合。所以，他们的交集将是另一个集合C，包含作为助教的学生，当然也是学生。他们的联合将是一个新的集合C，其中包含集合A中的所有教师和集合b中的所有学生。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/4900ba6c9fefda15ed856697a96ff8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*8UHtvTtc-mSkXpyXEeabVQ.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Intersection and Union</figcaption></figure><p id="ac07" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">现在，什么是并集上的<strong class="jm hv">交集？</strong></p><p id="ad4d" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">假设，我们的算法为某个网格中的对象输出了一个包围盒(比如A)。所以，交集在并集上告诉我们的是我们的预测有多接近基本事实(比如B)。我们将A和B的交集除以A和B的并集。如果IOU大于等于某个阈值(比如0。5)那么预测被认为是正确的或好的，否则我们需要在我们的算法上做更多的工作。如果IOU是1，那么它意味着我们的预测与地面事实完全相同。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/c6d18161c158a6f6b20a4a1907979249.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*tjmfO6gQ3ll8QbOtCGqKaA.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">IOU</figcaption></figure><p id="9ffe" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这里需要注意的一点是，IOU越大，预测就越准确，另一点是，按照惯例，我们使用0。5作为门槛。但是我们可以自由使用大于0的阈值。5.</p><p id="e916" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">下图描绘了这一想法:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/5accda1b13d0f425d55fde17eccbb009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*JoyOqNm42i90sM2Y7VWBYA.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Intersection over Union</figcaption></figure><p id="a6f6" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">恭喜你！我们走了很长的路。在我们准备写我们自己的物体探测程序之前，还有几个话题要谈。</p><h2 id="6eb5" class="md kv hu bd kw me mf mg la mh mi mj le jt mk ml lg jx mm mn li kb mo mp lk mq dt translated">非最大抑制</h2><p id="b8a7" class="pw-post-body-paragraph jk jl hu jm b jn lm iv jp jq ln iy js jt lo jv jw jx lp jz ka kb lq kd ke kf hn dt translated">到目前为止，我们已经注意到，对于跨越多个网格的单个对象的预测，每个网格将输出其自己的带有概率分数的预测(我们之前已经看到过Pc)。现在，这可能会使我们的预测看起来混乱，可能我们只是想看到一个单一的边界框的单一对象与最大概率得分(Pc)。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="fe ff mw"><img src="../Images/0955dcf50ad2cd9abb21b7450341f6f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeDbZPdTGOiuZfVZX015GQ.png"/></div></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Non-Max Suppression</figcaption></figure><p id="4b0f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们怎么做？</p><p id="bf0e" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">我们所做的是，在我们的网络输出的所有包围盒中，我们丢弃类别概率小于某个阈值(比如0。5)在剩余的盒子中，我们选择具有最高分类概率的盒子(例如，假设盒子的名称为A)。现在，我们用A计算剩余盒子的IOU，并丢弃IOU大于或等于0的盒子。5(说)。</p><p id="d990" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这里要注意的一点是，如果我们有三个职业，那么正确的做法是对所有三个职业都进行<strong class="jm hv"> NMS </strong>(非最大抑制)。</p><p id="7c2c" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">就是这个！最后，让我们看看什么是锚盒。</p><h2 id="787a" class="md kv hu bd kw me mf mg la mh mi mj le jt mk ml lg jx mm mn li kb mo mp lk mq dt translated">锚箱</h2><p id="862d" class="pw-post-body-paragraph jk jl hu jm b jn lm iv jp jq ln iy js jt lo jv jw jx lp jz ka kb lq kd ke kf hn dt translated">从一开始，我们就遇到了一些问题，我们也确实解决了这些问题。只剩下一个问题需要处理，那就是我们如何在同一个网格单元中检测多个对象？</p><p id="c48c" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">背后的思想是，我们可以定义两个边界框预测值或者甚至三个或更多的不同形状(因此它们能够检测不同大小的对象)(例如矩形、正方形等)，而不是用一个形状(例如矩形)来定义一个边界框预测值(Pc、bx、by、bh、bw、c1、C2…等)。</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nb"><img src="../Images/8fac66671eb3e9940ae1d29e6f2b9bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:294/format:webp/1*HzRsJBNJ7keu9EZjrzGPTQ.png"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">2 Anchor Boxes</figcaption></figure><p id="a13e" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">该图像显示了具有不同边界框值的两个<strong class="jm hv">锚框</strong>的定义，因此具有不同的形状。</p><p id="85b2" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">现在，我们如何决定哪个锚盒将被用于预测哪种类型的对象？</p><p id="c54a" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这里，我们再一次利用了并集上的交集。我们使用与物体形状具有最高IOU的盒子来进行预测。</p><p id="1658" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">所以，这都是关于锚箱的，我认为很重要。至此，我们大概总结出了目标检测所需的理论。恭喜你！完成一次伟大的旅程。这个故事的最后一个主题是关于YOLO算法。我们将总结我们从一开始就学习的所有组成部分，看看这些东西如何使这个算法优于任何其他算法！</p><p id="e3da" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">在此之前，为了对锚定框有更好的直觉，请考虑这张图片:</p><figure class="ls lt lu lv fq lw fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/db804bf7f626ec6677a7b156fd8650d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*W0feUO6TytmRNQLIbTxPDw.jpeg"/></div><figcaption class="lz ma fg fe ff mb mc bd b be z ek">Anchor Boxes</figcaption></figure><h2 id="7e57" class="md kv hu bd kw me mf mg la mh mi mj le jt mk ml lg jx mm mn li kb mo mp lk mq dt translated">YOLO算法</h2><p id="18ba" class="pw-post-body-paragraph jk jl hu jm b jn lm iv jp jq ln iy js jt lo jv jw jx lp jz ka kb lq kd ke kf hn dt translated">对于YOLO算法，当准备我们的训练集时，我们将图像分成网格(主要是19乘19)，并且我们为每个网格定义锚框(比方说每个网格2个锚框)。例如:19乘19网格中的每个网格将输出两个锚框(两个预测)。Y标签的大小将是19乘19乘2乘(5 +类的数量),其中2对应于锚框的数量，5对应于边界框(bx，by，bh，bw)和Pc。一旦我们用这种方法准备好训练数据集，我们就在CNN上训练它。这个CNN获取大小为(比如100乘110)的输入图像，并输出大小为19乘19乘2乘(5 +类的数量)的图像</p><p id="b9f3" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jm hv">预测</strong>:这个CNN在输入新的图像时，会以上面指定的格式输出Y标签。这里需要注意一些事情，首先，对于没有发现任何对象的网格，Pc=0(当然！)并将为边界框输出一些随机值，类将为0。第二，假设对象是矩形的，我们定义了两个定位框(一个是方形的，另一个是矩形的)，那么网络将输出矩形定位框的值，而方形将有一些我们不关心的随机值。</p><p id="1832" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">最后但并非最不重要的是，由于每个网格将输出两个边界框(因为锚框是两个，即矩形和正方形)，我们的输出将看起来非常混乱，因此为了处理这一点，我们将实现如上所述的非最大值抑制。</p><p id="1976" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated">这就是我对这个故事的全部看法。我希望，我能够帮助你，增加你的知识价值。在下一篇文章中，我们将使用Tensorflow和YOLO v2设计出我们自己的物体探测程序。</p><p id="0c3f" class="pw-post-body-paragraph jk jl hu jm b jn jo iv jp jq jr iy js jt ju jv jw jx jy jz ka kb kc kd ke kf hn dt translated"><strong class="jm hv">演职员表:[本故事中使用的图片] </strong></p><ol class=""><li id="587d" class="kg kh hu jm b jn jo jq jr jt ki jx kj kb kk kf kl km kn ko dt translated"><a class="ae jj" href="https://blog.csdn.net/Snoopy_Yuan/article/details/80021504" rel="noopener ugc nofollow" target="_blank">滑动窗口图像</a></li><li id="fcb4" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated"><a class="ae jj" href="https://kevinbinz.com/2017/10/20/set-theory-intro/" rel="noopener ugc nofollow" target="_blank">集合论形象</a></li><li id="c985" class="kg kh hu jm b jn kp jq kq jt kr jx ks kb kt kf kl km kn ko dt translated"><a class="ae jj" href="https://www.codemade.io/super-fast-object-detection-computer-vision/" rel="noopener ugc nofollow" target="_blank">非最大抑制</a></li></ol></div></div>    
</body>
</html>