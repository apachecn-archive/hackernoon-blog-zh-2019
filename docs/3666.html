<html>
<head>
<title>A Guide to Tracing in Elixir!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">仙丹追踪指南！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-guide-to-tracing-in-elixir-53b1afb996de#2019-06-17">https://medium.com/hackernoon/a-guide-to-tracing-in-elixir-53b1afb996de#2019-06-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/e8a84b7bb53b1f95327d551a5d7c03b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wz0Q9_GnivOdmB_pb4xwA.jpeg"/></div></div></figure><p id="154c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">问候！我是 Gabor，一个 Erlang 程序员。我喜欢描摹，需要的时候就用。当我开始使用 Elixir 时，我问了一个显而易见的问题，我如何在 Elixir-land 中进行跟踪？Elixir 社区已经在很多方面改善了用户体验(mix vs pre-rebar3，macros vs parse-transforms，等等，无止境)。自然，我期待在 Elixir 中使用所有伟大的追踪工具。虽然有一些很好的工具，即<a class="ae ka" href="https://github.com/nietaki/rexbug" rel="noopener ugc nofollow" target="_blank"> Rexbug </a>和<a class="ae ka" href="https://github.com/gabiz/tracer" rel="noopener ugc nofollow" target="_blank"> Tracer </a>，但我有点惊讶地看到，很少有人谈论跟踪。我找不到所有伟大的博客帖子，解释战斗故事的教程，以及追踪的奇迹。有一些，但 BEAM 虚拟机的这一强大功能在 Elixir 社区中似乎有些不足。</p><p id="0a3a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇博文中，我将讨论“什么是跟踪”，以及“什么时候使用跟踪合适？”和高度概括了梁的可用跟踪工具。</p><h1 id="bccb" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">什么是追踪？</h1><p id="ce5e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated"><a class="ae ka" href="https://en.wikipedia.org/wiki/Tracing_(software)" rel="noopener ugc nofollow" target="_blank">维基百科</a>对跟踪的定义如下:“跟踪涉及日志记录的特殊用途，以记录关于程序执行的信息。”这个定义不仅有用，而且提供了跟踪在日志记录和调试中的位置的概念。日志是一个非常有用的工具，可以用来查看我们的系统中发生了什么，它可以提供对错误和 bug 的洞察。但是这个狭隘的定义有一个很大的缺陷，我们选择发出日志消息的地方被硬编码到我们的程序逻辑中。</p><p id="166f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">选择在哪里插入日志消息完全是主观的，取决于假设和以前的经验。有时日志语句被插入到一个有用的位置，但是如果没有，您将不得不重新编译您的代码并插入额外的日志语句，这可能是一个非常乏味的活动(并且是绝大多数计算机语言中的标准)。在病态场景中，无偿使用日志语句甚至会成为系统 io 的一大负担(处理 500 条记录，生成 50000 行日志语句)。</p><p id="8899" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">日志对于解释系统正在做什么很有用，但是对于理解意外故障状态下的系统行为帮助不大。</p><p id="4a4f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">另一个极端是使用传统的分步调试器进行调试，比如 GNU 调试器(gdb)。这不需要修改您的代码，我们在程序执行时观察程序，在数据一步一步地发展时观察数据。这是观察算法如何工作或数据结构如何变化的好方法。但是在分布式系统中这是一个很大的问题，因为许多操作都是由短暂超时的瞬态过程处理的，举一个例子，gen_server 的调用超时为 5000 毫秒，很少有 Elixir 或 Erlang 系统不大量使用 OTP 来实现系统功能。</p><p id="aa1e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这里的关键是在系统工作时观察它，而不要让世界停下来。这听起来不可能吗？</p><p id="40cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">追踪拯救行动来了。追踪是一个窗口，通过它我们可以观察系统的阴谋。从顶层函数调用和带有可配置堆栈跟踪的消息传递开始，一直到监控调度程序的行为、端口交互和垃圾收集。在这方面，跟踪非常接近于一步一步的调试器，但是它将调试步骤变成了一个日志消息流，我们可以在闲暇时对其进行分析，以确定在给定的时间点系统中发生了什么。</p><h1 id="235b" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">神话</h1><h2 id="63b5" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">如果你有很好的监控，那么你不需要追踪。</h2><p id="7d15" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">让我们假设勤勉的监控已经到位。跟踪绝不是日志记录的替代品。但是监视和日志记录有同样的问题。如果您预先知道每个可能的事件需要监视哪些部分，那么您可能永远不需要跟踪。但是对于任何足够复杂的应用程序，您不可能监控所有的事情。所以会有很多系统的部分，没有测量。这就是跟踪非常方便的地方。</p><h2 id="1665" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">在生产中追踪是不安全的。</h2><p id="0019" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">做任何与生产有关的事情都有一定的风险。追踪也是如此。您应该小心，因为它的开销很小。您需要理解跟踪是做什么的，以及它如何影响系统的某些部分。也许您想首先在测试环境中测试跟踪活动，但是说它不安全是不对的。通过尽职调查，您可以利用 BEAM 的功能免费获得大量专门的日志记录。Elixir 的成功部分是因为它成功地利用了 BEAM 的并发和分布特性。一旦你学会利用它，这又是一顿免费餐。</p><h2 id="3528" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">你应该改变架构，这样你就不需要追踪了。</h2><p id="3041" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">如果你有能力这样做，你可能已经找到了正确的解决方案。但是在许多系统中，升级系统并不简单。试想一个需要认证才能投入生产的系统。“快而破事”不是哪里都允许的。这些环境通常是使用追踪等观察工具最多的地方。但你不需要在一个高度监管的环境中才能享受这些好处。启动跟踪比部署更改花费的时间更少，它可以在最需要的时候节省时间…当事情着火的时候。</p><h2 id="f6fd" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">我用 OpenTracing，我被覆盖了。</h2><p id="aae5" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">OpenTracing 是跟踪整个产品(包括前端、后端和基础设施)中的请求的一个非常好的方法。但是它要求你对你的代码进行检测。跟踪代码中特定于业务的部分是很好的，但是同样，它也有日志记录的问题。这不是临时的。你不能简单地添加额外的更深的层，或者看到光束的系统内部。如果您使用采样，那么甚至不能保证捕获到您正在寻找的事件。不幸的是，它有着相同的名字，但是用例并不完全相同。</p><h1 id="f9f1" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">如何使用跟踪</h1><p id="aab8" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">让我们列出一个策略，让追踪成为一种无痛苦的体验，不管它是一个开发、测试还是生产系统。</p><h2 id="c54a" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">1.形成一种理论</h2><p id="eb1f" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">在没有明确计划的情况下使用跟踪会导致灾难。因此，首先，您需要知道您在追踪什么，以及您期望什么样的输出。要做到这一点，您需要阅读您将要跟踪的代码，并对这些代码在系统中的交互方式有所了解。</p><p id="3436" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你希望函数只被调用几次吗？您希望函数参数很大吗？您希望流程存在，还是在开始跟踪后创建？你希望功能不会崩溃吗？您希望进程不会在两次函数调用之间被调度吗？你希望垃圾收集很快吗？</p><p id="058b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些是您可以通过使用跟踪来回答的一些问题，但是如果您的期望与事实相差甚远，那么跟踪的性能特征可能会引起一些头痛。如果函数被多次调用，而不是每隔一段时间调用一次，那么您需要一种自动机制，在它导致任何问题之前停止跟踪，或者跟踪到一个文件中，并进行适当的包装。或者您希望函数正确返回，但是它崩溃了，并且没有生成返回跟踪条目。在这种情况下，您需要通过设置正确的跟踪标志来捕获崩溃。这些是你在开始追踪前应该考虑的问题，这可能是你收集证据的唯一机会。</p><p id="e4e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您还可以使用跟踪来更好地理解代码。这可能看起来不直观，但是在这种情况下，我仍然建议你尝试形成并证明一个系统行为的理论。不要追踪每一件事，而是一次追踪一件事。</p><p id="682a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">记住，Elixir(和 Erlang)应用程序是在考虑弹性的情况下构建的。有些错误是预料之中的，应用程序不一定会报告。抓住这些案件可能比预期的更困难。</p><h2 id="4c42" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">2.选择正确的工具</h2><p id="bde0" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">有许多追踪工具。是的，即使是长生不老药。较高层次的工具将覆盖 99%的用例，但是您可以总是遵从较低层次的工具，这些工具可能有点难以控制。</p><p id="2ad0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">跟踪工具内置于 VM 中，因此 Elixir 开发人员很难将他们的代码翻译成 BEAM 能够理解的代码。这是为漂亮而高效的语法付出的代价，但实际上，这并不遥远。</p><p id="acb1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">一个很好的起点是<a class="ae ka" href="https://github.com/nietaki/rexbug" rel="noopener ugc nofollow" target="_blank"> rexbug </a>，它是<a class="ae ka" href="https://github.com/massemanet/redbug" rel="noopener ugc nofollow" target="_blank"> Redbug </a>的包装器。它不仅提供了一个使用 Elixir 的方便接口(它将 Elixir 语法翻译成 Erlang，并调用 Redbug)，而且还提供了许多保护措施来防止我们犯下大错，并防止跟踪消息使节点过载。如果我们有一个分布式应用程序，也可以从多个节点收集跟踪条目。想象一个集群，其中某个功能在一个随机节点上执行，作为一种负载平衡的方式。您可以登录到一个节点，在那里启动跟踪程序，看看发生了什么，而不管哪个节点执行它。</p><p id="ba01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">尽管 rexbug 的匹配语法方便易用，但有时为了获得更好的性能或更安全的操作，有必要对跟踪器进行微调。在这种情况下，<a class="ae ka" href="http://erlang.org/doc/man/dbg.html" rel="noopener ugc nofollow" target="_blank"> dbg </a>前来救援。它没有内置的安全措施，但有能力使用 match 规范的所有强大功能来限制可以跟踪的内容。您可以使用可选的过滤器跟踪发送或接收的消息，也可以指定要跟踪的特定进程。您还可以选择输出文件或网络端口作为跟踪条目的目标。这些功能中的一部分向 rexbug 公开，但不是全部。使用这个工具可以解决的问题如此之多，以至于几乎不需要使用 erlang 模块中的内置跟踪<a class="ae ka" href="http://erlang.org/doc/man/erlang.html#trace-3" rel="noopener ugc nofollow" target="_blank"> BIFs </a>。</p><h2 id="c21d" class="le kc hu bd kd lf lg lh kh li lj lk kl jn ll lm kp jr ln lo kt jv lp lq kx lr dt translated">3.分析结果</h2><p id="ad71" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">可以定制跟踪工具的输出，以简化分析阶段。这是您验证最初假设并在跟踪日志中找到证据的时候。您可以检查函数参数、返回值、调度逻辑、垃圾收集周期、进程和端口驱动程序之间的交互。</p><p id="4622" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有时，通过使用 python 和 matplotlib 等对输出进行后处理来可视化事件是一个好主意。有时事件的频率就是你要寻找的线索。</p><p id="4c2d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您是在大海捞针，那么跟踪到一个文件(或更多带包装的文件)并记录甚至千兆字节的数据是一个好主意。稍后，您可以使用自定义工具过滤掉所有噪音。您可以通过编写从文件中读取的跟踪客户端来创建自己的跟踪分析工具。您也可以在跟踪过程中进行这种过滤，方法是编写一个跟踪模块(用 Erlang 或 Elixir 编写),并将其用作动态过滤机制。</p><p id="21c3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你喜欢图形界面，那么<a class="ae ka" href="https://github.com/andytill/erlyberly" rel="noopener ugc nofollow" target="_blank">erly</a>是另一个选择。它是用 Java 编写的，提供了一个可以用来跟踪的 GUI。erlyberly 可以连接到远程 Erlang 节点或集群，并将输出消息定向到 GUI。如果希望跟踪命令在节点重启后仍然有效，这是非常方便的。</p><p id="9bb4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后，如果您部署了像<a class="ae ka" href="https://www2.erlang-solutions.com/wombattracing" rel="noopener ugc nofollow" target="_blank"> WombatOAM </a>这样的商业波束监控系统，您可以在 WombatOAM 中执行跟踪命令，这样您甚至不需要手动连接到您的节点。</p><h1 id="0d1d" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">了解更多信息</h1><p id="8b5e" class="pw-post-body-paragraph jc jd hu je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">你可以从弗莱德·赫伯特的优秀著作<a class="ae ka" href="https://www.erlang-in-anger.com/" rel="noopener ugc nofollow" target="_blank">“愤怒中的二郎”</a>中了解关于在 BEAM 上构建的跟踪和调试系统的知识。我推荐看看我在这篇文章中提到的工具。但是如果你真的想学习如何安全地跟踪，而不用担心破坏你的生产系统，你可以在<a class="ae ka" href="https://www2.erlang-solutions.com/tracingcodeelixir" rel="noopener ugc nofollow" target="_blank"> Code Elixir London </a>查看我们的跟踪教程。希望在那里见到你。</p><figure class="ls lt lu lv fq iv"><div class="bz el l di"><div class="lw lx l"/></div></figure></div></div>    
</body>
</html>