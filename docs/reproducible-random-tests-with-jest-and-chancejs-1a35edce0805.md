# 带有 Jest 和 ChanceJS 的可重复随机测试

> 原文：<https://medium.com/hackernoon/reproducible-random-tests-with-jest-and-chancejs-1a35edce0805>

如何在不影响可重现结果的情况下增加测试的多样性？

测试很重要。测试很好。测试是安全的。测试是可以被愚弄的。

![](img/d5f83c620ee55fc38040e88896c1e232.png)

Lava Lamps at Cloudflare — via [VirtuallyOnit](https://virtuallyonit.com/2017/11/16/one-of-the-secrets-guarding-the-secure-internet-is-a-wall-of-lava-lamps/)

即使有最好的意图，我们有时还是会以假阳性测试告终。我们首先编写测试(红色)，做尽可能简单的事情使它通过(绿色)，然后有人走进来，午餐时间到了，我们失去了焦点，忘记了重构。
严格遵循 TDD 原则，我们可能会得到这样的结果:

即使我们的测试想要断言基于一个已知的输入我们得到一个已知的输出，它测试的只是函数返回“*我是一个茶壶*

# 随机数据

为了解决这个问题，我们必须向测试中添加方差，以确保对于多个输入，我们得到正确的输出。传统上，这可以通过[三角测量](http://thedevengers.com/tdd-triangulation/)来完成，这将迫使我们编写越来越多的抽象解决方案。这是可行的，但是在有限数量的输入下，总有一种方法可以控制系统。

我不想深入写随机测试的错综复杂之处，这个话题应该有自己的文章，如果有需要，我会写的。现在，让我们考虑以下情况:

这里我们生成测试数据，它有一个随机输入和相应的预期输出。这样，每一次测试执行都使用不可预测的数据，因此伪造响应几乎是不可能的。

> 我们正在使用 [ChanceJS 库](https://chancejs.com/)来获取随机的东西，因为这样做实在太神奇了。

现在问题来了。想象一下，你有数百个左右随机数据的测试。你的变化是巨大的，在过去的几个月里，你已经用各种你以前可能没有想到的值测试了你的应用程序。在某一点上，某些东西会失败，而且会失败得很厉害。
您的第一反应可能是在本地重放测试，看看是否可以重现结果并找出问题所在。但是，当你所有的值都是完全随机的，并且每次都在变化的时候，你是怎么做到的呢？

除非你正在构建监管的赌博解决方案或高度专业化的解决方案，否则你最终将与之合作的大多数随机数发生器将是[伪随机数发生器](https://en.wikipedia.org/wiki/Pseudorandom_number_generator)。这种东西的主要特点是它们产生的值完全由一个初始值决定，这个初始值叫做**种子**。这意味着，如果你在一个序列中要求 5 个随机数，如果你使用相同的种子，序列每次都会给你完全相同的数字。

> 需要比这更随机的东西的公司，已经在他们的解决方案中变得相当有创意，包括将相机对准一系列熔岩灯。[https://www.youtube.com/watch?v=1cUUfMeOijg](https://www.youtube.com/watch?v=1cUUfMeOijg)

对我们来说不幸的是，我们完全满足于不安全的随机，我们可以利用它来为自己谋利。正如我们所了解的，给定相同的种子值，我们将总是得到相同的随机值。这意味着，如果我们能够找到一种方法来暴露和控制我们的测试种子，我们就可以随时随地用它来重现我们失败的测试。让我们修改我们的测试来处理种子。

这里你可以看到我们用一个特定的种子初始化了我们的随机生成器，这个种子是我们从一个环境变量中获得的，或者…随机创建的。在这个孤立的案例中就是这么简单。

# 在项目级别实施

在一个文件中控制随机性是很好的，但是如果你正在创建一个实际做一些事情的应用程序，这肯定是不够的。从现在开始，有很多方法可以做到这一点，请允许我分享我们的解决方案，它使用 Jest 的 globalSetup 选项和环境变量。

我们想实现两件事。

1.  如果没有指定种子，则创建一个新种子，并使其可用于所有测试
2.  如果用户指定，则使用现有种子

我选择与环境变量共享种子，因为我相信它是最友好的 CI，并且易于用命令行管理。这个小片段将在每次运行 Jest 时和测试执行之前运行。你要做的就是在你的 package.json 中告诉 Jest 使用这个 testSetup.js。

仅此而已。

# 重现测试

从现在开始，您的控制台中的每个测试运行都会有一条消息，让您知道种子是什么。您可以从 circle ci/Jenkins/Travis/git lab/etc 构建日志中复制种子，并使用

```
$ CHANCE_SEED=534a873a618e4e317060f9bc29f9115ad156168b jest
```

这会将 CHANCE_SEED 环境变量设置为 jest 执行所指定的值。例如，如果您有多阶段测试，您也可以使用它来保持构建管道中的测试数据相同。

# 没有更简单的方法吗？

当我写这篇文章时，我意识到这整个事情可以被打包并从日常用户中抽象出来，所以我继续做了一个包。

[](https://github.com/meza/jest-chance) [## meza/jest-chance

### Jest 和 ChanceJS - meza/jest-chance 的可重复随机测试助手

github.com](https://github.com/meza/jest-chance) 

这正是我们在文章中讨论的内容，但却是以一种显而易见的方式。它甚至使使用 Chance 变得更简单，因为您不再需要手动实例化它。

这将为您提供一个带有全局种子的 primed Chance 对象，这样您就不必记得在需要随机数据的每个测试中添加种子逻辑。

你怎么想呢?你使用随机测试数据吗？我很想听听你的经验之谈。