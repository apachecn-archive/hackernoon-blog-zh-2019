<html>
<head>
<title>Enforcing Code Quality for Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">强制 Node.js 的代码质量</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/enforcing-code-quality-for-node-js-c3b837d7ae17#2019-01-30">https://medium.com/hackernoon/enforcing-code-quality-for-node-js-c3b837d7ae17#2019-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="1ad2" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">使用林挺、格式化和带有代码覆盖的单元测试来实施质量标准</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/5ff4d2d9fc4b422293c68ff85c8f8090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5XEyjWDxYydmg7p56n0uqg.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Licensed from Adobe Stock Photo</figcaption></figure><p id="fdba" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果你要编写代码并交付生产，代码的高质量是很重要的。</p><p id="bc3a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在我的上一篇文章中，我向您展示了如何使用 docker-compose 来利用标准化的、已经存在的 docker 文件进行开发。让我们的应用程序为部署做好准备的下一步是生产它。</p><p id="d626" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我将继续使用我之前教程中的 React/Parcel 示例:<a class="ae kv" href="https://hackernoon.com/move-over-next-js-and-webpack-ba367f07545" rel="noopener ugc nofollow" target="_blank">移到 Next.js 和 Webpack 上！</a></p><p id="72a3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下面是源代码:<a class="ae kv" href="https://github.com/patrickleet/streaming-ssr-react-styled-components" rel="noopener ugc nofollow" target="_blank">https://github . com/Patrick let/streaming-SSR-react-styled-components</a></p><p id="2dd1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我还没有做任何与让应用程序“生产就绪”相关的事情，所以我也将谈谈这需要什么，尽管这可能需要另一篇文章来完成…我们将看到它如何进行。我是即兴创作的。</p><p id="ef8b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们从一些质量控制开始。</p><p id="17a1" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在这篇文章中，我们将探索林挺、格式化、单元测试和代码覆盖率，并实施一些质量标准。</p><h1 id="8a83" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">林挺和格式</h1><p id="401c" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">根据维基百科，to " <strong class="kb hv"> Lint </strong>，或<strong class="kb hv"> linter </strong>，是一种分析源代码以标记编程错误、bug、风格错误和可疑结构的工具。</p><p id="29d4" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">这意味着它会强制执行一些事情，比如使用空格还是制表符，或者确保您的代码使用分号是否一致。</p><p id="eaca" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">目前在我的项目中可能有很多林挺错误。</p><p id="435c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">到目前为止，我的目标是演示特定的概念，而过多的关于不同事物的边栏确实会影响手头的概念。因此，我选择放弃林挺，以保持前几篇文章的重点。</p><p id="9272" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在是时候“生产”我们的应用程序了，质量是重中之重。</p><p id="1444" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我更喜欢的 linter 格式是<a class="ae kv" href="https://standardjs.com/" rel="noopener ugc nofollow" target="_blank"> StandardJS </a>，这是一个非常简单的设置。但是在我们设置它之前，让我们也讨论一下格式化。</p><p id="2486" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated"><strong class="kb hv">格式化</strong>类似于林挺，但更少关注语法错误，更多关注的是让代码看起来更漂亮，因此这个流行的包被命名为<code class="eh lt lu lv lw b">prettier</code>。</p><p id="2be2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">感谢 Github 上几个令人敬畏的开源贡献者，我们可以在一个包中使用它们。感谢<a class="ae kv" href="http://sheerun.net/" rel="noopener ugc nofollow" target="_blank">亚当·斯坦凯维奇</a>、<a class="lx ly gr" href="https://medium.com/u/db72389e89d8?source=post_page-----c3b837d7ae17--------------------------------" rel="noopener" target="_blank">肯特·c·多兹</a>、<a class="ae kv" href="https://github.com/agarrharr" rel="noopener ugc nofollow" target="_blank">亚当·加勒特-哈里斯</a>和<a class="ae kv" href="https://github.com/BenoitAverty" rel="noopener ugc nofollow" target="_blank">伯努瓦·阿威提</a>！</p><p id="25a5" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在过去，我写过关于使用 husky 来确保规则在每次提交之前运行。漂亮标准包也建议这样做，所以现在让我们添加漂亮标准、健壮和 lint-staged。</p><h2 id="b45e" class="lz kx hu bd ky ma mb mc lc md me mf lg ki mg mh li km mi mj lk kq mk ml lm mm dt translated">配置更漂亮-标准</h2><p id="e468" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">首先安装所需的软件包:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="3fe3" class="lz kx hu lw b fv mr ms l mt mu">npm i --save-dev prettier-standard husky lint-staged</span></pre><p id="7d1d" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<strong class="kb hv"> package.json </strong>中添加以下“格式”脚本和新的“lint-staged”和“husky”部分:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="8536" class="lz kx hu lw b fv mr ms l mt mu">{<br/>  //...<br/>  "scripts": {<br/>    // ...<br/>    <strong class="lw hv">"format": "prettier-standard 'app/**/*.js' 'app/**/*.jsx' 'server/**/*.js'"<br/>  },<br/>  "lint-staged": {<br/>    "linters": {<br/>      "**/*.js": [<br/>        "prettier-standard",<br/>        "git add"<br/>      ],<br/>      "**/*.jsx": [<br/>        "prettier-standard",<br/>        "git add"<br/>      ]<br/>    }<br/>  },</strong><br/>  // ...<br/>}</span></pre><p id="6ac3" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我无法让 RegExp 工作，所以在没有查看源代码的情况下，我假设它使用的是 glob 而不是 RegExp。</p><p id="0464" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在你可以运行<code class="eh lt lu lv lw b">npm run format</code>来格式化你的代码并检查林挺错误。此外，每当您尝试提交时，将调用 husky 的<code class="eh lt lu lv lw b">pre-commit</code>挂钩，这将确保任何暂存文件(<code class="eh lt lu lv lw b">git add</code>暂存文件)在允许提交之前被正确地链接。</p><p id="df3b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们看看我第一遍做得怎么样。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="751f" class="lz kx hu lw b fv mr ms l mt mu">➜  npm run format</span><span id="2a08" class="lz kx hu lw b fv mv ms l mt mu">&gt; stream-all-the-things@1.0.0 format /Users/patrick.scottgroup1001.com/dev/patrickleet/open-source-metarepo/stream-all-the-things<br/>&gt; prettier-standard 'app/**/*.js' 'app/**/*.jsx' 'server/**/*.js'</span><span id="1273" class="lz kx hu lw b fv mv ms l mt mu">app/client.js 52ms<br/>app/imported.js 11ms<br/>app/styles.js 7ms<br/>app/App.jsx 11ms<br/>app/components/Header.jsx 76ms<br/>app/components/Page.jsx 7ms<br/>app/pages/About.jsx 6ms<br/>app/pages/Error.jsx 5ms<br/>app/pages/Home.jsx 6ms<br/>app/pages/Loading.jsx 6ms<br/>server/index.js 8ms<br/>server/lib/client.js 11ms<br/>server/lib/ssr.js 17ms</span></pre><p id="b8e8" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">基本上每个文件除了<code class="eh lt lu lv lw b">styles.js</code>都有林挺错误或者看起来不够漂亮！</p><h2 id="03e1" class="lz kx hu bd ky ma mb mc lc md me mf lg ki mg mh li km mi mj lk kq mk ml lm mm dt translated">忽略文件的林挺和格式</h2><p id="60e1" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">有一个小问题是这个项目特有的——<code class="eh lt lu lv lw b">app/imported.js</code>是一个生成的文件，linter 应该忽略它。</p><p id="1ac9" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">虽然 is 在文件顶端有<code class="eh lt lu lv lw b">eslint-disabled</code>，但是 prettier 不知道执行林挺规则。别担心，让我们撤销对该文件的更改，然后创建一个<code class="eh lt lu lv lw b">.prettierignore</code>文件和一个<code class="eh lt lu lv lw b">.eslintignore</code>文件，以便在以后的运行中显式忽略该文件的格式化。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="c350" class="lz kx hu lw b fv mr ms l mt mu">git checkout -- ./app/imported.js</span></pre><p id="0979" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">将撤消对该文件的更改。</p><p id="0bee" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在用下面的代码行创建<code class="eh lt lu lv lw b">.prettierignore</code>和<code class="eh lt lu lv lw b">.eslintignore</code>:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="1cae" class="lz kx hu lw b fv mr ms l mt mu">app/imported.js<br/>dist<br/>coverage<br/>node_modules</span></pre><p id="f852" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在当运行<code class="eh lt lu lv lw b">npm run format</code>时，文件<code class="eh lt lu lv lw b">app/imported.js</code>保持不变。由于文件是生成的，不解决这个问题可能会有问题。</p><p id="9d0b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，我提到提交也应该作为一个<code class="eh lt lu lv lw b">pre-commit</code>钩子运行<code class="eh lt lu lv lw b">npm run format</code>。让我们试一试。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="9bb2" class="lz kx hu lw b fv mr ms l mt mu">➜  git commit -m 'feat: prettier-standard'<br/>husky &gt; pre-commit (node v11.6.0)<br/>  ↓ Stashing changes... [skipped]<br/>    → No partially staged files found...<br/>  ✔ Running linters...</span></pre><p id="ca3b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">下面是 Github 上的提交。</p><h1 id="1fa9" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">单元测试和代码覆盖率</h1><p id="ef6f" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">作为生产我们的应用程序的一部分，我们真的应该确保我们的代码是经过充分测试的。理想情况下，你应该这样做，但我是一个坏人，在这个项目中忽略了这一点。</p><p id="df93" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们解决这个问题。</p><h2 id="71c6" class="lz kx hu bd ky ma mb mc lc md me mf lg ki mg mh li km mi mj lk kq mk ml lm mm dt translated">安装和配置 Jest</h2><p id="3155" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">首先，让我们安装 Jest 来编写单元测试。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="34e3" class="lz kx hu lw b fv mr ms l mt mu">npm i --save-dev jest babel-jest</span></pre><p id="6c81" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，让我们添加一个 jest 配置文件，这样我们就可以配置 jest 来知道在哪里可以找到我们的文件，并且能够使用漂亮的路径。</p><p id="2b36" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">添加以下<code class="eh lt lu lv lw b">jest.json</code>文件:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="d038" class="lz kx hu lw b fv mr ms l mt mu">{<br/>  "roots": ["&lt;rootDir&gt;/__tests__/unit"],<br/>  "modulePaths": [<br/>    "&lt;rootDir&gt;",<br/>    "/node_modules/"<br/>  ],<br/>  "moduleFileExtensions": [<br/>    "js",<br/>    "jsx"<br/>  ],<br/>  "transform": {<br/>    "^.+\\.jsx?$": "babel-jest"<br/>  },<br/>  "<!-- -->transformIgnorePatterns": <!-- -->["/node_modules/"],<br/>  "coverageThreshold": {<br/>    "global": {<br/>      "branches": 10,<br/>      "functions": 10,<br/>      "lines": 10,<br/>      "statements": 10<br/>    }<br/>  },<br/>  "collectCoverage": true,<br/>  "collectCoverageFrom" : [<br/>    "**/*.{js,jsx}"<br/>  ]<br/>}</span></pre><p id="2a07" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">好吧，让我们打开它。首先，我们将<code class="eh lt lu lv lw b">roots</code>设置为<code class="eh lt lu lv lw b">&lt;rootDir&gt;/__tests__/unit</code>。我喜欢将阶段测试放在<code class="eh lt lu lv lw b">__tests__/staging</code>中，所以将根设置为<code class="eh lt lu lv lw b">__tests__/unit</code>将允许我以后这样做。</p><p id="6934" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来，我们将<code class="eh lt lu lv lw b">modulePaths</code>设置为根目录，并将<code class="eh lt lu lv lw b">node_modules</code>设置为。这样，在我们的测试中，我们可以只导入<code class="eh lt lu lv lw b">app/*</code>或<code class="eh lt lu lv lw b">server/*</code>，而不是使用像<code class="eh lt lu lv lw b">../../</code>这样的相对路径。</p><p id="c13f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">接下来的两个键告诉 jest 使用 babel 来加载我们的文件，这样像<code class="eh lt lu lv lw b">import</code>这样的东西就可以正常工作了。</p><p id="0c70" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最后，最后三个部分定义了覆盖率设置——最低阈值，都是 10%,以及从哪里收集覆盖率。在本文中，我的目标只是配置好各个部分。在下一篇文章中，我将把覆盖率阈值增加到 100%,并逐步完成这个过程。</p><p id="4ff2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了运行，我们可以在<code class="eh lt lu lv lw b">package.json</code>的脚本部分定义一个<code class="eh lt lu lv lw b">test</code>脚本。因为我们正在使用 babel-jest，所以我们也需要提供一些 babel 设置，所以我们可以将<code class="eh lt lu lv lw b">BABEL_ENV</code>设置为<code class="eh lt lu lv lw b">test</code>，我们将在下一节中解决这个问题。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="3e24" class="lz kx hu lw b fv mr ms l mt mu">"scripts": {<br/>  // ...<br/>  <strong class="lw hv">"test": "cross-env BABEL_ENV=test jest --config jest.json",<br/>  "test:watch": "cross-env BABEL_ENV=test jest --config jest.json --watch"</strong><br/>}</span></pre><h2 id="75a1" class="lz kx hu bd ky ma mb mc lc md me mf lg ki mg mh li km mi mj lk kq mk ml lm mm dt translated">用巴别塔配置 Jest</h2><p id="5068" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">首先，为了让测试工作，我们需要配置一些巴别塔设置。在您的<code class="eh lt lu lv lw b">.babelrc</code>文件的<code class="eh lt lu lv lw b">env</code>键中添加以下部分:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="dfe9" class="lz kx hu lw b fv mr ms l mt mu">{<br/>  "env": {<br/>    <strong class="lw hv">"test": {<br/>      "presets":[<br/>        ["@babel/preset-env"],<br/>        ["@babel/preset-react"],<br/>      ],<br/>      "plugins": [<br/>        ["@babel/plugin-syntax-dynamic-import"]<br/>      ]<br/>    },</strong><br/>    // ...<br/>  }<br/>}</span></pre><p id="da50" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们安装我们提到的插件和预置:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="938a" class="lz kx hu lw b fv mr ms l mt mu">npm i --save-dev @babel/core @babel/preset-env @babel/preset-react @babel/plugin-syntax-dynamic-import babel-jest</span></pre><p id="c5f2" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我们目前的覆盖率为 0%，让我们为应用程序添加一个测试，并为服务器添加一个测试，这将使我们超过 10%的低阈值。</p><h2 id="a273" class="lz kx hu bd ky ma mb mc lc md me mf lg ki mg mh li km mi mj lk kq mk ml lm mm dt translated">用 Enzyme 测试客户端应用</h2><p id="f125" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">首先，我们来测试一下<code class="eh lt lu lv lw b">app</code>中的一个文件。我们将希望在应用程序中浅层渲染我们的组件来测试它们。为此，我们将使用<code class="eh lt lu lv lw b">enzyme</code>。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="c163" class="lz kx hu lw b fv mr ms l mt mu">npm i --save-dev enzyme <!-- -->enzyme-adapter-react-16</span></pre><p id="3b1a" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">Enzyme 有一个设置步骤，我们必须在测试中使用它之前添加这个步骤。在我们的<code class="eh lt lu lv lw b">jest.json</code>文件中，添加一个新的键:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="96c5" class="lz kx hu lw b fv mr ms l mt mu">{<br/>//other settings<br/>"setupTestFrameworkScriptFile": "&lt;rootDir&gt;/__tests__/setup.js"<br/>}</span></pre><p id="93fa" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">以及<code class="eh lt lu lv lw b">__tests__/unit/setup.js</code>处的设置文件:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="1886" class="lz kx hu lw b fv mr ms l mt mu">import { configure } from 'enzyme';<br/>import Adapter from 'enzyme-adapter-react-16';</span><span id="1513" class="lz kx hu lw b fv mv ms l mt mu">configure({ adapter: new Adapter() });</span></pre><p id="0f67" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在配置好酶，我们可以创建<code class="eh lt lu lv lw b">__tests__/unit/app/pages/Home.jsx</code>:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="9904" class="lz kx hu lw b fv mr ms l mt mu">import React from 'react'<br/>import { shallow } from 'enzyme'<br/>import Home from 'app/pages/Home.jsx'</span><span id="b17a" class="lz kx hu lw b fv mv ms l mt mu">describe('app/pages/Home.jsx', () =&gt; {<br/>  it('renders style component', () =&gt; {<br/>    expect(Home).toBeDefined()<br/>    const tree = shallow(&lt;Home /&gt;)<br/>    expect(tree.find('Page')).toBeDefined()<br/>    expect(tree.find('Helmet').find('title').text()).toEqual('Home Page')<br/>    expect(tree.find('div').text()).toEqual('Follow me at <a class="ae kv" href="http://twitter.com/patrickleet" rel="noopener ugc nofollow" target="_blank">@patrickleet</a>')<br/>    expect(tree.find('div').find('a').text()).toEqual('<a class="ae kv" href="http://twitter.com/patrickleet" rel="noopener ugc nofollow" target="_blank">@patrickleet</a>')<br/>  })<br/>})</span></pre><p id="e8cd" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">似乎我们的组件只是一个单一的功能，这就是我们需要达到这个文件 100%的覆盖率。</p><h2 id="ba98" class="lz kx hu bd ky ma mb mc lc md me mf lg ki mg mh li km mi mj lk kq mk ml lm mm dt translated">服务器端测试</h2><p id="6217" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">为了更好地衡量，让我们也创建一个服务器端测试。</p><p id="af11" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">我想测试<code class="eh lt lu lv lw b">server/index.js</code>，但在此之前，有几个重构会让我们的生活变得稍微轻松一些。</p><p id="a123" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">单元测试意味着测试单个单元。这意味着即使我们的应用程序使用 express，我们也不会在单元测试中测试 express。我们正在测试我们的服务器是否配置了适当的路由、中间件，以及是否调用了 listen 来启动服务器。express 的单元测试属于 express 项目。</p><p id="b52b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">为了只测试我们关心的单个单元，我们可以使用 mocking 来创建轻量级接口，我们可以使用<code class="eh lt lu lv lw b">jest.mock</code>来跟踪这些接口。如果我们将服务器实例从索引中提取到它自己的文件中，我们将能够更容易地模拟服务器。</p><p id="961c" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">创建包含以下内容的文件<code class="eh lt lu lv lw b">server/lib/server.js</code>:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="ebd7" class="lz kx hu lw b fv mr ms l mt mu">import express from 'express'</span><span id="e761" class="lz kx hu lw b fv mv ms l mt mu">export const server = express()<br/>export const serveStatic = express.static</span></pre><p id="deff" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">还有更新<code class="eh lt lu lv lw b">server/index.js</code>像这样:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="83ce" class="lz kx hu lw b fv mr ms l mt mu">import path from 'path'<br/>import log from 'llog'<br/><strong class="lw hv">import { server, serveStatic } from './lib/server'</strong><br/>import ssr from './lib/ssr'</span><span id="6720" class="lz kx hu lw b fv mv ms l mt mu">// Expose the public directory as /dist and point to the browser version<br/><strong class="lw hv">server</strong>.use(<br/>  '/dist/client',<br/>  <strong class="lw hv">serveStatic</strong>(path.resolve(process.cwd(), 'dist', 'client'))<br/>)</span><span id="ef52" class="lz kx hu lw b fv mv ms l mt mu">// Anything unresolved is serving the application and let<br/>// react-router do the routing!<br/><strong class="lw hv">server</strong>.get('/*', ssr)</span><span id="8448" class="lz kx hu lw b fv mv ms l mt mu">// Check for PORT environment variable, otherwise fallback on Parcel default port<br/>const port = process.env.PORT || 1234<br/><strong class="lw hv">server</strong>.listen(port, () =&gt; {<br/>  log.info(`Listening on port ${port}...`)<br/>})</span></pre><p id="4726" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在在我们的测试中，我们可以简单地模仿<code class="eh lt lu lv lw b">server/lib/server.js</code>，而不是更复杂的模仿<code class="eh lt lu lv lw b">express</code>。</p><p id="959b" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们在<code class="eh lt lu lv lw b">__tests__/unit/server/index.js</code>创建测试:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="bc81" class="lz kx hu lw b fv mr ms l mt mu">import 'server/index'</span><span id="f09d" class="lz kx hu lw b fv mv ms l mt mu">jest.mock('llog')<br/>jest.mock('server/lib/server', () =&gt; ({<br/>  server: {<br/>    use: jest.fn(),<br/>    get: jest.fn(),<br/>    listen: jest.fn()<br/>  },<br/>  serveStatic: jest.fn(() =&gt; "static/path")<br/>}))<br/>jest.mock('server/lib/ssr')</span><span id="73c1" class="lz kx hu lw b fv mv ms l mt mu">describe('server/index.js', () =&gt; {<br/>  it('main', () =&gt; {<br/>    const { server, serveStatic } = require('server/lib/server')<br/>    expect(server.use).toBeCalledWith('/dist/client', "static/path")<br/>   expect(serveStatic).toBeCalledWith(`${process.cwd()}/dist/client`)<br/>    expect(server.get).toBeCalledWith('/*', expect.any(Function))<br/>    expect(server.listen).toBeCalledWith(1234, expect.any(Function))<br/>  })<br/>})</span></pre><p id="6828" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">如果我们现在运行覆盖率，我们会注意到<code class="eh lt lu lv lw b">server/index.js</code>的覆盖率不是 100%。我们有一个匿名函数传递给 listen，这个函数很难获取。这需要一些小的重构。</p><p id="7984" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">重构 listen 调用以提取匿名函数。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="9ddf" class="lz kx hu lw b fv mr ms l mt mu">export const onListen = port =&gt; () =&gt; {<br/>  log.info(`Listening on port ${port}...`)<br/>}<br/>server.listen(port, onListen(port))</span></pre><p id="3323" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在我们可以轻松测试<code class="eh lt lu lv lw b">onListen</code>。</p><p id="f8e7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">让我们向我们的<code class="eh lt lu lv lw b">server/index.js</code>套件添加另一个测试来解释它。</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="435f" class="lz kx hu lw b fv mr ms l mt mu">import <strong class="lw hv">{ onListen } from</strong> 'server/index'</span><span id="bd7d" class="lz kx hu lw b fv mv ms l mt mu">// ...</span><span id="55c4" class="lz kx hu lw b fv mv ms l mt mu">describe('server/index.js', () =&gt; {<br/>  // ...</span><span id="1c87" class="lz kx hu lw b fv mv ms l mt mu">  <strong class="lw hv">it('onListen', () =&gt; {<br/>    const log = require('llog')<br/>    onListen(4000)()<br/>    expect(log.info).toBeCalledWith('Listening on port 4000...')<br/>  })</strong><br/>})</span></pre><p id="6b05" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">有了这些，我们对<code class="eh lt lu lv lw b">server/index.js</code>和<code class="eh lt lu lv lw b">app/pages/Home.jsx</code>有了 100%的覆盖率。</p><p id="866f" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">通过我们的两次测试，我们成功地将覆盖率从 0%提高到了 35–60 %,具体取决于指标:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff mw"><img src="../Images/3cfbc388146493889934249dc2ff7ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pmYql5L1HioeQLtb6gW9VA.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Current Coverage</figcaption></figure><h2 id="bb82" class="lz kx hu bd ky ma mb mc lc md me mf lg ki mg mh li km mi mj lk kq mk ml lm mm dt translated">向预提交挂钩添加测试</h2><p id="d888" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">最后，我们只希望确保测试作为一个预提交挂钩，以防止中断的测试进入代码，以及以后任何未测试的代码。</p><p id="a626" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在<code class="eh lt lu lv lw b">package.json</code>中，将<code class="eh lt lu lv lw b">pre-commit</code>改为:</p><pre class="jk jl jm jn fq mn lw mo mp aw mq dt"><span id="b40e" class="lz kx hu lw b fv mr ms l mt mu">"pre-commit": "lint-staged &amp;&amp; npm run test"</span></pre><p id="2606" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">现在，当有人试图提交项目时，它将强制执行 Jest 配置中定义的覆盖标准，并确保所有测试都通过！</p><h1 id="12c0" class="kw kx hu bd ky kz la lb lc ld le lf lg ja lh jb li jd lj je lk jg ll jh lm ln dt translated">结论</h1><p id="770d" class="pw-post-body-paragraph jz ka hu kb b kc lo iv ke kf lp iy kh ki lq kk kl km lr ko kp kq ls ks kt ku hn dt translated">当您的应用程序生产准备就绪时，以自动化的方式执行质量标准是非常必要的。在本文中，我向您展示了如何设置和配置林挺工具和格式化您的代码，以及如何配置您的项目，以便使用 enzyme 和 jest 进行测试和强制代码覆盖。</p><p id="1350" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">在下一部分中，我们将在继续创建生产就绪 Dockerfile 文件之前将覆盖率提高到 100%。</p><p id="0220" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">和往常一样，如果你觉得这很有帮助，请点击并按住拍手按钮，最多拍 50 次，跟我来，并与他人分享！</p><p id="8db7" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">最好，<br/> <a class="ae kv" href="https://twitter.com/pat_scott" rel="noopener ugc nofollow" target="_blank">李雅达·斯科特</a></p></div><div class="ab cl mx my hc mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hn ho hp hq hr"><p id="0075" class="pw-post-body-paragraph jz ka hu kb b kc kd iv ke kf kg iy kh ki kj kk kl km kn ko kp kq kr ks kt ku hn dt translated">查看本系列的其他文章！这是第三部分。</p><div class="ne nf fm fo ng nh"><a href="https://hackernoon.com/move-over-next-js-and-webpack-ba367f07545" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab ej"><div class="nj ab nk cl cj nl"><h2 class="bd hv fv z el nm eo ep nn er et ht dt translated">第 1 部分:讨论 Next.js 和 Webpack🤯</h2><div class="no l"><h3 class="bd b fv z el nm eo ep nn er et ek translated">简单流服务器端渲染(SSR)反应+样式-组件与包裹</h3></div><div class="np l"><p class="bd b gc z el nm eo ep nn er et ek translated">hackernoon.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv jt nh"/></div></div></a></div><div class="ne nf fm fo ng nh"><a href="https://hackernoon.com/a-better-way-to-develop-node-js-with-docker-cd29d3a0093" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab ej"><div class="nj ab nk cl cj nl"><h2 class="bd hv fv z el nm eo ep nn er et ht dt translated">第 2 部分:用 Docker 开发 Node.js 的更好方法</h2><div class="no l"><h3 class="bd b fv z el nm eo ep nn er et ek translated">并保持您的热代码重载</h3></div><div class="np l"><p class="bd b gc z el nm eo ep nn er et ek translated">hackernoon.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv jt nh"/></div></div></a></div><div class="ne nf fm fo ng nh"><a href="https://hackernoon.com/the-100-code-coverage-myth-900b83d20d3d" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab ej"><div class="nj ab nk cl cj nl"><h2 class="bd hv fv z el nm eo ep nn er et ht dt translated">第 4 部分:100%代码覆盖率的神话</h2><div class="no l"><h3 class="bd b fv z el nm eo ep nn er et ek translated">现在互联网上有很多建议说 100%的覆盖率不是一个有价值的目标。是吗？</h3></div><div class="np l"><p class="bd b gc z el nm eo ep nn er et ek translated">hackernoon.com</p></div></div><div class="nq l"><div class="nx l ns nt nu nq nv jt nh"/></div></div></a></div><div class="ne nf fm fo ng nh"><a href="https://hackernoon.com/a-tale-of-two-docker-multi-stage-build-layers-85348a409c84" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab ej"><div class="nj ab nk cl cj nl"><h2 class="bd hv fv z el nm eo ep nn er et ht dt translated">第 5 部分:两层(Docker 多阶段构建)的故事</h2><div class="no l"><h3 class="bd b fv z el nm eo ep nn er et ek translated">Node.js 的生产就绪 docker 文件</h3></div><div class="np l"><p class="bd b gc z el nm eo ep nn er et ek translated">hackernoon.com</p></div></div><div class="nq l"><div class="ny l ns nt nu nq nv jt nh"/></div></div></a></div></div></div>    
</body>
</html>