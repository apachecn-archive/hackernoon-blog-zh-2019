<html>
<head>
<title>Understanding Design Patterns: Facade using Pokemon and Dragonball Examples!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解设计模式:正面使用口袋妖怪和龙珠的例子！</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/understanding-design-patterns-facade-using-pokemon-and-dragonball-examples-5aeaa49e2b64?source=collection_archive---------9-----------------------#2019-04-05">https://medium.com/hackernoon/understanding-design-patterns-facade-using-pokemon-and-dragonball-examples-5aeaa49e2b64?source=collection_archive---------9-----------------------#2019-04-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="aa74" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">有23个经典的设计模式，在原著<code class="eh jp jq jr js b">Design Patterns: Elements of Reusable Object-Oriented Software</code>中有描述。这些模式为软件开发中经常重复出现的特定问题提供解决方案。</p><p id="0851" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我将描述如何使用<strong class="it hv"> Facade模式；以及</strong>如何以及何时应用。</p><h1 id="6721" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">门面模式:基本思想</h1><blockquote class="kr ks kt"><p id="292b" class="ir is ku it b iu iv iw ix iy iz ja jb kv jd je jf kw jh ji jj kx jl jm jn jo hn dt translated"><em class="hu">门面模式</em><strong class="it hv"><em class="hu"/></strong><em class="hu">(也拼写为</em>门面<em class="hu">)是一种</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank"> <em class="hu">软件设计模式</em></a><em class="hu"/><a class="ae ky" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"><em class="hu"/></a><em class="hu">。类似于架构中的</em><a class="ae ky" href="https://en.wikipedia.org/wiki/Facade" rel="noopener ugc nofollow" target="_blank"><em class="hu">facade</em></a><em class="hu">，facade是一个作为前端接口的对象，它屏蔽了更复杂的底层或结构代码。</em> —维基百科</p><p id="bd75" class="ir is ku it b iu iv iw ix iy iz ja jb kv jd je jf kw jh ji jj kx jl jm jn jo hn dt translated"><em class="hu">为子系统中的一组接口提供统一的接口。Facade定义了一个更高级的接口，使得子系统更容易使用。-设计模式:可重用面向对象软件的要素</em></p></blockquote><p id="69c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种模式的主要特点是使用一个类来简化复杂系统的接口。因此，这是该模式解决的两个问题:</p><ol class=""><li id="217c" class="kz la hu it b iu iv iy iz jc lb jg lc jk ld jo le lf lg lh dt translated">复杂子系统更容易使用。</li><li id="12e4" class="kz la hu it b iu li iy lj jc lk jg ll jk lm jo le lf lg lh dt translated">对子系统的依赖性被最小化。</li></ol><p id="7079" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">总而言之，facade模式包含不同类的几个实例，这些实例必须对客户端隐藏。这是简化界面的方式。这个模式的UML图如下所示:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ln"><img src="../Images/2a36f4644301c57872a8c45d8a664957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sriiv6rKfaIAi_1X.png"/></div></div></figure><p id="0afb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">Facade</code>类是模块和外部客户端之间的中间件。在UML中有一个单一的<code class="eh jp jq jr js b">Facade</code>类，但是当接口非常复杂时，该模式可以在不同的层之间使用。</p><h1 id="0aa8" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">门面模式:何时使用</h1><ol class=""><li id="6b8e" class="kz la hu it b iu lz iy ma jc mb jg mc jk md jo le lf lg lh dt translated">有一个复杂的系统，你需要一个简单的界面来与它交流。</li><li id="a71c" class="kz la hu it b iu li iy lj jc lk jg ll jk lm jo le lf lg lh dt translated">由于客户需要关于系统的广泛知识，代码是紧密耦合的。Facade模式允许减少组件之间的耦合。</li><li id="de33" class="kz la hu it b iu li iy lj jc lk jg ll jk lm jo le lf lg lh dt translated">系统需要一个进入分层软件每一层的入口点。</li></ol><p id="18a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">Facade模式有几个优点，概括起来有以下几点:</p><ul class=""><li id="aa8e" class="kz la hu it b iu iv iy iz jc lb jg lc jk ld jo me lf lg lh dt translated">代码更容易使用、理解和测试，因为外观简化了界面。</li><li id="c9cb" class="kz la hu it b iu li iy lj jc lk jg ll jk lm jo me lf lg lh dt translated"><strong class="it hv">干净的代码</strong>因为客户端/上下文不使用复杂的接口，系统更加<strong class="it hv">灵活和可重用</strong>。</li></ul><h1 id="05a0" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">外观模式——示例1:一个客户想要使用来自不同系统几个类</h1><p id="7167" class="pw-post-body-paragraph ir is hu it b iu lz iw ix iy ma ja jb jc mf je jf jg mg ji jj jk mh jm jn jo hn dt translated">我现在将向您展示如何使用JavaScript/TypeScript实现这种模式。在我们的例子中，我虚构了一个问题，其中有一个名为<code class="eh jp jq jr js b">Client</code>的类，它定义了两个方法，这两个方法使用了不同包中的几个类(<code class="eh jp jq jr js b">System1</code>和<code class="eh jp jq jr js b">System2</code>)。这些包由几个具有几个公共方法的类组成。下面的UML图显示了我刚刚描述的场景。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mi"><img src="../Images/bb0a875d2fa205d51938c8ba2a0e26a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CNl34U529_pnrVYd.jpg"/></div></div></figure><p id="73c0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">client</code>代码关联如下:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mj"><img src="../Images/8fb0c23ce9e9499bf4a5c15800bb76f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijAVEv3xLT0Ka41p8d0DKQ.png"/></div></div></figure><p id="afe9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这种解决方案的主要问题是代码是耦合的。也就是说，客户需要知道每个类在哪里以及如何工作。进口的大清单是门面是我们问题的解决方案的第一个征兆。另一个警告症状是客户需要对每个类的操作有广泛的了解。</p><p id="9b7b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决方案是使用一个facade模式，该模式包含在一个使用了<code class="eh jp jq jr js b">System1</code>和<code class="eh jp jq jr js b">System2</code>的类(<code class="eh jp jq jr js b">Facade</code>)中。也就是说，使用适配器模式的新UML图如下所示:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mk"><img src="../Images/7b363a847ff0d198e1aed6f295d02508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DWkMpSiAjxwF7AhE.jpg"/></div></div></figure><p id="ca55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与客户端和外观相关的代码如下:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ml"><img src="../Images/de3bb1891416be0bc5ad1dd416224aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejWJFZJDAM2kdK_tAw1yAQ.png"/></div></div></figure><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mm"><img src="../Images/869e057190dee8331f710f80e96c4a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k49IW53_iqQC5hZYqOnQrQ.png"/></div></div></figure><p id="0f43" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在新代码中，客户端将责任委托给外观，但是外观做的是与客户端相同的功能。事实上，如果代码增加，facade可以是一个名为<strong class="it hv">BLOB</strong>(【https://sourcemaking.com/antipatterns/the-blob】T21)的反模式。因此，一个好主意是在每个包中使用一个facade，就像你在下面的UML中看到的那样:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mn"><img src="../Images/64880cce9b267cfdae1ace7d843ae401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i4N4Uz1YYmhCym3l.jpg"/></div></div></figure><p id="7018" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">本解决方案中与<code class="eh jp jq jr js b">client</code>、<code class="eh jp jq jr js b">facade</code>、<code class="eh jp jq jr js b">facadeSystem1</code>和<code class="eh jp jq jr js b">facadeSystem2</code>相关的代码如下:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ml"><img src="../Images/de3bb1891416be0bc5ad1dd416224aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ejWJFZJDAM2kdK_tAw1yAQ.png"/></div></div></figure><p id="8c89" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">客户端与先前版本中的客户端完全相同。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mo"><img src="../Images/6c27c01b253c995a10891207e8655da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUB1R7kXDe5tpCE6MCEBmg.png"/></div></div></figure><p id="6f97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">外观使用为每个子系统创建的每个外观。现在更重要的是Facade类只知道由<code class="eh jp jq jr js b">FacadeSystem1</code>和<code class="eh jp jq jr js b">FacadeSystem2</code>提供的接口。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mp"><img src="../Images/4adafbe8d8757724e6ef2c6761dc9339.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtkT9XPrZgGdSTapOwukDQ.png"/></div></div></figure><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mp"><img src="../Images/6bcafad492a5140994c12c8432cd13f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EHbH8qh2xNEPiwT4jxAnfw.png"/></div></div></figure><p id="58bc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">FacadeSystem1</code>和<code class="eh jp jq jr js b">FacadeSystem2</code>只知道它们包的类。需要提醒的是，每个facade只导出应该是公共的类，这些方法可以是内部类之间的几个方法的组合。</p><p id="31f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经创建了几个npm脚本，在应用了Facade模式之后，这些脚本运行这里显示的代码示例。</p><p id="cecd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">npm run example1-problem</code><br/><code class="eh jp jq jr js b">npm run example1-facade-solution-1</code><br/>T2】</p><h1 id="cb9c" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">门面格局——例2:口袋妖怪和龙珠一起包装！</h1><p id="9786" class="pw-post-body-paragraph ir is hu it b iu lz iw ix iy ma ja jb jc mf je jf jg mg ji jj jk mh jm jn jo hn dt translated">使用Facade模式解决的另一个有趣的问题是，有几个具有不同接口的包，但它们可以一起工作。在下面的UML图中，您可以看到这种情况:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mq"><img src="../Images/260b704384707e82e4c4258e79c55ccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLfvtQU1yqTKGIR6qyPyGw.jpeg"/></div></div></figure><p id="bd7a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这种情况下，客户端使用包<code class="eh jp jq jr js b">DragonballFacade</code>和<code class="eh jp jq jr js b">PokemonFacade</code>。因此，客户端只需要知道这些外观提供的接口。例如，<code class="eh jp jq jr js b">DragonballFacade</code>提供了一个名为<code class="eh jp jq jr js b">genki</code>的方法，它计算几个一起工作的对象的值。另一方面，<code class="eh jp jq jr js b">PokemonFacade</code>提供了一个名为<code class="eh jp jq jr js b">calculateDamage</code>的方法，它与其包中的其他类进行交互。</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div class="fe ff mr"><img src="../Images/ca0abbc0803ceae2c44c99039d56c9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*81ixHnFQRVePOcdP.jpg"/></div></figure><p id="51d8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与客户端关联的代码如下:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff ms"><img src="../Images/0bdd2586b213723b5748fc63f4fed6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foXq8DMMUow1f538Vhbx9w.png"/></div></div></figure><p id="2779" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">与正面相关的代码如下:</p><figure class="lo lp lq lr fq ls fe ff paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="fe ff mt"><img src="../Images/9e99cce4ade5b93bdda74fba86175869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpiBStjKSns9JeUZx3iaYQ.png"/></div></div></figure><p id="0648" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经创建了两个npm脚本，它们在应用了Facade模式后运行这里显示的两个示例。</p><p id="22a1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh jp jq jr js b">npm run example2-problem</code> <br/> <code class="eh jp jq jr js b">npm run example2-facade-solution1</code></p><p id="8480" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">支持外观的一个巨大优势是从一个不那么简单的系统开发出最简单的系统。例如，在龙珠包中有一个<a class="ae ky" href="https://carloscaballero.io/design-patterns-adapter/" rel="noopener ugc nofollow" target="_blank">适配器模式</a>，它不影响客户端的正确行为。但是口袋妖怪包的复杂性更大，因为有一个称为<a class="ae ky" href="https://carloscaballero.io/design-patterns-template-method/" rel="noopener ugc nofollow" target="_blank">模板方法</a>的设计模式用于<code class="eh jp jq jr js b">calculateDamage</code>的方法，还有一个工厂模式用于创建不同的口袋妖怪。所有这些复杂性都隐藏在外观中，这些类中的任何变化都不会影响客户的行为，这使得我们可以创建更多的非耦合系统。</p><h1 id="5799" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">结论</h1><p id="7a2f" class="pw-post-body-paragraph ir is hu it b iu lz iw ix iy ma ja jb jc mf je jf jg mg ji jj jk mh jm jn jo hn dt translated">Facade模式可以避免项目中的复杂性，当有几个包相互通信，或者一个客户需要使用几个类时，facade模式非常适合。</p><p id="edc7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">最重要的事情不是实现我向你展示的模式，而是能够识别这个特定模式可以解决的问题，以及何时可以或不可以实现所述模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p><h1 id="9d06" class="jt ju hu bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dt translated">更多更多…</h1><ul class=""><li id="6025" class="kz la hu it b iu lz iy ma jc mb jg mc jk md jo me lf lg lh dt translated">设计模式:可重用的面向对象软件的元素。</li><li id="aad0" class="kz la hu it b iu li iy lj jc lk jg ll jk lm jo me lf lg lh dt translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Facade_pattern" rel="noopener ugc nofollow" target="_blank">门面模式——维基百科</a>。</li><li id="ff1f" class="kz la hu it b iu li iy lj jc lk jg ll jk lm jo me lf lg lh dt translated">【https://www.dofactory.com/javascript/facade-design-pattern T4】</li><li id="9afb" class="kz la hu it b iu li iy lj jc lk jg ll jk lm jo me lf lg lh dt translated"><a class="ae ky" href="https://github.com/sohamkamani/javascript-design-patterns-for-humans#-facade" rel="noopener ugc nofollow" target="_blank">https://github . com/sohamkamani/JavaScript-design-patterns-for-humans #-facade</a></li></ul></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><ul class=""><li id="d8ff" class="kz la hu it b iu iv iy iz jc lb jg lc jk ld jo me lf lg lh dt translated">本帖的<strong class="it hv"> GitHub </strong>分支为<a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/adapter-pattern" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Caballerog/blog/tree/master/facade-pattern</a></li></ul></div><div class="ab cl mu mv hc mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="ed6e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="ku">最初发布于</em><a class="ae ky" href="https://carloscaballero.io/design-patterns-facade" rel="noopener ugc nofollow" target="_blank"><em class="ku">www . carloscaballero . io</em></a><em class="ku">。</em></p></div></div>    
</body>
</html>