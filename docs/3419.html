<html>
<head>
<title>Refetch Strategies for Apollo’s GraphQL client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apollo 的 GraphQL 客户机的检索策略</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/refetch-strategies-for-apollos-graphql-client-248a449734cd#2019-06-02">https://medium.com/hackernoon/refetch-strategies-for-apollos-graphql-client-248a449734cd#2019-06-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="20bb" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">有几种方法可以重新提取数据。在本文中，我们通过示例来探究它们。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff jj"><img src="../Images/5a433e4f7f2c4301f09698e42b1a9320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*jofXE80HQMuadyEr-sGyAg.jpeg"/></div></figure><h1 id="59e8" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">设置</h1><p id="3473" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">在<a class="ae lf" href="https://hackernoon.com/giving-react-a-lift-with-apollo-boost-74c6ff32894d" rel="noopener ugc nofollow" target="_blank">用 Apollo-Boost </a>提升 React + GraphQL 中，我演示了如何快速启动和运行 React 应用程序，然后如何整合来自<a class="ae lf" href="https://www.npmjs.com/package/apollo-boost" rel="noopener ugc nofollow" target="_blank"> apollo-boost </a>的 ApolloClient React 组件。在撰写本文时，我使用 Apollo Launchpad 服务创建了一个 GraphQL 服务器实例，但现在它已经寿终正寝了。这次我将安装并运行来自<a class="ae lf" href="https://www.apollographql.com/docs/tutorial/introduction" rel="noopener ugc nofollow" target="_blank"> Apollo GraphQL 教程</a>的 GraphQL 服务器。下面是让该服务器运行的步骤:</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="4e44" class="ll js hu lh b fv lm ln l lo lp">git clone <a class="ae lf" href="https://github.com/apollographql/fullstack-tutorial/" rel="noopener ugc nofollow" target="_blank">https://github.com/apollographql/fullstack-tutorial/</a><br/>cd fullstack-tutorial/final/server<br/>npm install<br/>npm run-script start:ci</span></pre><p id="4b40" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">成功后，您将会看到:</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="9dbb" class="ll js hu lh b fv lm ln l lo lp">$ npm run-script start:ci<br/>...</span><span id="b81b" class="ll js hu lh b fv lv ln l lo lp">🚀 app running at <a class="ae lf" href="http://localhost:4000/" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/</a></span></pre><p id="4dfd" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">服务器必须在本地运行，我将要介绍的应用程序源的各个分支才能正常工作。</p><h1 id="99a6" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">该应用程序</h1><p id="1dbb" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">我忽略了 Apollo 教程附带的客户端，用我自己的替代。在本文中，我将遍历我的 GitHub 库的几个分支，在本文的最后有每个分支的链接。</p><p id="e98e" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">在开始之前，先在浏览器中查看一下位于<a class="ae lf" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000 </a>的 GraphQL 模式:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff lw"><img src="../Images/90b7bea101c7703f178608af781f4f7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPBXj__ZoMMYXk1NssPHig.png"/></div></div></figure><p id="14e8" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">从操场上，我可以查询<code class="eh mb mc md lh b">launches</code>:</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff me"><img src="../Images/94110e6e3c005a6bafcc8c1962c271ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7DDyXzjCljaDoPw7aeeGPQ.png"/></div></div></figure><p id="49dd" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">到目前为止，一切顺利。现在是时候搭建一个 app 了。在前面提到的文章中，React 应用程序是由<a class="ae lf" href="https://facebook.github.io/create-react-app/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>生成的。在这里，我会做同样的事情:</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="59f1" class="ll js hu lh b fv lm ln l lo lp">npx create-react-app apollo-refetch<br/>cd my-app<br/>npm start</span></pre><p id="106a" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">一旦所有东西都被加载并且服务器正在运行，您将看到一个原子的旋转图形。不错，但是没用。在替换该图形之前，我需要安装 GraphQL 和 Apollo 的 react 工具:</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="9493" class="ll js hu lh b fv lm ln l lo lp">npm i apollo-boost graphql react-apollo -S</span></pre><p id="b1b3" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">现在我们准备好出发了。</p><h1 id="98ea" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">第一步:查询组件</h1><p id="a9f1" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">我将首先创建一个名为<strong class="kl hv">launchs 的组件。</strong>这将替换在 apollo-boost 生成的应用的<code class="eh mb mc md lh b">src/App.js</code>中找到的应用组件的内部。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="9ae0" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">这产生了(在一些偷来的 CSS 的帮助下):</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mh"><img src="../Images/7105d216140d94289f852a7959c1b434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNzUmWc7yBy_xZ5VY9_OFQ.png"/></div></div></figure><p id="b94c" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">此初始页面将是只读视图。我添加了一个按钮，该按钮将导航到一个编辑器页面，以便可以对启动列表进行更改。</p><h1 id="0d5c" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">下一步:编辑器组件</h1><p id="3e48" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">编辑器组件看起来很像发布列表，但是有一个用于预订一个或多个发布的控件。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff mi"><img src="../Images/2fd714518d62a2ecd3eaef7481a7b61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWSaRTHICJjct_T-T7jG5g.png"/></div></div></figure><p id="8ae6" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">编辑器代码有一个类似于 Launches 页面的查询，还有两个变化，一个用于登录，另一个用于更新任务预订。</p><p id="c3cb" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">全栈教程中的服务器应用程序要求在授权预订之前登录。出于我的目的，我将从<a class="ae lf" href="https://www.npmjs.com/package/faker" rel="noopener ugc nofollow" target="_blank"> faker </a>生成一封随机的登录电子邮件，执行登录，获取 auth 密钥，然后确保我的 Apollo 客户端实例知道它以用于后续请求:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div><figcaption class="mj mk fg fe ff ml mm bd b be z ek">Full source code links at bottom of this post.</figcaption></figure><p id="45b2" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">它有一些问题。如果你去编辑页面，预订一两个航班，然后点击提交，它可能看起来没问题。但是，页面应该只显示未预订的航班，所以一旦执行了变异，您预订的航班应该会从列表中消失。此外，如果您返回到起始页，航班仍将显示为未预订。问题是，在您没有告诉它们的情况下，突变不会重新提取数据，如果没有重新提取，React 组件将不会重新呈现。</p><p id="3377" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">有几种重新提取数据的技术，这就是本文的其余部分。</p><h1 id="81bf" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">查询/检索</h1><p id="6e4d" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">最简单的重取场景是当组件既查询又变异时。该组件首先查询以填充比如说一个项目列表；然后，组件中有一个控件触发一个突变操作，比如添加/删除/修改一个或多个项目。一旦执行了突变，就通过重新提取数据来更新组件。</p><p id="7638" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">编辑器就是这样一个组件:</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="mf mg l"/></div></figure><p id="de57" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">查询子组件(从 apollo-client 导出)包装了前面显示的提交组件，其中包含一个 Mutate 组件。</p><p id="7385" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">在这种情况下，如果我想更新列表，使它不再显示我刚刚预订的航班，我可以使用查询组件提供的<code class="eh mb mc md lh b">refetch</code>函数:</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="b338" class="ll js hu lh b fv lm ln l lo lp">&lt;Query query={LAUNCHES}&gt;<br/>      {({ data, loading, error, <strong class="lh hv">refetch</strong> }) =&gt; {<br/>...<br/>            &lt;Submit refetch={refetch}/&gt;</span></pre><p id="4e6e" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">现在，当 Submit 执行变异时，它可以在之后重新提取:</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="dc22" class="ll js hu lh b fv lm ln l lo lp">const submitChanges = (evt, mBook, refetch) =&gt; {<br/>  const bookingElems = document.getElementsByName('booking')<br/>  const bookedAry = [];</span><span id="b9aa" class="ll js hu lh b fv lv ln l lo lp">if (bookingElems.length) {<br/>    bookingElems.forEach(booked =&gt; {<br/>      if (booked.checked)<br/>        bookedAry.push(booked.id)<br/>    });<br/>    mBook({variables: {ids: bookedAry}})<br/>    <strong class="lh hv">refetch();</strong><br/>  }<br/>}</span><span id="975a" class="ll js hu lh b fv lv ln l lo lp">const Submit = (props) =&gt; {<br/>  const {<strong class="lh hv">refetch</strong>} = props;<br/>...</span><span id="ef07" class="ll js hu lh b fv lv ln l lo lp">  return &lt;Mutation mutation={BOOK}}&gt;<br/>         {mBook =&gt; (<br/>            &lt;input type="submit" value="Submit Changes"<br/>              onClick={evt =&gt; submitChanges(evt, mBook, <strong class="lh hv">refetch</strong>)} /&gt;<br/>          )}<br/>        &lt;/Mutation&gt;</span></pre><p id="e44f" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">一切都很好，但是查询必须包含变异才能工作。的确，您可以将查询返回的 refetch 方法存储在某个 React 状态结构或 React 挂钩中，但还有另一种方法。</p><h1 id="3c0f" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">refetch 查询</h1><p id="7420" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">变异本身可以指导查询的重新提取，这又会更新显示查询结果的组件。</p><h2 id="83dd" class="ll js hu bd jt mn mo mp jx mq mr ms kb ks mt mu kd kw mv mw kf la mx my kh mz dt translated">按查询名称进行变异重取</h2><p id="286f" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">应用程序中有两个命名查询:<code class="eh mb mc md lh b">ls</code>和<code class="eh mb mc md lh b">bookie</code>。ls 查询用于 Launches 页面，bookie 查询用于 Editor 页面。</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="ee93" class="ll js hu lh b fv lm ln l lo lp">// Launches.js<br/>const qLaunches = gql`query ls {<br/>  launches {<br/>    launches {<br/>      id<br/>      site<br/>      mission {<br/>        name<br/>      }<br/>      rocket {<br/>        name<br/>        type<br/>      }<br/>      isBooked<br/>    }<br/>  }<br/>}`;</span><span id="9407" class="ll js hu lh b fv lv ln l lo lp">// Editor.js<br/>const LAUNCHES = gql`<br/>query bookie {<br/>  launches {<br/>    launches {<br/>      id<br/>      site<br/>      mission {<br/>        name<br/>      }<br/>      rocket {<br/>        name<br/>        type<br/>      }<br/>      isBooked<br/>    }<br/>  }<br/>}`;</span></pre><p id="1fec" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">注意到相似之处了吗？因为它们本质上是不同伪装下的相同查询，所以 Apollo 的缓存将使我将要演示的一些内容变得多余，但是概念是合理的。</p><p id="a372" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">我可以让突变组件<a class="ae lf" href="https://github.com/JeffML/apollo-refetch/tree/editorRefetch1" rel="noopener ugc nofollow" target="_blank">调用我想在突变完成后更新的查询</a>，而不是像传递烫手山芋一样传递<code class="eh mb mc md lh b">refetch</code>。</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="37ac" class="ll js hu lh b fv lm ln l lo lp">const Submit = (props) =&gt; {<br/>...<br/>        return &lt;Mutation mutation={BOOK} <strong class="lh hv">refetchQueries = {['ls', 'bookie']}</strong>&gt;<br/>          {mBook =&gt; (<br/>            &lt;input type="submit" value="Submit Changes"<br/>              onClick={evt =&gt; submitChanges(evt, mBook)} /&gt;<br/>          )}<br/>        &lt;/Mutation&gt;</span></pre><p id="b6e6" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">这将更新编辑器和启动页面。(实际上，由于我提到的缓存问题，更新一个会更新另一个。)</p><h2 id="0cdc" class="ll js hu bd jt mn mo mp jx mq mr ms kb ks mt mu kd kw mv mw kf la mx my kh mz dt translated">通过带有查询变量的完整查询进行的变异重取</h2><p id="542e" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">只要我没有必须传递给查询的变量，上述技术就没问题，但是如果我传递了变量，还有另一种语法:</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="4325" class="ll js hu lh b fv lm ln l lo lp">... refetchQueries = {[{<br/>        query: ['GetCollectionByUserId'],<br/>        variables: { userId : userId, first : :"Joe", last : "Friday"<br/>    }]}</span></pre><p id="bf2a" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">如果你不熟悉 GraphQL 查询变量，这里有一个例子<a class="ae lf" href="https://www.apollographql.com/docs/tutorial/queries/#fetching-a-single-launch" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9925" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">refetchQueries 技术的一个问题是，很难确定哪些突变会影响哪些查询。如果我要为一个大型项目编写一个新的突变组件，我会知道哪些查询受到影响吗？</p><h1 id="c138" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">投票</h1><p id="8329" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">保持查询组件新鲜的另一种技术是通过轮询。查询组件可以接受一个<code class="eh mb mc md lh b">pollInterval</code>属性，以毫秒为单位。</p><pre class="jk jl jm jn fq lg lh li lj aw lk dt"><span id="14b5" class="ll js hu lh b fv lm ln l lo lp">export default function Launches(props) {<br/>  const {setEditing} = props;</span><span id="b5c5" class="ll js hu lh b fv lv ln l lo lp">return (<br/>    &lt;Query query={qLaunches} <strong class="lh hv">pollInterval={1500}</strong>&gt;<br/>      {({ data, loading, error }) =&gt; {<br/>        if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;<br/>        if (error) return &lt;p&gt;ERROR&lt;/p&gt;;<br/>        return (<br/>          &lt;Fragment&gt;<br/>            &lt;input type='button' value='make changes' onClick={() =&gt; setEditing(true)}/&gt;<br/>            &lt;table style={{ border: 'solid 1px' }}&gt;<br/>              &lt;tbody&gt;<br/>                &lt;tr&gt;<br/>                  &lt;th&gt;Site&lt;/th&gt;&lt;th&gt;Mission&lt;/th&gt;&lt;th&gt;Rocket&lt;/th&gt;&lt;th&gt;Booked&lt;/th&gt;<br/>                &lt;/tr&gt;<br/>                {launchRows(data)}<br/>              &lt;/tbody&gt;<br/>            &lt;/table&gt;<br/>          &lt;/Fragment&gt;<br/>        );<br/>      }}<br/>    &lt;/Query&gt;<br/>  );<br/>};</span></pre><p id="80f5" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">然后，查询组件会不时刷新。如果监控实时事件，这可能非常方便，但是大量的轮询操作会影响网络性能。</p><h1 id="6088" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">捐款</h1><p id="f6c3" class="pw-post-body-paragraph kj kk hu kl b km kn iv ko kp kq iy kr ks kt ku kv kw kx ky kz la lb lc ld le hn dt translated">最后，GraphQL 提供了订阅功能，我之前已经<a class="ae lf" href="https://hackernoon.com/graphql-subscriptions-using-apollo-2-3eb3184768c4" rel="noopener ugc nofollow" target="_blank">写过关于它们的文章</a>。如果您对轮询不感兴趣，并且将查询和变化连接在一起似乎很难维护，那么拥有一个在订阅事件发生时刷新查询的订阅服务(如前所示，通过调用 refresh()方法)可能有其优势。</p><p id="308b" class="pw-post-body-paragraph kj kk hu kl b km lq iv ko kp lr iy kr ks ls ku kv kw lt ky kz la lu lc ld le hn dt translated">需要建立一点连接来实现这一点:基本上是从<code class="eh mb mc md lh b">subscribe</code>事件到查询<code class="eh mb mc md lh b">refresh()</code>方法的映射。与轮询相比，网络流量可能会减少，但代价是增加了到服务器的套接字连接。</p><h1 id="9631" class="jr js hu bd jt ju jv jw jx jy jz ka kb ja kc jb kd jd ke je kf jg kg jh kh ki dt translated">源代码</h1><ul class=""><li id="a6de" class="na nb hu kl b km kn kp kq ks nc kw nd la ne le nf ng nh ni dt translated">平原，不辞职工作编辑:<a class="ae lf" href="https://github.com/JeffML/apollo-refetch/tree/editor" rel="noopener ugc nofollow" target="_blank">https://github.com/JeffML/apollo-refetch/tree/editor</a></li><li id="f631" class="na nb hu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni dt translated">带 refetch 和 refetchQueries 的编辑器:<a class="ae lf" href="https://github.com/JeffML/apollo-refetch/tree/editorRefetch1" rel="noopener ugc nofollow" target="_blank">https://github . com/JeffML/Apollo-ref etch/tree/editorrefetch 1</a></li><li id="4805" class="na nb hu kl b km nj kp nk ks nl kw nm la nn le nf ng nh ni dt translated">查询轮询间隔:<a class="ae lf" href="https://github.com/JeffML/apollo-refetch/tree/polling" rel="noopener ugc nofollow" target="_blank">https://github.com/JeffML/apollo-refetch/tree/polling</a></li></ul></div></div>    
</body>
</html>