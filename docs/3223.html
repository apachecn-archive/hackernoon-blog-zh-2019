<html>
<head>
<title>Go + Serverless Offline, Wait Go! YES, It is really simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go +无服务器离线，Wait Go！是的，它确实被简化了</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/go-serverless-offline-wait-go-yes-it-is-really-simplified-1dea663b97d5?source=collection_archive---------5-----------------------#2019-05-22">https://medium.com/hackernoon/go-serverless-offline-wait-go-yes-it-is-really-simplified-1dea663b97d5?source=collection_archive---------5-----------------------#2019-05-22</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8b5a50035a1523e73f9bcada42ad5664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Hg4y5UoIt0BqW_zFKmu-A.jpeg"/></div></div><figcaption class="id ie fg fe ff if ig bd b be z ek">Complicated? Not Anymore!</figcaption></figure><div class=""/><p id="f741" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt ke translated"><span class="l kf kg kh bm ki kj kk kl km di"> B </span> ack在2018年，当AWS宣布支持lambda时，每个人都为这一重大宣布感到兴奋，后来这种支持部分来自不同的框架。然而，随着我们今天拥有的各种框架，如Serverless、AWS SAM、Apex，甚至是Terraform和CloudFormation等工具，记住所有这些命令变得非常困难，并且很难切换和迁移到不同的框架。</p><p id="8d76" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">我一直在市场上寻找一种解决方案，将所有这些框架包装在一个简单而强大的解决方案中，该解决方案统一了调用lambda函数或部署到AWS的所有命令，而无需记住特定的框架相关命令。不幸的是，每次我切换到使用或尝试不同的框架时，我都会在他们的网站上阅读大量的文档，并使用不同的插件来实现我所寻找的东西。这简直是浪费时间。</p><p id="caf8" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji ik">，</strong>因此，我想到了一个主意，将所有这些框架包装在一个简单的解决方案中，该方案根据您愿意使用的框架的选择来生成模板。不仅如此，它还允许您从一个框架切换到另一个框架，例如，如果您选择了无服务器(SLS ),您可以切换到AWS SAM。</p><h1 id="b5e6" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">先决条件</h1><ul class=""><li id="7016" class="ll lm ij ji b jj ln jn lo jr lp jv lq jz lr kd ls lt lu lv dt translated">安装<a class="ae lw" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">节点</a></li><li id="f483" class="ll lm ij ji b jj lx jn ly jr lz jv ma jz mb kd ls lt lu lv dt translated">安装<a class="ae lw" href="https://golang.org/dl/" rel="noopener ugc nofollow" target="_blank"> Go </a></li><li id="f4c5" class="ll lm ij ji b jj lx jn ly jr lz jv ma jz mb kd ls lt lu lv dt translated">安装Make [ <a class="ae lw" href="https://stackoverflow.com/questions/10265742/how-to-install-make-and-gcc-on-a-mac" rel="noopener ugc nofollow" target="_blank"> Mac </a>，<a class="ae lw" href="http://gnuwin32.sourceforge.net/packages/make.htm" rel="noopener ugc nofollow" target="_blank"> Windows </a>，<a class="ae lw" href="https://www.cyberciti.biz/faq/howto-installing-gnu-c-compiler-development-environment-on-ubuntu/" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a></li><li id="3bf5" class="ll lm ij ji b jj lx jn ly jr lz jv ma jz mb kd ls lt lu lv dt translated">安装Yeoman，又名yo，运行以下命令</li></ul><p id="3b25" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><em class="mc"> $ npm安装-g哟</em></p><h1 id="1983" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">我们走吧</h1><p id="28fe" class="pw-post-body-paragraph jg jh ij ji b jj ln jl jm jn lo jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">若要创建新服务，请运行以下命令。这应该会问你一些问题，比如语言、单元测试框架、路径及其类型。</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="9f6c" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ yo sls</em></span></pre><p id="96e5" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如下面的屏幕截图所示，您可以选择SAM或无服务器来管理部署。我计划增加更多的选项，如顶点，地形和云形成。</p><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div class="fe ff mu"><img src="../Images/dc842bfc34ade2fb684572388d9caa0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-fLaaSyHFPUOehoc1LRGA.png"/></div></figure><p id="e4ec" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">一旦你按下回车键，这将生成一堆脚本，简化大量繁重的工作，如本地调用、网络管理、调试..等等。</p><p id="eb1a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">现在，指定您需要添加到服务中的路由，以及您想要用来触发生成底层lambda的方法的类型。</p><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mv"><img src="../Images/14433f9108401d6bea207bc5d9e06ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iYXcR47Qo24eHHcGjKPAg.png"/></div></div></figure><p id="9c0c" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，指定要在单元测试中使用的框架</p><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mw"><img src="../Images/60bb8c09c7c76574c4c9a652d4a4fdab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g13Ln0os9yImmPFPtamTRw.png"/></div></div></figure><p id="d501" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如下图截图所示，这是我们搭建的。正如你所看到的，每条<em class="mc">路径</em>都有自己的目录，在这个目录下会有一个<em class="mc"> lambda </em>函数处理程序、简单的测试用例、<em class="mc"> Makefile </em>和<em class="mc"> event.json </em>，这些都符合你之前选择的路径类型。例如，如果您指定“<em class="mc"> get </em>”作为路由类型，这将从APIGateway生成get类型的事件。此外，生成的项目支持<em class="mc"> GO111MODULES </em>，并且捆绑了<em class="mc"> go.mod </em>和构建脚本。</p><p id="4000" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后需要注意的是，route文件夹下的<em class="mc"> Makefile </em>对应的是那个具体的route，根目录下的<em class="mc"> Makefile </em>是针对整个项目的。</p><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/7d90b716f158c6cac9661418a74d6a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*39VXgl7FlO3vuI413lXD_g.png"/></div></figure><h1 id="7c9c" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">测试完毕</h1><p id="ef1c" class="pw-post-body-paragraph jg jh ij ji b jj ln jl jm jn lo jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">为了开始测试我们刚刚创建的东西，让我们通过简单地运行</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="49ac" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make</em></span></pre><p id="0fab" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">生成的模板附带了简单的route func及其测试用例来运行测试</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="6afc" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make test</em></span></pre><p id="5d24" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果我想构建这个项目并调用一个特定的函数，您需要运行下面的代码，来调用在“route1”目录下定义的lambda函数，并在同一目录下定义附加的event.json。</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="923c" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make local-invoke func=route1</em></span></pre><p id="73d0" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您需要尝试不同的<em class="mc"> event.json </em>文件，您可以通过使用以下示例来传递它:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="562a" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make local-invoke func=route1 event=/path/to/event.json</em></span></pre><p id="3cf4" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您想作为本地API运行，请使用以下命令在端口3000上启动本地API</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="4afc" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make local-api</em></span></pre><h1 id="2c47" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">排除故障</h1><p id="a71a" class="pw-post-body-paragraph jg jh ij ji b jj ln jl jm jn lo jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">大约一年前，当我用Go启动Serverless时，我发现在本地调试它有很多困难，我必须配置端口并安装linux 的<em class="mc"> dlv，然后将其移植或安装到一个容器中，然后从VS代码附加一个会话。通过一个简单的命令，现在比你想象的要简单。</em></p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="effc" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make debug func=route1</em></span></pre><p id="d4f1" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">它现在正在侦听端口8997，等待调试会话的连接。这个项目已经配置好了一切，可以开始工作了。在VS代码中打开项目目录，在您的函数中放置一个断点，并转到左侧的<em class="mc">调试</em>选项卡，然后单击开始调试，如下所示。</p><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff my"><img src="../Images/502ef62bd797db247fe49f043fe569f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*757B0AOt672-FJL_QCeo_w.png"/></div></div></figure><h1 id="7a57" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">Docker网络</h1><p id="8d37" class="pw-post-body-paragraph jg jh ij ji b jj ln jl jm jn lo jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">如果你正在运行一个特定docker网络中的docker容器，并且你需要你的lambda来连接这个容器；例如，如果您在docker-compose堆栈中本地运行DynamoDB，那么它的容器将在一个<em class="mc"> XX </em>网络中运行，因此您需要在同一个网络中运行您的lambda，调用您的函数时只需传递网络参数，如下所示。</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="30d6" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make local-invoke func=route1 network=XX</em></span></pre><h1 id="dbbe" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">按指定路线发送</h1><p id="e173" class="pw-post-body-paragraph jg jh ij ji b jj ln jl jm jn lo jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">这些标准框架都没有提供任何在创建服务后在服务下添加新路由的方法，这可以通过运行以下命令轻松完成，它会询问您一些简单的问题，如路由类型和要使用的测试框架。</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="3558" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ yo sls:route</em></span></pre><h1 id="d868" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">部署</h1><p id="f5c3" class="pw-post-body-paragraph jg jh ij ji b jj ln jl jm jn lo jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">确保在<em class="mc"> ~/中定义了自己的AWS键。<em class="mc">默认</em>配置文件下的AWS/凭证</em>。要部署服务，请运行以下命令。它将根据所选择的框架，使用serverless.yml或template.yml中定义的所需资源来部署您的服务。</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="5be9" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make deploy</em></span></pre><p id="949a" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">部署服务后，您可以选择通过运行以下命令来销毁整个堆栈:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="99a9" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make undeploy</em></span></pre><p id="4b61" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">运行上面的命令将部署并销毁整个服务。但是，在某些情况下，您可能只想部署一个刚刚修改过的函数。如果是这样，通过执行以下命令，将工作目录更改为该路由并仅部署该路由:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="4be6" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ cd route1<br/>$ make deploy</em></span></pre><h1 id="35d7" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">结构</h1><p id="6362" class="pw-post-body-paragraph jg jh ij ji b jj ln jl jm jn lo jp jq jr md jt ju jv me jx jy jz mf kb kc kd hn dt translated">如果你用<em class="mc">无服务器</em>框架创建了你的项目，你仍然可以在任何时候切换到使用<em class="mc"> AWS SAM </em>。以下命令将根据定义的<em class="mc"> serverless.yml. </em>为SAM生成<em class="mc"> template.yml </em></p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="f9d9" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make sam</em></span></pre><p id="c432" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">如果您只是想尝试使用<em class="mc"> SAM调用一个函数，</em>运行以下命令，该命令接受<em class="mc">事件</em>和<em class="mc">网络</em>作为参数，方式与前面使用<em class="mc">本地调用</em>描述的方式相同</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="6473" class="mp ko ij ml b fv mq mr l ms mt"><em class="mc">$ make sam-invoke func=route1</em></span></pre><p id="ba42" class="pw-post-body-paragraph jg jh ij ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">最后，这个项目仍在进行中。目前它支持Go、C#、Python和Java，然而，将来会支持不同的特性、框架和语言。</p><h2 id="adbe" class="mp ko ij bd kp mz na nb kt nc nd ne kx jr nf ng lb jv nh ni lf jz nj nk lj nl dt translated">如果你喜欢这篇文章，最好是<a class="ae lw" href="http://github.com/msolimans/generator-sls" rel="noopener ugc nofollow" target="_blank">星，叉，和/或贡献。</a></h2></div></div>    
</body>
</html>