# 用 Apollo 服务器构建 GraphQL 代码的三种方法

> 原文：<https://medium.com/hackernoon/three-ways-to-structure-your-graphql-code-with-apollo-server-4788beed89db>

## 在本文中，我们将使用 Apollo 服务器，并在没有任何额外依赖的情况下开始。我们必须为我们的项目选择文件夹结构，我们将探索三种不同的结构以及它们的优缺点。

![](img/b2bd763b03941ac63f30a2c99f6ae3ba.png)

开始一个新项目时，构建代码可能是你必须做的第一件事。当然，如果你使用一个框架，你可能会得到一个默认的结构。这是因为“约定优于配置”原则通常有助于更快地开始。然而，当在 Node.js 中编写微型/小型服务时，我发现框架过于臃肿，因为它们附带了许多我们不需要的东西(例如:路由)，或者我们会在某个时候与另一个库交换(例如:安全)。这也是很好的开始你的新应用程序的基础，没有膨胀，并精选每一个我们要添加的依赖。这样，如果我们用同一个库编写多个服务，我们就能得到完全适合自己的框架。多美的东西啊！

阿波罗服务器通常与 T2 快捷网络服务器配对，但也包括自己的生产就绪服务器(这只是 Node 的 T4 http。服务器。这对我们来说是完美的，考虑到我们可以添加一个不同的 web 服务器，如 express 或 koa，如果我们以后需要它的话。然而，开始香草也意味着我们面对没有强制模式来构建我们的代码。对于没有经验的开发人员来说，这可能令人望而生畏。我们如何决定代码的结构？好了，不要再流汗了，我们将探索三种不同的架构，这样我们就可以选择最适合我们的架构。

在本文中，每个例子都来自于[beta flag/graph QL-server-scaffolding](https://github.com/betaflag/graphql-server-scaffolding)Github 仓库，在这里我们可以找到实现每个结构的工作应用程序。

从这个 repo 中，惟一的依赖项是 Apollo Server 和 GraphQL。

```
npm install apollo-server graphql
```

# 极简派

这种结构反映了在单个文件中编写一个服务器的纯粹的架构简单性。当然，这不适合大型项目，但我可以证明它在微型或小型服务中的使用是合理的。首先，并不是所有的 API 都需要大量的服务器代码。

考虑这个例子:你想在你的聊天应用程序中集成情感分析到你的消息中。您决定这不应该是您的核心应用程序的一部分，而应该外化到一个单独的服务中。它就像一个黑匣子:一个信息进来，一个分析出来。你可以立即开始使用一个名为“情绪”的开源库，它为你提供了一个简单的接口“*情绪.分析(消息)*”。编写您的情感分析微服务只需要将其包装在解析器中，并且可以很好地放入单个文件中。

```
.
├── package.json
└── src
    └── index.js
```

**优点**

*   您可以立即看到 API 的所有代码
*   你可以立即开始
*   当你使你的应用适应真实世界的使用时，重构和进化成一个更结构化的应用是很容易的。

**缺点**

*   只适合小的应用程序，否则会很快变得一团糟
*   它可能会在某个时候演变成另一种结构
*   如果每个人都在处理同一个文件，可能很难与其他开发人员协作。

# 角色扮演者

这是您在使用框架创建或搭建项目时通常会得到的结果。这是一个易于上手的结构，适合各种规模的应用。这种结构是根据文件各自的角色将文件放在它们所属的位置。GraphQL 类型定义位于" *typeDefs* "文件夹中，解析器位于(您猜对了)"*解析器*"文件夹中。

这里有一个在 GraphQL API 中可以找到的角色的详尽列表:*数据、模型、迁移、验证器、类型定义、解析器、服务、路由、配置、实用程序等。*

```
.
├── package.json
└── src
    ├── data
    │   └── index.js
    ├── models
    │   ├── Book.js
    │   └── index.js
    ├── resolvers
    │   ├── booksResolvers.js
    │   └── index.js
    └── typeDefs
        ├── index.js
        ├── query.js
        └── types
            ├── bookType.js
            └── index.js
```

摘自 Github 上的[beta flag/graph QL-server-scaffolding](https://github.com/betaflag/graphql-server-scaffolding)

**优点:**

*   适合所有种类和所有规模的应用
*   新来的人可以很容易地四处走动
*   每个文件代表一个关注点，比如一个类或者一个对象

**缺点:**

*   随着应用程序的增长，这些顶级目录变得杂乱无章
*   这种架构不是模块化的，可能会发展成一个整体
*   对于非常小的应用程序来说是过度的

# 领域专家

如果你想给你的应用增加额外的模块化风格，这种结构正适合你。在这种结构中，顶级文件夹代表域区域。它是模块化的，因为它们之间有自然的界限。我们甚至可以通过将域外部化到它们自己的 NPM 模块中来实现极端的模块化，这些模块可以在应用程序之间共享。然而，并不是因为你能，所以做这件事总是有意义的。

当开始一个新的应用程序时，定义你的域并不总是容易的。像用户、权限和配置文件这样的域是很自然的，但是，在某些时候你可能会有一些重叠的子域，这就是困难所在。

另一方面，用一个清晰的界面将你的域分开，并且一劳永逸地决定一个子域在哪里，这很棒。在大型应用程序中，团队通常围绕领域领域有机地形成。想想数据、报告、安全等。

```
.
├── package.json
└── src
    ├── books
    │   ├── Book.js
    │   ├── data.js
    │   ├── index.js
    │   ├── resolvers.js
    │   └── typeDef.js
    └── index.js
```

**优点:**

*   模块化；一个域可以在它自己的模块中具体化
*   可扩展；这种结构非常适合非常大应用程序
*   干净；强制子域成为父域确保没有重叠

**缺点**

*   对于较小的应用程序来说也是多余的
*   建立子域所有权时可能会出现冲突(但是解决它们确实是一件好事)
*   域边界可能从一开始就不清楚

# 结论

选择适合你的结构是你自己的选择，以后还可以改变。然而，从一开始就选择正确的方法是避免未来头痛的好方法。

如果你知道我没有提到的其他结构，我正在寻求帮助，将它们添加到我在[beta flag/graph QL-server-scaffolding](https://github.com/betaflag/graphql-server-scaffolding)的存储库中。也可以在下面的评论里添加。在推特上跟我讨论 [@betaflag](https://twitter.com/betaflag)

照片由 [Nicolas I.](https://unsplash.com/photos/gYNw3N1vJto?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/t/architecture?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄