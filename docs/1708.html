<html>
<head>
<title>Nebula container orchestrator — container orchestration for IoT devices &amp; distributed systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">nebula container orchestrator——面向物联网设备和分布式系统的容器编排</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/nebula-container-orchestrator-container-orchestration-for-iot-devices-distributed-systems-45f8a9a605f8#2019-03-12">https://medium.com/hackernoon/nebula-container-orchestrator-container-orchestration-for-iot-devices-distributed-systems-45f8a9a605f8#2019-03-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/69be21f20cb00dcb8fba32de197ed677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gldOWySz9qdHQaOISzzxxw.jpeg"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Photo by <a class="ae jg" href="https://www.pexels.com/@mateusz-dach-99805" rel="noopener ugc nofollow" target="_blank">Mateusz Dach</a> on <a class="ae jg" href="http://www.pexels.com" rel="noopener ugc nofollow" target="_blank">Pexels.com</a></figcaption></figure><p id="3145" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">比方说，你开始了一份新的工作，在一家公司担任开发人员/开发人员/SRE/etc，该公司开发了一款新的智能音箱(想想亚马逊 Echo 或 Google home)，你说这款设备取得了很大的成功，你很快发现自己拥有了一百万个客户，每个人家里都有一台设备，听起来很棒，对吧？现在，您面临的唯一问题是如何处理分布在世界各地的一百万台设备的部署？</p><ul class=""><li id="79e5" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">你可以走大多数老厂商的路，发布一个软件包供最终用户下载并安装在公司网站上，但在这个时代，这将很快让你的客户流失到竞争对手那里，他们没有这么高的维护需求。</li><li id="9ea6" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">你可以在你的代码库中创建一个自我更新的系统，但是这需要开发团队进行大量的维护和投入大量的人力&amp;即使这样也可能会导致问题和失败。</li><li id="2b70" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">您可以将代码库容器化，在每个智能音箱上创建一个单独的服务器 Kubernetes 集群，并从所有这些集群中创建一个巨大的联合集群(因为 Kubernetes 不支持这种规模，也不支持延迟容忍工作人员，这是必需的)，但这将导致所有资源的巨大成本，仅运行所有上述集群就浪费了这些资源。</li><li id="f80d" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">你可以使用<a class="ae jg" href="https://nebula-orchestrator.github.io/" rel="noopener ugc nofollow" target="_blank">Nebula Container Orchestrator</a>——它正是为解决这种分布式编排需求而设计的。</li></ul><p id="9ce7" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能已经从标题中猜到了，我想讨论列表中的最后一个选项。</p><p id="a527" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://nebula-orchestrator.github.io/" rel="noopener ugc nofollow" target="_blank">Nebula Container Orchestrator</a>旨在帮助开发人员和运营人员像对待分布式 Dockerized 应用程序一样对待物联网设备。它的目标是充当物联网设备以及分布式服务(如 CDN 或边缘计算)的 Docker orchestrator，这些服务可以跨越全球数千台(甚至数百万台)设备，而且它是开源和完全免费的。</p><p id="2536" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">不同的需求导致不同的指挥</strong></p><p id="951d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">仔细想想，分布式编制器有以下要求:</p><ul class=""><li id="c885" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">它需要能够容忍延迟，如果物联网设备是分布式的，那么每个设备都将通过互联网连接到 orchestrator，连接可能不总是稳定或快速的。</li><li id="1955" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">它需要向外扩展以处理成千上万(甚至成千上万)的物联网设备，大规模部署正迅速变得越来越普遍。</li><li id="ba59" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">它需要在多种架构上运行——许多物联网设备都使用 ARM 板。</li><li id="1962" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">它需要自我修复——你不希望每次出现一点小故障就不得不穿过城市去重置设备，对吧？</li><li id="0748" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">代码需要与硬件耦合——如果你的公司制造了上述例子中的智能扬声器&amp;智能冰箱，你将需要确保代码与打算在其上运行的设备耦合(在物联网用例中，不要将不同的应用打包到相同的设备中)。</li></ul><p id="e878" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">这与三大 orchestrator(Kubernetes、Mesos 和 Swarm)截然不同，它们旨在将尽可能多的不同应用程序/微服务打包到单个(或相对较少的)数据中心的相同服务器上，因此没有一个提供真正的延迟容忍连接，Swarm 和 Kubernetes 的可扩展性仅限于几千名员工。</p><p id="ad01" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">星云架构</strong></p><figure class="ku kv kw kx fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kt"><img src="../Images/8b33e3d7c7f7b098e034882ce3ac393a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEOxwRKMCb3Ld6WdAaDc_g.png"/></div></div></figure><p id="3eae" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><a class="ae jg" href="https://nebula-orchestrator.github.io/" rel="noopener ugc nofollow" target="_blank"> Nebula </a>设计了无状态 RESTful Manger 微服务，以提供管理集群的单点，以及提供所有容器检查更新的单点，在基于拉的方法中使用 Kafka 启发的单调 ID 配置更新， 这确保了对 Nebula 管理的任何应用程序的更改同时被拉至所有被管理的设备，并且还确保了所有设备将总是具有最新版本的配置(由于单调 ID)，所有数据都存储在 MongoDB 中，这是系统的单点事实， 在工人方面，它基于每个设备上的工人容器，负责启动/停止/更改在该设备上运行的其他容器，由于其设计，每个组件都可以向外扩展&amp;，因此 Nebula 可以根据您的需要进行扩展。</p><p id="1e91" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可以在 https://nebula.readthedocs.io/en/latest/architecture/<a class="ae jg" href="https://nebula.readthedocs.io/en/latest/architecture/" rel="noopener ugc nofollow" target="_blank">的</a>阅读更多关于星云建筑的内容</p><p id="0375" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">星云特征</strong></p><p id="fcc1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">由于 Nebula 完全是为了支持分布式系统而设计的，因此它有一些简洁的功能，允许它控制分布式物联网系统:</p><ul class=""><li id="aeda" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">旨在横向扩展其所有组件(物联网设备、API 层和 Mongo 全部横向扩展)</li><li id="fab6" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">能够管理数百万台物联网设备</li><li id="80a3" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">容许延迟—即使设备离线，当他恢复在线时，它也会重新同步</li><li id="4df3" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">动态添加/删除受管设备</li><li id="e254" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">快速简单的代码部署，使用新的容器图像标签(或其他配置更改)的单一 API 调用，它将被推送到该应用程序的所有设备。</li><li id="7a60" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">安装简单——MongoDB &amp;一个无状态 API 是管理层所需要的全部内容&amp;您想要管理的每个物联网设备上的一个包含一些 envvars 的容器负责工作层</li><li id="a1d0" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">管理所有设备的单一 API 端点</li><li id="02cd" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">允许使用同一个 Nebula orchestrator 控制多个设备(多个应用和设备组)</li><li id="c43c" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">不限于物联网，对其他类型的分布式系统也很有用</li><li id="33d9" class="kf kg hu jj b jk ko jo kp js kq jw kr ka ks ke kk kl km kn dt translated">API、Python SDK 和 CLI 控件可用</li></ul><p id="c13c" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">举个小例子</strong></p><p id="7278" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">以下命令将安装一个<a class="ae jg" href="https://nebula-orchestrator.github.io/" rel="noopener ugc nofollow" target="_blank">星云</a>集群供你玩，还将创建一个示例应用程序，需要安装 Docker，curl &amp; docker-compose:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="5739" class="ld le hu kz b fv lf lg l lh li">curl -L "https://raw.githubusercontent.com/nebula-orchestrator/docs/master/examples/hello-world/start_example_nebula_cluster.sh" -o start_example_nebula_cluster.sh &amp;&amp; sudo sh start_example_nebula_cluster.sh</span></pre><p id="259b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">但是让我们回顾一下这个命令的作用，以便更好地理解这个过程:</p><ol class=""><li id="f86a" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke lj kl km kn dt translated">脚本下载并运行 docker-compose.yml 文件，该文件创建:</li></ol><blockquote class="lk"><p id="df99" class="ll lm hu bd ln lo lp lq lr ls lt ke ek translated">A)MongoDB 容器——保存 Nebula 应用程序当前状态的后端数据库。</p><p id="6283" class="ll lm hu bd ln lo lu lv lw lx ly ke ek translated">b)一个管理器容器——一个 RESTful API 端点，管理员从这里管理 Nebula 设备从这里获取最新的配置状态，以匹配它们的当前状态</p><p id="02e3" class="ll lm hu bd ln lo lu lv lw lx ly ke ek translated">c)工人容器—这通常在物联网设备上运行，每个设备上只需要一个，但这只是一个示例，它运行在与管理层组件运行的服务器相同的服务器上。</p></blockquote><p id="1716" class="pw-post-body-paragraph jh ji hu jj b jk lz jm jn jo ma jq jr js mb ju jv jw mc jy jz ka md kc kd ke hn dt translated">值得一提的是 worker 容器上设置的“DEVICE_GROUP=example”环境变量，这个 DEVICE_GROUP 变量控制哪些 nebula 应用程序将连接到设备(类似于其他 orchestrators 中的 pod 概念)。</p><p id="6753" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">2.然后，脚本等待 API 变得可用。</p><p id="2e06" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">3.一旦 API 可用，脚本将发送以下两个命令:</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="a901" class="ld le hu kz b fv lf lg l lh li">curl -X POST \                               <br/>http://127.0.0.1/api/v2/apps/example \<br/>-H 'authorization: Basic bmVidWxhOm5lYnVsYQ=='  \                            -H 'cache-control: no-cache'    \                     <br/>-H 'content-type: application/json'    \                            -d '{<br/>    "starting_ports": [{"81":"80"}],  <br/>    "containers_per": {"server": 1},        <br/>    "env_vars": {},                       <br/>    "docker_image" : "nginx",                        <br/>    "running": true,                                <br/>     "volumes": [],  <br/>     "networks": ["nebula"],                 <br/>     "privileged": false,           <br/>     "devices": [],     <br/>     "rolling_restart": false        <br/>}'</span></pre><p id="5e3e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该命令创建一个名为“example”的应用程序，并将其配置为运行 nginx 容器来监听端口 81，正如您所看到的，它还可以控制通常传递给 docker run 命令的其他参数，如 envvars、networks 或 volume mounts。</p><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="79a4" class="ld le hu kz b fv lf lg l lh li">curl -X POST \                                <br/> http://127.0.0.1/api/v2/device_groups/example \                                 -H 'authorization: Basic bmVidWxhOm5lYnVsYQ==' \                                 -H 'cache-control: no-cache' \                                <br/>-H 'content-type: application/json' \                                 -d '{ <br/>    "apps": ["example"]             <br/>}'</span></pre><p id="f79b" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该命令创建一个名为“example”的设备组，并将名为“example”的应用程序连接到该设备组，</p><p id="75e3" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">4.在 nebula API 上创建应用程序&amp; device_groups 后，worker 容器将获取对 device_group 的更改，device _ group 被配置为该应用程序的一部分(本例中为“示例”)，并将在服务器上启动 Nginx 容器，您可以运行“docker logs worker”来查看 Nginx 容器在启动前的下载情况(如果您的连接速度较慢，这可能需要一点时间)。完成后，你可以在浏览器上访问<a class="ae jg" href="http://127.0.0.1:81/" rel="noopener ugc nofollow" target="_blank">http://&lt;server _ exterior _ FQDN&gt;:81/</a>来查看它的运行情况</p><p id="ae29" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">现在我们已经有了一个运行的星云系统，我们可以开始使用它来看看它的真正优势:</p><ul class=""><li id="23b4" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">我们可以通过在远程工作者上运行工作者容器来添加更多的远程工作者:</li></ul><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="adca" class="ld le hu kz b fv lf lg l lh li">sudo docker run -d --restart unless-stopped -v /var/run/docker.sock:/var/run/docker.sock --env DEVICE_GROUP=example --env REGISTRY_HOST=https://index.docker.io/v1/ --env MAX_RESTART_WAIT_IN_SECONDS=0 --env NEBULA_MANAGER_AUTH_USER=nebula --env NEBULA_MANAGER_AUTH_PASSWORD=nebula --env NEBULA_MANAGER_HOST=&lt;your_manager_server_ip_or_fqdn&gt; --env NEBULA_MANAGER_PORT=80 --env nebula_manager_protocol=http --env NEBULA_MANAGER_CHECK_IN_TIME=5 --name nebula-worker nebulaorchestrator/worker</span></pre><p id="e813" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">值得一提的是，通过上面的命令传递的许多 envvars 是可选的(具有相同的默认值)&amp;我们可以在多少台设备上运行该命令没有限制，在某些时候，您可能必须向外扩展管理器和/或后端数据库，但这些也没有限制。</p><ul class=""><li id="c74b" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">我们可以通过一个 API 调用来更改所有设备上的容器映像，例如，让我们将容器映像替换为 Apache 来进行模拟</li></ul><pre class="ku kv kw kx fq ky kz la lb aw lc dt"><span id="529c" class="ld le hu kz b fv lf lg l lh li">curl -X PUT \</span><span id="994a" class="ld le hu kz b fv me lg l lh li"><a class="ae jg" href="http://127.0.0.1/api/apps/example/update" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/api/</a>v2/<a class="ae jg" href="http://127.0.0.1/api/apps/example/update" rel="noopener ugc nofollow" target="_blank">apps/example/update</a> \</span><span id="0155" class="ld le hu kz b fv me lg l lh li">-H ‘authorization: Basic bmVidWxhOm5lYnVsYQ==’ \</span><span id="0b0e" class="ld le hu kz b fv me lg l lh li">-H ‘cache-control: no-cache’ \</span><span id="8e2e" class="ld le hu kz b fv me lg l lh li">-H ‘content-type: application/json’ \</span><span id="3f34" class="ld le hu kz b fv me lg l lh li">-d ‘{</span><span id="72ce" class="ld le hu kz b fv me lg l lh li">“docker_image”: “httpd:alpine”</span><span id="783a" class="ld le hu kz b fv me lg l lh li">}’</span></pre><ul class=""><li id="ba2f" class="kf kg hu jj b jk jl jo jp js kh jw ki ka kj ke kk kl km kn dt translated">同样，我们也可以更新应用的任何参数，如 env_vars、特权权限、卷挂载等，API 端点以及 Python SDK 和 CLI 的完整列表可在<a class="ae jg" href="https://nebula.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">https://nebula.readthedocs.io/en/latest/</a>的文档页面上找到</li></ul><p id="9502" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">希望这个小指南能让你看到物联网 docker orchestrator 的需求及其使用案例&amp;如果你有兴趣阅读更多相关信息，你可以访问位于 https://nebula-orchestrator.github.io/<a class="ae jg" href="https://nebula-orchestrator.github.io/" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae jg" href="https://nebula-orchestrator.github.io/" rel="noopener ugc nofollow" target="_blank">Nebula Container Orchestrator</a>网站，或者直接跳到 https://Nebula . readthedocs . io 上的文档</p></div></div>    
</body>
</html>