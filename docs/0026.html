<html>
<head>
<title>Running Laravel Artisan commands on AWS Fargate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 AWS Fargate 上运行 Laravel Artisan 命令</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/running-laravel-artisan-commands-on-aws-fargate-6c0e95f8e72b#2019-01-02">https://medium.com/hackernoon/running-laravel-artisan-commands-on-aws-fargate-6c0e95f8e72b#2019-01-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/2d47dbf70902fe1ee94c4bd064ee992f.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/0*zRxI0VdsFl4ezl8P.png"/></div></figure><p id="00e1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我最近发表了我关于在 AWS VPC 背后运行一个<a class="ae jw" href="https://hackernoon.com/the-challenges-of-running-laravel-on-aws-9f4480b46cf6" rel="noopener ugc nofollow" target="_blank">可扩展、高可用的 Laravel 项目的想法。在这篇文章中，我想谈谈在 Fargate 上运行 Laravel Artisan 命令。</a></p><h2 id="d81f" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">介绍</h2><p id="dc99" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">AWS Fargate 是一项 AWS 托管服务，允许我们在 ECS 上部署 Docker 容器，而无需管理底层基础设施(EC2 集群)。这意味着不再可能使用 bastion 主机获得对容器实例之一的 shell 访问并通过<code class="eh kx ky kz la b">docker exec</code>与容器交互。</p><p id="b821" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">允许<code class="eh kx ky kz la b">artisan</code>在 Fargate 上运行的一个关键概念是 Docker 命令，它负责执行给容器一个存在理由的命令。例如，在 alpine 映像上运行 Apache 时，命令将是<code class="eh kx ky kz la b">httpd -DFOREGROUND</code>。这个命令保持容器无限期运行，因为它的实现是一个事件循环，应该永远不会结束。如果我们准备一个带有命令<code class="eh kx ky kz la b">php artisan my:command</code>的 Docker 映像，那么这个命令将在容器一启动就被执行。如果命令以状态代码 0 结束，这意味着它成功执行，容器现在准备好正常关闭。这非常好，因为 AWS Fargate 是按分钟收费的，这意味着我们可以在命令执行的几分钟内启动一个容器并付费。</p><h2 id="df71" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">履行</h2><p id="cc9c" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">实现 Docker 镜像以在 Fargate 上运行<code class="eh kx ky kz la b">artisan</code>的第一步是 Docker 多阶段构建。以下 Dockerfile 分为<strong class="ja hv">基础</strong>、<strong class="ja hv">依赖</strong>、<strong class="ja hv">工匠</strong>和<strong class="ja hv"> App </strong>。</p><pre class="lb lc ld le fq lf la lg lh aw li dt"><span id="272c" class="jx jy hu la b fv lj lk l ll lm">+--------------+------------------------------------------------+<br/>|    Layer     |                  Description                   |<br/>+--------------+------------------------------------------------+<br/>|     base     | Operating System dependencies / PHP Extensions |<br/>| dependencies | Application Dependencies / Composer            |<br/>|   artisan    | Layer used for running Artisan commands        |<br/>|     app      | Web Application                                |<br/>+--------------+------------------------------------------------+</span></pre><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="a8b3" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">通过使用多阶段构建，我们可以选择要将哪些阶段推送到 AWS 弹性容器注册中心(ECR)。以下代码片段是 AWS CodeBuild 结合 AWS CodePipeline 使用的<code class="eh kx ky kz la b">buildspec.yaml</code>的示例。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><p id="d43c" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">注意，AWS ECR 现在有两个图像，一个用于<code class="eh kx ky kz la b">app</code>，另一个用于<code class="eh kx ky kz la b">artisan</code>。</p><p id="436a" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated"><em class="lp">注意:AWS ECR、CodeBuild 和 CodePipeline 的配置超出了本文的范围。</em> <strong class="ja hv"> <em class="lp">下面的</em> </strong> <em class="lp"> </em> <strong class="ja hv"> <em class="lp">步骤假设已经为工匠形象创建了任务定义。</em>T29】</strong></p><p id="14f7" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">为 Artisan 图像创建任务定义后，可以使用 AWS CLI 启动一个容器来运行一个<code class="eh kx ky kz la b">artisan</code>注册的命令。确保填写<code class="eh kx ky kz la b">your_cluster_name</code>、<code class="eh kx ky kz la b">your_task_definition_name-artisan</code>、<code class="eh kx ky kz la b">your_aws_profile</code>以及<strong class="ja hv">网络配置</strong>文件的正确路径。下面你会找到一个<code class="eh kx ky kz la b">network.json</code>的样本。</p><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><figure class="lb lc ld le fq iv"><div class="bz el l di"><div class="ln lo l"/></div></figure><h2 id="d16c" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">使用</h2><p id="ae0a" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">您现在可以通过<code class="eh kx ky kz la b">sh artisan.sh my:command</code>运行命令。通过发出这个命令，bash 脚本将指示 AWS CLI 在 Fargate 上使用 Docker 命令覆盖启动一个新容器，该命令覆盖运行<code class="eh kx ky kz la b">php /app/artisan $1</code>，其中<code class="eh kx ky kz la b">$1</code>是第一个参数，在本例中是<code class="eh kx ky kz la b">my:command</code>。Amazon 将使用这个命令在您的 ECS 集群上启动一个容器，命令一完成，容器就会退出。您应该能够将来自 stderr 和 stdout 的任何信息重定向到 CloudWatch，以便能够找出该命令给出的任何输出消息。</p><p id="b621" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">您希望运行的命令应该已经包含在被推送到 AWS ECR 的源代码中，并带有<code class="eh kx ky kz la b">-artisan</code>后缀。这意味着一旦您编写了自定义命令，您就必须首先推送您的代码更改，然后才运行 bash 脚本。</p><h2 id="5067" class="jx jy hu bd jz ka kb kc kd ke kf kg kh jj ki kj kk jn kl km kn jr ko kp kq kr dt translated">结论</h2><p id="04ef" class="pw-post-body-paragraph iy iz hu ja b jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr kw jt ju jv hn dt translated">正如我在上一篇文章中提到的，这对于不受 HTTP 请求限制的长时间运行的流程尤为重要。它还在能够在您的生产 VPC 上运行任意命令之前强制执行一个适当的部署过程，如果您的工作场所在推向生产之前有一个良好建立的代码审查过程，这将很好地工作。在一个发布周期之后，不必编写 API 端点来运行一次性流程，这极大地改进了我的开发过程，特别是因为我可以轻松地使用 Artisan 提供的简单控制台命令的 Laravel 思维模式。</p><p id="f037" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">这个过程将允许一个团队在生产环境中运行<code class="eh kx ky kz la b">php artisan migrate</code>,而不必在 VPC 之外打开 Amazon RDS。然而，由于<code class="eh kx ky kz la b">migrate</code>是一个在每个版本中不断执行的命令，我计划写另一篇文章解释如何准备一个专用于迁移的任务定义，它将在每次部署后自动启动。</p><p id="c20f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你喜欢阅读我如何在 VPC 背后的 AWS Fargate 上部署微服务，请关注我的<a class="ae jw" href="https://hackernoon.com/@deleugpn" rel="noopener ugc nofollow" target="_blank">https://hackernoon.com/@deleugpn</a>和<a class="ae jw" href="https://twitter.com/@deleugyn" rel="noopener ugc nofollow" target="_blank">https://twitter.com/@deleugyn</a>。</p></div></div>    
</body>
</html>