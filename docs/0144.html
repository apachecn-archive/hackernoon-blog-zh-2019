<html>
<head>
<title>Build a Go Cache in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在10分钟内建立Go缓存</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/build-a-go-cache-in-10-minutes-c908a8255568?source=collection_archive---------7-----------------------#2019-01-07">https://medium.com/hackernoon/build-a-go-cache-in-10-minutes-c908a8255568?source=collection_archive---------7-----------------------#2019-01-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/3d688cee80c715100e2b2d33a58d6a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvlMpkpIKmPm6IF_QnmjmQ.jpeg"/></div></div></figure><p id="99d7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">高速缓存是计算机科学最伟大的创新之一🔥🔥🔥。它显著减少了<a class="ae ka" href="https://hackernoon.com/tagged/cpu" rel="noopener ugc nofollow" target="_blank"> CPU </a>的工作，并在速度方面提供了巨大的性能增益。😃</p><p id="a4a2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它的工作原理是保存以后可能需要的计算结果。例如:假设你有一个服务，给定一个字符串，生成一个散列。缓存可以通过检查接收到的字符串的哈希是否已经生成来节省时间和资源。如果有，并且仍然在缓存中，那么它将被返回，而不需要再次运行哈希算法。</p><p id="ae12" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">今天，我们将构建一个<strong class="je hv"> LRU </strong> ( <em class="kb">最近最后使用的</em>)缓存，它存储固定数量的<code class="eh kc kd ke kf b">strings</code>，并在缓存满时弹出最后使用的项目。</p><p id="ebff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这不会是您想要在生产中运行的任何东西。但是它将清楚地展示使这种类型的缓存工作的<code class="eh kc kd ke kf b">data structures</code>和<code class="eh kc kd ke kf b">algorithms</code>。</p><p id="34df" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">获取并运行最终结果:</strong></p><pre class="kg kh ki kj fq kk kf kl km aw kn dt"><span id="6060" class="ko kp hu kf b fv kq kr l ks kt">git clone <a class="ae ka" href="https://github.com/Lebonesco/go_lru_cache.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Lebonesco/go_lru_cache.git</a><br/>go run main.go</span></pre><p id="39cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们开始写代码吧！</p><p id="2eb8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将从定义我们的<code class="eh kc kd ke kf b">data structures</code>开始。这些将包括<code class="eh kc kd ke kf b">Node</code>、<code class="eh kc kd ke kf b">Queue</code>、<code class="eh kc kd ke kf b">Hash</code>和<code class="eh kc kd ke kf b">Cache</code>。我们的<code class="eh kc kd ke kf b">Queue</code>将是一个从<code class="eh kc kd ke kf b">Hash</code>映射到的<code class="eh kc kd ke kf b">Node</code>指针的双向链表。这将允许值的<strong class="je hv"> O(1) </strong> <strong class="je hv">插入</strong>和<strong class="je hv">删除</strong>。👍</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="8856" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">注意:</strong>我们现在是<strong class="je hv"> </strong>只是缓存<code class="eh kc kd ke kf b">strings</code>，但是任何<code class="eh kc kd ke kf b">data type</code>都可以替换它。</p><p id="4cbe" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们将为<code class="eh kc kd ke kf b">Cache</code>和<code class="eh kc kd ke kf b">Queue</code>设置我们的构造函数。尽管<code class="eh kc kd ke kf b">Hash</code>开始时为空，但它需要初始化，否则会导致<strong class="je hv">“空指针错误”</strong>。此外，我们为<strong class="je hv">头部</strong>和<strong class="je hv">尾部</strong>创建两个空的<code class="eh kc kd ke kf b">Nodes</code>。当我们转向我们的<code class="eh kc kd ke kf b">Add()</code>和<code class="eh kc kd ke kf b">Remove()</code>方法时，这将更有意义。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="d38c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">到缓存的主代码上。</p><p id="1464" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">缓存有三个方法<strong class="je hv"/>，这三个方法是使其工作所必需的:<code class="eh kc kd ke kf b"><strong class="je hv">Check()</strong></code>(从用户处接收字符串并返回结果)、<code class="eh kc kd ke kf b"><strong class="je hv">Add()</strong></code>(将字符串添加到缓存中)、<code class="eh kc kd ke kf b"><strong class="je hv">Remove()</strong></code>(从缓存中弹出字符串)。</p><p id="b995" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在<code class="eh kc kd ke kf b">Check()</code>内部，如果<code class="eh kc kd ke kf b">string</code>已经存在于缓存中，我们首先移除它，然后再将它添加回去，这样<code class="eh kc kd ke kf b">string</code>就被移到了<code class="eh kc kd ke kf b">Queue</code>的前面。</p><p id="a036" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh kc kd ke kf b">Add()</code>和<code class="eh kc kd ke kf b">Remove()</code>都涉及类似的操作，重新分配<code class="eh kc kd ke kf b">Queue</code>中的<code class="eh kc kd ke kf b">Left</code>和<code class="eh kc kd ke kf b">Right</code>指针。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="bd2b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">太棒了，我们现在有一个工作缓存了！🎉🎉🎉</p><p id="0f9d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">最后一步是添加一个<code class="eh kc kd ke kf b">main()</code>和一些显示方法来演示我们的结果。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="ku kv l"/></div></figure><p id="4e6a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要查看运行中的代码，请运行:</p><pre class="kg kh ki kj fq kk kf kl km aw kn dt"><span id="cd91" class="ko kp hu kf b fv kq kr l ks kt">go run main.go<br/>START CACHE<br/>add: cat<br/>1 - [{cat}]<br/>add: blue<br/>2 - [{blue} &lt;--&gt; {cat}]<br/>add: dog<br/>3 - [{dog} &lt;--&gt; {blue} &lt;--&gt; {cat}]<br/>add: tree<br/>4 - [{tree} &lt;--&gt; {dog} &lt;--&gt; {blue} &lt;--&gt; {cat}]<br/>add: dragon<br/>5 - [{dragon} &lt;--&gt; {tree} &lt;--&gt; {dog} &lt;--&gt; {blue} &lt;--&gt; {cat}]<br/>add: potato<br/>remove: cat<br/>5 - [{potato} &lt;--&gt; {dragon} &lt;--&gt; {tree} &lt;--&gt; {dog} &lt;--&gt; {blue}]<br/>add: house<br/>remove: blue<br/>5 - [{house} &lt;--&gt; {potato} &lt;--&gt; {dragon} &lt;--&gt; {tree} &lt;--&gt; {dog}]<br/>remove: tree<br/>add: tree<br/>5 - [{tree} &lt;--&gt; {house} &lt;--&gt; {potato} &lt;--&gt; {dragon} &lt;--&gt; {dog}]<br/>add: cat<br/>remove: dog<br/>5 - [{cat} &lt;--&gt; {tree} &lt;--&gt; {house} &lt;--&gt; {potato} &lt;--&gt; {dragon}]</span></pre><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kw kv l"/></div></figure><p id="33ff" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢您花时间阅读这篇文章。</p><p id="6211" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你觉得它有帮助或有趣，请让我知道👏👏👏。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kx kv l"/></div></figure></div></div>    
</body>
</html>