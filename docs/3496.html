<html>
<head>
<title>Do I really need package-lock.json file?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我真的需要 package-lock.json 文件吗？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/do-i-really-need-package-lock-json-file-321ce29e7d2c#2019-06-06">https://medium.com/hackernoon/do-i-really-need-package-lock-json-file-321ce29e7d2c#2019-06-06</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="ee4a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您是否曾经发现自己即将提交代码，并且不知道如何处理 package-lock.json 文件？大家说说吧。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="ab fr cl ju"><img src="../Images/c8e1e02f11b6e21e3dabe261c0110b52.png" data-original-src="https://miro.medium.com/v2/format:webp/0*iDTNuTWoKqmqBOap.jpg"/></div><figcaption class="jx jy fg fe ff jz ka bd b be z ek">(📷 by <a class="ae kb" rel="noopener" href="/@npmjs">npmjs</a>)</figcaption></figure><h1 id="2a7a" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated"><strong class="ak">TL；</strong>博士</h1><ul class=""><li id="2e23" class="la lb hu it b iu lc iy ld jc le jg lf jk lg jo lh li lj lk dt translated">如果您正在与多个开发人员合作一个共享项目，并且您想要确保所有开发人员和环境的安装保持一致，那么您需要使用<code class="eh ll lm ln lo b">package-lock.json</code>。</li><li id="e076" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">对于 npm 修改<code class="eh ll lm ln lo b">package.json</code>或<code class="eh ll lm ln lo b">node_modules</code>树的任何操作，都会自动生成<code class="eh ll lm ln lo b">package-lock.json</code>(NPM ^5.x.x).的默认设置</li><li id="856d" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">如果<code class="eh ll lm ln lo b">package.json</code>已经用新模块或更新版本更新，它将否决<code class="eh ll lm ln lo b">package-lock.json</code> (^v5.1.0).</li><li id="1519" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">新的<code class="eh ll lm ln lo b">npm ci</code>命令(用于 CI/CD)仅从<strong class="it hv">包锁文件</strong>安装。如果<code class="eh ll lm ln lo b">package.json</code>和<code class="eh ll lm ln lo b">package-lock.json</code>不同步，那么它将报告一个错误(npm ^5.7.1).</li><li id="e362" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated"><strong class="it hv">包锁文件应该提交到源存储库中。</strong></li></ul><h1 id="1f1e" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">介绍</h1><h2 id="c126" class="lu kd hu bd ke lv lw lx ki ly lz ma km jc mb mc kq jg md me ku jk mf mg ky mh dt translated">简而言之，国家预防机制</h2><p id="15c2" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">npm 是最常见的 JavaScript 包管理器。它由一个命令行客户端(也称为 npm)和一个公共和付费私有软件包的在线数据库(称为 npm registry)组成。</p><h2 id="d441" class="lu kd hu bd ke lv lw lx ki ly lz ma km jc mb mc kq jg md me ku jk mf mg ky mh dt translated"><strong class="ak"> package.json </strong></h2><p id="ac5c" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">所有的 npm 包都在名为<strong class="it hv"> package.json </strong>的文件中定义。package.json 的内容必须写在 JSON <strong class="it hv"> </strong>中，定义文件中至少要有两个字段:<strong class="it hv">名称</strong>和<strong class="it hv">版本</strong>。依赖关系也在这个文件中定义。</p><h2 id="fe9b" class="lu kd hu bd ke lv lw lx ki ly lz ma km jc mb mc kq jg md me ku jk mf mg ky mh dt translated"><strong class="ak"> npm 安装</strong></h2><p id="5a37" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">命令<code class="eh ll lm ln lo b">npm instal</code> <strong class="it hv"> </strong>将 package.json 文件中定义的所有包及其依赖项安装到<code class="eh ll lm ln lo b">node_modules</code>文件夹中，如果该文件夹不存在，则创建它。</p><p id="4d1e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您可以通过运行<code class="eh ll lm ln lo b">npm install &lt;package-name&gt;.</code>来安装特定的软件包</p><p id="7f9a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lo b">--save</code>标志安装并添加一个条目到 package.json 文件<em class="ml">依赖项</em>(NPM 5 的默认设置)。</p><h1 id="a6d5" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">包版本控制</h1><p id="9b7a" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated"><em class="ml"> npm 作品有</em> <a class="ae kb" href="https://docs.npmjs.com/about-semantic-versioning" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv"> <em class="ml">语义版本</em></strong></a><strong class="it hv"><em class="ml"/></strong>(SEM ver)图式:<code class="eh ll lm ln lo b">(MAJOR.MINOR.PATCH)</code>。</p><p id="0ed9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">使用 npm 安装软件包时，会在 package.json 中添加一个条目，其中包含软件包名称和应该使用的服务器。如果不指定确切的版本，npm 将安装最新版本(在 NPM 注册表上标记为<code class="eh ll lm ln lo b">latest</code>的版本)。</p><p id="4005" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这个 semver 定义中，npm 支持以下<strong class="it hv">通配符</strong>:</p><p id="424f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">默认情况下，所有版本都带有前缀<code class="eh ll lm ln lo b"><strong class="it hv">^</strong></code> <strong class="it hv">(插入符号)</strong>。这意味着允许修改到<code class="eh ll lm ln lo b">MINOR</code>部分。因此，举例来说，与版本<code class="eh ll lm ln lo b">^1.3.1</code>具有依赖性意味着<code class="eh ll lm ln lo b">1.3.5</code>和<code class="eh ll lm ln lo b">1.4.0</code>都将被认为是有效的，并且如果可用的话，将使用它们中的“最新”版本。</p><p id="bc9d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">类似的逻辑也适用于<code class="eh ll lm ln lo b"><strong class="it hv">~</strong></code> <strong class="it hv">(波浪号)</strong>。一旦用在版本号前面，表示:只允许<code class="eh ll lm ln lo b">PATCH </code>段修改。因此，在上面的例子中，如果我们有<code class="eh ll lm ln lo b">~3.2.3</code>，那么在提到的两个候选项中，唯一有效的候选项就是<code class="eh ll lm ln lo b">3.2.4</code>。</p><p id="0303" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">命令<code class="eh ll lm ln lo b">npm outdated</code>和<code class="eh ll lm ln lo b">npm update</code>能够根据定义的范围分别跟踪和更新依赖性。</p><h1 id="19ed" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">属国</h1><h2 id="d336" class="lu kd hu bd ke lv lw lx ki ly lz ma km jc mb mc kq jg md me ku jk mf mg ky mh dt translated">依赖关系树</h2><p id="4ce9" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">npm 安装了一个<em class="ml">依赖关系树</em>，其中安装的每个包都有自己的依赖关系集，即使它与其他包有共享的依赖关系。</p><p id="77f0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着 npm 可以安装同一软件包的不同版本。例如，如果我们有两个包 A 和 B，它们具有共享的依赖关系“dep_A”，则每个包可以使用不同版本的“dep_A”。最终的目录结构将是:</p><pre class="jp jq jr js fq mm lo mn mo aw mp dt"><span id="6da1" class="lu kd hu lo b fv mq mr l ms mt">node_modules/<br/>├── package_A/<br/>│   └── node_modules/<br/>│       ├── dep_A/<br/>│       └── dep_B/<br/>└── package_b/<br/>    └── node_modules/<br/>        ├── dep_A/<br/>        └── dep_C/</span></pre><p id="193b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">实际上，每个依赖项都有自己的<code class="eh ll lm ln lo b">node_modules</code>目录等等。</p><ul class=""><li id="5644" class="la lb hu it b iu iv iy iz jc mu jg mv jk mw jo lh li lj lk dt translated">npm ^3.X.X 执行了一些优化，试图在可能的时候共享依赖关系。</li></ul><h2 id="7524" class="lu kd hu bd ke lv lw lx ki ly lz ma km jc mb mc kq jg md me ku jk mf mg ky mh dt translated">依赖地狱</h2><p id="ba52" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">我们看到 npm 处理版本和依赖关系，什么会出错？</p><p id="d3cc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当处理一个共享项目时，在部署过程中，您希望确保安装项目依赖项的任何人(开发人员、CI 服务器等。)，每次都会得到相同的结果。显然，您已经决定指定要安装的依赖项的确切版本，但是那些依赖项的依赖项又如何呢？—您无法控制完整的从属树。</p><p id="bd83" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们看一个常见的案例:</p><p id="d3c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你直接靠<code class="eh ll lm ln lo b">express</code>确切版本<code class="eh ll lm ln lo b">4.17.1</code> - &gt; <code class="eh ll lm ln lo b">express</code>靠<code class="eh ll lm ln lo b">body-parser</code>范围<code class="eh ll lm ln lo b">~1.17.4</code>-&gt;T5】靠<code class="eh ll lm ln lo b">accepts</code>范围<code class="eh ll lm ln lo b">~1.3.4</code> - &gt;等等…</p><p id="dc8d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">您只能控制 express 版本，但是即使您根本没有碰过您的<code class="eh ll lm ln lo b">package.json</code>，您也可能会在<code class="eh ll lm ln lo b">npm install.</code>的两个独立执行中得到不同的依赖树</p><h1 id="050c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">包装锁定</h1><p id="050e" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">使用锁文件确保每次从任何地方安装时，每个安装结果对于整个依赖关系树都是相同的和可重复的。这是通过指定版本、位置和完整性散列来完成的。</p><p id="d2ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">锁定文件旨在在创建锁定文件时锁定整个依赖关系树的所有版本。</p><h2 id="8e2a" class="lu kd hu bd ke lv lw lx ki ly lz ma km jc mb mc kq jg md me ku jk mf mg ky mh dt translated">包锁. json</h2><p id="d728" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">对于 npm 修改<code class="eh ll lm ln lo b">package.json</code>或<code class="eh ll lm ln lo b">node_modules</code>树的任何操作，都会自动生成 npm 锁文件<code class="eh ll lm ln lo b">package-lock.json</code>(NPM ^5.x.x).的默认设置</p><p id="3622" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这意味着运行<code class="eh ll lm ln lo b">npm install</code>将生成<code class="eh ll lm ln lo b">package-lock.json</code>文件，如果它没有当前<code class="eh ll lm ln lo b">node_modules</code>的版本。</p><p id="d358" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">文件格式</strong></p><p id="e799" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该文件包含包名到依赖对象的映射。依赖对象具有以下属性:</p><p id="d602" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/files/package-lock.json#version-1" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">版本</strong> </a>这是一个唯一标识这个包的说明符，应该可以用来获取它的新副本。</p><p id="1cec" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/files/package-lock.json#dev" rel="noopener ugc nofollow" target="_blank"><strong class="it hv">dev</strong></a><strong class="it hv"/>如果为真，则此依赖关系仅为开发依赖关系。</p><p id="183f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/files/package-lock.json#requires" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">要求</strong> </a> <strong class="it hv"> </strong>列出了<em class="ml">要求</em>的模块列表，以便您的应用程序正常运行和工作，而不管它将安装在哪里。<strong class="it hv">该版本应通过正常匹配规则匹配我们的<code class="eh ll lm ln lo b"><strong class="it hv">dependencies</strong></code>或比我们高一级的依赖关系</strong>。</p><p id="9b97" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">锁文件中的<code class="eh ll lm ln lo b">requires</code>字段将使用范围。(自 npm ^6.x.x 起默认)</p><p id="2817" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/files/package-lock.json#dependencies-1" rel="noopener ugc nofollow" target="_blank"> <strong class="it hv">依赖关系</strong> </a> <strong class="it hv"> </strong>这种依赖关系的依赖关系，完全如同在顶层。</p><p id="f0cd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">完整文件格式:<a class="ae kb" href="https://docs.npmjs.com/files/package-lock.json" rel="noopener ugc nofollow" target="_blank">https://docs.npmjs.com/files/package-lock.json</a></p><p id="785c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">那么到底是什么让人如此困惑，为什么开发者一直删除这个文件？在<code class="eh ll lm ln lo b">package-lock</code>之前，装置的唯一真实来源是<code class="eh ll lm ln lo b">package.json</code>。当 package-lock 首次发布时，<code class="eh ll lm ln lo b">package.json</code>中的一个变化并没有影响到 package-lock，这对于习惯与<code class="eh ll lm ln lo b">package.json</code>一起工作的开发者来说并不直观。</p><p id="8936" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">自从 npm ^5.1.x 以来，行为已经改变:<code class="eh ll lm ln lo b">package.json</code>将否决<code class="eh ll lm ln lo b">package-lock.json</code>，如果<code class="eh ll lm ln lo b">package.json</code>已经用新模块或更新版本更新，例如:</p><ul class=""><li id="3712" class="la lb hu it b iu iv iy iz jc mu jg mv jk mw jo lh li lj lk dt translated">如果一个模块不存在于 package-lock 中，但是存在于 package.json 中，那么这个模块将被安装。</li><li id="03ea" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">Package A，版本 1.0.0 同时存在于 package.json 和包锁中。如果在 package.json 中手动将包 A 编辑为 1.1.0 版，将安装 1.1.0 版。</li></ul><h1 id="e34c" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">npm ci</h1><p id="da43" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">好的，所以<code class="eh ll lm ln lo b">package.json</code>和<code class="eh ll lm ln lo b">package-lock.json</code>可以住在一起，但是等等，还有最后一件事我们需要谈谈..</p><p id="4f16" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">npm 5.7.0 中引入的<code class="eh ll lm ln lo b">npm ci</code>命令忽略<code class="eh ll lm ln lo b">package.json</code>，仅安装<code class="eh ll lm ln lo b">package-lock.json</code> <strong class="it hv">中指定的依赖项</strong>。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff mx"><img src="../Images/e28739ccce9478d0919aa4c22fd728e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*iqhxc-w4RIs44i4P.gif"/></div></figure><p id="8f41" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lo b"><em class="ml">npm ci</em></code>是在<strong class="it hv">测试环境、持续集成或部署过程中安装依赖项的一种更快、更可靠的方式</strong>。增加的速度和可靠性，减少了浪费的时间，促进了最佳实践。</p><ul class=""><li id="cab0" class="la lb hu it b iu iv iy iz jc mu jg mv jk mw jo lh li lj lk dt translated"><code class="eh ll lm ln lo b">npm ci</code>仅从锁定文件安装，因此您必须提交锁定文件。</li><li id="aff3" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">快多了(2 倍-10 倍！)比<code class="eh ll lm ln lo b"><em class="ml">npm install.</em></code></li><li id="4a44" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">如果<code class="eh ll lm ln lo b"><em class="ml">package.json</em></code>和锁定文件不同步，它将报告一个错误。</li><li id="b794" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">它的工作原理是扔掉你的 node_modules 并从头开始重新创建它。</li><li id="59fc" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">不会改变<code class="eh ll lm ln lo b">package.json</code>或<code class="eh ll lm ln lo b">package-lock.json.</code></li></ul><h1 id="ee21" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">版本更新</h1><p id="6bd3" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">默认情况下，npm 会在通过<code class="eh ll lm ln lo b">npm install</code>安装依赖项时为 SEMVER 范围添加插入符号(<code class="eh ll lm ln lo b">^</code>)前缀(以启用跟踪和更新)。</p><p id="3e4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">此默认行为可以更改:</p><p id="a706" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lo b">npm config set save-prefix='~'</code>将默认值设置为波浪号。</p><p id="4849" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lo b">npm config set save-exact true</code>将取消自动前缀。</p><h2 id="3934" class="lu kd hu bd ke lv lw lx ki ly lz ma km jc mb mc kq jg md me ku jk mf mg ky mh dt translated">有用的命令</h2><p id="4b5d" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated"><code class="eh ll lm ln lo b"><a class="ae kb" href="https://docs.npmjs.com/cli/outdated.html" rel="noopener ugc nofollow" target="_blank">npm outdated</a>:</code>检查过期版本(显示任何已安装的软件包)。</p><p id="95a9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lo b"><a class="ae kb" href="https://docs.npmjs.com/cli/update" rel="noopener ugc nofollow" target="_blank">npm update</a></code>:将列出的所有包更新到最新版本，<strong class="it hv">遵守永远</strong>。</p><p id="6cda" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lo b"><a class="ae kb" href="https://www.npmjs.com/package/npm-check-updates" rel="noopener ugc nofollow" target="_blank">npm-check-updates</a>:</code>检查过期版本(仅显示来自<code class="eh ll lm ln lo b">package.json</code>的主包)。</p><p id="cfe5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><code class="eh ll lm ln lo b"><a class="ae kb" href="https://www.npmjs.com/package/npm-check-updates" rel="noopener ugc nofollow" target="_blank">npm-check-updates</a> -u</code>:将你的 package.json 依赖项升级到<em class="ml">最新</em>版本，<strong class="it hv">忽略指定版本</strong>。</p><p id="b0b4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">扫描你的项目的漏洞。</p><h1 id="33db" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">最优方法</h1><ul class=""><li id="9fe3" class="la lb hu it b iu lc iy ld jc le jg lf jk lg jo lh li lj lk dt translated">当开始一个新项目时，使用<code class="eh ll lm ln lo b">npm init</code>创建一个<code class="eh ll lm ln lo b">package.json</code>文件。</li><li id="b40b" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">一旦你列出了你想在项目中使用的所有包，使用<code class="eh ll lm ln lo b">npm install --save</code>安装并保存它们。</li><li id="3306" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">记住:默认情况下，npm 将使用前缀<code class="eh ll lm ln lo b">^</code>保存您的依赖项，为了保存准确的版本，您可以运行<code class="eh ll lm ln lo b">npm config set save-exact true.</code></li><li id="dbf4" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">运行<code class="eh ll lm ln lo b">npm install</code>将生成\update <code class="eh ll lm ln lo b">package-lock.json</code>文件，可以锁定整个依赖树的所有版本。</li><li id="eb1f" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">使用<code class="eh ll lm ln lo b">npm install</code>添加新的依赖项，更新依赖项，并在从源存储库提取更改后。</li><li id="e2ed" class="la lb hu it b iu lp iy lq jc lr jg ls jk lt jo lh li lj lk dt translated">持续集成时使用<code class="eh ll lm ln lo b">npm ci</code>。</li></ul><h1 id="0945" class="kc kd hu bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dt translated">结论</h1><p id="3cc5" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated">在处理共享项目时，强烈建议将包锁文件提交给源代码控制:这将允许团队中的任何其他人、您的部署、您的持续集成以及在您的包源代码中运行 npm install 的任何其他人获得与您正在开发的完全相同的依赖树。</p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><h1 id="8dce" class="kc kd hu bd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz dt translated">阅读更多</h1><p id="020f" class="pw-post-body-paragraph ir is hu it b iu lc iw ix iy ld ja jb jc mi je jf jg mj ji jj jk mk jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/files/package.json" rel="noopener ugc nofollow" target="_blank"> package.json </a></p><p id="31a0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/files/package-lock.json" rel="noopener ugc nofollow" target="_blank">包锁. json </a></p><p id="daad" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/about-semantic-versioning" rel="noopener ugc nofollow" target="_blank">语义版本</a></p><p id="fb0d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/cli/install" rel="noopener ugc nofollow" target="_blank">NPM-安装</a></p><p id="5c5e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/cli/ci.html" rel="noopener ugc nofollow" target="_blank"> npm-ci </a></p><p id="8b6c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae kb" href="https://docs.npmjs.com/cli/shrinkwrap" rel="noopener ugc nofollow" target="_blank">NPM-收缩包装</a></p></div><div class="ab cl my mz hc na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="hn ho hp hq hr"><p id="4fd4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">感谢阅读。随意分享！</p></div></div>    
</body>
</html>