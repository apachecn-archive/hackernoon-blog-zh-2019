<html>
<head>
<title>[Laravel Testing 101] Writing tests for guest user functionalities on a Laravel CRUD application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Laravel测试101]为Laravel CRUD应用程序上的访客用户功能编写测试</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/laravel-testing-101-writing-tests-for-guest-user-functionalities-on-a-laravel-crud-application-6d71bef5d89b?source=collection_archive---------15-----------------------#2019-01-02">https://medium.com/hackernoon/laravel-testing-101-writing-tests-for-guest-user-functionalities-on-a-laravel-crud-application-6d71bef5d89b?source=collection_archive---------15-----------------------#2019-01-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><a href="https://goo.gl/RDUt4v"><div class="fe ff fg"><img src="../Images/52bf9e84126f483254abfde8427668f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fh3jPIRkLQOFi35thK-fkQ.png"/></div></a></figure><blockquote class="ix iy iz"><p id="29ac" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><em class="hu">这是我即将出版的电子书</em> <a class="ae jz" href="https://laraveltesting101.com/" rel="noopener ugc nofollow" target="_blank"> <em class="hu"> Laravel测试101 </em> </a> <em class="hu">的节选。如果您还没有阅读前面的章节(在这里可以免费获得:</em> <a class="ae jz" href="https://youghourta.com/2018/11/27/laravel-testing-101-where-to-start/" rel="noopener ugc nofollow" target="_blank"> <em class="hu">向您的Laravel CRUD应用程序添加测试:从哪里开始？</em> </a> <em class="hu">这里:</em> <a class="ae jz" href="http://youghourta.com/2018/12/12/what-should-we-be-testing-in-a-laravel-crud-application/" rel="noopener ugc nofollow" target="_blank"> <em class="hu">我们应该在一个【laravel】CRUD应用中测试什么？</em> </a> <em class="hu">)，请先这样做再看这一篇。</em></p></blockquote><p id="0991" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">现在，我们对应该在Laravel应用程序中测试的功能有了更好的了解，让我们从测试guest可以做什么开始，因为它没有登录用户可以做的复杂。</p><p id="60bc" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">正如我们在<a class="ae jz" href="http://youghourta.com/2018/12/12/what-should-we-be-testing-in-a-laravel-crud-application/" rel="noopener ugc nofollow" target="_blank">上一章</a>中所讨论的，以下是我们在应用程序中拥有的与客人相关的功能:</p><ol class=""><li id="6366" class="kd ke hu jd b je jf ji jj ka kf kb kg kc kh jy ki kj kk kl dt translated">客人在访问时可以看到所有的文章</li><li id="a0a9" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">客人可以看到一篇文章</li><li id="1a13" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">客人可以看到用户简档</li><li id="5a90" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">客人不能写新文章，而是被重定向到注册页面</li><li id="9948" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">客人可以访问并获得注册页面</li><li id="3a78" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">客人可以访问并获得登录页面</li></ol><h1 id="01ea" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">确保PHPUnit与您的应用程序一起正常工作</h1><p id="d556" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">在我们开始编写任何测试之前，让我们确保<strong class="jd hv"> PHPUnit </strong>与您的应用程序一起正常工作。</p><p id="a68a" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">PHPUnit的二进制文件包含在项目的<code class="eh km kn ko kp b">vendor/bin/phpunit</code>中，所以您需要做的就是执行它(从项目目录中)。</p><p id="5e93" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">您应该会看到这样的结果:</p><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff ly"><img src="../Images/85e7aa483cbd16cca7e170ac0f1ccea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CcdniNI2VXBfl8Xp"/></div></div></figure><p id="fe7d" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">尽管我们还没有编写任何测试，但Laravel包含了以下示例测试:</p><ul class=""><li id="d963" class="kd ke hu jd b je jf ji jj ka kf kb kg kc kh jy mh kj kk kl dt translated"><code class="eh km kn ko kp b">/tests/Feature/ExampleTest.php</code></li><li id="805d" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy mh kj kk kl dt translated"><code class="eh km kn ko kp b">/tests/Unit/ExampleTest.php</code></li></ul><p id="46bc" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated"><strong class="jd hv">附注</strong>:我建议为上面的命令添加一个别名，这样你就不需要每次想运行测试时都键入<code class="eh km kn ko kp b">vendor/bin/phpunit</code></p><p id="b2f7" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">例如，我使用这个别名:</p><p id="a471" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated"><code class="eh km kn ko kp b">alias lphpunit="vendor/bin/phpunit"</code></p><h1 id="182c" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">1/客人访问时可以看到所有文章<code class="eh km kn ko kp b">/articles</code></h1><p id="84d2" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">因为我们要测试与<code class="eh km kn ko kp b">ArticleController</code>相关的功能，让我们首先创建一个专用于这个控制器的类。</p><p id="528c" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated"><code class="eh km kn ko kp b">php artisan make:test ArticleControllerTest</code></p><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mi"><img src="../Images/94544daa66ceab229e8721b8734d14fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qxYUc7xI8JMofCqi"/></div></div></figure><p id="685c" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">注意，我没有将<code class="eh km kn ko kp b">--unit</code>标志传递给命令，这意味着我们不是在创建一个单元测试，而是一个<strong class="jd hv">特性测试</strong>。新创建的类应该位于<code class="eh km kn ko kp b">/tests/Feature/ArticleControllerTest.php</code></p><p id="65df" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">你可以去掉<code class="eh km kn ko kp b">ArticleControllerTest</code>附带的<code class="eh km kn ko kp b">testExample</code>。</p><p id="8976" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">让我们创建我们的第一个测试。</p><p id="32d9" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">当执行PHPUnit时，它会寻找所有以<code class="eh km kn ko kp b">test</code>开头或者dockblock中有<code class="eh km kn ko kp b">@test</code>的公共方法。</p><p id="6b8e" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">所以你可以使用这种格式:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="84fd" class="mn kw hu kp b fv mo mp l mq mr">public function testGuestCouldSeeListOfArticles()<br/>{<br/>...<br/>}</span></pre><p id="4eab" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">或者这个:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="9a10" class="mn kw hu kp b fv mo mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_allows_anyone_to_see_list_all_articles()<br/>{<br/>...<br/>}</span></pre><p id="2ccc" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我更喜欢第二种，因为它更容易阅读。</p><p id="dfd1" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我从最基本的测试开始。我只是想确保每当我点击<code class="eh km kn ko kp b">/articles</code>路径时，我都能得到一个有效的页面。</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="8049" class="mn kw hu kp b fv mo mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_allows_anyone_to_see_list_all_articles()<br/>{<br/>	$response = $this-&gt;get(route('get_all_articles'));<br/>	$response-&gt;assertSuccessful();<br/>}</span></pre><p id="28c7" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">保存文件并运行PHPUnit(使用<code class="eh km kn ko kp b">vendor/bin/phpunit</code>或我们之前创建的<code class="eh km kn ko kp b">lphpunit</code>别名)。</p><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mi"><img src="../Images/e28902efa2e94b1984116dd5d748217f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fQytYAnIji8umlR_"/></div></div></figure><p id="ff0f" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我们的测试通过了</p><p id="5d7d" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">注意，尽管我们只写了一个测试和一个断言，PHPUnit告诉我们有3个测试和3个断言。</p><blockquote class="ix iy iz"><p id="84eb" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><em class="hu">注意:一个</em> <strong class="jd hv"> <em class="hu">断言</em> </strong> <em class="hu">是测试一个单一的“事物”，</em> <strong class="jd hv"> <em class="hu">一个测试可能<br/>包含多个断言</em> </strong> <em class="hu">。我们上面写的测试只包含一个<br/>单断言</em>T10】</p></blockquote><p id="56fb" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">这背后的原因是PHPUnit将运行<code class="eh km kn ko kp b">/tests</code>目录中的所有测试。在我们目前所处的阶段，每次运行所有的测试都不成问题，但是如果您想只运行一个测试，您可以将测试的名称(方法的名称)作为参数传递给<code class="eh km kn ko kp b">--filter</code>标志，如下所示:<br/> <code class="eh km kn ko kp b">lphpunit --filter=it_allows_anyone_to_see_list_all_articles</code></p><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff ms"><img src="../Images/6fe6d31db91e9b5b3997e897af975799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UoOJ_B5ooke_t8vy"/></div></div></figure><p id="2fd8" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">…是的，正如您可能已经猜到的那样，您可以为这个命令添加一个别名，以便在下次您想只运行一个测试时节省时间。</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="1e20" class="mn kw hu kp b fv mo mp l mq mr">alias lphpunit="vendor/bin/phpunit"  <br/>alias lphpunitf="lphpunit --filter="</span></pre><p id="7580" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated"><code class="eh km kn ko kp b">lphpunitf it_allows_anyone_to_see_list_all_articles</code></p><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mt"><img src="../Images/4129cbffdf83ce8f1ab4947c2cfc572c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H4fz3hc8-VBeQWmn"/></div></div></figure><p id="57ea" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">如你所知，我们想要测试的不仅仅是得到一个有效的页面，我们想要确保我们得到的是正确的页面。</p><p id="f193" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我们可以通过以下步骤对此进行测试:</p><ul class=""><li id="ae9a" class="kd ke hu jd b je jf ji jj ka kf kb kg kc kh jy mh kj kk kl dt translated">确保我们得到了正确的视角</li><li id="e52a" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy mh kj kk kl dt translated">确保视图包含该页面所需的变量</li></ul><p id="38c5" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">Laravel提供了两种方法来测试上述内容:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="41e1" class="mn kw hu kp b fv mo mp l mq mr">$response-&gt;assertViewIs('articles.index');<br/>$response-&gt;assertViewHas('articles');</span></pre><p id="7d86" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我们的测试类现在应该是这样的:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="6bff" class="mn kw hu kp b fv mo mp l mq mr">&lt;?php<br/>namespace Tests\Feature;</span><span id="e6e9" class="mn kw hu kp b fv mu mp l mq mr">use Tests\TestCase;<br/>use Illuminate\Foundation\Testing\WithFaker;<br/>use Illuminate\Foundation\Testing\RefreshDatabase;</span><span id="971d" class="mn kw hu kp b fv mu mp l mq mr">class ArticleControllerTest extends TestCase<br/>{<br/>	/**<br/>	* @test<br/>	*/<br/>	public function it_allows_anyone_to_see_list_all_article()<br/>	{<br/>		$response = $this-&gt;get(route('get_all_articles'));</span><span id="556d" class="mn kw hu kp b fv mu mp l mq mr">		$response-&gt;assertSuccessful();<br/>		$response-&gt;assertViewIs('articles.index');<br/>		$response-&gt;assertViewHas('articles');<br/>	}</span><span id="16d5" class="mn kw hu kp b fv mu mp l mq mr">}</span></pre><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mi"><img src="../Images/0f82a66f467ce776e7471beb8f871201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qzwHp91CJ-WLlMYd"/></div></div></figure><p id="d6b2" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">既然我们可以测试我们正在获得正确的视图(使用正确的变量)，我们不再需要保留第一个断言，因为它是隐式的。</p><h1 id="4cc8" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">2/客人可以看到一篇文章</h1><p id="70d6" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">既然我们已经测试了访客用户可以查看所有文章的列表，那么让我们确保她也可以查看单个文章。</p><p id="98ed" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">为了确保该功能(向访客用户显示单个文章)按预期工作，我们需要以下步骤:</p><ol class=""><li id="0028" class="kd ke hu jd b je jf ji jj ka kf kb kg kc kh jy ki kj kk kl dt translated">获取要查看的文章(随机)</li><li id="8e2f" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">生成到这篇文章的路由，并向它发送一个<code class="eh km kn ko kp b">GET</code>请求</li><li id="3e71" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">确保我们获得了正确的视图(在本例中为<code class="eh km kn ko kp b">articles.view</code></li><li id="58f3" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">确保返回的视图包含一个名为<code class="eh km kn ko kp b">$article</code>的变量</li><li id="9958" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy ki kj kk kl dt translated">确保我们得到的是我们想要访问的文章，而不是另一篇。</li></ol><p id="509a" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我们的测试应该是这样的:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="c764" class="mn kw hu kp b fv mo mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_allows_anyone_to_see_individual_articles()<br/>{<br/>	$article = Article::get()-&gt;random();<br/>	$response = $this-&gt;get(route('view_article', ['id' =&gt; $article-&gt;id]));<br/>	<br/>	$response-&gt;assertViewIs('articles.view');<br/>	$response-&gt;assertViewHas('article');<br/>	$returnedArticle = $response-&gt;original-&gt;article;<br/>	$this-&gt;assertEquals($article-&gt;id, $returnedArticle-&gt;id, "The returned article is different from the one we requested");<br/>}</span></pre><blockquote class="ix iy iz"><p id="fa52" class="ja jb jc jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><em class="hu">注意:<br/>我们可以通过</em> <code class="eh km kn ko kp b"><em class="hu">$response-&gt;original</em></code> <em class="hu">变量</em>访问返回的视图</p></blockquote><p id="5665" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">您可能会问，为什么我们要为这么简单的功能做所有这些步骤。这个特性确实很简单，它的测试也很简单……简单，但并不琐碎。</p><p id="5be2" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我们采取所有这些步骤是为了确保以下几点:</p><ul class=""><li id="cadd" class="kd ke hu jd b je jf ji jj ka kf kb kg kc kh jy mh kj kk kl dt translated">我们希望每次都能访问一篇随机的文章(我们不希望总是请求相同的ID或相同的文章)，因为我们可能会在代码中遇到一个问题，使得应用程序总是返回相同的文章。例如，想象一下，由于某种原因，我们没有搜索特定的文章，而是更新了我们的代码以使用<code class="eh km kn ko kp b">Article::first()</code>，如果我们一次又一次地返回相同的文章(使用相同的ID)，我们将无法检测到这个问题。</li><li id="140d" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy mh kj kk kl dt translated">强烈建议在测试中使用routes而不是URL，因为如果您改变了URL的结构，您就不需要更新您的测试。</li><li id="d23b" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy mh kj kk kl dt translated">我们还想确保我们确实得到了我们所请求的文章，因为我们可能得到包含我们正在寻找的变量的正确视图，但是它可能包含与我们所请求的不同的文章。</li></ul><h1 id="4f5f" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">3/客人可以看到用户档案</h1><p id="9593" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">这一个应该看起来很像前面的测试，因为概念是相同的(访问一个模型并返回它)，但是我们访问的是一个用户而不是一篇文章。<br/>因为我们在这里不是测试文章，我们应该首先创建一个新的测试类:</p><p id="e23e" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated"><code class="eh km kn ko kp b">php artisan make:test UserControllerTest</code></p><p id="a41e" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">那么我们需要做的就是添加下面的测试:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="7a73" class="mn kw hu kp b fv mo mp l mq mr">/**<br/> * @test<br/> */<br/>public function it_allows_anyone_to_see_users_profiles()<br/>{<br/>    $user = User::get()-&gt;random();</span><span id="61ca" class="mn kw hu kp b fv mu mp l mq mr">    $response = $this-&gt;get(route('show_user_profile', ['id' =&gt; $user-&gt;id]));</span><span id="6f66" class="mn kw hu kp b fv mu mp l mq mr">    $response-&gt;assertViewIs('users.show');<br/>    $response-&gt;assertViewHas('user');</span><span id="9111" class="mn kw hu kp b fv mu mp l mq mr">    $returnedUser = $response-&gt;original-&gt;user;</span><span id="c7b4" class="mn kw hu kp b fv mu mp l mq mr">    $this-&gt;assertEquals($user-&gt;id, $returnedUser-&gt;id, "The returned user is different from the one we requested");<br/>}</span></pre><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mi"><img src="../Images/fda9f35a4a8d60b0b08282b1bc3b458a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J_rnAHWPpQXPXe35"/></div></div></figure><h1 id="0b03" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">4/一个客人不能写新文章，而是被重定向到注册页面</h1><p id="d10e" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">这种方法(以及本章中的其余方法)要简单得多，因为它们不需要访问数据库。</p><p id="a794" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">为了测试该功能，我们需要以下步骤:</p><ul class=""><li id="30d3" class="kd ke hu jd b je jf ji jj ka kf kb kg kc kh jy mh kj kk kl dt translated">尝试进入<code class="eh km kn ko kp b">create_new_article</code>路线</li><li id="ecb9" class="kd ke hu jd b je kq ji kr ka ks kb kt kc ku jy mh kj kk kl dt translated">测试我们是否被重定向到登录页面[登录或注册页面？]</li></ul><p id="edaf" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">测试应该是这样的:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="4a9d" class="mn kw hu kp b fv mo mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_prevent_non_logged_in_users_from_creating_new_articles()<br/>{<br/>	$response = $this-&gt;get(route('create_new_article'));<br/>	$response-&gt;assertRedirect('login');<br/>}</span></pre><h1 id="5ac9" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">5.客人可以访问并获得注册页面和6。客人可以访问并获得登录页面</h1><p id="900c" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">这两个测试甚至更容易编写，因为我们只是检查当我们试图访问登录和注册页面时，我们是否得到了有效的页面。因为我们使用的是Laravel内置的认证控制器，所以我们不需要自己测试认证。</p><p id="afe7" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">对于这两个测试，我们也需要一个新的测试类。我们可以为他们创建一个专门的类。通常我把所有的“页面测试”(即当我们点击某个URL时确保我们得到有效页面的测试)放在一个<code class="eh km kn ko kp b">PagesControllerTest</code>(特别是如果我有一个名为<code class="eh km kn ko kp b">PagesController</code>的控制器)；或者只为<code class="eh km kn ko kp b">HomeController</code>创建一个测试类，因为在大多数情况下，我会将我测试的页面的逻辑添加到这个类中。</p><p id="050f" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">这两个测试用例应该如下所示:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="0069" class="mn kw hu kp b fv mo mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_returns_register_page()<br/>{<br/>	$response = $this-&gt;get(route('register'));<br/>	$response-&gt;assertSuccessful();<br/>}</span><span id="5c09" class="mn kw hu kp b fv mu mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_returns_login_page()<br/>{<br/>	$response = $this-&gt;get(route('login'));<br/>	$response-&gt;assertSuccessful();<br/>}</span></pre><p id="0dcf" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">此外，除了检查我们是否获得了有效的页面(在这种情况下已经足够了)，我们还检查我们是否获得了正确的视图，如下所示:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="5c88" class="mn kw hu kp b fv mo mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_returns_register_page()<br/>{<br/>	$response = $this-&gt;get(route('register'));<br/>	$response-&gt;assertViewIs('auth.register');<br/>}</span><span id="023f" class="mn kw hu kp b fv mu mp l mq mr">/**<br/>* @test<br/>*/<br/>public function it_returns_login_page()<br/>{<br/>	$response = $this-&gt;get(route('login'));<br/>	$response-&gt;assertViewIs('auth.login');<br/>}</span></pre><h1 id="ce94" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">测试如何检测代码库中的重大变化？</h1><p id="7830" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">正如我们在前一章中所讨论的，编写测试的一个目标是确保应用程序的功能将按照我们最初构建它们时的预期方式工作。</p><p id="1075" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">我想展示一个简单的例子，测试将如何通知我们，我们正在引入一个改变应用程序行为的新代码(一个突破性的改变)。</p><p id="3897" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">让我们假设在这个应用程序上工作了几个星期后，我们出于某种原因决定更新<code class="eh km kn ko kp b">ArticleController</code>的构造函数:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="1d49" class="mn kw hu kp b fv mo mp l mq mr">public function __construct()<br/>{<br/>	$this-&gt;middleware("can:manage,article")-&gt;only('edit', 'update', 'delete');<br/>	$this-&gt;middleware("auth")-&gt;only('create');<br/>}</span></pre><p id="c744" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">对此:</p><pre class="lz ma mb mc fq mj kp mk ml aw mm dt"><span id="6dfb" class="mn kw hu kp b fv mo mp l mq mr">public function __construct()<br/>{<br/>$this-&gt;middleware("can:manage,article")-&gt;only('edit', 'update', 'delete');<br/>$this-&gt;middleware("auth");<br/>}</span></pre><p id="9569" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">唯一的变化是从构造函数的第二行删除了<code class="eh km kn ko kp b">-&gt;only('create')</code>。</p><p id="032e" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">这可能是偶然发生的(一个队友没有看到用这个中间件只保护一个动作的价值),也可能是有意为之，以防止访客在登录前阅读文章。</p><p id="491f" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">如果我们运行测试，我们会得到这个:</p><figure class="lz ma mb mc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="fe ff mv"><img src="../Images/e040d890ee2b6849187646c942b2e665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v8btVE9JrCATgFDc"/></div></div></figure><p id="26d9" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">在编写应用程序的任何测试之前，您可能不会很快注意到这种突破性的变化。也许突破性的改变甚至会在没有人注意到的情况下被部署，因为大多数时间你都是以登录用户的身份使用你的应用程序，你不会认为你需要在应用程序的每一个小的改变之后测试来宾功能。</p><p id="271a" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">但是通过测试，任何突破性的变化都会被立即检测出来，甚至不需要手动测试应用程序。如果你在你的项目中设置了一个CI(持续集成)(我们将在后面的电子书中探讨如何设置它),如果不先解决这个问题，你甚至不能合并/部署。</p><h1 id="c0fc" class="kv kw hu bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls dt translated">结论</h1><p id="53ad" class="pw-post-body-paragraph ja jb hu jd b je lt jg jh ji lu jk jl ka lv jo jp kb lw js jt kc lx jw jx jy hn dt translated">在本章中，我们探讨了测试来宾用户功能所需的不同步骤。我们已经看到，尽管测试很简单，但它们有时需要额外的步骤来确保我们测试的是正确的东西，并且我们没有遗漏一些边缘情况(尤其是当我们引入可能破坏应用程序的更改时)。我们还看到了测试如何检测代码库中的重大变化。</p><p id="6a4f" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">在接下来的章节中，我们将探索与登录用户相关的测试，这可能比我们目前看到的测试更具挑战性。</p><p id="6cbc" class="pw-post-body-paragraph ja jb hu jd b je jf jg jh ji jj jk jl ka jn jo jp kb jr js jt kc jv jw jx jy hn dt translated">如果你想继续下去，并得到关于这本书的任何进展的通知(例如新的免费章节)，请在这里注册:<a class="ae jz" href="https://laraveltesting101.com/" rel="noopener ugc nofollow" target="_blank">https://laraveltesting101.com/</a></p></div></div>    
</body>
</html>