<html>
<head>
<title>Explained: The Snax Trustless Authentication Protocol</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释:Snax无信任认证协议</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/snax-trustless-authentication-protocol-f925216ae7d2?source=collection_archive---------19-----------------------#2019-03-12">https://medium.com/hackernoon/snax-trustless-authentication-protocol-f925216ae7d2?source=collection_archive---------19-----------------------#2019-03-12</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/dd6c2734fe04e91e6a16293187b1b1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uNfimu4twFNCPq_eFkaASg.png"/></div></div></figure><div class=""/><p id="0666" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Snax运营的基本技术是将区块链交易与Twitter、Reddit等社交媒体平台上的账户绑定在一起。</p><p id="697b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">Snax区块链允许你<a class="ae ka" href="https://hackernoon.com/snax-social-transaction-and-why-sharing-is-caring-afc32c8f1646" rel="noopener ugc nofollow" target="_blank">将交易</a>发送到整合到Snax <strong class="je ig">的任何公共平台上的任何账户名下，而无需接收者</strong>事先开具发票(我们称之为社交交易)。</p><p id="7fc4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可以确定交易将到达接收方，而不必依赖于集中的第三方(当然，除了社交平台本身)。本文将使用Twitter帐户的认证示例来解释Snax无信任认证协议是如何工作的。</p><h1 id="c6f4" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">不要相信。但是核实一下。</h1><p id="84c2" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">这是构建开放密码系统(包括区块链系统)的主要原则。</p><p id="5632" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">使用oAuth 2.0构建的认证解决方案，例如OpenID connect，可以很好地与集中式服务器一起工作，但是，在分散式系统中很难实现它们。</p><p id="cdfb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些系统旨在解决一个特定的问题，即用户(<em class="le">客户端</em>)何时需要获得某项服务的授权(<em class="le">集中式服务器</em>)。然而，使用基于区块链的系统，任何用户的认证和授权必须不是由一个服务器来验证，而是由外部观察者(<em class="le">第三方</em>)在任何时刻来验证。</p><p id="27d7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> Snax无信任认证协议为以下问题提供了解决方案</strong>:</p><ol class=""><li id="41bf" class="lf lg if je b jf jg jj jk jn lh jr li jv lj jz lk ll lm ln dt translated">对来自Snax区块链上任何公共平台的用户进行身份验证。</li><li id="17fc" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">随时向任何第三方提供用户身份验证的证明。</li><li id="6915" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">在没有公共平台参与的情况下，使用Snax帐户完成任何后续认证。</li></ol></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="1d08" class="kb kc if bd kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky dt translated">第一步。认证。</h1><p id="a90e" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">以Twitter为例，它是一个在线公共平台(Twitter将在main net发布时集成到Snax区块链)。</p><p id="ed43" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们假设您有一个Twitter帐户，并且希望使用该帐户在Snax区块链中完成身份验证。将使用以下算法进行身份验证:</p><ol class=""><li id="909e" class="lf lg if je b jf jg jj jk jn lh jr li jv lj jz lk ll lm ln dt translated">客户端(用户)生成一对密钥(<em class="le"> priv_key，pub_key </em>)。</li><li id="d122" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">客户在snax区块链上选择任何未分配的账户名称(<em class="le">Snax _ name</em>)(<em class="le">Snax _ name</em>账户将在区块链上注册)。</li><li id="e2d6" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">客户端生成一个密钥(<em class="le"> K </em>)。</li><li id="5a7d" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">客户端计算一个哈希函数<br/> <em class="le"> H(K，snax _ name)= hmac _ sha 256(K | | hmac _ sha 256(K | | snax _ name))</em></li><li id="267f" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">客户通过从他们的Twitter帐户创建一条推文来发布接收到的散列值<em class="le">H</em>,<strong class="je ig">确认他们的意图</strong> <strong class="je ig">在Snax区块链上完成认证</strong>。</li><li id="b97c" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">客户端向oracle发送以下信息:<br/> - Pair ( <em class="le"> K，snax _ name</em>)<br/>-Their<em class="le">pub _ key</em>，将为其注册帐户名<em class="le"> snax_name </em>。<br/> -他们在Twitter上的帐户名<em class="le"> N </em>和一个到认证tweet的链接(可选，因为oracle可以使用Twitter API在提要上找到认证tweet)</li><li id="c74c" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">然后，Oracle会计算您的散列值<em class="le"> H </em>，并将其与认证tweet中的散列值进行比较。如果哈希值相同，Oracle认为身份验证过程已经完成。</li><li id="d6f5" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">Oracle使用参数(<em class="le"> K，snax_name，pub_key，N，L </em>)调用Twitter平台智能合约的注册方法。</li><li id="7e1d" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">twitter平台智能合约然后用公钥<em class="le"> pub_key </em>注册账户<em class="le"> snax_name </em>，并向区块链添加关于Twitter用户<em class="le"> N </em>成功认证的信息、公钥<em class="le"> K、</em>和链接<em class="le"> L </em>。</li></ol><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mf"><img src="../Images/a27210f5c3e1961e33e7ee0ef7524faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrOhvLb2Unqmw_BgDidPMw.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Snax authentication process</figcaption></figure><h1 id="14b5" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第二步。证明。</h1><p id="52f0" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在有必要解释为什么第三方可能不信任已经完成用户认证的集中式oracle。</p><p id="dc87" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们考虑以下媒介攻击的可能性:</p><ol class=""><li id="e4a9" class="lf lg if je b jf jg jj jk jn lh jr li jv lj jz lk ll lm ln dt translated">甲骨文受到威胁。</li><li id="742d" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">入侵者伪造用户的身份验证请求。</li></ol><p id="03d7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">对这种攻击的主要防御来自于暴力强制传入数据</strong> ( <em class="le"> K，snax_name </em>)满足认证散列<em class="le"> H </em>的不可能性。</p><p id="a510" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为包含hash <em class="le"> H </em>的认证tweet是由twitter帐户的所有者在Twitter上发布的，所以入侵者无法生成有效的对(<em class="le"> K，snax_name </em>)，除非该对是由帐户的实际所有者提供的。</p><p id="262b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这样，任何第三方在任何时候都可以使用下面的算法来验证Twitter账户<em class="le"> N </em>的所有者的认证:</p><ol class=""><li id="96f1" class="lf lg if je b jf jg jj jk jn lh jr li jv lj jz lk ll lm ln dt translated">把嵌入到区块链对中的关于用户的认证(<em class="le"> K，snax_name </em>)。</li><li id="6f3b" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">生成hash <em class="le"> H(K，snax_name </em>)。</li><li id="0b77" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">转到已发布的链接<em class="le"> L. </em></li><li id="c375" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">验证发布推文<em class="le"> L </em>的账号确实属于用户<em class="le"> N </em>的账号。</li><li id="9f9b" class="lf lg if je b jf lo jj lp jn lq jr lr jv ls jz lk ll lm ln dt translated">检查tweet <em class="le"> L </em>中是否存在hash <em class="le"> H </em>。如果找到了散列，那么用户认证是有效的。</li></ol><h1 id="9178" class="kb kc if bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">第三步。使用Snax帐户作为验证者。</h1><p id="e544" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">现在，用户的认证可以被证明，区块链账户的名字<em class="le"> snax_name </em>可以随后被用作Twitter <em class="le"> N </em>的用户的认证。例如，snax区块链使用账户<em class="le"> N </em>的<em class="le"> snax_name </em>来进行Snax令牌的<a class="ae ka" rel="noopener" href="/@Snax/snax-token-distribution-a181610ffe8">发行。</a></p><p id="bc4f" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这一过程还使得有可能创建到公共网络的任何账户的交易，集成到Snax平台中，而无需接收者事先开具发票。平台智能合约将自动完成对<em class="le"> snax_name </em>的交易，从该处完成对接收方的认证。如果身份验证尚未完成，则平台智能合约将等待其完成以执行交易。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><h1 id="2bf9" class="kb kc if bd kd ke ma kg kh ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky dt translated">结论</h1><p id="46a0" class="pw-post-body-paragraph jc jd if je b jf kz jh ji jj la jl jm jn lb jp jq jr lc jt ju jv ld jx jy jz hn dt translated">我们已经了解了Snax无信任认证协议在宏观层面上是如何工作的。</p><p id="c36a" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当然，发布认证消息的行为(例如tweet)可能会给用户带来不便，但是，我们还没有看到任何可靠的替代技术来创建无信任认证。</p><p id="0ccb" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这种不便可以通过在现有社交网络的API中集成Snax无信任认证协议(或类似协议)来解决。一般来说，这不是一个复杂的过程，但是，它确实需要平台为第三方请求创建一个公共认证API。</p></div><div class="ab cl lt lu hc lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="hn ho hp hq hr"><p id="a7a9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您对Snax emission如何工作、如何获得出版商奖励或如何成为Snax network的一名制作人有任何疑问，请随时加入我们在<a class="ae ka" href="https://discord.gg/qygxJAZ." rel="noopener ugc nofollow" target="_blank">https://discord.gg/qygxJAZ.</a>的讨论，不要忘记在<a class="ae ka" href="https://twitter.com/SnaxTeam" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我们，并为这篇文章鼓掌！</p><p id="73f7" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">此外，你可以在这里找到常见问题的答案<a class="ae ka" href="https://snax.one/faq." rel="noopener ugc nofollow" target="_blank">https://snax.one/faq.</a></p></div></div>    
</body>
</html>