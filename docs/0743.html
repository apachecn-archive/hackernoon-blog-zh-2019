<html>
<head>
<title>GraphQL on Rack — Writing a modular GraphQL Server in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rack 上的 GraphQL——用 Ruby 编写模块化的 graph QL 服务器</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphql-on-rack-writing-a-modular-graphql-server-in-ruby-5a4e02d5472c#2019-01-30">https://medium.com/hackernoon/graphql-on-rack-writing-a-modular-graphql-server-in-ruby-5a4e02d5472c#2019-01-30</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="4e76" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">在本文中，我将展示通过重用开源的 GraphQL gem 和 Rack(一个模块化的 Ruby web 服务器接口),在 Ruby 中从头开始组装一个生产就绪的 GraphQL 服务器所需的部分。</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/ba9653d053bda9cb4d109ba4d4564de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MN_G0unOsZGl7g5aZ9NovA.png"/></div></div></figure><h1 id="d195" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">为什么是 Rack？</h1><p id="a8f2" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在 Ruby-land，<a class="ae lj" href="http://rack.github.io/" rel="noopener ugc nofollow" target="_blank"> Rack </a>可以比作 Node.js 的优秀<a class="ae lj" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express </a> web 服务器。然而，它的方法有点不同。虽然 Express 是一个完整的 web 服务器，但 Rack 只为您提供构建自己的组件。因为大多数 Ruby web 服务器都是在机架上构建的，所以我们可以用它们来支持我们的 GraphQL 服务器。</p><h2 id="5089" class="lk jw hu bd jx ll lm ln kb lo lp lq kf kw lr ls kh la lt lu kj le lv lw kl lx dt translated">机架应用</h2><p id="4b70" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在 Rack 中，像大多数 web 服务器一样，您处理 web 请求和响应。请求是来自 web 浏览器的信息(URL、用户代理、cookies、参数)，响应是 web 服务器发送回浏览器的信息(状态、标题、HTML、JSON)。</p><p id="9bfe" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">最简单的 Rack 应用程序只是接收一个请求并返回一个响应。</p><pre class="jk jl jm jn fq md me mf mg aw mh dt"><span id="f62a" class="lk jw hu me b fv mi mj l mk ml">app = Proc.new<!-- --> <!-- -->do<!-- --> <!-- -->|env|<!-- --> </span><span id="32d8" class="lk jw hu me b fv mm mj l mk ml">  ['200', {'Content-Type'<!-- --> <!-- -->=&gt; 'text/html'}, ['Hello World']]</span><span id="e1dd" class="lk jw hu me b fv mm mj l mk ml">end</span></pre><p id="efc7" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">Proc 定义了一个新的代码块，当服务器接收到一个请求并将其信息包装在<em class="mn"> env </em>参数中时执行。该块返回一个包含 3 项的数组:HTTP 状态代码、响应头和响应体。</p><p id="fcf2" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">Rack 提供了多种运行应用程序的方式。它提供了一个名为<strong class="kp hv"> rackup </strong>的基本开发服务器，但是因为 Rack 是模块化的，所以你可以用任何实现 Rack 接口的生产就绪的 Ruby web 服务器来替换运行时，比如<a class="ae lj" href="https://github.com/macournoyer/thin" rel="noopener ugc nofollow" target="_blank"> Thin </a>。</p><pre class="jk jl jm jn fq md me mf mg aw mh dt"><span id="16ce" class="lk jw hu me b fv mi mj l mk ml">gem install thin<br/>thin start</span></pre><p id="558a" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">对，就是这么简单！</p><h1 id="ece9" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">构建服务器</h1><p id="a7a6" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">基于上面提到的概念，让我们构建服务器的框架。</p><pre class="jk jl jm jn fq md me mf mg aw mh dt"><span id="77ec" class="lk jw hu me b fv mi mj l mk ml">require 'rack'</span><span id="936d" class="lk jw hu me b fv mm mj l mk ml">class GraphQLServer<br/>  def initialize(schema:, context: {})<br/>    <a class="ae lj" href="http://twitter.com/schema" rel="noopener ugc nofollow" target="_blank">@schema</a> = schema<br/>    <a class="ae lj" href="http://twitter.com/context" rel="noopener ugc nofollow" target="_blank">@context</a> = context<br/>  end</span><span id="25a6" class="lk jw hu me b fv mm mj l mk ml">  def response(status: 200, response)<br/>    [<br/>      200, <br/>      {<br/>        'Content-Type' =&gt; 'application/json', <br/>        'Content-Length' =&gt; response.bytesize.to_s<br/>      }, <br/>      [response]<br/>    ]<br/>  end</span><span id="c30a" class="lk jw hu me b fv mm mj l mk ml">  def call(env)<br/>    request = Rack::Request.new(env)<br/>    response(200, "")<br/>  end<br/>end</span></pre><p id="fbb0" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated"><em class="mn"> initialize </em>方法将 GraphQL 模式作为参数和上下文对象，我们将在运行时将它传递给模式解析器。看看<a class="ae lj" href="http://graphql-ruby.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL gem </a>了解更多关于如何构建模式的信息。在本文结尾，我还提供了一个例子。</p><p id="0167" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">Rack 为每个请求调用了<em class="mn"> call </em>方法，但是现在它没有做太多事情。</p><p id="caeb" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">我决定以自己的方法提取<em class="mn">响应</em>，以简化我们将在下面讨论的<em class="mn">调用</em>方法。</p><h2 id="4375" class="lk jw hu bd jx ll lm ln kb lo lp lq kf kw lr ls kh la lt lu kj le lv lw kl lx dt translated">提取有效载荷</h2><p id="12ad" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">GraphQL HTTP 协议可以使用 GET 和 POST 请求类型传递有效负载。当使用 GET 时，有效负载位于请求参数中，当使用 POST 时，它位于请求体中。</p><p id="c600" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">我们添加了一个条件来根据请求类型提取有效负载，如下所示:</p><pre class="jk jl jm jn fq md me mf mg aw mh dt"><span id="a3e7" class="lk jw hu me b fv mi mj l mk ml">def call(env)<br/>  request = Rack::Request.new(env)</span><span id="54f5" class="lk jw hu me b fv mm mj l mk ml"><strong class="me hv">  payload = if request.get?<br/>    request.params<br/>  elsif request.post?<br/>    body = request.body.read<br/>    JSON.parse(body)<br/>  end</strong><br/>  <br/>  response(200, "")<br/>end</span></pre><h2 id="36c6" class="lk jw hu bd jx ll lm ln kb lo lp lq kf kw lr ls kh la lt lu kj le lv lw kl lx dt translated">处理 GraphQL 请求</h2><p id="7913" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">在<a class="ae lj" href="https://graphql.org/learn/serving-over-http/" rel="noopener ugc nofollow" target="_blank"> GraphQL HTTP 协议</a>中，一个请求由 3 个对象组成:查询、它的变量和操作名。由于我们已经解析了有效负载和模式(来自构造函数)，我们只需将这些参数传递给<a class="ae lj" href="http://graphql-ruby.org/api-doc/1.8.13/GraphQL/Schema.html#execute-instance_method" rel="noopener ugc nofollow" target="_blank"> schema.execute </a>方法。</p><pre class="jk jl jm jn fq md me mf mg aw mh dt"><span id="75db" class="lk jw hu me b fv mi mj l mk ml">def call(env)<br/>  request = Rack::Request.new(env)</span><span id="20e5" class="lk jw hu me b fv mm mj l mk ml">  payload = if request.get?<br/>    request.params<br/>  elsif request.post?<br/>    body = request.body.read<br/>    JSON.parse(body)<br/>  end</span><span id="4920" class="lk jw hu me b fv mm mj l mk ml"><strong class="me hv">  result = </strong><a class="ae lj" href="http://twitter.com/schema" rel="noopener ugc nofollow" target="_blank"><strong class="me hv">@schema</strong></a><strong class="me hv">.execute(<br/>    payload['query'], <br/>    variables: payload['variables'],<br/>    operation_name: payload['operationName'],<br/>    context: </strong><a class="ae lj" href="http://twitter.com/context" rel="noopener ugc nofollow" target="_blank"><strong class="me hv">@context</strong></a><strong class="me hv">, <br/>  ).to_json</strong><br/>  <br/>  response(200, <strong class="me hv">result</strong>)<br/>end</span></pre><p id="c761" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">就是这样！现在，您在 Ruby 中拥有了一个符合规范的 GraphQL 服务器。</p><h1 id="a3ae" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">使用新的 GraphQL 服务器</h1><p id="75ba" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">您可以将 Rack server 与 GraphQL gem 构建的任何模式一起使用，并与您最喜欢的 Ruby web 服务器一起提供服务。</p><pre class="jk jl jm jn fq md me mf mg aw mh dt"><span id="e49d" class="lk jw hu me b fv mi mj l mk ml">require 'graphql'</span><span id="5c38" class="lk jw hu me b fv mm mj l mk ml">type_def = &lt;&lt;-GRAPHQL<br/>  type Query {<br/>    hello: String<br/>  }<br/>GRAPHQL</span><span id="8e54" class="lk jw hu me b fv mm mj l mk ml">resolver = {<br/>  "Query" =&gt; { <br/>    "hello" =&gt; Proc.new { "world" }<br/>  }<br/>}</span><span id="4ce3" class="lk jw hu me b fv mm mj l mk ml">schema = GraphQL::Schema.from_definition(<br/>  type_def, <br/>  default_resolve: resolver<br/>)</span><span id="1be9" class="lk jw hu me b fv mm mj l mk ml"><strong class="me hv">run GraphQLServer.new(schema: schema)</strong></span></pre><p id="0578" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">我还没有介绍过<em class="mn"> run </em>指令，但是它只是允许 Rack 使用你的服务器来处理所有传入的请求。</p><h1 id="524d" class="jv jw hu bd jx jy jz ka kb kc kd ke kf ja kg jb kh jd ki je kj jg kk jh kl km dt translated">下一步是什么？</h1><p id="1f2f" class="pw-post-body-paragraph kn ko hu kp b kq kr iv ks kt ku iy kv kw kx ky kz la lb lc ld le lf lg lh li hn dt translated">这是一个非常简单和天真的实现，但它可以与任何符合规范的 GraphQL 客户端(如 Apollo)一起工作。然而，如果你想要更多的灵活性和一些错误处理，你可以使用我的开源 graph QL-server gem，本文就是基于它的。</p><p id="4d39" class="pw-post-body-paragraph kn ko hu kp b kq ly iv ks kt lz iy kv kw ma ky kz la mb lc ld le mc lg lh li hn dt translated">如果你喜欢这类东西，请在 Medium 和<a class="ae lj" href="https://twitter.com/betaflag" rel="noopener ugc nofollow" target="_blank"> Twitter @betaflag </a>上关注我。</p></div></div>    
</body>
</html>