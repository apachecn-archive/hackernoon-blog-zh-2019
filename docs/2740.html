<html>
<head>
<title>Apollo vs Redux — rendering with data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿波罗vs Redux——用数据渲染</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/apollo-vs-redux-rendering-with-data-3a0da3b1ffab?source=collection_archive---------9-----------------------#2019-04-29">https://medium.com/hackernoon/apollo-vs-redux-rendering-with-data-3a0da3b1ffab?source=collection_archive---------9-----------------------#2019-04-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/a8c7e8805caf579c7ee6bf123b044690.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*BCObdypXqeOfXa4qr50diQ.jpeg"/></div></figure><p id="7670" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Apollo和Redux是与React一起使用的两个流行的库。它们被收录的原因多种多样，但主要是为了:<br/> 1。管理一家商店<br/> 2。协助处理数据获取<br/> 3。用更新的道具触发任何重新渲染</p><p id="c472" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">但是他们在幕后使用什么机制来做到这一点，当涉及到处理道具和渲染时，他们有什么不同？</p><p id="a588" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我决定进行调查，下面就是它的产物。</p></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><h1 id="20ee" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">TLDR；</h1><p id="7392" class="pw-post-body-paragraph iy iz hu ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv hn dt translated"><em class="lg">阿波罗</em>使用一个可观测值并手动强制重新渲染，在渲染点读取数据的当前可观测值。</p><p id="7612" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Redux 也使用一个可观察对象，但是使用观察者通知为它的订阅者更新本地状态。</p></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><h1 id="8553" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">看得见的</h1><p id="346f" class="pw-post-body-paragraph iy iz hu ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv hn dt translated">首先要接触的重要事物是可观察的。它们是一个新的<em class="lg">异步原语</em>，具有一些强大的属性。下面是一个基本的例子。</p><ol class=""><li id="f773" class="lh li hu ja b jb jc jf jg jj lj jn lk jr ll jv lm ln lo lp dt translated">从订阅功能创建您的可观察对象</li></ol><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="58c0" class="lz ke hu lv b fv ma mb l mc md">const subscriptionFunction = (observer) =&gt; {<br/>   // do some stuff, could be async.<br/>   observer.next("Call with some data");<br/>   observer.complete();<br/>   return () =&gt; console.log("Unsubscribing")<br/>}<br/>const ourObservable = new Observable(subscriptionFunction);</span></pre><p id="0642" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">2.订阅你的观察。这将调用<em class="lg">预订功能</em>。</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="01c1" class="lz ke hu lv b fv ma mb l mc md">const  subscriber = ourObservable.subscribe({<br/>   next(x) { console.log(x) }, // “Call with some data"<br/>   error(err) { console.log("Received terminating error of the<br/>   sequence.") },<br/>   complete() { console.log("Stream has completed successfully.") }<br/>});<br/>subscriber.unsubscribe(); // "Unsubscribing"</span></pre><p id="1bca" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">基本上我们可以定义对象之间的一对多关系。当父可观察对象的状态改变时，它的从属对象(观察对象)被通知并更新。</p><p id="ad32" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">他们有几个强大的属性，包括懒惰，可取消，可以在一个序列中运行多次。</p><p id="ef88" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">今天就来看看<a class="ae me" href="https://github.com/zenparsing/zen-observable" rel="noopener ugc nofollow" target="_blank"> zen-observable </a>吧，以符合规范的方式使用它们。</p></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><h1 id="ecf3" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">让我们从阿波罗开始</h1><p id="a1c9" class="pw-post-body-paragraph iy iz hu ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv hn dt translated">Apollo在Observables订阅函数中使用fetch(在我最近的<a class="ae me" href="https://www.youtube.com/watch?v=zO_ZuWERUy8" rel="noopener ugc nofollow" target="_blank">演讲中可以找到关于Apollo内部的全部细节)。可观测数据也作为归一化数据的存储。</a></p><p id="f060" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">在收到来自HTTP请求的响应时，存储被更新，然后触发<em class="lg">" force render()"</em>(Reacts方法手动触发给定组件内的重新呈现)。</p><p id="51b1" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">最后使用“渲染道具模式”,用当前可观察的数据渲染孩子。值得注意的是，这里根本没有使用React state。</p><p id="3b7b" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">下面是一个带有基本查询组件的页面加载事件的分类。</p><figure class="lq lr ls lt fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="fe ff mf"><img src="../Images/ed0801f8d1add6b6b26dbb2e01e9fba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otZnzjv943XpO2s3ZbYkng.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek">Full anatomy of a page-load with Apollo</figcaption></figure></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><h1 id="aef6" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">现在回到Redux</h1><p id="82be" class="pw-post-body-paragraph iy iz hu ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv hn dt translated">使用Redux，我们将忽略实际的HTTP获取机制(假设为此使用了<a class="ae me" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> thunks </a>或<a class="ae me" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> sagas </a>),并专注于存储更新和组件重新呈现。</p><p id="d7ae" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">当一个组件<em class="lg">“connects()”</em>被添加到可观察商店的订户列表中(更多关于<a class="ae me" href="https://redux.js.org/api/store" rel="noopener ugc nofollow" target="_blank"> Redux可观察商店的信息，请点击</a>)。<br/>当一个reducer在存储中改变状态时，所有的订阅者都会得到通知并运行一个<em class="lg">“setState()”</em>。</p><p id="1cf6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">结果是连接的组件及其子组件用更新的道具重新呈现。</p><p id="d2b0" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">Redux的connect的简化版如下:</p><pre class="lq lr ls lt fq lu lv lw lx aw ly dt"><span id="98da" class="lz ke hu lv b fv ma mb l mc md">class Connect extends Component {<br/>     trySubscribe() {<br/>        this.unsubscribe =<br/>          this.store.subscribe(this.handleChange.bind(this))<br/>        this.handleChange()<br/>     }</span><span id="a6f4" class="lz ke hu lv b fv mo mb l mc md">     componentDidMount() {<br/>       this.trySubscribe()<br/>     }</span><span id="958d" class="lz ke hu lv b fv mo mb l mc md">     handleChange() { <br/>       const storeState = this.store.getState()<br/>       const prevStoreState = this.state.storeState<br/>       // logic using store and react state<br/>       // if the Store state has changed, update Reacts state<br/>       this.setState({ storeState })<br/>     }<br/>}</span></pre></div><div class="ab cl jw jx hc jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="hn ho hp hq hr"><h1 id="effa" class="kd ke hu bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">摘要</h1><p id="e865" class="pw-post-body-paragraph iy iz hu ja b jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr lf jt ju jv hn dt translated">我发现这两个库都利用了<em class="lg"> Observables </em>非常有趣，尽管它们使用不同的机制<em class="lg">。</em></p><p id="43c6" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">我认为，如果没有别的，它显示了Observables在Javascript的未来将扮演的角色。它们目前处于正式提案的第一阶段(全部细节请参见<a class="ae me" href="https://github.com/tc39/proposal-observable" rel="noopener ugc nofollow" target="_blank"> tc39，此处为</a>)，因此有望很快落地。考虑到他们带来的力量(解决承诺有时流不能解决的问题),似乎有很多场景非常适合他们。</p><p id="2fd2" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">阅读它们在野外的工作实例，比如Redux和Apollo，是了解它们更多的好方法。</p><p id="960f" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">接下来，我将检查这些方法的优缺点，并尝试解释为什么这些库选择了它们所选择的方法。</p><p id="d3df" class="pw-post-body-paragraph iy iz hu ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv hn dt translated">如果你喜欢这个，请鼓掌。或者让我知道你是否有任何想法或反馈。谢谢:)</p></div></div>    
</body>
</html>