<html>
<head>
<title>How to Cache Bust a React App?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何缓存一个React应用？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/how-to-cache-bust-a-react-app-6775081e09cc?source=collection_archive---------22-----------------------#2019-04-24">https://medium.com/hackernoon/how-to-cache-bust-a-react-app-6775081e09cc?source=collection_archive---------22-----------------------#2019-04-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="4647" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这篇文章也交叉发表在-</p><p id="7120" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">开发— <a class="ae jp" href="https://dev.to/flexdinesh/cache-busting-a-react-app-22lk" rel="noopener ugc nofollow" target="_blank">缓存破坏反应应用</a></p><p id="0dfb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv"><em class="jq">TL；DR</em></strong><em class="jq">—</em><a class="ae jp" href="https://docs.npmjs.com/about-semantic-versioning" rel="noopener ugc nofollow" target="_blank"><em class="jq">SEM ver</em></a><em class="jq">您的应用程序，并在每个构建上生成一个不会被浏览器缓存的</em> <code class="eh jr js jt ju b"><em class="jq">meta.json</em></code> <em class="jq">文件。当版本不匹配时，使缓存无效并硬重新加载应用程序。</em> <strong class="it hv"> <em class="jq">注意:本帖中的例子和解释都是基于React的。但是这个策略将适用于任何web应用程序/框架。</em> </strong></p><p id="9f91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">尽管缓存很棒，但缓存失效已经是一个长期的问题了。<strong class="it hv">使浏览器<strong class="it hv">中加载的网络应用的<strong class="it hv">缓存</strong>失效是很难的</strong>。但是<strong class="it hv">使</strong>保存到<strong class="it hv">主屏幕</strong>的网络应用的<strong class="it hv">缓存</strong>失效<strong class="it hv">更加困难</strong>。</strong></p><p id="f0b9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">缓存的快速介绍-</p><p id="1c54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">服务器缓存:</strong> Web服务器在第一次请求资源时缓存资源。第二次以后，资源由服务器缓存提供。除此之外还有很多——CDN、源服务器、边缘服务器等，但我们不会一一介绍。使服务器缓存失效非常简单，因为我们可以控制我们的服务器，并且在每次新部署时，我们可以自动或手动清除旧缓存。</p><p id="ac54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><strong class="it hv">浏览器缓存:</strong>浏览器也以自己的方式缓存资源。当一个站点第一次被加载到用户的浏览器中时，浏览器决定在本地缓存一些资源(主要是图像、js和css等资产),下次用户访问同一个站点时，浏览器从本地缓存中提供资源。由于我们无法控制用户的浏览器，所以在过去清除用户浏览器中的缓存一直有点困难。有了缓存头和像webpack这样的构建工具，每次构建都会生成独特的块，这就变得更容易管理了，但是仍然存在缺陷。</p><p id="40b1" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以下是浏览器缓存的一些问题-</p><ol class=""><li id="c8b3" class="jv jw hu it b iu iv iy iz jc jx jg jy jk jz jo ka kb kc kd dt translated"><strong class="it hv">浏览器</strong>倾向于<strong class="it hv">忽略缓存验证</strong>如果站点在<strong class="it hv">同一个标签</strong>中被刷新——如果用户锁定标签，即使服务器缓存被清除，站点也很有可能从浏览器缓存中被加载。</li><li id="d646" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">如果你的应用程序正在注册一个<strong class="it hv">服务工作者</strong>，那么服务工作者<strong class="it hv">缓存</strong>将<strong class="it hv">失效</strong>，除非用户在<strong class="it hv">新标签</strong>中打开站点。如果该选项卡从未关闭，用户将永远无法使用服务工作人员缓存。</li><li id="e981" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo ka kb kc kd dt translated">如果用户<strong class="it hv">将</strong>站点添加到手机/平板电脑的<strong class="it hv">主屏幕</strong>，那么只有当用户明确<strong class="it hv">退出应用</strong>时，浏览器<strong class="it hv">缓存</strong>才会<strong class="it hv">失效</strong>——这几乎等同于在浏览器中打开相同的标签页。我知道有些人几个月都不会退出他们的主屏幕应用程序。</li></ol><p id="76c3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">理想情况下，缓存有助于更快地加载网站。禁用缓存不是答案。它也不可靠，因为你不能控制用户浏览器的行为。我们希望找到一种方法，在每次新版本的应用部署到服务器时，清除浏览器或服务人员缓存。</p><p id="8523" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">简单而有效的方法</p><ul class=""><li id="412b" class="jv jw hu it b iu iv iy iz jc jx jg jy jk jz jo kj kb kc kd dt translated">永远不要部署</li><li id="25a2" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated">将应用版本捆绑到应用中</li><li id="711f" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated">生成一个包含每次构建的应用版本的<code class="eh jr js jt ju b">meta.json</code>文件</li><li id="a675" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated">加载时获取<code class="eh jr js jt ju b">meta.json</code>并比较版本</li><li id="6a2d" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated">当版本不匹配时，强制清除缓存并硬重新加载</li></ul><h1 id="953c" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">永远不要部署</h1><p id="efa8" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">用<a class="ae jp" href="https://docs.npmjs.com/about-semantic-versioning" rel="noopener ugc nofollow" target="_blank">永远不要用</a>给你所有的部署版本。我个人使用这三个npm命令来自动增加包的版本，并创建一个git commit和一个相应的版本标签。</p><ul class=""><li id="752f" class="jv jw hu it b iu iv iy iz jc jx jg jy jk jz jo kj kb kc kd dt translated"><code class="eh jr js jt ju b">npm version patch</code> - <em class="jq">对于仅修复了错误的版本</em></li><li id="3352" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated"><code class="eh jr js jt ju b">npm version minor</code> - <em class="jq">针对具有新功能且未修复错误的版本</em></li><li id="5c8b" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated"><code class="eh jr js jt ju b">npm version major</code> - <em class="jq">主要版本或突破性功能</em></li></ul><p id="5ffc" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">记得用<code class="eh jr js jt ju b">--tag</code>属性- <code class="eh jr js jt ju b">git push origin master --tags</code>推送提交</p><h1 id="6f6e" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">将应用版本捆绑到应用中</h1><p id="8c93" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">在webpack构建(或相关构建工具)期间解析包版本，并在应用程序中设置一个全局变量，以便您可以在浏览器控制台中方便地检查版本，并使用它与最新版本进行比较。</p><pre class="ln lo lp lq fq lr ju ls lt aw lu dt"><span id="0df1" class="lv kl hu ju b fv lw lx l ly lz">import packageJson from '{root-dir}/package.json';<br/>global.appVersion = packageJson.version;</span></pre><p id="44da" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一旦设置完成，您就可以通过键入<code class="eh jr js jt ju b">appVersion</code>在浏览器控制台中检查应用程序版本。</p><h1 id="dbde" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">生成一个包含每次构建的应用版本的<code class="eh jr js jt ju b">meta.json</code>文件</h1><p id="a29f" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">运行一个脚本，在应用程序的<code class="eh jr js jt ju b">public</code>目录中生成一个<code class="eh jr js jt ju b">meta.json</code>文件。</p><p id="eded" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">添加一个<code class="eh jr js jt ju b">prebuild</code> npm脚本，它将在每个<code class="eh jr js jt ju b">build</code>之前生成<code class="eh jr js jt ju b">meta.json</code>文件。</p><pre class="ln lo lp lq fq lr ju ls lt aw lu dt"><span id="b52d" class="lv kl hu ju b fv lw lx l ly lz">/* package.json */<br/><br/>{<br/>    "scripts": {<br/>        "generate-build-version": "node generate-build-version",<br/>        "prebuild": "npm run generate-build-version",<br/>        // other scripts<br/>     }<br/>}</span><span id="5c6b" class="lv kl hu ju b fv ma lx l ly lz">/* generate-build-version.js */<br/><br/>const fs = require('fs');<br/>const packageJson = require('./package.json');<br/><br/>const appVersion = packageJson.version;<br/><br/>const jsonData = {<br/>  version: appVersion<br/>};<br/><br/>var jsonContent = JSON.stringify(jsonData);<br/><br/>fs.writeFile('./public/meta.json', jsonContent, 'utf8', function(err) {<br/>  if (err) {<br/>    console.log('An error occured while writing JSON Object to meta.json');<br/>    return console.log(err);<br/>  }<br/><br/>  console.log('meta.json file has been saved with latest version number');<br/>});</span></pre><p id="d767" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在每次构建之后，一旦部署了应用程序，就可以使用路径<code class="eh jr js jt ju b">/meta.json</code>访问<code class="eh jr js jt ju b">meta.json</code>，并且可以像REST端点一样获取json。它不会被浏览器缓存，因为浏览器不会缓存XHR请求。因此，即使您的包文件被缓存，您也将总是获得最新的<code class="eh jr js jt ju b">meta.json</code>文件。</p><p id="dbf9" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，如果您的包文件中的<code class="eh jr js jt ju b">appVersion</code>小于<code class="eh jr js jt ju b">meta.json</code>中的<code class="eh jr js jt ju b">version</code>，那么我们知道<strong class="it hv">浏览器缓存是过时的，我们将需要使其无效</strong>。</p><p id="7a13" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以用这个脚本来比较语义版本-</p><pre class="ln lo lp lq fq lr ju ls lt aw lu dt"><span id="4bda" class="lv kl hu ju b fv lw lx l ly lz">// version from `meta.json` - first param<br/>// version in bundle file - second param<br/>const semverGreaterThan = (versionA, versionB) =&gt; {<br/>  const versionsA = versionA.split(/\./g);<br/><br/>  const versionsB = versionB.split(/\./g);<br/>  while (versionsA.length || versionsB.length) {<br/>    const a = Number(versionsA.shift());<br/><br/>    const b = Number(versionsB.shift());<br/>    // eslint-disable-next-line no-continue<br/>    if (a === b) continue;<br/>    // eslint-disable-next-line no-restricted-globals<br/>    return a &gt; b || isNaN(b);<br/>  }<br/>  return false;<br/>};</span></pre><p id="010d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你也可以在我的<a class="ae jp" href="https://github.com/flexdinesh/cache-busting-example/blob/ad03c264e2f52c71609726104e38ea3593520e07/src/CacheBuster.js#L6" rel="noopener ugc nofollow" target="_blank"> GitHub示例</a>中找到这段代码</p><h1 id="cc1a" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">加载时提取<code class="eh jr js jt ju b">meta.json</code>并比较版本</h1><p id="4db7" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">安装<code class="eh jr js jt ju b">App</code>后，读取<code class="eh jr js jt ju b">meta.json</code>并将当前版本与服务器中的最新版本进行比较。</p><p id="1ae0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">当出现<strong class="it hv">版本不匹配时</strong> = &gt;强制<strong class="it hv">清除缓存</strong>并在版本相同时硬重新加载= &gt;渲染应用程序的其余部分</p><p id="6b91" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我已经构建了一个<code class="eh jr js jt ju b">CacheBuster</code>组件，它将强制清除缓存并重新加载站点。该逻辑将适用于大多数网站，但可以根据应用程序的定制情况进行调整。</p><pre class="ln lo lp lq fq lr ju ls lt aw lu dt"><span id="5bd7" class="lv kl hu ju b fv lw lx l ly lz">/* CacheBuster component */<br/>import packageJson from '../package.json';<br/>global.appVersion = packageJson.version;<br/><br/>const semverGreaterThan = (versionA, versionB) =&gt; {<br/>    // code from above snippet goes here<br/>}<br/><br/>export default class CacheBuster extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      loading: true,<br/>      isLatestVersion: false,<br/>      refreshCacheAndReload: () =&gt; {<br/>        console.log('Clearing cache and hard reloading...')<br/>        if (caches) {<br/>          // Service worker cache should be cleared with caches.delete()<br/>          caches.keys().then(function(names) {<br/>            for (let name of names) caches.delete(name);<br/>          });<br/>        }<br/>        // delete browser cache and hard reload<br/>        window.location.reload(true);<br/>      }<br/>    };<br/>  }<br/><br/>  componentDidMount() {<br/>    fetch('/meta.json')<br/>      .then((response) =&gt; response.json())<br/>      .then((meta) =&gt; {<br/>        const latestVersion = meta.version;<br/>        const currentVersion = global.appVersion;<br/><br/>        const shouldForceRefresh = semverGreaterThan(latestVersion, currentVersion);<br/>        if (shouldForceRefresh) {<br/>          console.log(`We have a new version - ${latestVersion}. Should force refresh`);<br/>          this.setState({ loading: false, isLatestVersion: false });<br/>        } else {<br/>          console.log(`You already have the latest version - ${latestVersion}. No cache refresh needed.`);<br/>          this.setState({ loading: false, isLatestVersion: true });<br/>        }<br/>      });<br/>  }<br/><br/>  render() {<br/>    const { loading, isLatestVersion, refreshCacheAndReload } = this.state;<br/>    return this.props.children({ loading, isLatestVersion, refreshCacheAndReload });<br/>  }<br/>}</span></pre><p id="1e23" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们可以使用这个<code class="eh jr js jt ju b">CacheBuster</code>组件来控制<code class="eh jr js jt ju b">App</code>组件中的渲染</p><pre class="ln lo lp lq fq lr ju ls lt aw lu dt"><span id="71da" class="lv kl hu ju b fv lw lx l ly lz">/* App component */<br/>class App extends Component {<br/>  render() {<br/>    return (<br/>      &lt;CacheBuster&gt;<br/>        {({ loading, isLatestVersion, refreshCacheAndReload }) =&gt; {<br/>          if (loading) return null;<br/>          if (!loading &amp;&amp; !isLatestVersion) {<br/>            // You can decide how and when you want to force reload<br/>            refreshCacheAndReload();<br/>          }<br/><br/>          return (<br/>            &lt;div className="App"&gt;<br/>              &lt;header className="App-header"&gt;<br/>                &lt;h1&gt;Cache Busting - Example&lt;/h1&gt;<br/>                &lt;p&gt;<br/>                  Bundle version - &lt;code&gt;v{global.appVersion}&lt;/code&gt;<br/>                &lt;/p&gt;<br/>              &lt;/header&gt;<br/>            &lt;/div&gt;<br/>          );<br/>        }}<br/>      &lt;/CacheBuster&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="89d2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你也可以在这里找到这两个组件的代码</p><p id="825b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">CacheBuster—<a class="ae jp" href="https://github.com/flexdinesh/cache-busting-example/blob/master/src/CacheBuster.js" rel="noopener ugc nofollow" target="_blank">CacheBuster . js</a></p><h1 id="e4dc" class="kk kl hu bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">当版本不匹配时，强制清除缓存并硬重新加载</h1><p id="f472" class="pw-post-body-paragraph ir is hu it b iu li iw ix iy lj ja jb jc lk je jf jg ll ji jj jk lm jm jn jo hn dt translated">每次加载应用程序时，我们都会检查最新版本。根据应用程序版本是否过时，我们可以决定以不同的方式清除缓存。</p><p id="5ddf" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">举个例子，</p><ul class=""><li id="4984" class="jv jw hu it b iu iv iy iz jc jx jg jy jk jz jo kj kb kc kd dt translated">您可以在渲染应用程序之前进行硬重新加载</li><li id="d84f" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated">你可以显示一个模式/弹出窗口，要求用户点击一个按钮并触发一个硬重载</li><li id="0e0b" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated">当应用程序空闲时，你可以硬加载</li><li id="b182" class="jv jw hu it b iu ke iy kf jc kg jg kh jk ki jo kj kb kc kd dt translated">您可以在几秒钟后用<code class="eh jr js jt ju b">setTimeout()</code>硬重新加载</li></ul><p id="2de0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">你可以从这篇文章中找到完整的代码，以及这个报告中的一个工作示例— <a class="ae jp" href="https://github.com/flexdinesh/cache-busting-example" rel="noopener ugc nofollow" target="_blank">缓存破坏示例</a></p><p id="70c7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这是所有的乡亲。如果你对这种方法有任何反馈(好的和坏的)，请在评论中告诉我。</p><p id="efcb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">破坏缓存很有趣。🎉</p></div><div class="ab cl mb mc hc md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hn ho hp hq hr"><p id="dc1f" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><em class="jq">最初发表于</em><a class="ae jp" href="https://dineshpandiyan.com/cache-busting" rel="noopener ugc nofollow" target="_blank"><em class="jq"/></a><em class="jq">。</em></p><figure class="ln lo lp lq fq mi"><div class="bz el l di"><div class="mj mk l"/></div></figure></div></div>    
</body>
</html>