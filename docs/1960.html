<html>
<head>
<title>Building a Pincode Mapper and Routing engine with Postgis and pgrouting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Postgis和pgrouting构建密码映射器和路由引擎</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/building-a-pincode-mapper-and-routing-engine-with-postgis-and-pgrouting-79bba806a842?source=collection_archive---------4-----------------------#2019-03-24">https://medium.com/hackernoon/building-a-pincode-mapper-and-routing-engine-with-postgis-and-pgrouting-79bba806a842?source=collection_archive---------4-----------------------#2019-03-24</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/5c817c51764460b49fa109e3c8620a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zm58M7T7Unl2yqZqqOCbUQ.png"/></div></div></figure><blockquote class="jc jd je"><p id="8158" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">🌎<strong class="ji hv">存储和处理GIS数据:</strong></p></blockquote><p id="2500" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">随着许多组织无时无刻不在处理地理空间数据，存储和处理GIS数据已经变得非常重要。你可能知道postgres提供了一个漂亮的扩展，叫做<a class="ae kh" href="https://postgis.net/" rel="noopener ugc nofollow" target="_blank"> P </a> ostgis，可以很容易地用来存储、查询和处理空间信息。<a class="ae kh" href="https://pgrouting.org/" rel="noopener ugc nofollow" target="_blank"> P </a>灌浆扩展了postgis以提供地理空间路由功能。</p><p id="55eb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">有时我们有相对于时间的位置数据。这种数据被称为时空数据，这种数据对于在空间和时间上追踪某物或某人非常有用。</p><p id="f14c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">Postgis中的轨迹可以用来处理<a class="ae kh" href="https://github.com/anitagraser/postgis-spatiotemporal" rel="noopener ugc nofollow" target="_blank">时空数据</a>，但是如果你的数据很大，那么你可以利用Geomesa或Geospark以及Apache Accumulo和Geoserver来处理你的时空大数据。</p><p id="e8a9" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">QGIS和Timemanager插件是一种非常酷的可视化时空数据的开源方式。(<a class="ae kh" href="https://github.com/anitagraser" rel="noopener ugc nofollow" target="_blank">https://github.com/anitagraser</a>)。你也可以去看看Topi Tjukanov，他已经用qgis和timemanager做了一些很酷的东西。他的文章和动画帮了大忙🙏🏼🙏🏼</p><p id="54db" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">特别为mah boy Kepler . GL(<a class="ae kh" href="https://github.com/uber/kepler.gl" rel="noopener ugc nofollow" target="_blank">https://github.com/uber/kepler.gl</a>)大声喊出来</p><blockquote class="jc jd je"><p id="2f7a" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">🌎<strong class="ji hv">印度的密码映射</strong></p></blockquote><p id="d909" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">印度有邮局，每个邮局都有自己的服务区。每个邮局所覆盖的服务区域都有自己唯一的密码，因此邮局知道自己的范围。因此，从历史上看，我们划分了我们的城市，并战略性地设置了可以为整个城市服务的邮局。这些数据很有价值。如果我们能从给定的纬度和经度推断出密码，那就太棒了。</p><p id="8508" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">数据集:</p><ol class=""><li id="7667" class="kk kl hu ji b jj jk jn jo ke km kf kn kg ko kd kp kq kr ks dt translated">城市的密码边界数据(<a class="ae kh" href="https://github.com/datameet/PincodeBoundary" rel="noopener ugc nofollow" target="_blank">https://github.com/datameet/PincodeBoundary</a>)</li><li id="b064" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd kp kq kr ks dt translated">密码映射到LatLongs(<a class="ae kh" href="https://github.com/sanand0/pincode/blob/master/data/IN.csv" rel="noopener ugc nofollow" target="_blank">https://github.com/sanand0/pincode/blob/master/data/IN.csv</a>)</li></ol><p id="5fb0" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">算法</p><ol class=""><li id="8134" class="kk kl hu ji b jj jk jn jo ke km kf kn kg ko kd kp kq kr ks dt translated">使用Pincode Boundaries数据集，我们可以使用边界框将latlong隔离到特定的城市，并检查哪个Pincode面包含给定的latlong(非常简单),但是这种方法对于位于面的边上的latlong来说是不明确的(文字边情况……smh)</li><li id="289a" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd kp kq kr ks dt translated">使用Pincode latlong数据集，我们可以编写一个空间KDtree算法来检查数据库中与给定latlong最接近的latlong，并将其映射到相应的Pincode。这种方法并不精确，因为在某些情况下，一个latlong比它的实际密码更接近另一个密码</li></ol><p id="cfc4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">一个简单的函数将两种算法合二为一</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="e7d6" class="lh li hu ld b fv lj lk l ll lm"><strong class="ld hv">import</strong> <strong class="ld hv">geopandas</strong> <strong class="ld hv">as</strong> <strong class="ld hv">gpd</strong><br/><strong class="ld hv">from</strong> <strong class="ld hv">shapely.geometry</strong> <strong class="ld hv">import</strong> Point, Polygon<br/><strong class="ld hv">import</strong> <strong class="ld hv">pandas</strong> <strong class="ld hv">as</strong> <strong class="ld hv">pd</strong><br/><strong class="ld hv">import</strong> <strong class="ld hv">numpy</strong> <strong class="ld hv">as</strong> <strong class="ld hv">np</strong><br/><strong class="ld hv">from</strong> <strong class="ld hv">scipy</strong> <strong class="ld hv">import</strong> spatial<br/><strong class="ld hv">import</strong> <strong class="ld hv">pandas</strong> <strong class="ld hv">as</strong> <strong class="ld hv">pd</strong></span><span id="be6f" class="lh li hu ld b fv ln lk l ll lm">df = pd.read_csv('allindpincode.csv')<br/>latlongs = df.iloc[:,2:]<br/>d =  np.array(latlongs)<br/>tree = spatial.KDTree(d)</span><span id="8b8c" class="lh li hu ld b fv ln lk l ll lm">data = gpd.read_file('allcitiescombined.geojson')</span><span id="c582" class="lh li hu ld b fv ln lk l ll lm">def getpincode(lat , long):<br/>    lat = float(lat)<br/>    long = float(long)<br/>    p = Point(long,lat)<br/>    for i in range(0,len(data)):<br/>        if p.within(data['geometry'][i]) is True:<br/>            pin = int(data['pin_code'][i])<br/>        else:<br/>            pin = 0<br/>    if pin !=0:<br/>        return pin<br/>    else:<br/>        latlongs = np.array([lat,long])<br/>        result = tree.query(latlongs)<br/>        pin = int(data1.iloc[[result[1]]]['postalcode'])       <br/>    return pin</span></pre><p id="49e3" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我已经编写了一个简单的python包，其中包含了这些想法，可以从给定的latlong(针对印度城市)外推pincode</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="4f43" class="lh li hu ld b fv lj lk l ll lm">pip install git+https://github.com/Sangarshanan/Pincode-Mapping.git</span></pre><div class="lo lp fm fo lq lr"><a href="https://github.com/Sangarshanan/pincode-mapping" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hv fv z el lw eo ep lx er et ht dt translated">sangarshanan/pincode-映射</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">用于从Lat Longs-Sangarshanan/Pincode-mapping外推Pincode的软件包</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf ja lr"/></div></div></a></div><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="9af5" class="lh li hu ld b fv lj lk l ll lm">from geopincoder import pincode_mapper as pm</span><span id="a5b6" class="lh li hu ld b fv ln lk l ll lm">pincode = pm.geocode.to_pincode(28.7041, 77.1025)</span><span id="b548" class="lh li hu ld b fv ln lk l ll lm">print(pincode)</span></pre><blockquote class="jc jd je"><p id="3712" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated">🌎<strong class="ji hv">用Postgis和Pgrouting构建路由引擎</strong></p></blockquote><p id="0d05" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">构建路由引擎相当容易，尤其是OSM是一个非常有用的公开可用的道路网络数据源。</p><p id="75ac" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">提取。OSM文件的任何地区，你想建立一个路由引擎使用osm提取器和选择边界框</p><p id="9ed6" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">https://www.openstreetmap.org/export<a class="ae kh" href="https://www.openstreetmap.org/export#map=5/21.841/90.483" rel="noopener ugc nofollow" target="_blank"/></p><p id="a04e" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">现在转到Postgres并创建一个新的数据库或使用现有的</p><p id="0daf" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">为postgis和pgrouting创建扩展(<a class="ae kh" href="https://docs.pgrouting.org/2.2/en/doc/src/installation/installation.html" rel="noopener ugc nofollow" target="_blank">首先安装pgrouting f </a></p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="0362" class="lh li hu ld b fv lj lk l ll lm">CREATE EXTENSION postgis;<br/>CREATE EXTENSION pgrouting;</span></pre><p id="0b1a" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我们使用osm 2 placement将OpenStreetMap数据轻松导入到pgrouting数据库(<a class="ae kh" href="https://github.com/pgRouting/osm2pgrouting" rel="noopener ugc nofollow" target="_blank">https://github.com/pgRouting/osm2pgrouting</a>)</p><p id="641c" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">按照github页面的说明，使用boost、libpqxx、expat和cmake编译工具(osm 2 placement)</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="c2ce" class="lh li hu ld b fv lj lk l ll lm">osm2pgrouting — f Bangalore.osm — conf osm2pgrouting/mapconfig_for_cars.xml — dbname pgroute — username postgres — clean</span></pre><p id="64bb" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">上面给出的命令获取了我为Bangalore提取的OSM文件，并配置了允许汽车通行的道路网络。现在，道路网络作为节点和边保存在pgroute数据库中。</p><p id="44e2" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我们还可以在不使用— clean的情况下执行数据的增量添加</p><p id="ebc4" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">现在，使用具有道路网络数据的数据库，推断两个纬度之间的道路路径变得非常容易</p><ol class=""><li id="d4e5" class="kk kl hu ji b jj jk jn jo ke km kf kn kg ko kd kp kq kr ks dt translated">使用osm 2 placement生成的表连接到数据库</li><li id="389f" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd kp kq kr ks dt translated">取两个纬度(源和目的地)并找到离这两个纬度最近的节点</li><li id="47d9" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd kp kq kr ks dt translated">现在我们知道了节点，我们必须找到这些节点之间的路径。(将道路网络想象成一个简单的图形，我们的问题是找到图形中两个节点之间的最短路径)</li><li id="c551" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd kp kq kr ks dt translated">我们可以利用任何路径查找算法(Dijkstra算法)来计算路径在给定节点之间包含的边</li></ol><figure class="ky kz la lb fq iv"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="5a88" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">上面附上的要点给了我们可以外推两个纬度之间的距离的函数，并给你以公里为单位的答案(对不起，美国)</p><p id="b002" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">你也可以看看我和我的伙伴们开发的flask应用程序，用来做密码映射和路由</p><div class="lo lp fm fo lq lr"><a href="https://github.com/Sangarshanan/godseye" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab ej"><div class="lt ab lu cl cj lv"><h2 class="bd hv fv z el lw eo ep lx er et ht dt translated">Sangarshanan/godseye</h2><div class="ly l"><h3 class="bd b fv z el lw eo ep lx er et ek translated">地球_美洲:使用经度绘制密码，并推断经度之间的道路路径…</h3></div><div class="lz l"><p class="bd b gc z el lw eo ep lx er et ek translated">github.com</p></div></div><div class="ma l"><div class="mi l mc md me ma mf ja lr"/></div></div></a></div><p id="c42d" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">虽然使用谷歌地图或其他API来解决这个问题要容易得多，但是构建自己的路由引擎还是很有趣的</p><p id="9195" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">我最近也有机会使用graph hopper(<a class="ae kh" href="https://github.com/graphhopper/graphhopper" rel="noopener ugc nofollow" target="_blank">https://github.com/graphhopper/graphhopper</a>)，这是一个比谷歌地图更酷的开源API</p><p id="170f" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">使用Graphhopper设置路由引擎非常简单。只需克隆repo，将osm文件复制到那里并运行shell脚本</p><pre class="ky kz la lb fq lc ld le lf aw lg dt"><span id="5589" class="lh li hu ld b fv lj lk l ll lm">git clone git://github.com/graphhopper/graphhopper.git<br/>cd graphhopper; git checkout master<br/>./graphhopper.sh -a web -i bangalore.som</span></pre><p id="2d94" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">运行这些之后，你会看到“在HTTP 8989启动服务器”，现在转到http://localhost:8989/你应该会看到班加罗尔的地图。你应该可以点击地图上的两个点，然后一条路线出现了。</p><p id="3c69" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">以下附带的python脚本可帮助您将道路网络保存为gpx图，并使用ipyleaflet在Jupyter笔记本中绘制相同的图</p><figure class="ky kz la lb fq iv"><div class="bz el l di"><div class="mg mh l"/></div></figure><p id="4f7b" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">希望这有所帮助</p><blockquote class="jc jd je"><p id="bdcb" class="jf jg jh ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hn dt translated"><strong class="ji hv">看看我从</strong>复制粘贴的一些有用的链接</p></blockquote><ul class=""><li id="94d2" class="kk kl hu ji b jj jk jn jo ke km kf kn kg ko kd mj kq kr ks dt translated"><a class="ae kh" rel="noopener" href="/@tjukanov/animated-routes-with-qgis-9377c1f16021">https://medium . com/@ tjukanov/animated-routes-with-qgis-9377 c1f 16021</a></li><li id="8dfd" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd mj kq kr ks dt translated"><a class="ae kh" href="https://eng.uber.com/engineering-an-efficient-route/" rel="noopener ugc nofollow" target="_blank">https://eng.uber.com/engineering-an-efficient-route/</a></li><li id="23ea" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd mj kq kr ks dt translated"><a class="ae kh" href="http://kazuar.github.io/visualize-trip-with-flask-and-mapbox/" rel="noopener ugc nofollow" target="_blank">http://kazuar . github . io/visualize-trip-with-flask-and-map box/</a></li><li id="60ed" class="kk kl hu ji b jj kt jn ku ke kv kf kw kg kx kd mj kq kr ks dt translated"><a class="ae kh" href="http://map.project-osrm.org/" rel="noopener ugc nofollow" target="_blank">http://map.project-osrm.org/</a></li></ul><p id="1636" class="pw-post-body-paragraph jf jg hu ji b jj jk jl jm jn jo jp jq ke js jt ju kf jw jx jy kg ka kb kc kd hn dt translated">和平✌️</p></div></div>    
</body>
</html>