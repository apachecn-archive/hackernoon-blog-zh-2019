<html>
<head>
<title>Hands-on Projects to Learn the Basics of React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动手项目，学习 React 的基础知识</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/hands-on-projects-to-learn-the-basics-of-react-3a06726514a8#2019-01-31">https://medium.com/hackernoon/hands-on-projects-to-learn-the-basics-of-react-3a06726514a8#2019-01-31</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/576757a866047cf9e870cb91a5a7219d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLBTwlihNj6U1eyEL46C5g.png"/></div></div></figure><p id="2c8c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt ka translated"><span class="l kb kc kd bm ke kf kg kh ki di"> H </span>你看过 React 官方的井字游戏教程了吗？如果你有，你可能会注意到简介中的这个<strong class="je hv">加粗的</strong>文本</p><blockquote class="kj kk kl"><p id="1d09" class="jc jd km je b jf jg jh ji jj jk jl jm kn jo jp jq ko js jt ju kp jw jx jy jz hn dt translated">你可能想跳过它，因为你不是在开发游戏——但是给它一个机会。</p></blockquote><p id="8495" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我猜即使 React 团队也知道构建井字游戏没什么意思，因为他们加入了这条线。虽然这个项目确实让你理解了 React，但是你需要很强的毅力来完成这个教程。</p><p id="f203" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在不要误会我，我很感激这个引进项目，但我只是不喜欢它。如果你在想同样的事情，我将在本教程中写一些你可以用来学习 React 的替代项目。</p><p id="7a39" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">那么有哪些前端项目可以拿起来学习 React 呢？当我浏览教程和博客帖子时，我注意到一个好的 React 入门教程必须做到以下几点:</p><ul class=""><li id="e38f" class="kq kr hu je b jf jg jj jk jn ks jr kt jv ku jz kv kw kx ky dt translated">教授 React 的基础知识，如组件、状态和道具</li><li id="18d9" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated">处理动态数据、状态和道具的变化</li><li id="786b" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated">显示了生命周期方法的使用</li></ul><p id="0603" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上，几乎所有内容都来自于<em class="km">主要概念</em>选项卡。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff le"><img src="../Images/56223dfec956013272677bd7bb3ad37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1Qde7LcWMMkT9XdFP7s_Q.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Core React knowledge right in this tab!</figcaption></figure><p id="8dc8" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在本教程结束时，您将更好地理解 React 概念的用法，如组件、状态和生命周期方法，以及它们如何在常见的 web 应用程序 UI 中使用。</p><h2 id="487e" class="ln lo hu bd lp lq lr ls lt lu lv lw lx jn ly lz ma jr mb mc md jv me mf mg mh dt translated">目录</h2><ul class=""><li id="2f88" class="kq kr hu je b jf mi jj mj jn mk jr ml jv mm jz kv kw kx ky dt translated"><a class="ae mn" href="https://hackernoon.com/hands-on-projects-to-learn-the-basics-of-react-3a06726514a8#1ff5" rel="noopener ugc nofollow" target="_blank">前端乐趣与卡片列表</a></li><li id="c30c" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><a class="ae mn" href="https://hackernoon.com/hands-on-projects-to-learn-the-basics-of-react-3a06726514a8#1566" rel="noopener ugc nofollow" target="_blank">使用向导表单变得复杂</a></li><li id="f5ea" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><a class="ae mn" href="https://hackernoon.com/hands-on-projects-to-learn-the-basics-of-react-3a06726514a8#4e78" rel="noopener ugc nofollow" target="_blank"> GitHub 搜索 App </a></li><li id="9702" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><a class="ae mn" href="https://hackernoon.com/hands-on-projects-to-learn-the-basics-of-react-3a06726514a8#7342" rel="noopener ugc nofollow" target="_blank">结论</a></li></ul><p id="4157" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意:对于本教程的 CSS 部分，我们将使用 Bootstrap 来使它看起来更好，而不用编写我们自己的 CSS。您可以放心地忽略示例代码的 <code class="eh mo mp mq mr b"><em class="km">className</em></code> <em class="km">部分，因为它们来自 Bootstrap </em></p><h1 id="1ff5" class="ms lo hu bd lp mt mu mv lt mw mx my lx mz na nb ma nc nd ne md nf ng nh mg ni dt translated">卡片列表的前端乐趣</h1><p id="c1a0" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn nj jp jq jr nk jt ju jv nl jx jy jz hn dt translated">让我们从利用 JSX、组件和道具开始——React UI 的基本成分。这是我们的最终产品:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="nm nn l"/></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">A list of cards with React</figcaption></figure><p id="677d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所以让我们来建造它。我们所要做的就是创建返回 JSX 元素的<code class="eh mo mp mq mr b">&lt;Card/&gt;</code>组件:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="7df6" class="ln lo hu mr b fv ns nt l nu nv">function Card(props) {<br/>    return (<br/>      &lt;div className="card"&gt;<br/>        &lt;img className="card-img-top"<br/>             src="<a class="ae mn" href="https://via.placeholder.com/600x250.png" rel="noopener ugc nofollow" target="_blank">https://via.placeholder.com/600x250.png</a>" <br/>             alt="cap image" /&gt;<br/>        &lt;div className="card-body"&gt;<br/>          &lt;h5 className="card-title"&gt;Title Placeholder&lt;/h5&gt;<br/>          &lt;p className="card-text"&gt;Description Placeholder&lt;/p&gt;<br/>          &lt;a href="#" className="btn btn-primary"&gt;Learn more&lt;/a&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="a085" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后创建一个父组件，呈现三次<code class="eh mo mp mq mr b">&lt;Card/&gt;</code>。我们可以把它命名为<code class="eh mo mp mq mr b">&lt;CardList/&gt;</code></p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="8e1b" class="ln lo hu mr b fv ns nt l nu nv">function CardList() {<br/>  return (<br/>    &lt;div className="row"&gt;<br/>      &lt;div className="col-sm-4"&gt;<br/>        &lt;Card /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="col-sm-4"&gt;<br/>        &lt;Card /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="col-sm-4"&gt;<br/>        &lt;Card /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b5e6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要忘记在代码的底部添加<code class="eh mo mp mq mr b">ReactDOM.render</code>调用。这是负责将 React 应用程序引入 HTML 元素的代码。</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="9ec9" class="ln lo hu mr b fv ns nt l nu nv">ReactDOM.render(&lt;CardList /&gt;, document.getElementById('root'));</span></pre><p id="ba9c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们需要将我们自己的数据包含到这些卡片中，所以向其中传递一些<code class="eh mo mp mq mr b">props</code>。</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="950e" class="ln lo hu mr b fv ns nt l nu nv">function CardList() {<br/>  return (<br/>    &lt;div className="row"&gt;<br/>      &lt;div className="col-sm-4"&gt;<br/>        &lt;Card     <strong class="mr hv">featureImage="</strong><a class="ae mn" href="https://sebhastian.com/static/eb0e936c0ef42ded5c6b8140ece37d3e/fcc29/feature-image.png" rel="noopener ugc nofollow" target="_blank"><strong class="mr hv">https://sebhastian.com/static/eb0e936c0ef42ded5c6b8140ece37d3e/fcc29/feature-image.png</strong></a><strong class="mr hv">"<br/>          title="How To Make Interactive ReactJS Form"<br/>          description="Let's write some interactive form with React"<br/>          link="</strong><a class="ae mn" href="https://sebhastian.com/interactive-react-form" rel="noopener ugc nofollow" target="_blank"><strong class="mr hv">https://sebhastian.com/interactive-react-form</strong></a><strong class="mr hv">"<br/></strong>        /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="col-sm-4"&gt;<br/>        &lt;Card<br/>          // your data<br/>        /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div className="col-sm-4"&gt;<br/>        &lt;Card<br/>          // your data<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="8484" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后在我们的<code class="eh mo mp mq mr b">&lt;Card/&gt;</code>组件中使用这些道具:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="ebb7" class="ln lo hu mr b fv ns nt l nu nv">function Card(props) {<br/>  return (<br/>    &lt;div className="card"&gt;<br/>      &lt;img className="card-img-top" src=<strong class="mr hv">{props.featureImage}</strong> alt="cap image" /&gt;<br/>      &lt;div className="card-body"&gt;<br/>        &lt;h5 className="card-title"&gt;<strong class="mr hv">{props.title}</strong>&lt;/h5&gt;<br/>        &lt;p className="card-text"&gt;<strong class="mr hv">{props.description}</strong>&lt;/p&gt;<br/>        &lt;a href=<strong class="mr hv">{props.link}</strong> className="btn btn-primary"&gt;Learn more&lt;/a&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="5b3f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在这个<code class="eh mo mp mq mr b">&lt;Card/&gt;</code>组件在它的 JSX 中使用了 JavaScript，非常类似于模板引擎，不是吗？</p><p id="9737" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">你可能想知道，“为什么我们使用<code class="eh mo mp mq mr b">function</code>而不是<code class="eh mo mp mq mr b">class</code>来声明组件？”</p><p id="2832" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为我们没有保留<code class="eh mo mp mq mr b">state</code>或者使用生命周期方法。React 组件被声明为<code class="eh mo mp mq mr b">class</code>以便使用这两个东西(虽然现在我们也可以用 React 钩子来做，但是我们现在不考虑钩子。)</p><p id="5168" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">正如我们在例子中看到的，React 的 UI 由三个基本成分组成:组件、JSX 和道具。</p><ul class=""><li id="b005" class="kq kr hu je b jf jg jj jk jn ks jr kt jv ku jz kv kw kx ky dt translated"><strong class="je hv">组件</strong>是由方法和 JSX 组成的一个 UI。</li><li id="1a38" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><strong class="je hv"> JSX </strong>是用 JS 增压的 HTML，使我们能够用 JavaScript 语法描述 UI。</li><li id="6339" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><strong class="je hv"> Props </strong>是我们传递给组件的任意输入。</li></ul><p id="a711" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">除了基本的 UI 模式之外，我们从这个简单的静态卡中真的学不到更多的东西，所以让我们继续一个更复杂的任务。</p><h1 id="1566" class="ms lo hu bd lp mt mu mv lt mw mx my lx mz na nb ma nc nd ne md nf ng nh mg ni dt translated">向导表单变得复杂</h1><p id="7d48" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn nj jp jq jr nk jt ju jv nl jx jy jz hn dt translated">在第二个练习中，我们将构建一个向导表单，这是一个多步骤表单，旨在简化长而复杂的表单的填写过程。通过在屏幕上只显示几个输入，用户会感到被鼓励去填充空白输入，而不是感到不知所措并可能放弃表单。</p><p id="9e01" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们看看如何使用 React 构建这样的表单:</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="nm nn l"/></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">React wizard form</figcaption></figure><p id="c134" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">创建多步骤表单最简单的方法是创建一个容器表单组件，其中包含所有向导步骤组件。这个图表会帮助你清楚地理解它。</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/40abe50b2627d1ef9f6c33e329ab1b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JMYuPH3dZS3HRGVwJ0UgXQ.png"/></div></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">React wizard form diagram</figcaption></figure><p id="4238" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">虽然它看起来比常规表单更复杂，但向导表单仍然使用相同的反应原理。但是因为我们在这个练习中有<code class="eh mo mp mq mr b">state</code>，我们需要包括一个新的原则:</p><ul class=""><li id="537c" class="kq kr hu je b jf jg jj jk jn ks jr kt jv ku jz kv kw kx ky dt translated"><strong class="je hv">状态</strong>用于存储动态数据</li></ul><p id="afa1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将拥有一个父组件和三个子组件，而不是一个表单组件。在上图中，<code class="eh mo mp mq mr b">&lt;MasterForm/&gt;</code>组件将通过 props 向子组件发送数据和函数，子组件将触发<code class="eh mo mp mq mr b">handleChange()</code>函数在<code class="eh mo mp mq mr b">&lt;MasterForm/&gt;</code>的<em class="km">状态</em>下设置值。我们还需要一个函数将表单从一个步骤移动到另一个步骤。</p><p id="df1c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">就像<code class="eh mo mp mq mr b">CardList</code>如何给<code class="eh mo mp mq mr b">Card</code>发道具一样，这些子组件会从<code class="eh mo mp mq mr b">&lt;MasterForm/&gt;</code>那里收到道具用于<code class="eh mo mp mq mr b">value</code>和<code class="eh mo mp mq mr b">onChange</code>道具。</p><ul class=""><li id="e9a0" class="kq kr hu je b jf jg jj jk jn ks jr kt jv ku jz kv kw kx ky dt translated"><code class="eh mo mp mq mr b">&lt;Step1/&gt;</code>组件将呈现输入的电子邮件地址</li><li id="1868" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><code class="eh mo mp mq mr b">&lt;Step2/&gt;</code>将用户名输入渲染</li><li id="3de6" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><code class="eh mo mp mq mr b">&lt;Step3/&gt;</code>将呈现密码输入和提交按钮</li></ul><p id="999d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">父组件<code class="eh mo mp mq mr b">&lt;MasterForm/&gt;</code>将向子组件提供数据和功能，子组件将使用其<code class="eh mo mp mq mr b">props</code>将用户输入传递回父组件。</p><p id="ce94" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，我们将创建表单子组件。本例中每个表单步骤只包含一个输入。注释将显示<code class="eh mo mp mq mr b">props</code>的用法。</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="8dfb" class="ln lo hu mr b fv ns nt l nu nv">function Step1(props) {<br/>  if (props.currentStep !== 1) {<br/>    return null<br/>  } <br/>  return(<br/>    &lt;div className="form-group"&gt;<br/>      &lt;label htmlFor="email"&gt;Email address&lt;/label&gt;<br/>      &lt;input<br/>        className="form-control"<br/>        id="email"<br/>        name="email"<br/>        type="text"<br/>        placeholder="Enter email"<br/>        <strong class="mr hv">value={props.email} // props from parent<br/>        onChange={props.handleChange} // props from parent</strong><br/>        /&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="4dc0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为子组件看起来几乎彼此相似，所以我只展示了上面的其中一个。您可以查看完整代码的演示。注意我们如何使用<code class="eh mo mp mq mr b">function</code>而不是<code class="eh mo mp mq mr b">class</code>，因为我们不使用<code class="eh mo mp mq mr b">state</code>或生命周期方法。</p><p id="9774" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们可以把这个子组件放到主窗体<code class="eh mo mp mq mr b">render()</code>函数中，传入必要的道具。为了处理用户在文本中输入内容的事件，我们使用了<code class="eh mo mp mq mr b">onChange</code>合成事件，它是 React 核心库的一部分，用于处理事件。更多详情<a class="ae mn" href="https://reactjs.org/docs/events.html#form-events" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="a6b5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们制作<code class="eh mo mp mq mr b">&lt;MasterForm/&gt;</code>组件并初始化它的状态和方法。<code class="eh mo mp mq mr b">currentStep</code>状态将被初始化为值 1。这是一个步骤指示器，这样我们的表单就知道我们现在在哪一步。我们将使用 ES6 类，因为该组件需要本地状态:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="0b81" class="ln lo hu mr b fv ns nt l nu nv">class MasterForm extends React.Component {<br/>  <strong class="mr hv">constructor(props) {<br/>    super(props)<br/>    this.state = {<br/>      currentStep: 1,<br/>      email:  '',<br/>      username: '',<br/>      password: '', <br/>    }<br/>  }</strong></span><span id="3d7f" class="ln lo hu mr b fv nw nt l nu nv">// creating functions with ES6 arrow function syntax</span><span id="cbd5" class="ln lo hu mr b fv nw nt l nu nv">handleChange = event =&gt; {<br/>    const {name, value} = event.target<br/>    this.setState({<br/>      [name]: value<br/>    })    <br/>  }<br/>   <br/>  handleSubmit = event =&gt; {<br/>    event.preventDefault()<br/>    const { email, username, password } = this.state<br/>    alert(`Your registration detail: \n <br/>           Email: ${email} \n <br/>           Username: ${username} \n<br/>           Password: ${password}`)<br/>  }<br/>  <br/>  // render method here...<br/>}</span></pre><p id="7873" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">接下来，我们在<code class="eh mo mp mq mr b">&lt;MasterForm/&gt;</code>的渲染方法中添加步骤。它将发送<code class="eh mo mp mq mr b">handleChange()</code>函数和所需的<code class="eh mo mp mq mr b">state</code>值作为道具，注意突出显示的代码块:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="43ce" class="ln lo hu mr b fv ns nt l nu nv">render() {    <br/>  return (<br/>    <strong class="mr hv">&lt;React.Fragment&gt;</strong><br/>    &lt;h1&gt;A Wizard Form!&lt;/h1&gt;<br/>    &lt;p&gt;Step {this.state.currentStep} &lt;/p&gt; <br/>      <br/>    &lt;form onSubmit={this.handleSubmit}&gt;<br/>    {/* <br/>      render the form steps and pass required props in<br/>    */}</span><span id="f72a" class="ln lo hu mr b fv nw nt l nu nv"><strong class="mr hv">&lt;Step1 <br/>        currentStep={this.state.currentStep} <br/>        handleChange={this.handleChange}<br/>        email={this.state.email}<br/>      /&gt;<br/>      &lt;Step2 <br/>        currentStep={this.state.currentStep} <br/>        handleChange={this.handleChange}<br/>        username={this.state.username}<br/>      /&gt;<br/>      &lt;Step3 <br/>        currentStep={this.state.currentStep} <br/>        handleChange={this.handleChange}<br/>        password={this.state.password}<br/>      /&gt;<br/></strong>    &lt;/form&gt;<br/>    <strong class="mr hv">&lt;/React.Fragment&gt;</strong><br/>  )<br/>}</span></pre><p id="3ff0" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">因为<code class="eh mo mp mq mr b">render()</code>必须返回单个元素，所以<code class="eh mo mp mq mr b">&lt;React.Fragment&gt;</code>组件允许您在 render()方法中返回多个元素，而无需创建额外的 DOM 元素。更多详情<a class="ae mn" href="https://reactjs.org/docs/react-api.html#reactfragment" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="5930" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后我们添加下一步或上一步函数，它将检查当前步骤是否有上一步或下一步。如果是，它将向上或向下推动<code class="eh mo mp mq mr b">currentStep</code>:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="ad06" class="ln lo hu mr b fv ns nt l nu nv">class MasterForm extends React.Component {<br/>  /*<br/>  * Test current step with ternary<br/>  * _next and _previous functions will be called on button click<br/>  */</span><span id="9d8b" class="ln lo hu mr b fv nw nt l nu nv">_next = () =&gt; {<br/>    let currentStep = this.state.currentStep<br/>    currentStep = currentStep &gt;= 2? 3: currentStep + 1<br/>    this.setState({<br/>      currentStep: currentStep<br/>    })<br/>  }<br/>    <br/>  _prev = () =&gt; {<br/>    let currentStep = this.state.currentStep<br/>    currentStep = currentStep &lt;= 1? 1: currentStep - 1<br/>    this.setState({<br/>      currentStep: currentStep<br/>    })<br/>  }</span><span id="9a06" class="ln lo hu mr b fv nw nt l nu nv">// ... the rest of the code</span></pre><p id="577b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将创建检查当前步骤是 1 还是 3 的函数。这是因为我们有 3 步向导表单。有多的可以换。如果当前步骤没有下一步或上一步，按钮将会消失。这些按钮将调用我们的<code class="eh mo mp mq mr b">_next</code>和<code class="eh mo mp mq mr b">_previous</code>方法。</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="d246" class="ln lo hu mr b fv ns nt l nu nv">/*<br/>* the functions for our button<br/>*/<br/>previousButton(){<br/>  let currentStep = this.state.currentStep;<br/>  if(currentStep !==1){<br/>    return (<br/>      &lt;button <br/>        className="btn btn-secondary" <br/>        type="button" onClick=<strong class="mr hv">{this._prev}</strong>&gt;<br/>      Previous<br/>      &lt;/button&gt;<br/>    )<br/>  }<br/>  return null;<br/>}</span><span id="a398" class="ln lo hu mr b fv nw nt l nu nv">nextButton(){<br/>  let currentStep = this.state.currentStep;<br/>  if(currentStep &lt;3){<br/>    return (<br/>      &lt;button <br/>        className="btn btn-primary float-right" <br/>        type="button" onClick=<strong class="mr hv">{this._next}</strong>&gt;<br/>      Next<br/>      &lt;/button&gt;        <br/>    )<br/>  }<br/>  return null;<br/>}</span></pre><p id="5f3d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">剩下的就是呈现下一个和上一个按钮</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="b5a8" class="ln lo hu mr b fv ns nt l nu nv">/*<br/>* add buttons to our form in render<br/>*/<br/>render(){<br/>  return(<br/>    &lt;form onSubmit={this.handleSubmit}&gt;<br/>      {/* <br/>        ... other codes<br/>      */}<br/>      <br/>      <strong class="mr hv">{this.previousButton()}<br/>      {this.nextButton()}</strong><br/>    &lt;/form&gt;<br/>  )<br/>}</span></pre><p id="274b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想知道为什么我们在上面的按钮调用中使用了<code class="eh mo mp mq mr b">()</code>，那是因为我们需要实际执行按钮功能。<code class="eh mo mp mq mr b">_next</code>和<code class="eh mo mp mq mr b">_previous</code>功能仅在点击按钮时执行，因此在通话时不能有<code class="eh mo mp mq mr b">()</code>。</p><p id="3a0b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">唷！这里有很多组件和状态之间的交互，但是我希望现在你已经理解了在 React 应用程序中使用<code class="eh mo mp mq mr b">state</code>。综上所述，<code class="eh mo mp mq mr b">state</code>只是我们在一个组件中定义的任意数据，它永远成为那个组件的一部分。我们可以把它传递给另一个组件，我们可以更新它，我们可以根据组件当前的状态做一些有条件的事情。</p><p id="8796" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这个示例表单中，我们使用了 state 来跟踪用户的输入和向导表单的当前步骤。因为 React 是从父组件到子组件的单向数据流，所以要记住只有<code class="eh mo mp mq mr b">state</code>的所有者才能改变或更新它。</p><p id="5d46" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了使用<code class="eh mo mp mq mr b">state</code>,我们可以使用 ES6 类或者 React 钩子(将在另一个教程中解释)。)</p><p id="1bda" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">还想再做一次练习吗？那就开始吧！</p><p id="96d1" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km">附言:如果你正在开发 react 表单，你可能想看看这个由</em> <a class="ae mn" href="https://goshakkk.name/wizard-form-collect-info/" rel="noopener ugc nofollow" target="_blank"> <em class="km"> Arinich </em> </a>编写的深入教程</p><h1 id="4e78" class="ms lo hu bd lp mt mu mv lt mw mx my lx mz na nb ma nc nd ne md nf ng nh mg ni dt translated">GitHub 搜索应用</h1><p id="c982" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn nj jp jq jr nk jt ju jv nl jx jy jz hn dt translated">现在，对于我们的第三个练习，让我们实际使用一些 ES6 特性从 GitHub API 获取数据并显示其结果。这个练习将包括我们从以前的项目和新项目中学到的所有东西:<em class="km">生命周期方法</em>和<em class="km">渲染列表</em>。</p><figure class="lf lg lh li fq iv"><div class="bz el l di"><div class="nm nn l"/></div><figcaption class="lj lk fg fe ff ll lm bd b be z ek">Simple GitHub search app</figcaption></figure><p id="30cc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km">注意:有额外的 css，我为这个应用程序写的。如果你没有分叉笔</em>，确保访问上面代码笔的 CSS 标签并粘贴它</p><p id="dbce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">首先，让我们探索一下我们将要<a class="ae mn" href="https://developer.github.com/v3/search/#search-users" rel="noopener ugc nofollow" target="_blank">使用</a>的 Github API。因为我们只按用户名搜索，所以我们需要这个 API url:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="941a" class="ln lo hu mr b fv ns nt l nu nv"><a class="ae mn" href="https://api.github.com/search/users?q={--search-string--}" rel="noopener ugc nofollow" target="_blank">https://api.github.com/search/users?q={--search-string--}</a></span></pre><p id="0849" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们先通过编写大的 header 组件来准备构建应用程序。它实际上只是静态自举大屏幕:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="d6c6" class="ln lo hu mr b fv ns nt l nu nv">const Header = () =&gt; {<br/>  return (<br/>    &lt;div className="jumbotron"&gt;<br/>      &lt;h1&gt;Github Search App&lt;/h1&gt;<br/>      &lt;h2&gt;Search users in GitHub using this simple React application.&lt;/h2&gt;<br/>      &lt;p&gt;Click on the card to see more detail about individual user. The search default is nsebhastian (me!)&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="d483" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在让我们考虑制作输入表单。我们需要:</p><ol class=""><li id="7164" class="kq kr hu je b jf jg jj jk jn ks jr kt jv ku jz nx kw kx ky dt translated">搜索表单</li><li id="22f1" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz nx kw kx ky dt translated">提交搜索表单时调用 Github API</li><li id="7364" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz nx kw kx ky dt translated">在卡片列表中显示搜索结果</li></ol><p id="d859" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们将从声明 API 常量开始</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="6692" class="ln lo hu mr b fv ns nt l nu nv">const API = 'https://api.github.com/';</span></pre><p id="23eb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，让我们用两个状态值初始化“top”组件:<code class="eh mo mp mq mr b">searchText</code>和<code class="eh mo mp mq mr b">data</code>。</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="639c" class="ln lo hu mr b fv ns nt l nu nv">class App extends React.Component {<br/>  constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      searchText: 'nsebhastian',<br/>      data: '',<br/>    }<br/>  }<br/>  <br/>  fetchSearch = username =&gt; {<br/>    let url = `${API}search/users?q=${username}`;<br/>    fetch(url)<br/>    .then((res) =&gt; res.json() )<br/>    .then((data) =&gt; {<br/>      <strong class="mr hv">this.setState({<br/>        data: data<br/>      });</strong><br/>    })<br/>    .catch((error) =&gt; console.log('Oops! . There Is A Problem' + error) )<br/>  }</span><span id="76e5" class="ln lo hu mr b fv nw nt l nu nv"><strong class="mr hv">componentDidMount() {<br/>    this.fetchSearch(this.state.searchText);<br/>  }</strong></span></pre><p id="122c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><code class="eh mo mp mq mr b">fetchSearch</code>函数将从 API url 获取数据，将其转换为 JSON 对象，然后用新获取的数据更新我们的<code class="eh mo mp mq mr b">data</code>状态。它将在组件生命周期方法<code class="eh mo mp mq mr b"><a class="ae mn" href="https://reactjs.org/docs/react-component.html#componentdidmount" rel="noopener ugc nofollow" target="_blank">componentDidMount</a></code>中被调用。如果您不熟悉生命周期方法，它们基本上是在构建和呈现组件的过程中的特定时间运行的方法。除了<code class="eh mo mp mq mr b">componentDidMount</code>还有其他方法，包括<code class="eh mo mp mq mr b">constructor</code>方法。并不是所有的生命周期方法都被频繁使用，其中一些会比其他的更经常使用。</p><p id="67da" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们继续我们的应用程序，编写<code class="eh mo mp mq mr b">App</code>组件的<code class="eh mo mp mq mr b">render</code>方法:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="a43b" class="ln lo hu mr b fv ns nt l nu nv">render() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;MyHeader /&gt;<br/>      <strong class="mr hv">&lt;SearchForm <br/>        fetchSearch={this.fetchSearch}<br/>      /&gt;<br/>      &lt;Profiles <br/>        data={this.state.data}<br/>      /&gt;</strong><br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="918e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">您可能已经猜到了，我们需要创建另外两个组件，即<code class="eh mo mp mq mr b">&lt;SearchForm/&gt;</code>和<code class="eh mo mp mq mr b">&lt;Profiles/&gt;</code>。</p><p id="7009" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">让我们从<code class="eh mo mp mq mr b">&lt;SearchForm/&gt;</code>开始。我们以前在 React 中写过表单，所以这不会很难。我们只需要一个单一的文本输入和提交按钮。另外，让我向您展示另一种不使用<code class="eh mo mp mq mr b">state</code>获取输入值的方法:</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="cdd3" class="ln lo hu mr b fv ns nt l nu nv">class SearchForm extends React.Component {<br/>  render() {<br/>    return (<br/>        &lt;div className="search-bar"&gt;<br/>          &lt;form<br/>            className="input-group"<br/>            <strong class="mr hv">onSubmit={this.handleForm}</strong>&gt;<br/>            &lt;input<br/>              type="search"<br/>              ref="username"<br/>              placeholder="Type Username here"<br/>              className="form-control"/&gt;<br/>            &lt;span className="input-group-btn"&gt;<br/>              &lt;button type="submit" <br/>                className="btn btn-warning"&gt;Submit&lt;/button&gt;<br/>            &lt;/span&gt;<br/>          &lt;/form&gt;<br/>        &lt;/div&gt;</span><span id="6c4d" class="ln lo hu mr b fv nw nt l nu nv">)<br/>  }</span><span id="6435" class="ln lo hu mr b fv nw nt l nu nv"><strong class="mr hv">handleForm = event =&gt; {<br/>    event.preventDefault();<br/>    let username = this.refs.username.value<br/>    this.props.fetchSearch(username);<br/>  }<br/>}</strong></span></pre><p id="db4a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如您所见，我们通过使用<code class="eh mo mp mq mr b">ref</code>获得用户名值。这样我们根本不需要初始化<code class="eh mo mp mq mr b">state</code>。我们必须使用 ES6 类来声明组件，因为我们需要编写<code class="eh mo mp mq mr b">handleForm</code>函数。</p><p id="e238" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在该写最后一个组件<code class="eh mo mp mq mr b">&lt;Profiles/&gt;</code>了。我将利用这个机会向您展示组件声明— <em class="km">箭头函数样式</em>。</p><pre class="lf lg lh li fq no mr np nq aw nr dt"><span id="3588" class="ln lo hu mr b fv ns nt l nu nv">Profiles = props =&gt; {<br/>    if(props.data){<br/>      let data = props.data;</span><span id="cad2" class="ln lo hu mr b fv nw nt l nu nv">if (data.message === 'Not Found')<br/>        return (<br/>           &lt;div className="notfound"&gt;<br/>              &lt;h2&gt;Oops !!!&lt;/h2&gt;<br/>              &lt;p&gt;The Component Couldn't Find The You Were Looking For . Try Again &lt;/p&gt;<br/>           &lt;/div&gt;<br/>        );<br/>        <strong class="mr hv">else{<br/>          // map the users into JSX elements<br/>          let userList = data.items.map((name) =&gt; {<br/>            return (<br/>                &lt;a key={name.id} href={name.html_url} target="blank"&gt;<br/>                &lt;div className="bs-callout bs-callout-info"&gt;<br/>                  &lt;img className="user" src={name.avatar_url} alt={`${name.login}`}/&gt;<br/>                  &lt;h4&gt;Username : {name.login}&lt;/h4&gt;<br/>                  &lt;p&gt; Url : {name.html_url}&lt;/p&gt;<br/>                  &lt;p&gt; Score : {name.score} &lt;/p&gt;<br/>                &lt;/div&gt;<br/>                &lt;/a&gt;<br/>            );<br/>          })<br/>          // then render it<br/>          return (<br/>            &lt;div&gt;{userList}&lt;/div&gt;<br/>          );<br/>        }</strong><br/>    }<br/>    else {<br/>      return &lt;div&gt;Fetching data . . .&lt;/div&gt;<br/>    }<br/>}</span></pre><p id="4036" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你从一开始就遵循这个教程，我想你可以理解这个<code class="eh mo mp mq mr b">&lt;Profiles/&gt;</code>组件是做什么的。它将接受来自其父节点的<code class="eh mo mp mq mr b">props</code>命名数据，然后基于该属性做一些事情。我们使用<code class="eh mo mp mq mr b">map</code>函数迭代并写入来自<code class="eh mo mp mq mr b">data</code>数组的 JSX 元素。然后简单的返回进行渲染。</p><p id="dd20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意一个<code class="eh mo mp mq mr b">key</code>道具是如何传递到<code class="eh mo mp mq mr b">&lt;a&gt;</code>元素中的，这样 React 就可以识别列表中的单个元素。更多细节<a class="ae mn" href="https://reactjs.org/docs/lists-and-keys.html#keys" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="d967" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在你可以搜索并点击结果，进入 GitHub 用户档案。干得好，走了这么远！我们实际上可以通过使用 React Router 来改进应用程序，并创建用户页面来查看单个用户的详细视图，但我们现在就到此为止，当我们实际了解 React Router 时，我们将继续学习<strong class="je hv"> React Router refactoring </strong>。</p><h1 id="7342" class="ms lo hu bd lp mt mu mv lt mw mx my lx mz na nb ma nc nd ne md nf ng nh mg ni dt translated">结论</h1><p id="367d" class="pw-post-body-paragraph jc jd hu je b jf mi jh ji jj mj jl jm jn nj jp jq jr nk jt ju jv nl jx jy jz hn dt translated">我们构建了三个练习项目来学习 React 基础知识，从简单的静态卡片列表开始，到从 GitHub API 获取数据并显示数据的更复杂的 React 应用程序。我们还学习了使用<code class="eh mo mp mq mr b">state</code>的动态数据管理。</p><p id="31e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">从这些教程中获得的是简单且可重用的 React 模式，你几乎可以在任何 React 应用程序中看到:</p><ul class=""><li id="8caa" class="kq kr hu je b jf jg jj jk jn ks jr kt jv ku jz kv kw kx ky dt translated"><strong class="je hv">组件</strong>是由方法和 JSX 组成的一个 UI。</li><li id="578d" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><strong class="je hv">JSX</strong>HTML 被 JS 增压，使我们能够使用 JavaScript 语法描述 UI</li><li id="a3c5" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><strong class="je hv"> Props </strong>是我们传递给组件的任意输入。</li><li id="3d72" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><strong class="je hv">状态</strong>用于存储动态数据。我们可以用它来呈现用户界面和存储获取的数据</li><li id="1f69" class="kq kr hu je b jf kz jj la jn lb jr lc jv ld jz kv kw kx ky dt translated"><strong class="je hv">生命周期方法</strong>用于组件渲染需要调用的方法。最简单的例子是调用 API 和获取数据</li></ul><p id="6979" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感觉怎么样？通过实际构建您更可能在项目中使用的组件来学习 React 不是更有趣吗？对你来说太难了吗？请给我反馈，这样我可以提高我的写作技巧。</p><p id="c760" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我很快会报道更多关于 React 的内容——比如使用钩子或者 React 路由器——所以如果你对此感兴趣，一定要关注我或者<a class="ae mn" href="https://sebhastian.com/subscribe" rel="noopener ugc nofollow" target="_blank">订阅我的时事通讯。我保证不会给你的收件箱发垃圾邮件！</a></p><p id="ef5b" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">感谢阅读🙌</p><figure class="lf lg lh li fq iv fe ff paragraph-image"><a href="https://sebhastian.com/subscribe"><div class="fe ff ny"><img src="../Images/8f5af2ba45c90820d187d15c44de33b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*76cHdZDHqV62bWfKr0ViVw.jpeg"/></div></a></figure></div><div class="ab cl nz oa hc ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="hn ho hp hq hr"><p id="1ae6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="km">原载于</em><a class="ae mn" href="https://sebhastian.com" rel="noopener ugc nofollow" target="_blank"><em class="km">sebhastian.com</em></a></p></div></div>    
</body>
</html>