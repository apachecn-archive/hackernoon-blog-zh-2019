<html>
<head>
<title>SOLID by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实例证明</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/solid-by-example-bff2379dd3e2?source=collection_archive---------5-----------------------#2019-06-05">https://medium.com/hackernoon/solid-by-example-bff2379dd3e2?source=collection_archive---------5-----------------------#2019-06-05</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="a30a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在这篇文章中，我们将讨论如何利用<strong class="it hv">坚实的</strong>原则来编写“干净的代码”。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/450bab07da59b159e7797387f7d82f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_KLJBLZPJlPsZACHmgfCA.png"/></div></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">SOLID</figcaption></figure><h1 id="146f" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">糟糕的代码对我们有什么影响</h1><ol class=""><li id="ab28" class="ld le hu it b iu lf iy lg jc lh jg li jk lj jo lk ll lm ln dt translated">难以调试</li><li id="1f6b" class="ld le hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">难以理解</li><li id="979d" class="ld le hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">难以扩展或者修改</li><li id="78ad" class="ld le hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">修改一个特征会破坏其他特征</li><li id="5fd7" class="ld le hu it b iu lo iy lp jc lq jg lr jk ls jo lk ll lm ln dt translated">难以测试</li></ol><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/1e765950d56cca4005fdbcf9bf820675.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/1*PFc426_QAQdxMMO-65yW5g.gif"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Dealing with Bad Code</figcaption></figure><p id="d82e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们绝对不想处于这种情况。让我们熟悉一些概念，帮助我们避免这些。</p><h1 id="e4a5" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">单一责任原则(SRP)</h1><blockquote class="lu lv lw"><p id="c5eb" class="ir is lx it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hn dt translated">一个类或函数应该有且只有一个改变的理由</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Example of a class violating SRP</figcaption></figure><p id="652e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们对上面这个类有什么看法。让我们假设它是博客系统的一部分。这门课有什么问题？如果内容发生变化，“内容管理”将会更新，如果我们改变打印博客的方式，“显示管理”将会更新，如果我们选择以其他方式保存博客，“持久管理”将会更新。太多的人在一个班里有股份从来都不是一件好事。这个班的职责是什么？维护博客信息，打印博客和持久化博客。正如我们所看到的，它显然有不止一个责任。</p><p id="b9a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">确定单一的职责可能有些棘手，因为你看到所有的功能都与博客相关。诀窍是考虑可能对改变这个类感兴趣的不同实体。因此，如果有不止一方对改变类别或功能感兴趣，我们显然违反了SRP。在我们的例子中有3个:内容管理、显示管理和持久性管理。当心使用“然后”来给你的类或函数增加更多的责任，并让我们相信它只有一个责任。</p><p id="6fa5" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们重构</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">SRP refactored</figcaption></figure><p id="1143" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">所以现在我们把额外的责任转移到了外面。博客只有关于博客的信息。“Printer”和“Persist”已被移到它们自己的模块中。现在，如果这三件事情中的任何一件必须改变，也不会影响到其他地方。</p><h1 id="6f28" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">开闭原理</h1><blockquote class="lu lv lw"><p id="1976" class="ir is lx it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hn dt translated">功能必须对扩展开放，但对修改关闭</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Open Closed Principle Violation</figcaption></figure><p id="8bc3" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">该程序的目的是找出我们每辆车中的剩余空气。当我们想增加一个新的交通工具，比如一个自行车，会发生什么？我们必须添加另一个“if else”并修改“findAirLeft”函数。这还没有结束。这个“if else”阶梯将在所有我们想要基于车辆类型处理一些逻辑的地方重复。正如你所看到的，我们不能在不修改的情况下扩展程序，为了一个小的改变，我们可能不得不改变很多代码。</p><p id="6fa8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们重构</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Open Closed Principle Refactored</figcaption></figure><p id="11a4" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">现在，如果你看到我们的重构代码，没有“if else”阶梯，我们有一个抽象类Vehicle，带有findAir方法，所有的Vehicle都实现了这个方法。如果我们想添加另一辆车(扩展)，我们不需要触及现有的功能(不修改)。</p><h1 id="557c" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">利斯科夫替代原理</h1><blockquote class="lu lv lw"><p id="cd78" class="ir is lx it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hn dt translated">您应该能够在程序中的任何地方用子类替换超类，而不会出现任何意外行为</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">LSP Violations</figcaption></figure><p id="bff0" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果我们看一下这个例子，我们有一个“List ”,它存储了许多值。现在我们想实现“Stack”，我们看到我们已经有了一个存储许多值的类，我们决定重用该功能，我们扩展List类并覆盖get和put方法以遵循LIFO(这就是堆栈的工作方式)。</p><p id="a431" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">会出什么问题呢？看看第26行。当我们将一个堆栈对象作为列表传递给其他模块时会发生什么？有人会像使用链表一样使用它，因为链表和栈的操作方式不同。</p><p id="b808" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">每当我们继承时，我们需要确保它是可替换的。此外，如果我们只是需要另一个类的一些功能，并不强制进行继承，我们可以使用组合，并感到高兴。</p><p id="881b" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们重构</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">LSP Refactored</figcaption></figure><p id="b678" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">我们仍然在重复使用“列表”功能。但是现在我们没有继承。在这种情况下，没有人会受伤，因为没有混乱。</p><h1 id="a602" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">界面分离原理</h1><blockquote class="lu lv lw"><p id="3eda" class="ir is lx it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hn dt translated">创建简单、集中的界面，而不是臃肿的大界面</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Interface Segregation Violation</figcaption></figure><p id="77a7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上面这段代码有什么问题。接口时钟定义了时钟的所有功能。问题是闹钟并不需要所有的功能，它只需要“设置闹铃”和“获取闹铃”就可以了，但它却被迫实现了其他不必要的功能，要么返回null，要么让函数为空。</p><p id="afde" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们重构</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Interface Segregation Refactored</figcaption></figure><p id="f440" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个想法是创建更小更集中的界面，而不是庞大臃肿的界面。</p><h1 id="0b79" class="kf kg hu bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc dt translated">从属倒置原则</h1><blockquote class="lu lv lw"><p id="c1f6" class="ir is lx it b iu iv iw ix iy iz ja jb ly jd je jf lz jh ji jj ma jl jm jn jo hn dt translated">一个类不应该依赖于另一个具体的类，相反，它应该依赖于一个抽象</p></blockquote><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Dependency Inversion Violation</figcaption></figure><p id="f378" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个类的问题是，当我们决定切换到另一种形式的存储时，比如说一个SQL数据库，或者如果FileWriter改变了它的一些API，这个类也需要改变。BookDB类依赖于具体的FileWriter类。紧密耦合从来都不是一个好主意。</p><p id="beeb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">让我们重构</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="mb mc l"/></div><figcaption class="kb kc fg fe ff kd ke bd b be z ek">Dependency Inversion Refactored</figcaption></figure><p id="495d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">因此，我们用“save”方法签名和FilePersist模块实现了一个接口。现在BookDB类依赖于一个抽象，而不是直接依赖于FilePersist具体实现。有了这一改变，较低层次的模块改变将不会影响BookDB，而且我们可以通过注入BookPersist接口的一些其他实现(松散耦合)来轻松地切换持久性方法。</p><p id="727c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如果你仔细观察，“开闭原则”和“依赖倒置”是齐头并进的。通过遵循“依赖倒置”,我们可以避免违反“开闭原则”。</p><p id="6f8c" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在现实世界中，我们可能最终会违反一些原则，让我们意识到这一点并采取立场。例如，我们违反了一个原则，这样使用我们模块的客户就不需要违反任何原则。</p><p id="08c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">SOLID只是编写“干净代码”的众多原则之一。还有其他像吻，干，YAGNI等..我们可以在以后的帖子中讨论它们。请在评论中留下你的反馈。</p></div></div>    
</body>
</html>