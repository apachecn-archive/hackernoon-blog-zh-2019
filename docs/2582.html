<html>
<head>
<title>Anti Patterns of Continuous Integration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">持续集成的反模式</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/anti-patterns-of-continuous-integration-e1cafd47556d?source=collection_archive---------4-----------------------#2019-04-23">https://medium.com/hackernoon/anti-patterns-of-continuous-integration-e1cafd47556d?source=collection_archive---------4-----------------------#2019-04-23</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><p id="bd26" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated"><a class="ae jp" href="https://hackernoon.com/tagged/continuous-integration" rel="noopener ugc nofollow" target="_blank"><strong class="it hv"/>(CI)</a>持续集成并不是软件开发中的新术语。众所周知，它通过提供快速反馈和减少集成问题来简化软件开发。</p><h2 id="ab7b" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">根据定义:</h2><blockquote class="kl km kn"><p id="20e4" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">持续集成(CI)是一种开发实践，它要求开发人员每天数次将代码集成到共享存储库中。然后，每个签入都由一个自动构建来验证，允许团队尽早发现问题。</p><p id="ed2b" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">通过定期集成，您可以快速检测错误，并更容易地定位错误。https://www.thoughtworks.com/continuous-integration<br/>——<a class="ae jp" href="https://www.thoughtworks.com/continuous-integration" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="3970" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">然而，有时人们会说，由于团队规模/项目结构/复杂性，CI在特定项目中不起作用。在这篇博客中，我将讨论常见的反模式可能会导致人们觉得CI没有为项目工作。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="ab fr cl kx"><img src="../Images/a7719e02f4525eca7042a94a433bfe50.png" data-original-src="https://miro.medium.com/v2/format:webp/1*OG3PkvHHBw0_hEcwV4Keog.jpeg"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Image Source: <a class="ae jp" href="https://journal.missiondata.com/improving-delivery-with-continuous-integration-72a9ffea2117" rel="noopener ugc nofollow" target="_blank">https://journal.missiondata.com/improving-delivery-with-continuous-integration-72a9ffea2117</a></figcaption></figure><h2 id="6605" class="jq jr hu bd js jt ju jv jw jx jy jz ka jc kb kc kd jg ke kf kg jk kh ki kj kk dt translated">什么是反模式？</h2><blockquote class="kl km kn"><p id="dab6" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated"><em class="hu">反模式就像模式一样，只是它给出的不是解决方案，而是表面上看起来像解决方案但实际上不是的东西。</em></p><p id="faa8" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated"><em class="hu">—https://martinfowler.com/bliki/AntiPattern.html<a class="ae jp" href="https://martinfowler.com/bliki/AntiPattern.html" rel="noopener ugc nofollow" target="_blank">安德鲁·克尼格</a>T13】)</em></p></blockquote><p id="2fbb" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">根据<em class="ko">设计模式</em>的作者的观点，要正式区分实际的反模式和简单的坏习惯、坏实践或坏想法，至少要有两个关键要素:</p><blockquote class="kl km kn"><p id="3bb1" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">*一种常用的流程、结构或行动模式，尽管最初看起来是对某个问题的适当而有效的回应，但其不良后果多于良好后果。</p><p id="df57" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">*存在另一种解决方案，它是有记录的、可重复的，并且被证明是有效的</p></blockquote></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><p id="ec55" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下面是持续集成的常见反模式。</p><h1 id="b357" class="ll jr hu bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb dt translated"><strong class="ak">不常签入</strong></h1><p id="f343" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">这违背了持续集成的基本原则。在这种情况下，代码会在本地笔记本电脑上保存很长时间，而不会被提交和签入。最普遍的原因是完成整个特性需要大量的修改。由于签入不频繁，集成被延迟。在开发特性的同时，其他开发人员签入他们的代码。这项功能花费的时间越长，其他人签入的代码就越多。这导致了大量的合并冲突，因为要进行大量的修改。</p><p id="d5e6" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这导致巨大的集成工作，因为来自不同开发人员的巨大变化将导致许多合并冲突。这些冲突不容易解决，因为要做的更改太多了。</p><p id="b631" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">克服这一点的最简单的解决方案是，将特性分成更小的独立任务。在每个任务结束时，应该有一个提交和签入。它不仅有助于更快、更方便的集成，还有助于获得更具体的提交消息。如果需要恢复特定任务，这可能会很有用。</p><p id="9d54" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在下图中，您可以看到可能的任务列表:</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/61c42098871654d8d1bb8b8ffaef92b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OhknAqvcI3y9Dp4I944KEw.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Possible list of tasks for a feature</figcaption></figure><h1 id="9a86" class="ll jr hu bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb dt translated"><strong class="ak">特征分支</strong></h1><blockquote class="kl km kn"><p id="6727" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">特性分支背后的核心思想是所有的特性开发都应该在一个专门的分支中进行。这种封装使得多个开发人员在不干扰主要代码库的情况下处理功能变得容易。</p></blockquote><p id="f698" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在一个项目中，如果特性分支在完成之前从来没有从主线(存储库的主要分支)得到变更，那么这个项目就离持续集成很远。事实上，这种方法可以称为<strong class="it hv">持续隔离</strong>。</p><blockquote class="kl km kn"><p id="8503" class="ir is ko it b iu iv iw ix iy iz ja jb kp jd je jf kq jh ji jj kr jl jm jn jo hn dt translated">术语<a class="ae jp" href="https://twitter.com/benjiweber/status/831193574502961154" rel="noopener ugc nofollow" target="_blank">持续隔离</a>来自一条推文，并被<a class="ae jp" href="https://paulhammant.com/2017/02/14/fake-news-via-continuous-isolation/" rel="noopener ugc nofollow" target="_blank">保罗·哈曼特</a>扩展。Thoughtworks后来将这种做法确定为<a class="ae jp" href="https://www.thoughtworks.com/radar/techniques/ci-theatre" rel="noopener ugc nofollow" target="_blank">“CI Theatre”</a>。</p></blockquote><p id="6f4d" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">一个孤立的特性分支会导致很多冲突，因为当特性完成时，主线会有大量的变化。在大量开发人员进行巨大变更的情况下，现在每个人都需要坐在一起进行合并，否则，合并时可能会错过一些重要的变更。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mm"><img src="../Images/7d384552828b6ffac6010ea2bcabbb2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/0*8LI-PFwKLCpav6fu.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Image Source: <a class="ae jp" href="https://www.martinfowler.com/bliki/FeatureBranch.html" rel="noopener ugc nofollow" target="_blank">https://www.martinfowler.com/bliki/FeatureBranch.html</a></figcaption></figure><p id="e987" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上图显示了一个包含许多长期特性分支的存储库。<br/>支乘<strong class="it hv"> <em class="ko">【梅子教授】</em> </strong>得到了P1、P2当地的首肯..P5，她在P1-2点和P3-4点从主线上换车。最后，在P1 5号，她将其并入主线。<br/>分支由<strong class="it hv"> <em class="ko">【牧师绿】</em> </strong>同时启动的有本地犯G1、G2..G6，并在G1-2、G3(在P1-5之前)与主线换车。现在，他决定将其合并到主线中，为此，他需要将“<strong class="it hv"> <em class="ko">普拉姆</em> </strong>教授”所做的所有更改合并进来。因为有很多提交，所以很难将它们集成在一起。</p></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><p id="f9d7" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">解决上面问题的方法很简单，<strong class="it hv">避免长生命特征分支</strong>。应该只有一个分支作为真理的单一来源。所有的开发工作都是从这个分支开始的，应该被推送到同一个分支。这个单独的分支通常被称为主干(在Git中通常是主分支)。这种开发实践被称为<strong class="it hv">基于主干的开发</strong>，因为所有的开发都是针对主干进行的。</p><p id="b6e8" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">在项目中，在合并之前需要得到<strong class="it hv">拉请求</strong>的批准，这个问题可以通过对每个任务使用<strong class="it hv">短期分支</strong>来解决。一旦任务完成，这些分支就会合并，并且在整个特性完成之前不需要存在。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mn"><img src="../Images/2054c2749b57ac72a535f8665f4fc6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/0*eNHfO4dGtTrnTl_z.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Image Source: <a class="ae jp" href="https://www.martinfowler.com/bliki/FeatureBranch.html" rel="noopener ugc nofollow" target="_blank">https://www.martinfowler.com/bliki/FeatureBranch.html</a></figcaption></figure><p id="24dd" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上图显示了短命分支的使用。<strong class="it hv"> <em class="ko">格林牧师</em> </strong>进行本地提交G1并将其合并到主线。<strong class="it hv"> <em class="ko">梅子教授</em> </strong>做了一个本地提交P1，在她能把它合并到主线之前，她需要接受提交G1，把它和她的改变合并到本地，然后推。当牧师Green需要下一次提交时，他也会这样做。这是一系列多个小合并，不需要一个巨大的合并事件。</p><h1 id="6863" class="ll jr hu bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb dt translated"><strong class="ak">破建</strong></h1><p id="2949" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">好吧，破房子不是问题。这是构建管道的用例之一，在出错时给出早期反馈。当它长时间坏掉时，问题就出现了。</p><p id="33ef" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这导致了阻塞，因为在构建修复之前不应该有任何其他的签入。失败构建的检入将创建更多的文件、更多的变更和更多的依赖，这使得缺陷的检测和隔离变得困难。</p><p id="51c2" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">如上所述，不完整的构建不是问题所在，因此没有解决方案。这只是一个让修复一个坏的构建成为首要任务的原则。如果修复构建需要大量时间，恢复提交是修复构建的有效选项。</p><h1 id="5100" class="ll jr hu bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb dt translated"><strong class="ak">构建时间</strong></h1><p id="5763" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">持续集成的全部意义在于拥有快速的反馈。长时间运行的构建增加了开发人员在签入后的等待时间，因为他们需要等待构建完成后才能继续。这可能导致不频繁的签入，以避免长时间的多次等待。</p><p id="1700" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">构建时间长的一个原因是作为构建的一部分运行各种检查和测试。为了克服这个问题，构建应该被配置为只编译代码和运行快速单元测试。其他耗时的检查/测试可以作为<strong class="it hv">流水线方式</strong>的后续步骤进行，快速反馈不需要这些检查/测试，但需要进行测试。</p><p id="6e8e" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">这个想法是在测试/检查和构建时间之间找到一个平衡，这样一个构建足够稳定，可以转移到下一个任务。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff mo"><img src="../Images/63faf238557b328819a13b01b424d371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/0*gm437osHdI-s9Q-U.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Image Source: <a class="ae jp" href="https://i.stack.imgur.com/kXpHf.png" rel="noopener ugc nofollow" target="_blank">https://i.stack.imgur.com/kXpHf.png</a></figcaption></figure><p id="cc76" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">上图显示了一个<a class="ae jp" href="https://martinfowler.com/bliki/TestPyramid.html" rel="noopener ugc nofollow" target="_blank">测试金字塔</a>，它将测试分为4个部分。<strong class="it hv">单元测试</strong>、<strong class="it hv">集成测试</strong>、<strong class="it hv">验收测试</strong>、<strong class="it hv"> UI或End2End测试</strong>。随着我们在金字塔中向上移动，测试的数量减少，运行时间增加。</p><p id="f9ff" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下图显示了运行上述测试的管道。作为构建的一部分，只有<strong class="it hv">单元测试</strong>会运行，花费的时间很少。其他一切都将稍后运行，但是一旦构建完成，开发人员就可以进入下一个任务。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mp"><img src="../Images/e6eeeb04d42c078d49fb82d78ffb62ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qn_Izth9Ehy0ssTOpRQKKw.png"/></div></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">A demo pipeline which runs different kind of tests in different stages</figcaption></figure><h1 id="7113" class="ll jr hu bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb dt translated"><strong class="ak">建立反馈</strong></h1><p id="98dd" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">修复一个坏的构建的第一步是意识到这个构建是坏的。如果构建被破坏了，但是没有人意识到这一点，那么每个人都会很高兴并继续在这个被破坏的构建上工作。</p><p id="20ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">对此可能有简单的解决方案:</p><ul class=""><li id="8138" class="mq mr hu it b iu iv iy iz jc ms jg mt jk mu jo mv mw mx my dt translated">可以有一个CI仪表板，显示构建的状态。</li><li id="5285" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">CI服务器可以配置为通过邮件、slack等方式通知团队。一旦有关于构建被破坏的通知，这应该成为优先事项，</li></ul><p id="516a" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">下图显示了来自<strong class="it hv"><em class="ko">gocd-slack-bot</em></strong>的关于构建状态的通知。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff ne"><img src="../Images/d3464fd74771ff7ed647c027102ff8d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/0*CqHmX85ZEP3IJPUT.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek">Image Source: <a class="ae jp" href="http://blog.ashwanthkumar.in/2015/02/gocd-slack-build-notifier.html" rel="noopener ugc nofollow" target="_blank">http://blog.ashwanthkumar.in/2015/02/gocd-slack-build-notifier.html</a></figcaption></figure><h1 id="3285" class="ll jr hu bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb dt translated"><strong class="ak">垃圾邮件通知的恐怖</strong></h1><p id="d98d" class="pw-post-body-paragraph ir is hu it b iu mc iw ix iy md ja jb jc me je jf jg mf ji jj jk mg jm jn jo hn dt translated">如上所述，CI服务器可以配置为通知构建状态。现在让我们想象一个大团队进行大量的签入。如果每2分钟就有一个关于构建通过的通知，这将导致<a class="ae jp" href="https://en.wikipedia.org/wiki/Alarm_fatigue" rel="noopener ugc nofollow" target="_blank">警报疲劳</a>。人们会被构建通知淹没，并开始忽略这些通知。这使得通知无效，因为人们可能会错过关于构建失败的通知。</p><p id="0ada" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">要解决这个问题，CI服务器应该配置为不在每次登记时通知。它应该被配置为只在新的签入失败时才发出通知，这是人们应该关注构建的时候，所以它会被修复。另一个有用的通知是当一个新的签入修复了一个损坏的构建时，因为它将允许其他人签入他们等待构建被修复的代码。</p><h1 id="ffb7" class="ll jr hu bd js lm ln lo jw lp lq lr ka ls lt lu kd lv lw lx kg ly lz ma kj mb dt translated"><strong class="ak">总结</strong></h1><ul class=""><li id="1fbe" class="mq mr hu it b iu mc iy md jc nf jg ng jk nh jo mv mw mx my dt translated">频繁地对远程存储库进行小规模的独立提交是顺利持续集成的关键。</li><li id="e0c0" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">对l̶o̶n̶g̶-̶l̶i̶v̶e̶d̶̶f̶e̶a̶t̶u̶r̶e̶̶b̶r̶a̶n̶c̶h̶e̶s̶说不。对于小型任务，遵循<strong class="it hv">基于主干的开发</strong>或<strong class="it hv">短期分支</strong>。</li><li id="f935" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">残破的构建应该是重中之重。在修复版本之前，没有其他签入。</li><li id="2073" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">减少构建时间。如果出现问题，它有助于获得快速反馈。</li><li id="d2a6" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">Setup dashboard是一种通知机制，用于向团队成员通知构建状态。</li><li id="7dd6" class="mq mr hu it b iu mz iy na jc nb jg nc jk nd jo mv mw mx my dt translated">仅从CI发送重要通知，以避免垃圾邮件。</li></ul></div><div class="ab cl le lf hc lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="hn ho hp hq hr"><p id="9689" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">以上是主要的反模式，我在我工作过的项目中见过。我也很想听听你的经历。</p><p id="40ab" class="pw-post-body-paragraph ir is hu it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hn dt translated">喜欢读它，让别人知道鼓掌，分享。感谢任何反馈。</p></div></div>    
</body>
</html>