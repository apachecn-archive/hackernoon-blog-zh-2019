<html>
<head>
<title>GraphQL in 10 minutes. Thing I wish someone told me when I started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">十分钟后GraphQL。我希望有人在我开始的时候告诉我</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/graphql-in-10-minutes-thing-i-wish-someone-told-me-when-i-started-12a598e40001?source=collection_archive---------8-----------------------#2019-05-17">https://medium.com/hackernoon/graphql-in-10-minutes-thing-i-wish-someone-told-me-when-i-started-12a598e40001?source=collection_archive---------8-----------------------#2019-05-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/ba67fe27089293159c4f5d31b9cca3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UoLTL4a5r9-od2c74VeIQ.png"/></div></div></figure><p id="390a" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">首先，相对于休息服务的优势</strong></p><p id="2f4d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">想象一下，你有一个管理人员列表的web应用程序。他们每个人都有几个朋友。这就变成了一个“图”,这是一个CS数据结构术语，用于描述通过定向或不定向关系链接在一起的项目。</p><p id="bcc7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果是为了REST API设计，我可能不得不写一些类似于<code class="eh ka kb kc kd b">get-people-by-id</code>、<code class="eh ka kb kc kd b">get-people-friends-count-by-id</code>和<code class="eh ka kb kc kd b">get-people-friends-details-by-id</code>的东西</p><p id="e154" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果你想得到所有的数据，你要么必须进行3次调用来得到上述所有的信息，要么你在服务器端把这3件事结合起来，然后不管用户要求什么都返回。这就是所谓的<code class="eh ka kb kc kd b"><strong class="je hv">over fetching</strong></code> <strong class="je hv"> </strong>和<code class="eh ka kb kc kd b"><strong class="je hv">under fetching</strong></code></p><p id="8483" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL解决方案看起来更加优雅。<br/>对于这种情况，我们只需要人的基本信息，没有任何细节</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="0b62" class="km kn hu kd b fv ko kp l kq kr">query {<br/>  People(id: 123){<br/>    name<br/>    age<br/>  }<br/>}</span></pre><p id="5681" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于这种情况，我们需要更多信息</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="64af" class="km kn hu kd b fv ko kp l kq kr">query {<br/>  People(id: 123){<br/>    name<br/>    age<br/>    friendsCount<br/>    friends{<br/>      name<br/>      age<br/>    }<br/>  }<br/>}</span></pre><p id="b2cd" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">更好的是，我们可以深入到朋友关系的循环洞里</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="b9f2" class="km kn hu kd b fv ko kp l kq kr">query {<br/>  People(id: 123){<br/>    name<br/>    age<br/>    friendsCount<br/>    friends{<br/>      name<br/>      age<br/>      friends{<br/>        name<br/>        age<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="e1d2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv"> GraphQL基本构建模块:类型、查询、变异和订阅</strong></p><p id="ffc3" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">类型就像我们人类语言中的物体或名词。在上面的例子中，People只是一个类型，它应该是这样的:(！意味着它是必需的)</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="b6ea" class="km kn hu kd b fv ko kp l kq kr">type People {<br/>  id: ID!<br/>  name: String!<br/>  age: Int<br/>  friendsCount: Int<br/>  friends: [People]<br/>}</span></pre><p id="ae20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">要描述一个列表，可以像javascript一样使用[]语法。以下是更多细节</p><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div class="fe ff ks"><img src="../Images/c06f7e028a7ca4da2425fdf9bbb1fadc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*HRJvOouKVjkeFdO2eRqzYA.png"/></div></figure><p id="ff05" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">查询</strong>的例子如上一段所示，这就像一种使用描述方式的查询语言。</p><p id="a82c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">突变</strong>是根据类型更新/更改/删除/添加数据</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="1363" class="km kn hu kd b fv ko kp l kq kr">mutation {     <br/>   addPeople(name: "John Doe" age:21) {<br/>         id<br/>         age<br/>         name<br/>  }<br/>}</span></pre><p id="f896" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">订阅就像消息系统中的发布/订阅方式。在大多数流行的GraphQL服务器实现中，它们是使用WebSocket和一些支持发布/订阅的解决方案来实现的，如Redis等<br/>我们可以使用GraphQL订阅来构建一个聊天应用程序，而无需知道它是如何使用Websockets实现的，非常简洁。</strong></p><p id="204c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">以下要点很容易被忽视，但却非常重要</p><ol class=""><li id="0893" class="kt ku hu je b jf jg jj jk jn kv jr kw jv kx jz ky kz la lb dt translated">类型、查询、变异和订阅是在模式中定义的，就像数据库的创建模式脚本一样。<br/>都是以单词`<strong class="je hv">开头的类型</strong></li></ol><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="6f09" class="km kn hu kd b fv ko kp l kq kr">type Subscription {<br/>  messageAdded(channelId: ID!): Message<br/>}<br/>type query{<br/>  allPeople: [People]<br/>}<br/>type mutation{<br/>  addPeople(name:String! age:Int): People<br/>}</span></pre><p id="57e9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">2.在你的app客户端或者GraphQL或者GraphQL Playground等客户端工具中，使用查询、变异、订阅等命令。<br/> <br/>简而言之，首先使用<code class="eh ka kb kc kd b">type query</code> <code class="eh ka kb kc kd b">type mutation</code>和<code class="eh ka kb kc kd b">type subscription</code>定义它们，然后在客户端使用它们</p><p id="67ed" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">不要像我以前一样被他们的客户端用法语法和模式定义语法弄糊涂了:)</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="ee97" class="km kn hu kd b fv ko kp l kq kr">subscription {<br/>  messageAdded(channelId: 1) {<br/>    id<br/>    text<br/>  }<br/>}</span></pre><p id="05fc" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">3.查询、变异和订阅都可以带参数。看起来是这样的</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="c628" class="km kn hu kd b fv ko kp l kq kr">query getPhotos($filter:PhotoFilter $page:DataPage $sort:DataSort) <br/>{<br/>   allPhotos(filter:$filter paging:$page sorting:$sort){ ... }<br/>}</span></pre><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lc"><img src="../Images/5939fee588d1d8103b62999a7d4bf8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YYNsa0MZwRVf7oXIFASVg.jpeg"/></div></div><figcaption class="ld le fg fe ff lf lg bd b be z ek">Wearing double socks</figcaption></figure><p id="03e4" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">当我开始的时候，我认为那些addPeople(name:String age:Int)的东西是参数，为什么我们需要那些$xxx的东西。<br/>不就像男人穿双袜子一样吗？</p><p id="473d" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">实际上那些美元..类似上面的getPhotos命令是针对<strong class="je hv">客户端</strong>的，allPhotos命令是针对<strong class="je hv">服务器</strong>的。这确实有助于我理解语法，希望它对你也有意义。所有照片(…)将被发送到服务器，以便它可以解析答案并发回结果。<br/>在客户端(App客户端代码或GraphiQL工具)，您可以提供如下参数(输入变量)</p><blockquote class="lh li lj"><p id="2f87" class="jc jd lk je b jf jg jh ji jj jk jl jm ll jo jp jq lm js jt ju ln jw jx jy jz hn dt translated">注意，您可以在工具的左下角为上面的突变语句中的$input变量提供变量。那个用户输入！是一个<strong class="je hv">输入类型</strong>，只是另一个用于输入变量定义的类型</p></blockquote><figure class="ke kf kg kh fq iv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/b0aee94aebe42f0a4e84e753e6de1865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*s36m5CTlaug6T3UbomxlLg.png"/></div></figure><p id="41fb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">4.上面列出的所有参数和类型元素，如id、用户名、电子邮件、电话，都由空格或新行分隔，而不是逗号。</p><p id="0875" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">注意下面的查询/突变语句，是空格，不是逗号</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="59ae" class="km kn hu kd b fv ko kp l kq kr">allPhotos(filter:$filter paging:$page sorting:$sort)</span></pre><p id="c558" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很容易被忽略，尤其是上面显示的变量部分使用逗号来分隔各个变量</p><p id="655f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">5.列出一种类型的所有条目，如id、用户名、电子邮件、电话，可能会很乏味，尤其是如果你必须一次又一次地指定它们。于是就有了一个方便的东西叫做<strong class="je hv">片段</strong></p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="7943" class="km kn hu kd b fv ko kp l kq kr">fragment userDetails on User {<br/>   id<br/>   username<br/>   email<br/>   phone<br/>   ...<br/>   ...<br/>}</span></pre><p id="4c20" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后，无论何时我们需要获取用户，我们都可以使用这个片段</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="6887" class="km kn hu kd b fv ko kp l kq kr">getUser(id: 123){<br/>  ...userDetails<br/>}</span></pre><p id="7cce" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这很像Javascript ES6 …操作符</p><p id="2db7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">6.其他有趣的类型。</p><p id="1dd7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">联合类型</strong>只是不同类型的组合<br/>如果我们有两种类型，如学习小组和锻炼，我们可以将它们联合起来</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="b115" class="km kn hu kd b fv ko kp l kq kr">union AgendaItem = StudyGroup | Workout</span></pre><p id="d12e" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后当我们查询这个新类型时，我们可以使用特殊的语法来动态获取相关的属性。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="8ff9" class="km kn hu kd b fv ko kp l kq kr">query schedule {<br/> agenda {<br/>   …on Workout {<br/>     name<br/>     reps<br/>   }<br/>   …on StudyGroup {<br/>     name<br/>     subject<br/>     students<br/>   }<br/> }<br/>}</span></pre><p id="ccc2" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je hv">接口</strong>。这就像片段，但片段是用于<em class="lk">查询和突变</em>，接口是用于<em class="lk">类型</em>定义<em class="lk">定义</em>。它只是从不同类型中提取公共字段，这样所有这些类型就可以共享公共属性</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="2dbe" class="km kn hu kd b fv ko kp l kq kr">interface AgendaItem {<br/> name: String!<br/> start: DateTime!<br/> end: DateTime!<br/>}</span><span id="ddb4" class="km kn hu kd b fv lp kp l kq kr">type StudyGroup implements AgendaItem {<br/> name: String!<br/> start: DateTime!<br/> end: DateTime!<br/> participants: [User!]!<br/> topic: String!<br/>}</span><span id="2ac9" class="km kn hu kd b fv lp kp l kq kr">type Workout implements AgendaItem {<br/> name: String!<br/> start: DateTime!<br/> end: DateTime!<br/> reps: Int!<br/>}</span></pre><p id="b664" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">GraphQL有很多术语和概念，所以下面是我的快速参考，我希望在开始时就知道它们。</p><p id="596f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了让GraphQL服务器工作，我们需要提供<strong class="je hv">模式</strong>和<strong class="je hv">解析器</strong></p><p id="a9f9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">模式就是我们上面谈到的所有类型、查询、变异和订阅。高级类型有<strong class="je hv">枚举</strong>、<strong class="je hv">标量</strong>、<strong class="je hv">列表、联合、片段和接口</strong></p><p id="7146" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">解析器是为查询和突变检索数据的实现函数</p><p id="7f3c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">对于客户端，使用<code class="eh ka kb kc kd b">query</code>、<code class="eh ka kb kc kd b">mutation</code>和<code class="eh ka kb kc kd b">subscription</code>和<br/>进行服务器端模式定义，使用<code class="eh ka kb kc kd b">type query</code>、<code class="eh ka kb kc kd b">type mutation</code>和<code class="eh ka kb kc kd b">type subscription</code></p><p id="9f37" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这些也可以把<strong class="je hv">变量</strong>作为输入，所以你可以把变量组合在一起创建<strong class="je hv"> InputType </strong>它只是变量集合定义<br/>参考上面的GraphiQL截图，那个UserInput！是自定义输入类型</p><p id="3812" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面是一个使用App客户端代码进行类似GraphiQL示例的变异调用的示例</p><blockquote class="lh li lj"><p id="9549" class="jc jd lk je b jf jg jh ji jj jk jl jm ll jo jp jq lm js jt ju ln jw jx jy jz hn dt translated">注意突变语句和变量是分开发送的，就像上面的GraphiQL示例一样。</p></blockquote><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="3334" class="km kn hu kd b fv ko kp l kq kr">import { request } from 'graphql-request'</span><span id="e028" class="km kn hu kd b fv lp kp l kq kr">var url = '<a class="ae lq" href="http://localhost:4000/graphql'" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql'</a></span><span id="89e8" class="km kn hu kd b fv lp kp l kq kr">var mutation = `<br/>    mutation populate($count: Int!) {<br/>        addFakeUsers(count:$count) {<br/>            id<br/>            name<br/>        }<br/>    }<br/>`</span><span id="9789" class="km kn hu kd b fv lp kp l kq kr">var variables = { count: 3 }</span><span id="260c" class="km kn hu kd b fv lp kp l kq kr">request(url, mutation, variables)<br/>    .then(console.log)<br/>    .catch(console.error)</span></pre><p id="1191" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我花了相当长的时间才理解了这么多术语，并理解了服务器定义和客户机请求语法之间的细微差别。</p><p id="3b32" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">希望这些对你有所帮助，并随着时间的推移用它来更新基础知识。欢呼和掌声:)</p></div></div>    
</body>
</html>