<html>
<head>
<title>BEM should not exist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BEM不应该存在</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/bem-should-not-exist-6414005765d6?source=collection_archive---------8-----------------------#2019-01-04">https://medium.com/hackernoon/bem-should-not-exist-6414005765d6?source=collection_archive---------8-----------------------#2019-01-04</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/350db14ffcdaf551d02eb29c42b2aa59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3me548Yz7Y68m_J4pGz7WA.gif"/></div></div></figure><p id="2ef9" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">有很多理由不使用这种方法，但由于它的简单性和对HTML和CSS工作的误解，这种方法已经在全世界的前端开发人员中广泛传播；大多数情况下是来自独联体国家的开发者。BEM现在用于大型俄语项目(<a class="ae ka" href="http://yandex.ru" rel="noopener ugc nofollow" target="_blank"> Yandex </a>、<a class="ae ka" href="http://habr.com" rel="noopener ugc nofollow" target="_blank"> Habr </a>)和几个框架(<a class="ae ka" href="https://github.com/mlaursen/react-md" rel="noopener ugc nofollow" target="_blank"> react-md </a>)中。在本文中，将对这种开发方法的优缺点进行详细的回顾。所有的例子都将在BEM官方网站上展示。</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kb"><img src="../Images/fc6cd1b3277ff277b49552c854efaca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ym78wygemvNWsepH3o7ijA.jpeg"/></div></div></figure><p id="a317" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">缩写“<strong class="je hv">BEM</strong>”—块/元素/修饰符。每一个设计或布局都可以在视觉上被分割成块，比如侧边栏。每个块可以包含一个或几个元素。元素可以有状态的修饰符(活动的，禁用的)，<br/>用于改变边框、宽度、颜色等的附加类。将设计分成可视块的想法并不新鲜，BEM提供的是使类名更长，总是使元素依赖于块标题，并全局声明所有类。这实际上毫无帮助，并导致项目标记的可悲后果。以下是边界元法使用中的所有问题:</p><h1 id="a2b7" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">不可读的HTML</h1><p id="9d31" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">这是来自BEM官方网站的标记。冗长且类似PHP的名称类使得任何混有属性的标记都不可读:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lj"><img src="../Images/d8cc843c206bc002e7aab0d3caaa8eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/1*LAb4sInyWS0EhAq5kiJHsg.gif"/></div></figure><p id="072c" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">下面显示的标记是一个在类名中没有继承<br/>的例子，父块的标题，修饰符通过SASS中的继承绑定到主类，而不是HTML类名:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lk"><img src="../Images/6397b2ead0d611a582bafa4f55300f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/1*hgEbe7CXPrKpUo5AWyvQvg.gif"/></div></figure><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ll"><img src="../Images/73cef3691113f67e604eb30f09414e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/1*0XDn4AOa6CqVNcWgzNxKgQ.gif"/></div></figure><h1 id="234a" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">修饰符继承的困难</h1><p id="ec87" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">BEM-global中的任何类，修饰符也不例外。例如，在CSS提供给main类的地方，一个按钮继承了几个修饰符，如"<em class="lm">活动的</em>，<em class="lm">禁用的</em>，<em class="lm">错误的</em>BEM。这个类将是全局的，继承了块标题和元素标题的类名。这种方法忽视了CSS功能，如级联和突然延长类名:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/785a85be8f3e6e6919ba6e86f5477b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/1*P1t1UQy3nHxpfsrDySlf5A.gif"/></div></figure><p id="296f" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">通过SASS而不是从类名中的单词继承修饰符的例子:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/e77372c99240a190998e426271c7c042.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/1*Wka37KVmt9TQXYneMF8g6g.gif"/></div></figure><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lp"><img src="../Images/bcd452b4672ba85770c0c2567b1c58b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/1*dAgNFn7VR7xdy4FUOZYHVg.gif"/></div></figure><p id="95b7" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">所有类都是伪全局的。基本上一点都不差。问题是，在类名中，我们保存了块或元素名，不能在块外的任何地方使用它们，类的全局性质变得无用。另外，在浏览器中的一个选项卡上，我们有像“<em class="lm">promo _ section _ color _ white”</em>这样的全局类，它们只能将“<em class="lm">promo _ section”</em>的背景色改为白色。对于其他具有白色背景的块，您应该编写一个名称中带有硬编码的新类。元素不能在项目中的任何地方使用，尽管这在技术上是可行的:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/99eff613ae050b8afb7f4fb2d8b8858f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/1*uHb0jVFlXfmqLeITjMyMcA.gif"/></div></figure><p id="0313" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它可以由真正的全局类来完成，在其他部分重用而不会丢失任何东西，而不是通过HTML中的文本绑定到block:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/e68ad0de5e997dc4ab9a10d787218343.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*zDEikl-4sEhPD7qSTrvaog.gif"/></div></figure><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff ls"><img src="../Images/9501557b9e0594fd2e669bdd8bd220d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/1*Ap7tvOTKjG6u2CltS69TzA.gif"/></div></figure><h1 id="4230" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">禁止语义使用</h1><p id="1d8a" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">这是文件中的一段引文:</p><blockquote class="lt lu lv"><p id="8e8d" class="jc jd lm je b jf jg jh ji jj jk jl jm lw jo jp jq lx js jt ju ly jw jx jy jz hn dt translated">在使用BEM时，你也不应该使用CSS标签或者 <code class="eh lz ma mb mc b">ID</code> <em class="hu">选择器。</em></p></blockquote><p id="53cb" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">ID在CSS中的用法值得怀疑，但为什么不是标签呢？如此大的潜力，mixins或cycles可以用在带有语义的预处理程序中，但是它被贬低了:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff md"><img src="../Images/c2df13e556b9efcd740ee21b9b4d7656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/1*v4qYibtWQX-xWGkM8qwFLA.gif"/></div></figure><p id="43f5" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，h1、h2等可以应用样式。，但是没有链接到HTML标签，我们有class "<em class="lm">article _ _ heading _ level _ 1 "</em>:</p><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff me"><img src="../Images/969397b3643005601fdae5c7b262f46f.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/1*0SWbedV6nJTaQmZ2NvuLMQ.gif"/></div></figure><figure class="kc kd ke kf fq iv fe ff paragraph-image"><div class="fe ff mf"><img src="../Images/8ec0598b64537c319051795894926560.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/1*raYnVSPX8dMoj7B-4zAbag.gif"/></div></figure><h1 id="017e" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">仅通过块暗示标记</h1><p id="ca84" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">仅通过块暗示标记。有很多元素:按钮、下拉菜单、标题、副标题、部分等等。在每一个大模板里。但是在BEM中你不能重用类。如果您希望"<em class="lm">article _ _ heading _ level _ 1 "</em>不在文章中而是用相同的样式您将编写相同的样式，但是用新的类或者将从其他块中继承"<em class="lm">article _ _ heading _ level _ 1 "</em>。基本上，这是禁止创建一个完整的模板，但没有比登陆页面更复杂的东西。</p><h1 id="094d" class="kg kh hu bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld dt translated">赞成的意见</h1><p id="5d5b" class="pw-post-body-paragraph jc jd hu je b jf le jh ji jj lf jl jm jn lg jp jq jr lh jt ju jv li jx jy jz hn dt translated">一亲:写代码更简单，不应该支持。如果你用BEM编写CSS，改变文件样式的机会几乎为零。如果标记需要一些编辑，代码无论如何都会被重写，因为没有人愿意去阅读。</p><p id="d0f6" class="pw-post-body-paragraph jc jd hu je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">BEM破坏了模板的概念，禁止使用CSS函数和可能性，强迫开发者硬编码。评论中任何关于BEM的好想法都值得思考。这里提供的所有例子都是一种可能的方式，而不是我自己的标记。<br/>也许我在某些地方甚至没有保存语义。如果批评，那就建议。我建议Bootstrap、SMACSS和OOCSS的架构和想法。</p></div></div>    
</body>
</html>