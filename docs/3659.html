<html>
<head>
<title>Android Unidirectional Data Flow with LiveData</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用LiveData的Android单向数据流</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/android-unidirectional-flow-with-livedata-bf24119e747?source=collection_archive---------0-----------------------#2019-06-17">https://medium.com/hackernoon/android-unidirectional-flow-with-livedata-bf24119e747?source=collection_archive---------0-----------------------#2019-06-17</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><div class=""><h2 id="28fd" class="pw-subtitle-paragraph ir ht hu bd b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ek translated">改进Coinverse的性能和结构</h2></div><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff jj"><img src="../Images/bc6e9a85f753d73ed027338760f19314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODOuKt0GBD1a30NkzOlf1g.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">pc — <a class="ae jz" href="https://www.linkedin.com/in/ned-scher-60bbb152/" rel="noopener ugc nofollow" target="_blank">Ned Scher</a>, Waterfall at Yosemite National Park (2015)</figcaption></figure><p id="8e15" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt kw translated"><span class="l kx ky kz bm la lb lc ld le di"> T </span> <strong class="kc hv">何<em class="lf">单向数据流</em>【UDF】模式自2月份推出第一个测试版以来，提高了</strong><a class="ae jz" href="https://play.google.com/store/apps/details?id=app.coinverse" rel="noopener ugc nofollow" target="_blank"><strong class="kc hv">coin verse</strong></a><strong class="kc hv">的可用性和性能。Coinverse是第一个以加密货币形式创建涵盖技术和新闻的音频广播的应用程序。使用UDF的升级包括更有效的新闻订阅源创建，删除相邻的原生广告，以及更快的音频播放加载。</strong></p><p id="9f4f" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">TLDR:</p><div class="lg lh fm fo li lj"><a href="https://android.jlelse.eu/sample-app-android-unidirectional-data-flow-b9f8ad0fbca3" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab ej"><div class="ll ab lm cl cj ln"><h2 class="bd hv fv z el lo eo ep lp er et ht dt translated">示例应用——Android单向数据流</h2><div class="lq l"><h3 class="bd b fv z el lo eo ep lp er et ek translated">在Coinverse中使用LiveData</h3></div><div class="lr l"><p class="bd b gc z el lo eo ep lp er et ek translated">android.jlelse.eu</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jt lj"/></div></div></a></div><p id="88b6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">UDF模式将应用程序组织成三个主要区域，视图<strong class="kc hv">状态、事件</strong>和<strong class="kc hv">效果</strong>，确保应用程序模块化和可靠。<strong class="kc hv"> </strong>我从<a class="ae jz" href="https://fragmentedpodcast.com" rel="noopener ugc nofollow" target="_blank">片段播客</a>、<a class="ae jz" href="https://fragmentedpodcast.com/episodes/148/" rel="noopener ugc nofollow" target="_blank"> <em class="lf">进化中的Android架构(第一部分)</em> </a> <em class="lf"> </em>与<a class="ly lz gr" href="https://medium.com/u/b85c7e530b1f?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">Kaushik Gopal</a>at<a class="ly lz gr" href="https://medium.com/u/45aee787ef17?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">insta cart</a>和<a class="ly lz gr" href="https://medium.com/u/e75f3da9f41a?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank"> Donn Felker </a>的第148集了解到了UDF模式。乍一听，这很有趣，但一个大的检修。当我致力于修复bug并意识到各种流程变得多么复杂时，UDF变得引人注目。</p><p id="b2d2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">到目前为止，我看到的UDF的例子是和<a class="ae jz" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank"> Rx </a>在一起。Rx是一个强大的可定制工具，用于创建可以实时观察的数据流。然而，<a class="ae jz" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>提供了相同的观察状态变化的好处，最重要的是它很简单，直接与Android的<a class="ae jz" href="https://developer.android.com/topic/libraries/architecture" rel="noopener ugc nofollow" target="_blank">架构组件</a>集成，并默认处理Android的生命周期事件。如果你不熟悉，可以看看谷歌的何塞·阿尔塞雷卡在LiveData上的演讲。首先，我在Coinverse中重构了由<code class="eh ma mb mc md b">ContentFragment</code>、<code class="eh ma mb mc md b">ContentViewModel</code>和<code class="eh ma mb mc md b">ContentRepository</code>组成的内容新闻订阅流，我们将在下面介绍。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://www.youtube.com/watch?v=Elp-Z-pQTpM" rel="noopener ugc nofollow" target="_blank">Medellín Android talk — Unidirectional Data Flow por Adam Hurwitz</a> (2019)</figcaption></figure><h1 id="27b4" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">UDF背景</h1><p id="e678" class="pw-post-body-paragraph ka kb hu kc b kd my iv kf kg mz iy ki kj na kl km kn nb kp kq kr nc kt ku kv hn dt translated">UDF模式，又名<em class="lf">单向数据</em>或<em class="lf">状态流</em>最初在web开发中随着脸书的<a class="ae jz" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae jz" href="https://redux.js.org" rel="noopener ugc nofollow" target="_blank"> Readux </a>状态管理、<a class="ae jz" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a> UI库而普及。早期的Android <a class="ae jz" href="https://www.youtube.com/watch?v=SsH_rByBbq4" rel="noopener ugc nofollow" target="_blank">实验</a>可以从2015年<a class="ly lz gr" href="https://medium.com/u/94f5b1677695?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank"> SoundCloud </a>的<a class="ly lz gr" href="https://medium.com/u/e363db1ba716?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">布莱恩·伊根</a>和<a class="ly lz gr" href="https://medium.com/u/d85794e20ff7?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">纪尧姆·隆</a>中找到。<a class="ly lz gr" href="https://medium.com/u/8ddd94878165?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">杰克·沃顿</a>关于Rx的演讲教育了开发者关于<a class="ae jz" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应式编程</a>的知识，这是UDF的基础。</p><h2 id="38f1" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">越来越多的Android应用采用</h2><p id="f94c" class="pw-post-body-paragraph ka kb hu kc b kd my iv kf kg mz iy ki kj na kl km kn nb kp kq kr nc kt ku kv hn dt translated">举几个例子…</p><ul class=""><li id="790a" class="nr ns hu kc b kd ke kg kh kj nt kn nu kr nv kv nw nx ny nz dt translated"><a class="ly lz gr" href="https://medium.com/u/b85c7e530b1f?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">考什克·戈帕尔</a>和<a class="ly lz gr" href="https://medium.com/u/eeb6311ddecd?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">莱莫纳斯·图劳卡斯</a> @ <a class="ly lz gr" href="https://medium.com/u/45aee787ef17?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank"> Instacart </a></li><li id="e25d" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated"><a class="ly lz gr" href="https://medium.com/u/630ba9fc9922?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">丹希尔</a> @罗宾汉</li><li id="9ad7" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated"><a class="ly lz gr" href="https://medium.com/u/a03444eaea8f?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">唐纳德陈</a> @ <a class="ly lz gr" href="https://medium.com/u/a4c6efa67fe0?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank"> Instagram工程</a> / Lyft</li><li id="8939" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">塞萨尔·瓦连特</li></ul><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff of"><img src="../Images/dca5a01061adeaedb381a8e142bd9201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bu_z58aU2ACad_AWIqKW0Q.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">App companies adopting UDF</figcaption></figure><h1 id="6fb1" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">模型视图视图模型-MVVM</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff og"><img src="../Images/0c5ceb2eb98e0edebfa9196347942685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6v29bgv5lu7IZ7JI1nuPEg.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Gem Lake, Yosemite Emigrant Wilderness Trail (2018)</figcaption></figure><p id="fd6e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">对于Coinverse的第一次迭代，我使用了<em class="lf">模型视图视图模型</em> (MVVM)方法。MVVM将用户界面与业务逻辑分开，提高了可读性和组织性。然而，随着一个应用程序随着MVVM的增长，它变成了一个数据湖。信息通过<em class="lf">活动</em>和<em class="lf">片段</em>与<em class="lf">数据绑定、</em> <em class="lf">视图模型</em>、<em class="lf"> </em>和<em class="lf">存储库</em>在许多点流入、流出和流通。这增加了跟踪逻辑、调试和测试的复杂性，这需要模仿许多组件。</p><h1 id="2600" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">UDF优势</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oh"><img src="../Images/af654fffb97d1e21e8fbbedcecf19fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpZ-Q5QoQyDX2Iie9K0Ilg.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">pc — <a class="ae jz" href="https://www.linkedin.com/in/ned-scher-60bbb152/" rel="noopener ugc nofollow" target="_blank">Ned Scher</a>, Waterfall at Yosemite National Park (2015)</figcaption></figure><p id="9e20" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">UDF是一个瀑布，信息通过单一来源向一个方向流动，提供了许多好处。</p><ul class=""><li id="f8cb" class="nr ns hu kc b kd ke kg kh kj nt kn nu kr nv kv nw nx ny nz dt translated">流的一个入口点——UI和业务逻辑通过单个入口点进行交互。</li><li id="6197" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">控制涉及异步事件的UI——确切知道事情开始和结束的时间和地点</li><li id="3b73" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">调试问题—易于跟踪事件顺序并识别错误</li><li id="fdc9" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">简化的测试——大部分逻辑包含在ViewModel中，需要较少的模仿。</li></ul><h1 id="8058" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">LiveData</h1><p id="89fa" class="pw-post-body-paragraph ka kb hu kc b kd my iv kf kg mz iy ki kj na kl km kn nb kp kq kr nc kt ku kv hn dt translated">LiveData提供了一种实施UDF的简单方法。</p><ul class=""><li id="bbd2" class="nr ns hu kc b kd ke kg kh kj nt kn nu kr nv kv nw nx ny nz dt translated">生命周期感知</li><li id="d607" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">可以发出多个或单个事件</li><li id="679c" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">简明代码</li><li id="9ced" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">快速实施</li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="me mf l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://www.youtube.com/watch?v=2rO4r-JOQtA&amp;t" rel="noopener ugc nofollow" target="_blank">LiveData talk from 2018 Android Developer Summit</a></figcaption></figure><h1 id="be80" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">查看状态、事件和效果</h1><h2 id="064f" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">视图状态</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff oi"><img src="../Images/88decfa85375c85197781d4415e3c581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*la5a4mK4-w-XBofhJnJE_g.png"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">Coinverse’s main newsfeed</figcaption></figure><p id="4825" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">视图状态负责保存最终视图的持久化数据。这需要在屏幕上向用户显示所有内容，包括关于内容的信息，如启用状态。</p><p id="920c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">查看上面的Coinverse主新闻提要，视图状态的例子包括提要的内容、要显示的内容和T2，以及用来填充提要的T3。</p><h2 id="8d33" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">事件</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/d33dc8ed4bca5983264f37e833fcd043.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*Sr3klaremk7Xf5yVHhVB9A.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd ok">ContentSelected(…)</strong></figcaption></figure><p id="80db" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">视图<strong class="kc hv">事件</strong>由用户界面和系统启动的动作组成。UI动作包括按钮按压和文本输入，而系统动作可能是Android生命周期事件和屏幕旋转。</p><p id="8c22" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在<em class="lf">比特币基地博客的</em>内容被选中的情况下，一个视图<strong class="kc hv">事件</strong>被创建，<code class="eh ma mb mc md b">ContentSelected</code>。<strong class="kc hv"/><strong class="kc hv">事件</strong>将与业务层共享信息，发起对所选音频的检索。</p><h2 id="649e" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">效果</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/df8ec4e63c4bd99db04e28421dc3b39f.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*JVpV-zOErNTLr62nOwyPKA.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><strong class="bd ok">ContentSwiped(…)</strong></figcaption></figure><p id="16d7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">视图<strong class="kc hv">效果</strong>是不会持续的一次性UI事件。<strong class="kc hv">效果</strong>包括导航、对话框和祝酒词。<strong class="kc hv">效果</strong>由业务层创建，用于启动UI中的更改。</p><p id="7040" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当上面的<em class="lf"> CCN </em>项被向右滑动时，业务层给内容添加一个<em class="lf">保存的</em>标签。业务层发送<strong class="kc hv">效果</strong>、<code class="eh ma mb mc md b">ContentSwiped</code>、<strong class="kc hv">、</strong>通知UI内容标签的变化。然后，UI可以从主新闻订阅源中删除内容。</p><h1 id="2839" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">应用程序结构</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff ol"><img src="../Images/21dad872cb5d1dcaa60b196f625b7b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mabK9JlVLH9ngONpLwLwHA.png"/></div></div></figure><p id="61f3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">让我们了解一下单向数据流是如何构成的。<em class="lf">视图</em>处理存储在单个流中的所有UI和系统级动作。<strong class="kc hv"> </strong>流被发送到<em class="lf">视图模型</em>，视图模型接收动作并在业务逻辑中相应地处理它们。</p><p id="e083" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="lf">视图模型</em>是视图<strong class="kc hv">状态</strong>的真实来源，并创建任何必要的<strong class="kc hv">效果</strong>。<em class="lf"> ViewModel </em>还处理对数据<em class="lf">存储库</em>层的请求，管理从<em class="lf">存储库</em>返回的结果<strong class="kc hv">加载</strong>、成功<strong class="kc hv">内容</strong>和<strong class="kc hv">错误</strong>状态，并带有一个<code class="eh ma mb mc md b">Lce</code>对象(下面将详细介绍<code class="eh ma mb mc md b">Lce</code>)。</p><p id="d74e" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">状态</strong>和<strong class="kc hv">效果</strong>都由<em class="lf">视图观察，</em>实时更新<em class="lf">视图模型</em>的任何变化。</p><h1 id="d56e" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">履行</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/2eabdb3eabc24c72b3b9d074fa9829f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*bJ8BqVgv_FovqWHQsrnSJQ.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">mainfeed loading</figcaption></figure><p id="18ab" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">我们将使用Coinverse的主要新闻提要加载作为如何实现UDF的例子。</p><h2 id="8472" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">第1步，共6步—定义模型</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><ul class=""><li id="a8b8" class="nr ns hu kc b kd ke kg kh kj nt kn nu kr nv kv nw nx ny nz dt translated">视图<strong class="kc hv">状态— </strong>在<em class="lf">视图模型中存储为LiveData对象，</em>存储LiveData类型的<code class="eh ma mb mc md b">contentList</code></li><li id="3c4e" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated">查看<strong class="kc hv">事件</strong>和<strong class="kc hv">效果</strong> —使用科特林的<a class="ae jz" href="https://kotlinlang.org/docs/reference/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">密封类</a>来传递一次性事件</li></ul><p id="54d7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">视图<strong class="kc hv">状态</strong>使用<code class="eh ma mb mc md b">LiveData</code>,因为数据不可变与<code class="eh ma mb mc md b">MutableLiveData</code>相比很重要。否则，数据的流动就不是单向的，状态可以在许多地方改变。</p><p id="de9b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">视图<strong class="kc hv">事件</strong>和<strong class="kc hv">效果</strong>不会持久保存在<em class="lf">视图模型</em>中。一个密封的类，像一个枚举，但是在类的层次上，是用来传递信息的。密封类定义了有数据或没有数据的父类和子类。<code class="eh ma mb mc md b">ScreenLoad</code> <strong class="kc hv">事件</strong>是一个<code class="eh ma mb mc md b">data class</code>，带有关于<em class="lf">视图模型</em>应该加载什么的数据<em class="lf"> </em>。而<code class="eh ma mb mc md b">UpdateAds</code> <strong class="kc hv">效果</strong>是没有数据告诉查看者更新新闻订阅源中的广告的<code class="eh ma mb mc md b">class</code>。</p><h2 id="f643" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">第2步，共6步—将事件传递给视图模型</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><p id="22f3" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在本例中，当系统动作<code class="eh ma mb mc md b">onCreate</code>发生时，一个<code class="eh ma mb mc md b">ScreenLoad</code>事件被添加到视图事件流中，并从<em class="lf">片段</em>发送到<em class="lf">视图模型</em>以开始创建主提要。</p><p id="3496" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在<em class="lf">视图</em> / <em class="lf">片段</em>中创建的所有事件都被添加到一个<em class="lf"> LiveData </em>对象<code class="eh ma mb mc md b">_viewEvent</code>中，一个<code class="eh ma mb mc md b">MutableLiveData</code>对象更新不可变的<code class="eh ma mb mc md b">LiveData</code>对象。我使用基于<a class="ly lz gr" href="https://medium.com/u/b85c7e530b1f?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank"> Kaushik </a>的<a class="ae jz" href="https://github.com/kaushikgopal/movies-usf" rel="noopener ugc nofollow" target="_blank">样本</a>传递<code class="eh ma mb mc md b">onResume</code>中所有事件的模式。</p><p id="b31a" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">LiveData将数据打包存储在一个<code class="eh ma mb mc md b">Event</code>中。正如<a class="ly lz gr" href="https://medium.com/u/e0a4c9469bb5?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank"> Jose </a>在他的<a class="ae jz" rel="noopener" href="/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150"> LiveData关于事件的帖子</a>中所解释的，事件确保一个唯一的对象被添加到一个流中。这避免了为一个动作意外创建多个对象。</p><h2 id="f9d1" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">第3步，共6步—处理事件</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/0f005fd61fe28365d76529f9e82b94d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*T7LFf2sTajJvy9tHfxD5oQ.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">mainfeed loaded</figcaption></figure><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><p id="d092" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="lf"> ViewModel </em>接收传入的事件，根据<strong class="kc hv">密封的</strong> <code class="eh ma mb mc md b">ViewEvent</code>类的类型在<code class="eh ma mb mc md b">when</code>语句中处理每个事件。对于<code class="eh ma mb mc md b">ScreenLoad</code>，整个<code class="eh ma mb mc md b">ViewState</code>被所需的数据更新。为了填充新闻提要，向<em class="lf">存储库</em>发出一个带有<code class="eh ma mb mc md b">getMainFeed</code>的请求。</p><p id="646b" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><strong class="kc hv">更新状态值</strong></p><p id="57a2" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">在需要更新<code class="eh ma mb mc md b">ViewState</code>的一个属性而不是整个<code class="eh ma mb mc md b">ViewState</code>的情况下，Kotlin的浅层<a class="ae jz" href="https://kotlinlang.org/docs/reference/data-classes.html#copying" rel="noopener ugc nofollow" target="_blank"> <em class="lf">复制</em> </a>功能很有用。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><h2 id="bace" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">第4步，共6步—使用LCE模式管理网络请求</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><p id="1192" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">为了管理网络请求，<a class="ly lz gr" href="https://medium.com/u/b85c7e530b1f?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank"> Kaushik </a>引入了具有三种状态的<code class="eh ma mb mc md b">Lce</code> <strong class="kc hv">密封</strong>类对象，<strong class="kc hv">加载</strong>，<strong class="kc hv">内容</strong>，以及<strong class="kc hv">错误</strong>。<strong class="kc hv"/><strong class="kc hv">内容</strong>状态代表请求成功。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><p id="79eb" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">一个<strong class="kc hv">密封的</strong>类对于返回不同类型的结果也很有用。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><p id="f039" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><code class="eh ma mb mc md b">getMainFeed</code>的网络请求共享通过LiveData流将<code class="eh ma mb mc md b">Lce</code>状态发送给<em class="lf"> ViewModel </em>。对于<strong class="kc hv">内容</strong>和<strong class="kc hv">错误</strong>状态，可以将<code class="eh ma mb mc md b">PagedListResult</code>类传递到<code class="eh ma mb mc md b">Lce</code>中。然后<em class="lf">视图模型</em>将适当地管理每个状态。</p><h2 id="df5c" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">第5步，共6步—处理LCE国家</h2><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/c70ac1b94bc1b17841075a6eb9b72895.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*wMlmdpNDniHOvUmQk73tCA.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">mainfeed error</figcaption></figure><p id="30ff" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">gif显示有些事情出了差错。我们将在<em class="lf">视图模型</em>中看到错误是如何处理的。</p><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><p id="43a6" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">UDF简化了从网络请求新内容和从<a class="ae jz" href="https://developer.android.com/topic/libraries/architecture/room" rel="noopener ugc nofollow" target="_blank">会议室</a>数据库检索更新内容的方法。在使用UDF之前，Coinverse分别调用了两个存储库方法来填充主新闻提要。</p><p id="9300" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">当提要被加载时，现有的房间数据库内容被返回，这样用户就不会盯着一个空屏幕。对于成功的<code class="eh ma mb mc md b">Content</code>案例，返回来自Room的更新内容。对于请求新内容的错误，与<code class="eh ma mb mc md b">Loading</code>情况类似，还会显示现有的房间内容。在上面的错误中，一个<code class="eh ma mb mc md b">SnackBar</code>视图<strong class="kc hv">效果</strong>被传递给<em class="lf">片段</em>以显示错误消息。</p><p id="6200" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated"><em class="lf">视图模型</em>用LiveData <code class="eh ma mb mc md b">SwitchMap</code>观察每个<code class="eh ma mb mc md b">Lce</code>状态。<code class="eh ma mb mc md b">SwitchMap</code>传入一个LiveData对象并返回一个新的不同的LiveData对象，该对象保存到视图<strong class="kc hv">状态</strong>。</p><p id="d642" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">像所有LiveData一样，必须在视图中观察到一个<code class="eh ma mb mc md b">SwitchMap</code>，以便在<em class="lf">视图模型</em>内的地图中发出值。</p><h2 id="24d6" class="nd mh hu bd mi ne nf ng mm nh ni nj mq kj nk nl ms kn nm nn mu kr no np mw nq dt translated">第6步(共6步)—观察状态变化！</h2><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="om mf l"/></div></figure><p id="b732" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">现在，当更新发生时，可以观察到视图<strong class="kc hv">状态</strong>。以同样的方式观察视图<strong class="kc hv">效果</strong>。</p><h1 id="95c0" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">奖励——删除相邻广告</h1><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff oj"><img src="../Images/e73e1c6d1efe97fb69ec7f926c56db1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*AGXWJqvVrY4C1Nje1KC1FQ.gif"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">auto adjacent ads detection</figcaption></figure><p id="f0b4" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">除了上面简化的新闻提要，UDF还改进了Twitter原生MoPub广告在新闻提要中的显示方式。MoPub的<code class="eh ma mb mc md b">MoPubRecyclerAdapter</code>没有内置的方法来避免相邻广告的显示。内容可以滑动以保存或删除，最终导致两个广告并排出现。在UDF之前，这是由用户通过手动滑动来进行刷新的。</p><p id="a59c" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">与UDF有一个<code class="eh ma mb mc md b">contentLabeled</code>观<strong class="kc hv">态</strong>。当视图状态<strong class="kc hv">的状态</strong>改变时，意味着一个项目被标记为从主馈送中移除，对相邻广告进行检查。如果删除内容会创建相邻的广告，则广告会自动刷新。</p><h1 id="f77b" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">权衡取舍</h1><p id="e733" class="pw-post-body-paragraph ka kb hu kc b kd my iv kf kg mz iy ki kj na kl km kn nb kp kq kr nc kt ku kv hn dt translated">将LiveData用于单向数据流非常好，但并不完美。</p><p id="59c1" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">LiveData仅适用于影响UI的逻辑。对于非UI逻辑，不会观察到LiveData，因为它需要传入生命周期。对于这些实例，可以使用<a class="ae jz" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协程</a>或Rx。如果不涉及UI，那么更好的解决方案可能是用<a class="ae jz" href="https://firebase.google.com/docs/functions/callable#call_the_function" rel="noopener ugc nofollow" target="_blank"> Firebase云功能</a>将逻辑完全卸载到后端。</p><p id="6709" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">LiveData在线程等方面没有太多的定制。随着今年最新的Google I/O更新，协程似乎可以轻松地与LiveData集成，提供更多的定制。</p><h1 id="2b47" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">Coinverse后续步骤</h1><ul class=""><li id="d57a" class="nr ns hu kc b kd my kg mz kj on kn oo kr op kv nw nx ny nz dt translated"><strong class="kc hv">单向数据流— </strong>扩展到Coinverse应用的其余部分</li><li id="d483" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated"><strong class="kc hv"> JUnit测试</strong>——现在，大多数newsfeed逻辑都在<em class="lf"> ViewModel </em>中模块化了，JUnit测试会更容易，对组件的模仿会更少。</li><li id="e560" class="nr ns hu kc b kd oa kg ob kj oc kn od kr oe kv nw nx ny nz dt translated"><strong class="kc hv"> Kotlin协同程序— </strong>通过使用与LiveData集成的<a class="ae jz" href="https://developer.android.com/kotlin/coroutines" rel="noopener ugc nofollow" target="_blank"> Kotlin协同程序</a>控制线程来提高性能</li></ul><p id="a4e7" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">接下来:</p><div class="lg lh fm fo li lj"><a rel="noopener follow" target="_blank" href="/@AdamHurwitz/udf2-0-5052c3e1c62a"><div class="lk ab ej"><div class="ll ab lm cl cj ln"><h2 class="bd hv fv z el lo eo ep lp er et ht dt translated">使用LiveData - 2.0的Android单向数据流</h2><div class="lq l"><h3 class="bd b fv z el lo eo ep lp er et ek translated">改进状态模型+协程流程</h3></div><div class="lr l"><p class="bd b gc z el lo eo ep lp er et ek translated">medium.com</p></div></div><div class="ls l"><div class="oq l lu lv lw ls lx jt lj"/></div></div></a></div><h1 id="0bba" class="mg mh hu bd mi mj mk ml mm mn mo mp mq ja mr jb ms jd mt je mu jg mv jh mw mx dt translated">资源</h1><ul class=""><li id="4e80" class="nr ns hu kc b kd my kg mz kj on kn oo kr op kv nw nx ny nz dt translated"><strong class="kc hv">在Play Store上查看coin verse:</strong></li></ul><div class="lg lh fm fo li lj"><a href="https://play.google.com/store/apps/details?id=app.coinverse" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab ej"><div class="ll ab lm cl cj ln"><h2 class="bd hv fv z el lo eo ep lp er et ht dt translated">Coinverse -加密货币新闻、比特币、以太坊Google Play上的应用</h2><div class="lq l"><h3 class="bd b fv z el lo eo ep lp er et ek translated">安卓上没有？-订阅资料片更新@ bit.ly/coinverse-beta1.你是开发者吗？-检查开放的…</h3></div><div class="lr l"><p class="bd b gc z el lo eo ep lp er et ek translated">play.google.com</p></div></div><div class="ls l"><div class="or l lu lv lw ls lx jt lj"/></div></div></a></div><ul class=""><li id="073d" class="nr ns hu kc b kd ke kg kh kj nt kn nu kr nv kv nw nx ny nz dt translated">探索并运行Coinverse代码:</li></ul><div class="lg lh fm fo li lj"><a href="https://android.jlelse.eu/sample-app-android-unidirectional-data-flow-b9f8ad0fbca3" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab ej"><div class="ll ab lm cl cj ln"><h2 class="bd hv fv z el lo eo ep lp er et ht dt translated">示例应用——Android单向数据流</h2><div class="lq l"><h3 class="bd b fv z el lo eo ep lp er et ek translated">在Coinverse中使用LiveData</h3></div><div class="lr l"><p class="bd b gc z el lo eo ep lp er et ek translated">android.jlelse.eu</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx jt lj"/></div></div></a></div><ul class=""><li id="51c1" class="nr ns hu kc b kd ke kg kh kj nt kn nu kr nv kv nw nx ny nz dt translated"><a class="ae jz" href="https://docs.google.com/presentation/d/1bj-lG2ghJO5EVIJRrCt3eH-lZsz8ChPc1hVXZ_KYpD8?rm=minimal" rel="noopener ugc nofollow" target="_blank">幻灯片</a>:</li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="os mf l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">UDF Slides</figcaption></figure><ul class=""><li id="cdfa" class="nr ns hu kc b kd ke kg kh kj nt kn nu kr nv kv nw nx ny nz dt translated"><a class="ae jz" href="https://docs.google.com/document/d/13fmrGJbGHNEPo3FN7IDmwQjxjXK3qoACSRqjyawV32k?rm=minimal" rel="noopener ugc nofollow" target="_blank">注意事项</a>:</li></ul><figure class="jk jl jm jn fq jo"><div class="bz el l di"><div class="ot mf l"/></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek">UDF Notes</figcaption></figure></div><div class="ab cl ou ov hc ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="hn ho hp hq hr"><p id="f3b0" class="pw-post-body-paragraph ka kb hu kc b kd ke iv kf kg kh iy ki kj kk kl km kn ko kp kq kr ks kt ku kv hn dt translated">非常感谢麦德林安卓聚会<a class="ae jz" href="https://www.meetup.com/Medellin-Android/" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae jz" href="https://twitter.com/Iyubinest" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·戈麦斯</a>和<a class="ly lz gr" href="https://medium.com/u/eaf44c102d99?source=post_page-----bf24119e747--------------------------------" rel="noopener" target="_blank">卡洛斯·丹尼尔</a>组织这次演讲！如果你在麦德林，我建议你去他们的聚会。</p><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="fe ff pb"><img src="../Images/7c31f8511b3caaeac309300daf84a4b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pG8nRh7mnbkkx_I-k8Cyfw.jpeg"/></div></div><figcaption class="jv jw fg fe ff jx jy bd b be z ek"><a class="ae jz" href="https://www.youtube.com/watch?v=Elp-Z-pQTpM" rel="noopener ugc nofollow" target="_blank">Medellín Android talk — Unidirectional Data Flow por Adam Hurwitz</a> (2019)</figcaption></figure><figure class="jk jl jm jn fq jo fe ff paragraph-image"><div class="fe ff pc"><img src="../Images/ca4727e683da6a69980e9e6d985b2934.png" data-original-src="https://miro.medium.com/v2/resize:fit:124/0*grvJQXZg5AWw4sx3"/></div></figure></div></div>    
</body>
</html>