# 我是如何毁了我的 JavaScript 代码却仍然赢得了编码挑战

> 原文：<https://medium.com/hackernoon/how-i-ruined-my-javascript-code-and-still-won-the-coding-challenge-b32ea4215b1>

![](img/282bc4d499f085b601690eee63ff9bad.png)

所有开发人员都想写出可读和可维护的代码。这也一直是我个人的编程目标。但是，有一次我做了一件不同的，完全相反的事情。这是一次有趣的旅行，我不后悔。请舒适地坐着，我将告诉你一个关于过度复杂的 JavaScript 代码如何打动评委的故事。

# TSH 编码挑战

在软件之家，我们有一个名为“编码挑战”的循环活动——你用自己选择的语言写一段代码，然后解决评委指定的问题。获胜的标准是什么？你可以写任何符合需求的东西，但是也要让陪审团相信你的代码是最好的。(*蒂娜·特纳在后台玩*)。所以，如果你想获得更多的选票，就在工作中做一些巧妙的、令人惊讶的或者优雅的事情(或者更好的是，一次都做！).

这个版本的目标是编写一个验证邮政编码的简单函数。该函数应该接受一个字符串进行测试，如果提供的代码是正确的，则返回一个布尔答案:一个简单的 TRUE 或 FALSE。每个邮政编码应该有五个数字，在第二个和第三个字符之间有一个可选的分隔符。空格、破折号和下划线是这里唯一允许的分隔符。换句话说，这些邮政编码是正确的:

*   00000
*   12345
*   67–890
*   00 111
*   66_666

而那些不是:

*   a1–234
*   12.345
*   7890
*   111–11

# 平淡无奇的表情

每个人想到的第一个解决方案是正则表达式。这是格式验证的最佳实践，特别是当我们已经建立了什么是好的什么不是好的规则时。

> *当然，我没有使用正则表达式。*

不是因为这是最简单的方法。我只是希望大多数参加编码挑战的人会使用它们(顺便说一句，我是完全正确的)。所以，我采取了不同的方法。我想逆潮流而动，让我的代码尽可能复杂。然而，在代码中制造混乱似乎太琐碎了，所以我决定更具体一些，然后…打打高尔夫。代码高尔夫。

# 开发商打高尔夫吗？

高尔夫的规则非常简单:球员试图用尽可能少的球杆击球，将一个小白球放入草地的多个洞中。代码高尔夫有点类似。你必须用最少的字符数编写代码。你可以说，我们数的不是击球次数，而是键盘敲击次数。代码越短，你的结果越好，但是还是要按照规则来工作。

使用正则表达式仍然是一个好的解决方案，因为代码会非常短。这是真的，但也太容易了(看在上帝的份上，这是一个编码挑战！).我认为正则表达式是一个禁忌，因为它会扼杀乐趣。我也希望这会打动评委。

> 哦，我选择了 JavaScript，为什么不呢？

理论够了，现在来写点乱七八糟的代码吧！

![](img/790d659f751387b8ed0f2c10d31c7692.png)

# 坚实的基础

我通过在 Jest 框架中编写一些测试来开始我的代码。我对一个函数做了 18 个小单元测试，以覆盖所有的边缘情况。一个完美的[测试驱动开发](https://tsh.io/blog/model-view-presenter-testing-tdd/)方法(实际上没有那么多——我是开玩笑的)。

所有的测试都不出所料地失败了。我甚至还没有开始编写我的邮政编码验证器。为此，我必须首先创建函数。

我使用了匿名箭头函数，因为它的签名比带有函数和 return 关键字的普通函数的签名要短。不要介意长变量名。我现在保留它们只是为了让代码更易读，以后我会删除它们。

# 数字问题

现在，我们需要检查代码的适当位置是否只有数字。请注意，邮政编码实际上只是一些数字之间带有可选分隔符的数字。换句话说，如果我们忽略这个分隔符，我们可以把邮政编码当作一个五位数！那么，让我们在验证中使用它。我通过选择前两个字符，后三个字符，并检查它们是否一起构成一个数字。

例如，对于代码 12–345，我们从开头分割“12”，从结尾分割“345”，并将其连接成“12345”。请注意，该代码对中间有多少个分隔符或提供的代码有多长不敏感，我们总是使用前两个和后三个字符。现在，我们必须验证结果。我用数字函数将它转换成数字类型。它尽可能从字符串中返回一个正确的数值，否则返回 NaN(非数字类型)。

旁注:我们已经可以通过使用一个+号操作符来代替 Number 函数，使这段代码变得更短一些。这段代码的工作方式与上面的代码完全相同:

我们还没有完成，因为我们的函数目前正在返回数字，但它必须返回一个 TRUE 或 FALSE 值。我们可以很容易地通过使用一个双惊叹号来解决这个问题，它的作用相当于一个双重否定:它把所有的东西都变成一个布尔值。

太好了！但是这里有一个问题我需要解决。例如，如果代码是“1a-234”，在将其转换为数字后，我们将得到一个 NaN，在转换为 boolean 后，它为 FALSE。很好！12–345 将被正确地解释为一个数字(12345)，我们将得到 TRUE 和 end。太棒了。00–000 怎么样？“00000”将被很好地解释为一个数字(零)，但将它转换为 bool 将产生 false，因为零是 FALSE！

这就是为什么我们要在结果上加 1 的原因。在我们的代码中只需要多两个字符，但是它会使我们的数字总是正的和真的。00–000 edge 案例不再有问题。

不幸的是，我们的代码仍然存在一些问题。您知道在 [JavaScript](https://tsh.io/blog/javascript-static-site-generator-setup-tutorial-part-1/) 中，一些数字可以包含字母吗？它是用来写二进制或十六进制数的。因为这些数字，0b10111 和 0x30 完全有效。这些 0b 和 0x 前缀是这里的关键。在检查函数中，我们必须小心处理它们，并“中断”像 0b-101 和 0x-111 这样的输入，这些输入在验证期间将返回 TRUE。幸运的是，这很容易。我们可以使用之前完成的修复，并通过在连接的开始移动添加的 1 来稍微调整一下。

现在，像 0b-101 这样的邮政编码将连接成 10b101，由于前缀错误，10b 101 不再是二进制数。整齐，我们在慢慢前进！对于带点的数字:“0.123”，这里只需要解决一个边缘情况。它们不是有效的邮政编码，但是目前，我们的验证器将为它们返回 TRUE，因为它们是正确的数字。那么，我们能做什么呢？和上次一样:用句号打破那些数字。我决定这样做……引入第二个句号！

现在，每当邮政编码只有数字时，验证器将在内部生成一个句号，例如:12–345 变成 1.12345，这是一个正确的数字。这将返回 TRUE。然而，当该功能将提供有问题的邮政编码时，如“1。-234”那么验证器将产生一个 1.1.234，这是不合适的，并将返回 FALSE。这个解决方案的唯一缺点是，我们在代码 golf 中多丢失了三个字符。这是我暂时可以接受的。

唷，最困难的部分已经过去了。现在我们来谈谈分离器。

# 认识一下分离器

在上面的例子中，我们主要使用破折号，但是允许使用三种分隔符:破折号、下划线、空格和空字符串(没有分隔符)。如果我们想用它们定义一个数组，我们会得到这样的结果:

很多省略号。我们在这里打高尔夫，所以我们不能就这样离开。你知道 ES6 的传播算子吗？它允许将一个数组中的元素放到另一个数组中，而无需手动重写所有元素。像这样:

好吧，但我为什么要说这个？因为字符串也可以作为数组处理，所以——多亏了它和 spread 操作符——我们可以通过扩展允许的“可见”分隔符的字符串来节省一些字符。

这个数组和上面的一样。然而，这里我们只用了 12 个字符，而不是 15 个。你还记得之前修复点号问题时丢失的三个字符吗？我们刚刚在代码高尔夫中发现并弥补了它们。

当然，我们不仅需要检查分隔符是否是允许的类型，还需要检查它是否在正确的位置。现在，我们将重复拆分字符串的技巧:我们将从提供的代码中获取所有字符，从第二个字符之后开始，到倒数第三个字符之前结束。如果分隔符正确，它应该包含在可用分隔符的数组中。

感谢它，如果有人提供，例如，“12___345”我们将测试“__”。此外，没有分隔符的代码，如 12345，将用一个空字符串进行测试，该字符串在我们允许的分隔符数组中。

把所有东西粘在一起，我得到了这个:

# 最后一击

目前，几乎所有的事情都完成了。用户绕过验证器的唯一方法是传递一个三或四位数的字符串。我们来分析一下这个例子“:“1234”。该函数将连接修复“1。“，前两个字“12”，后三个字“234”。我们将得到“1.12234”，这是一个很好的数字，我们的验证器不会发现这个问题。因此，我们必须额外检查字符串是否至少有 5 个字符。怎么做？通过检查字符串的第五个字符是否存在。我在函数体的开头添加了检查。

那是我们不得不检查的最后一件事。其他不正确的邮政编码，比如字符太多的编码，将被我之前添加的机制拒绝。知道我们可以直接从代码中删除所有不必要的空格和字符，会给我们的代码带来更多的好处。

最后的结果？只有 86 个字符。验证器通过了 18 个单元测试中的每一个。您可以通过使用 repl.it 服务自己查看。

# 奖杯授予……

软件公司的评委们喜欢我的疯狂解决方案吗？是的。我得到了大多数的选票，赢得了编码挑战。我的奖？一瓶上好的比利时啤酒！你可能会问自己，这是我能想到的最好的解决方案吗？我不确定。也许有人可以用更少的字符重写这个验证器？

[锻炼你的大脑](https://tsh.io/blog/brain-overload-why-and-how-you-should-change-your-learning-patterns/)并且偶尔改变你的模式会创造奇迹！亲爱的读者，如果你想在代码高尔夫中击败我，请将你的代码发送到 [**这个电子邮件地址**](mailto:social@tsh.io) **。看到更好的解决方案，我会很兴奋。我们希望有同样的机会，所以只要记住规则:使用普通的 JavaScript，不允许使用正则表达式。祝你好运！**

# PS。呈指数增长的问题

这篇文章发表后差不多两个星期过去了——它在许多地方被分享，并在 Reddit、脸书、Twitter 和我们的社交电子邮件地址上引发了一些评论。最常出现的话题是指数。是的，我承认，我忘了他们。

简单地说，当有人试图验证“1e234”时，验证器将返回 TRUE，这是一个假阴性。这是因为在 JavaScript 中，除了前面提到的十六进制和二进制数字，我们还有一种特殊的符号来书写非常大或非常小的数字。

所谓的指数或科学记数法是由字母“e”分隔的两个正常数字组成的。要得到“完整值”,你必须取第一个数字(有效位)并乘以第二个数字(指数)的 10 次幂。于是“12e3”就变成了 12 * 10 = 12 * 1000 = 12000。当你想输入行星间距离的代码时，这很方便。然而，如果你想描述人体细胞有多小，你可以在第二个数字前面加上否定。例如，“34e-5”是 34 * 10^-5 = 34 * 0.00001 = 0.00034。

![](img/c0f5a6f471fb6af9cb34aed70d0f7324.png)

e

所以现在我们知道这里的问题是什么，我们终于可以解决它了。让我们从添加新的单元测试开始。

我们如何让它过去？我们不需要在我们的验证器代码中做一次革命，我们只需要使用我们已经用于句号问题的相同技巧。我们将在验证器内部生成的数字上增加一个额外的“e”字符。现在，当有人使用邮政编码时，验证器将返回 FALSE，因为任何数字都不能有两个“e”字符。有人建议将它放在邮政编码的分片部分之间，但我会将它添加到现有的前缀中以节省一些字符。

我必须在字符前加一个额外的零，这样我们就不会在数字中得到一个无效的“1.e”。这个解决方案将使我们的测试通过，但我们必须意识到一些后果。此时，验证器将总是在内部创建一个用指数符号表示的数字。这意味着我们可能会遇到数字范围限制或负指数的问题。为此，我增加了四项测试。

第一个测试检查如果用户试图生成一个非常大的数字会发生什么。正确的“99999”邮政编码将在内部生成一个字符串“1.0e99999”，然后验证程序将尝试对其进行编号。然而，它不能计算精确的值，因为它对于 JavaScript 引擎来说太大了。该操作将返回 Infinity 值，幸运的是，在转换为 bool 后，Infinity 为真。我们的验证器将正确工作，第一个测试将是绿色的。

第二个测试类似，但是，它检查如果有人试图偷偷输入一个减号来迫使验证器计算一些非常非常小的数字会发生什么。意外的是，这个测试也可以工作，因为内部生成的“1.0e-9999”会生成一个非常小的数字，浏览器会将其更改为零。当转换为 bool 时，zero 为 FALSE。

不幸的是，第三次额外测试将失败。它在第一个位置也有一个减号，但是这个数字不会太小。对于无效的邮政编码“-0001”，验证程序将连接一个字符串“1.0e-0001”，它等于 0.1，是一个有效的数字。这是一个问题，因为我们的验证器会接受这个值并返回 TRUE。怎么修？请注意，指数中的减号只在第一位置有效。如果我们不允许用户将减号放在指数的第一位，那么我们将测试设为绿色。最简单的方法当然是在“e”字符后面加一个零。

这使得代码看起来更像是黑魔法！但是，嘿——测试现在是绿色的。这一招也将修复第四次测试。像“1e+23”这样的数字也是有效的，我们不希望我们的邮政编码中有任何加号。所以现在所有的测试都通过了，我们可以收工了。

> 目前完整的解决方案需要 89 个字符，但希望它能涵盖所有的边缘情况。 [***在这里自己测试一下吧！***](https://repl.it/@marcingajda/blogPostalCodeValidator2)

感谢所有在讨论中提到这个问题或者直接联系我的人。我还想说，许多人给我发来了他们关于如何改进代码并使其更短的伟大想法！因为大赛还在进行，我就不剧透别人的想法了。但是，伙计，我本可以拯救这么多的角色…谁知道呢，也许有一天我会发表和评论这些解决方案。🙂

**文章由 Marcin Gajda 撰写，首次发表于软件之家博客**[](http://www.tsh.io/blog)****。访问博客，获得更多关于最佳开发实践和软件外包技巧的文章。****