<html>
<head>
<title>A (Short) Intro to Cryptoeconomic Modelling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">密码经济建模的(简短)介绍</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/a-short-intro-to-cryptoeconomic-modelling-1-2-a840fa55bd18?source=collection_archive---------6-----------------------#2019-02-16">https://medium.com/hackernoon/a-short-intro-to-cryptoeconomic-modelling-1-2-a840fa55bd18?source=collection_archive---------6-----------------------#2019-02-16</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/c3c42d81b8d1d15b56ecdae55ac8c243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*241yt5qGzbVEKRZ-W1uMPA.jpeg"/></div></div></figure><blockquote class="jc"><p id="ece7" class="jd je hu bd jf jg jh ji jj jk jl jm ek translated">用Python设计和测试协议机制</p></blockquote><h1 id="3a7d" class="jn jo hu bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dt translated">概观</h1><p id="662b" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt li translated"><span class="l lj lk ll bm lm ln lo lp lq di">如果</span>你一直在关注2017年加密热潮后的区块链空间，你可能会遇到关于可扩展性、互操作性和治理的讨论。</p><p id="95f5" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">今天，摩根大通宣布创造他们的新稳定硬币“JPM硬币”,以支持他们新颖的企业支付网络。无论你是一家使用公共链技术的初创公司，还是一家使用基于许可的分类账的企业，今天都标志着一场标记化世界的竞赛的开始。</p><p id="8ae6" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">经济学的未来将是可互操作的，这意味着资产、代理和交易逻辑可能都存在于不同的分类账/平台中。因此，虽然竞赛已经开始，但围绕分类帐和分类帐间系统的可伸缩性和健壮性，仍有重要的协议级挑战需要解决。</p><h2 id="a58c" class="lw jo hu bd jp lx ly lz jt ma mb mc jx kw md me kb la mf mg kf le mh mi kj mj dt translated">TL；速度三角形定位法(dead reckoning)</h2><p id="4f6c" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt translated">本文是探讨经济和加密机制设计的两部分系列文章的第一部分。</p><ul class=""><li id="8bda" class="mk ml hu kn b ko lr ks ls kw mm la mn le mo jm mp mq mr ms dt translated">第一部分:我们将使用Python3构建一个简单的区块链(本文)。</li><li id="5247" class="mk ml hu kn b ko mt ks mu kw mv la mw le mx jm mp mq mr ms dt translated">第二部分:我们将确定网络的期望结果，并使用第一部分中的区块链设计/测试机制。</li></ul><p id="81bc" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">设计协议级技术并不容易，但是许多这样的机制可以用来创建“部分分散”的组织(两害相权取其轻)。</p><p id="afa1" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">权力下放不会在一夜之间发生。无论你是分析师、程序员还是“壁橱里的”经济学家，这个系列都旨在加强你对协议的理解，并为你提供一个设计和测试<strong class="kn hv">实用</strong>加密经济机制的框架。</p><h1 id="63e6" class="jn jo hu bd jp jq jr js jt ju jv jw jx jy my ka kb kc mz ke kf kg na ki kj kk dt translated">第一部分:使用Python构建一个简单的区块链</h1><p id="79dc" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt translated">在第一篇文章中，我们将使用Python3构建一个简单的区块链。我推荐克隆脚本的Jupyter笔记本版本或使用colab链接(您不需要在那里安装依赖项)。这个区块链模拟将作为测试本系列第二部分中讨论的未来加密和经济机制的基础。</p><ul class=""><li id="63dd" class="mk ml hu kn b ko lr ks ls kw mm la mn le mo jm mp mq mr ms dt translated">Google colab链接(推荐):<a class="ae nb" href="https://colab.research.google.com/drive/1U3Zp3SckhwussLox6Ko4lJCnUzl0lpE3" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1 u 3 ZP 3 sckhwusslox 6 ko 4 ljcnuzl 0 LPE 3</a></li><li id="99af" class="mk ml hu kn b ko mt ks mu kw mv la mw le mx jm mp mq mr ms dt translated">Jupyter笔记本:<a class="ae nb" href="https://github.com/albertocevallos/Intro_To_Cryptoeconomic_Modelling/blob/master/blockchain.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/albertocevallos/Intro _ To _ Cryptoeconomic _ modeling/blob/master/block chain . ipynb</a></li><li id="6fe0" class="mk ml hu kn b ko mt ks mu kw mv la mw le mx jm mp mq mr ms dt translated">github repo:<a class="ae nb" href="https://github.com/albertocevallos/Intro_To_Cryptoeconomic_Modelling" rel="noopener ugc nofollow" target="_blank">https://github . com/albertocevallos/Intro _ To _ Cryptoeconomic _ modeling</a></li></ul><p id="b61e" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">我们开始吧！</p><h2 id="1343" class="lw jo hu bd jp lx ly lz jt ma mb mc jx kw md me kb la mf mg kf le mh mi kj mj dt translated">步骤1:导入依赖关系</h2><p id="2712" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt translated">您需要导入以下依赖项:</p><pre class="nc nd ne nf fq ng nh ni nj aw nk dt"><span id="a492" class="lw jo hu nh b fv nl nm l nn no"><strong class="nh hv">import</strong> <strong class="nh hv">datetime</strong><br/><strong class="nh hv">import</strong> <strong class="nh hv">hashlib</strong></span></pre><p id="8a03" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">“datetime”将用于生成时间戳，“hashlib”包含创建块时使用的哈希算法。您可以使用<a class="ae nb" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> pip </a>安装依赖项。</p><h2 id="ae3e" class="lw jo hu bd jp lx ly lz jt ma mb mc jx kw md me kb la mf mg kf le mh mi kj mj dt translated">步骤2:创建一个块</h2><p id="eb86" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt translated">现在，我们将定义“块”数据结构。在这个模拟中，每个块有7个属性。</p><p id="6156" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated"><strong class="kn hv">block no:</strong>block的编号。<br/> <strong class="kn hv">数据</strong>:存储在块中的任何数据(如交易、证书、图片)。<br/> <strong class="kn hv">下一个</strong>:指向下一个块的指针。<br/> <strong class="kn hv"> hash </strong>:唯一ID和完整性验证机制，包含块属性的签名(不变性机制)。<br/> <strong class="kn hv"> nonce </strong>:数字只使用一次。<br/> <strong class="kn hv"> previous_hash </strong>:存储链中前一个块的hash (ID)。<br/> <strong class="kn hv">时间戳</strong>:包含块生成时的时间戳。</p><pre class="nc nd ne nf fq ng nh ni nj aw nk dt"><span id="2112" class="lw jo hu nh b fv nl nm l nn no"><strong class="nh hv">class</strong> <strong class="nh hv">Block</strong>:<br/>    blockNo = 0<br/>    data = <strong class="nh hv">None</strong><br/>    next = <strong class="nh hv">None</strong><br/>    hash = <strong class="nh hv">None</strong><br/>    nonce = 0<br/>    previous_hash = 0x0<br/>    timestamp = datetime.datetime.now()<br/><br/>    <strong class="nh hv">def</strong> __init__(self, data):<br/>        self.data = data<br/>    <br/>    <strong class="nh hv">def</strong> hash(self):</span><span id="e6f2" class="lw jo hu nh b fv np nm l nn no">        h = hashlib.sha256()</span><span id="c3e2" class="lw jo hu nh b fv np nm l nn no">        h.update(<br/>        str(self.nonce).encode('utf-8') +<br/>        str(self.data).encode('utf-8') +<br/>        str(self.previous_hash).encode('utf-8') +<br/>        str(self.timestamp).encode('utf-8') +<br/>        str(self.blockNo).encode('utf-8')<br/>        )<br/>        <strong class="nh hv">return</strong> h.hexdigest()<br/><br/>    <strong class="nh hv">def</strong> __str__(self):<br/>        <strong class="nh hv">return</strong> "Block Hash: " + str(self.hash()) + "<strong class="nh hv">\n</strong>BlockNo: " + str(self.blockNo) + "<strong class="nh hv">\n</strong>Block Data: " + str(self.data) + "<strong class="nh hv">\n</strong>Hashes: " + str(self.nonce) + "<strong class="nh hv">\n</strong>--------------"</span></pre><p id="3a17" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">'<strong class="kn hv"> init </strong>'函数将在数据存储后生成一个块。'<strong class="kn hv"> hash </strong>'函数包含计算' hash '属性的逻辑。</p><figure class="nc nd ne nf fq iv fe ff paragraph-image"><div class="fe ff nq"><img src="../Images/979cdd36497d0b79763a6f0b4d64daea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ONl_UixLI9I1RJxMIMRd3g.png"/></div><figcaption class="nr ns fg fe ff nt nu bd b be z ek">Each ‘hash’ serves as the next block’s ‘previous_hash’ attribute, forming a chain.</figcaption></figure><p id="3887" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">哈希函数是确定性的，这意味着如果您在给定的块中更改一个事务，它将更改该给定块的哈希，并更改在它之后产生的所有块。</p><p id="4fb8" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">我们将使用SHA-256来生成代表一段文本的几乎唯一的256位签名。散列函数的输入将是由5个块属性(nonce、数据、previous_hash、时间戳和块号)组成的串联字符串。</p><h2 id="2404" class="lw jo hu bd jp lx ly lz jt ma mb mc jx kw md me kb la mf mg kf le mh mi kj mj dt translated">第三步:创建区块链</h2><p id="8cc9" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt translated">让我们来定义‘区块链’数据结构本身。它将由通过散列指针链接在一起的块组成。</p><p id="1e26" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">我们将为sybil控件使用一个基本的工作验证机制。请记住，区块链将PoW或PoS机制与共识协议(如最重/“最长”链选择(Nakamoto共识)或pBFT、Tendermint)结合起来以实现共识。</p><p id="1939" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">在我们的模拟中，我们只有一个节点(miner)，它需要计算不同的nonce值，直到块的散列小于或等于网络的当前目标(难度)。</p><p id="90f6" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">难度或差异决定了开采一个区块在计算上的严格程度。'<strong class="kn hv"> maxNonce </strong>'是我们可以在32位数字中存储的最大数，而'<strong class="kn hv"> target </strong>'是挖掘块的目标哈希值(需要添加到链中)。</p><p id="bcc2" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">然后，我们创建我们的“创世纪块”,并将其设置为我们的区块链的头部。</p><p id="ca2c" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">让我们定义一下我们的'<strong class="kn hv"> add </strong>函数。我们只需要添加块作为我们唯一的参数。我们使用链中最近的块的散列(ID)来更新'<strong class="kn hv"> previous_hash </strong>属性。我们还将通过将前一个块的编号加1来更新“blockNo”属性(因为这是链中的下一个块)。</p><p id="3ba3" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">我们将设置(新的)块等于它自己，使它成为链的头。</p><pre class="nc nd ne nf fq ng nh ni nj aw nk dt"><span id="d6f7" class="lw jo hu nh b fv nl nm l nn no"><strong class="nh hv">class</strong> <strong class="nh hv">Blockchain</strong>:<br/><br/>    diff = 20<br/>    maxNonce = 2**32<br/>    target = 2 ** (256-diff)<br/><br/>    block = Block("Genesis")<br/>    head = block<br/><br/>    <strong class="nh hv">def</strong> add(self, block):<br/><br/>        block.previous_hash<br/>        block.blockNo = self.block.blockNo + 1<br/><br/>        self.block.next = block<br/>        self.block = self.block.next<br/><br/>    <strong class="nh hv">def</strong> mine(self, block):<br/>        <strong class="nh hv">for</strong> n <strong class="nh hv">in</strong> range(self.maxNonce):<br/>            <strong class="nh hv">if</strong> int(block.hash(), 16) &lt;= self.target:<br/>                self.add(block)<br/>                print(block)<br/>                <strong class="nh hv">break</strong><br/>            <strong class="nh hv">else</strong>:<br/>                block.nonce += 1</span></pre><p id="151a" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">为了挖掘链的头部，块将需要具有等于或小于“<strong class="kn hv">目标</strong>”值的散列。我们将运行一个循环，直到这个语句为真。</p><h2 id="ba0a" class="lw jo hu bd jp lx ly lz jt ma mb mc jx kw md me kb la mf mg kf le mh mi kj mj dt translated">第四步:打印区块链</h2><p id="c90a" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt translated">最后，让我们初始化区块链，并运行挖掘功能10次。打印出10块的内容。</p><pre class="nc nd ne nf fq ng nh ni nj aw nk dt"><span id="a1fc" class="lw jo hu nh b fv nl nm l nn no">blockchain = Blockchain()<br/><br/><strong class="nh hv">for</strong> n <strong class="nh hv">in</strong> range(10):<br/>    blockchain.mine(Block("Block " + str(n+1)))<br/><br/><strong class="nh hv">while</strong> blockchain.head != <strong class="nh hv">None</strong>:<br/>    print(blockchain.head)<br/>    blockchain.head = blockchain.head.next</span></pre><h1 id="a2cb" class="jn jo hu bd jp jq jr js jt ju jv jw jx jy my ka kb kc mz ke kf kg na ki kj kk dt translated">结论</h1><p id="0795" class="pw-post-body-paragraph kl km hu kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh jm hn dt translated">我们可以使用Python对区块链架构中使用的基本加密经济机制和数据结构进行建模。接下来，我们将分析:</p><ul class=""><li id="2aec" class="mk ml hu kn b ko lr ks ls kw mm la mn le mo jm mp mq mr ms dt translated">攻击媒介(例如sybil攻击)</li><li id="b192" class="mk ml hu kn b ko mt ks mu kw mv la mw le mx jm mp mq mr ms dt translated">治理(如决策、共识)</li><li id="23b5" class="mk ml hu kn b ko mt ks mu kw mv la mw le mx jm mp mq mr ms dt translated">产品要求(如安全级别、速度)</li></ul><p id="24f3" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">了解你的网络的预期结果对于设计经济激励(例如，阻止奖励、惩罚)和加密协议(例如，P2P加密消息)是至关重要的。这些机制中的许多可以融入新兴创业公司和成熟企业的代码中，确保更高水平的隐私、安全和信任。</p><p id="2362" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">在未来，所有的公司都会以这样或那样的方式涉足科技。企业家、分析师和程序员可以利用这种思维来建立部分分散的组织，并将它们连接到更大的基础设施，如<a class="ae nb" href="https://www.ethereum.org/" rel="noopener ugc nofollow" target="_blank">以太坊</a>或<a class="ae nb" href="https://polkadot.network/" rel="noopener ugc nofollow" target="_blank"> Polkadot </a>。</p><p id="e5a4" class="pw-post-body-paragraph kl km hu kn b ko lr kq kr ks ls ku kv kw lt ky kz la lu lc ld le lv lg lh jm hn dt translated">应用研究@<a class="ae nb" href="https://keter.io/" rel="noopener ugc nofollow" target="_blank">keter . io</a><br/><a class="ae nb" href="https://twitter.com/acvlls" rel="noopener ugc nofollow" target="_blank">https://twitter.com/acvlls</a><br/><a class="ae nb" href="https://www.linkedin.com/in/albertocevallos/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/albertocevallos/</a></p><figure class="nc nd ne nf fq iv fe ff paragraph-image"><div class="fe ff nv"><img src="../Images/578859d799a6b2f106c19d1fcc0f9bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/1*KMFrt3udLlfmUjXupxe9CQ.gif"/></div><figcaption class="nr ns fg fe ff nt nu bd b be z ek">The race to tokenization has begun!</figcaption></figure></div></div>    
</body>
</html>