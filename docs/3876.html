<html>
<head>
<title>Password Stretching using Key Derivation Function(KDF)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用密钥派生函数的密码扩展(KDF)</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/password-stretching-using-key-derivation-function-kdf-a5abc570f9e5#2019-06-28">https://medium.com/hackernoon/password-stretching-using-key-derivation-function-kdf-a5abc570f9e5#2019-06-28</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/03a5ee0285c11ecae0bea66845e3971e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqoIas2TgHfFn9u_QqnO9A.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">caption : <a class="ae jg" href="https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/" rel="noopener ugc nofollow" target="_blank">https://www.thesslstore.com/blog/difference-sha-1-sha-2-sha-256-hash-algorithms/</a></figcaption></figure><p id="8a93" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">密钥导出函数也称为密码延伸，是区块链、匿名 p2p 应用等加密应用的主要部分，其目标是获取密码或密钥，然后根据配置中选择的字节数生成加密的非常坚固的密钥。</p><p id="c1af" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在加密系统中直接使用密码不是最安全的模式，KDF 算法通常用于从输入密码中创建更随机的更长的密钥。</p><p id="8725" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">有不同的 KDF 算法，例如 Bcrypt 对于相同的给定输入不会返回相同的输出。这意味着不可能使用 Bcrypt 从给定的密码生成相同的密钥。对于给定的输入，其他人每次都会返回相同的结果，这反过来意味着有可能从给定的密码生成相同的密钥。</p><p id="a668" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">KDF 算法是基于加密哈希函数，如 SHA-256，布莱克-2B 或分组密码在 AES 加密中使用，他们利用了盐和胡椒的概念。</p><figure class="kg kh ki kj fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kf"><img src="../Images/1f8a03f7027de5e72191c510ff60e07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZUyfiI6_5qZFCtnRwjSRw.png"/></div></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">KDF Algorithm Process</figcaption></figure><p id="04bd" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">KDF 算法可以在几乎所有的编程语言中实现，但是在这篇文章中，我将使用 GoLang 编程语言。</p><p id="5e8f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">我们将使用 GoLang 中的 pkdf 包来生成我们的密钥，包的链接是<a class="ae jg" href="https://godoc.org/golang.org/x/crypto/pbkdf2" rel="noopener ugc nofollow" target="_blank">https://godoc.org/golang.org/x/crypto/pbkdf2</a></p><p id="2e6d" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">下面是实现我们的 KDF 算法的代码库。</p><figure class="kg kh ki kj fq iv"><div class="bz el l di"><div class="kk kl l"/></div><figcaption class="jc jd fg fe ff je jf bd b be z ek">Kdf-implementation codebase</figcaption></figure><p id="5303" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">基于它被很好地注释的事实，代码是自解释的，但是我将解释更多关于实现中的一些事情。</p><p id="111f" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">在<strong class="jj hv">第 3–10 行</strong>，我们导入了应用程序中需要使用的包。<br/> <strong class="jj hv">第 17 行</strong>以屏蔽格式从终端获取用户的字节密码。<br/> <strong class="jj hv">第 25 行</strong>创建一个 salt in 字节，用于 out 程序。这可以是用户选择的任意盐。<br/> <strong class="jj hv">第 28 行</strong>打印出用户输入的原始密码。<br/> <strong class="jj hv">第 32–34 行</strong>计算输入密码的 sha-256 哈希，并在终端上打印出来。<br/> <strong class="jj hv">第 43 行</strong>根据输入参数获取派生密钥。</p><pre class="kg kh ki kj fq km kn ko kp aw kq dt"><span id="097d" class="kr ks hu kn b fv kt ku l kv kw">func Key(password, salt []<a class="ae jg" href="https://godoc.org/builtin#byte" rel="noopener ugc nofollow" target="_blank">byte</a>, iter, keyLen <a class="ae jg" href="https://godoc.org/builtin#int" rel="noopener ugc nofollow" target="_blank">int</a>, h func() <a class="ae jg" href="https://godoc.org/hash" rel="noopener ugc nofollow" target="_blank">hash</a>.<a class="ae jg" href="https://godoc.org/hash#Hash" rel="noopener ugc nofollow" target="_blank">Hash</a>) []<a class="ae jg" href="https://godoc.org/builtin#byte" rel="noopener ugc nofollow" target="_blank">byte</a></span></pre><p id="8de1" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">该包提供的键功能允许我们自定义输入键的强化级别。以下是提供给我们更改的参数。</p><p id="5da5" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">密码</strong>:该输入密码需要被拉伸，类型必须为字节。<br/> <strong class="jj hv">盐</strong>:盐是添加到输入密码中的额外一层，使其更加坚固。Type 必须在 byte <br/> <strong class="jj hv"> iter </strong>中:Iteration 是在计算派生键的 hash 时迭代的次数。Type 必须是 Int <br/> <strong class="jj hv"> KeyLen </strong>:这是要返回的建议键的长度。类型必须是 Int。<br/> <strong class="jj hv"> h </strong>:这是生成密钥<br/>时使用的散列函数，然后返回包含派生密码的输出。</p><p id="6f46" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv">第 46 行</strong>打印出派生的密钥，这将是一个很长的密钥，所以我们需要通过将它传递给阿沙-256 哈希函数来将其降低到 32 字节，这是在<strong class="jj hv">第 49 行</strong>中完成的。<br/>最后，我们打印出派生密钥的散列值。</p><p id="7c9e" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">通过执行 go run main.go 运行应用程序，产生以下输出。</p><pre class="kg kh ki kj fq km kn ko kp aw kq dt"><span id="a4f1" class="kr ks hu kn b fv kt ku l kv kw"><br/>1.) Original Password :-&gt; mySecurePassword</span><span id="f317" class="kr ks hu kn b fv kx ku l kv kw">2.) Hashed Password :-&gt; b6573a02de91d76cc442a6f42aa749c6eee0982c148bb7e9116ee44f93e6807a</span><span id="4107" class="kr ks hu kn b fv kx ku l kv kw">3.) KDF Key :-&gt;  cdf347254e0fb199015a2721110c0a1b1bfc4f66f718a712930173f93290ed783e08e5655c57fd608da39269a10708<br/>fbe191b1141c6ea9d97d02f6bfbbd90580a3aed101a627e8e96d5cb5c51e24dbe1d5e2dca531c9f658de77080352a0394bb48af8636b840<br/>358314bfea2c0eb6a411ea36212bd13bd552a29be78e59fab17</span><span id="49c1" class="kr ks hu kn b fv kx ku l kv kw">4.) Hashed Derived Key :-&gt; e6e562be28fc935a2ea2e57f21b018237098aeab64c2621d11627be4e9dfe601</span></pre><p id="c344" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能认为第二个和第四个答案产生了相同的长度，尽管长度。你是对的，原因是散列函数总是返回固定长度的大小，而不管输入的大小。</p><p id="8eaa" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">你可能想问的另一个问题是，如果散列函数产生某种随机性和密钥拉伸，为什么我们不能只使用散列函数来进行密钥拉伸。对此的回答是，暴力破解散列函数的结果更容易，而暴力破解 KDF 算法是基于计算开销的。</p><p id="7596" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">请随意从下面的链接下载代码库，并根据您的需要进行扩展。</p><p id="9cc8" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated">感谢您的阅读！</p><p id="53f0" class="pw-post-body-paragraph jh ji hu jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hn dt translated"><strong class="jj hv"> <em class="ky">做些支持和表示一些爱(鼓掌)</em> </strong></p><div class="kz la fm fo lb lc"><a href="https://github.com/princesegzy01/kdf-implementation/blob/master/main.go" rel="noopener  ugc nofollow" target="_blank"><div class="ld ab ej"><div class="le ab lf cl cj lg"><h2 class="bd hv fv z el lh eo ep li er et ht dt translated">princesegzy 01/KDF-实现</h2><div class="lj l"><h3 class="bd b fv z el lh eo ep li er et ek translated">一个在 GoLang 中用于密码扩展的密钥衍生函数(KDF)算法的实现…</h3></div><div class="lk l"><p class="bd b gc z el lh eo ep li er et ek translated">github.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ja lc"/></div></div></a></div></div></div>    
</body>
</html>