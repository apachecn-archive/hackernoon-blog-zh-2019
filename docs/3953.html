<html>
<head>
<title>First Algorand Dutch Auction — Transparent?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第一次阿尔格兰德荷兰拍卖会——透明？</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/first-algorand-dutch-auction-transparent-873afa1c0fd5?source=collection_archive---------11-----------------------#2019-07-02">https://medium.com/hackernoon/first-algorand-dutch-auction-transparent-873afa1c0fd5?source=collection_archive---------11-----------------------#2019-07-02</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div class="fe ff ir"><img src="../Images/a0198e4c15f5b98664e21fab099fe39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*1VwXe-mAajkRkJXxWGLXvg.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek"><a class="ae jc" href="https://auctions.algorand.foundation/algorand/auction" rel="noopener ugc nofollow" target="_blank">https://auctions.algorand.foundation/algorand/auction</a></figcaption></figure><p id="c89b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">上周三，6月19日，是第一次阿尔格兰德基金会荷兰拍卖会；因此，第一个算法被发布。</p><h1 id="eb4c" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">快速回顾——荷兰式拍卖是如何运作的</h1><p id="bcea" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">阿尔格兰德基金会有最好的资源让你了解他们的阿尔戈拍卖是如何运作的:</p><ul class=""><li id="cf2c" class="le lf hu jf b jg jh jk jl jo lg js lh jw li ka lj lk ll lm dt translated"><a class="ae jc" href="https://algorand.foundation/algo-auctions" rel="noopener ugc nofollow" target="_blank"> Algo Auctions </a>，了解拍卖机制。</li><li id="4e1a" class="le lf hu jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm dt translated"><a class="ae jc" href="https://algorand.foundation/token-dynamics" rel="noopener ugc nofollow" target="_blank"> Token Dynamics </a>，了解第一次拍卖如何符合长期计划和规则。</li><li id="a13e" class="le lf hu jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm dt translated"><a class="ae jc" href="https://www.youtube.com/watch?v=0xlLgteeqQE" rel="noopener ugc nofollow" target="_blank">荷兰拍卖如何运作</a>，一个更好理解它们的短片。</li></ul><p id="5a43" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">简单来说，拍卖的目标是找到市场愿意为拍卖的Algos数量支付的价格(称为清算价格)。</p><p id="696b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">你可能已经看过了，<strong class="jf hv">这个过程据说是公平的，但是为什么呢？</strong></p><p id="eebc" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">首先，每个人支付相同的价格。即使你在拍卖达到清算价格之前出价，你也要支付清算价格。</p><p id="a087" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">第二，参与拍卖的每个人都有相同的实时信息。每个人在做投标决定时都处于同一条船上。</p><p id="928e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">然而，即使我们认为这听起来很公平，但最终结果的透明度呢？我们应该相信阿尔格朗基金会关于谁以什么价格收到了多少阿尔格朗的结果吗？</p><p id="ccad" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">在本文中，我将解释并给出一个您可以自己执行的步骤，即<strong class="jf hv">检查官方公布的拍卖结果。</strong></p><h1 id="3b53" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">我们在这里想做什么？</h1><p id="53d6" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">提及拍卖结果的阿尔格兰德基金会官方博客文章可以在<a class="ae jc" href="https://algorand.foundation/june192019winnings" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在那篇文章中，他们声称:</p><blockquote class="ls lt lu"><p id="cfad" class="jd je lv jf b jg jh ji jj jk jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz ka hn dt translated">这个文件的hash已经提交到Algorand区块链的Block 144366，Transaction hedi 522 dr 4 l 473 w 4 nxpttv 55 hbadgifvh 7 c 7 xc 3 z 2d 3 tjzakuq 7 a。</p><p id="6d87" class="jd je lv jf b jg jh ji jj jk jl jm jn lw jp jq jr lx jt ju jv ly jx jy jz ka hn dt translated">hash为kxt 3 gmgtxyehbevtsl 5 bufmuowusmlx 5 r 3j gbtn 2 wuckig 7 HNA，可以通过以下方法获得:sha 512 _ 256(" aO " | | auction 1 . outcomes)</p></blockquote><p id="41f8" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">为了证实这一说法，我们应该详细理解公开承诺的含义。</p><p id="bbef" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><em class="lv"> auction1.outcomes </em>文件是一个包含拍卖结果的二进制文件。这代表拍卖结束时，每个投标人赢得了多少算法。现在，让我们假设这个文件是正确的。</p><p id="99a7" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">为了简洁和唯一地表示这个结果，Algorand Foundation构造了一个<em class="lv">提交散列</em>，它是对文件应用<em class="lv"> SHA512_256 </em>散列函数的结果(带有一个前缀，表示提交对应的是哪种结果)，从而产生输出:<em class="lv">kxt 3 gmgtxyehbevtsa l5 bufmuowuwusml x 5r 3j gbtn 2 wuckig 7 HNA。</em></p><p id="de14" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">随后，他们将这个散列结果发布在Algorand区块链中，这可以在块144366内的<a class="ae jc" href="https://algoexplorer.io/tx/HEDI522DR4L473W4NXPTTV55HBADGIFVH7C7XC3Z2D3TJZAKUQ7A" rel="noopener ugc nofollow" target="_blank">事务</a>中找到。</p><p id="5892" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">即使阿尔格兰德基金会网站遭到黑客攻击，有人试图通过提供一个新的伪造的<em class="lv"> auction1.outcome </em>文件来欺骗人们，让他们认为现在的结果是不同的，这也很容易被发现，因为这个文件的哈希与提交给阿尔格兰德区块链的哈希不匹配。由于区块链是一种不可变的数据结构，并且分叉在设计上是不可能的，所以<em class="lv">auction 1 . output</em>不能被改变，并且继续与提交的散列匹配。</p><p id="3b82" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">然而，如果这个<em class="lv"> auction1.outcome </em>没有被正确计算呢？如何才能透明地检查结果？</p><p id="160d" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">我们可以使用<a class="ae jc" href="https://github.com/algorand/go-algorand/tree/6cbbcda734906f3f64a63356f199d6189964b782/cmd/auctionminion" rel="noopener ugc nofollow" target="_blank"><em class="lv">auction minion</em></a><em class="lv"/>，它在最近开源的<em class="lv">go-algrand</em>资源库中可用。(感谢工程研究副总裁Naveed Ihsanullah 告诉我这件事)。</p><p id="b40a" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这与基金会管理拍卖和计算结果使用的命令行工具相同，所以让我们自己尝试使用它，看看最终的输出哈希是否与链上提交的哈希匹配。使用这一工具，我们可以以可验证和透明的方式验证结果，原因有二:</p><ul class=""><li id="6abb" class="le lf hu jf b jg jh jk jl jo lg js lh jw li ka lj lk ll lm dt translated">代码是开源的，所以我们可以检查拍卖计算是如何进行的。</li><li id="213b" class="le lf hu jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm dt translated">用于计算的这个工具数据源将是我们自己的节点分类帐，所以我们不信任一些外部实体节点，因此也不信任外部数据。</li></ul><p id="16ad" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">简而言之，我们将从源代码编译该工具，然后该工具将使用我们的节点中包含的拍卖投标数据来重新生成拍卖结果。重新生成的拍卖结果的散列，<em class="lv"> auction1.outcome，</em>可以与阿尔格兰德基金会在区块链提交的结果相比较。如果散列是相同的，那么我们确认拍卖结果也是相同的。</p><h1 id="5d7f" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">逐步验证步骤</h1><p id="c21b" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">让我们在Ubuntu机器上完全从零开始。为了使这些步骤易于重现，所有指向源代码的链接都将指向特定的提交，而不是可能改变的分支。</p><h2 id="dac2" class="mb kc hu bd kd mc md me kh mf mg mh kl jo mi mj kp js mk ml kt jw mm mn kx mo dt translated">步骤1 —在MainNet上运行归档节点</h2><p id="068e" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">为此，我们有两个选择，从Algorand开发者网站下载最新的二进制文件，或者从源代码构建。</p><p id="2bdc" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">对于第一个选项，您应该遵循<a class="ae jc" href="https://developer.algorand.org/docs/introduction-installing-node" rel="noopener ugc nofollow" target="_blank">开发者网站</a>中描述的步骤。一个重要的考虑是节点的<em class="lv">数据</em>文件夹应该有一个<em class="lv"> config.json </em>文件，其中<em class="lv">存档</em>标志应该设置为<em class="lv">真(</em>默认为<em class="lv">假)。</em>该标志应在节点首次启动前设置，否则本地数据将处于不一致状态。</p><p id="d4de" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">归档行为是必要的，因为默认的节点行为是只在本地保留最近几百轮数据块，以最大限度地降低节点的存储需求。如果拍卖发生在这个最小保留范围之前<em class="lv"> auctionminion </em>将找不到拍卖块。</p><p id="5f6e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">您可以从位于<code class="eh mp mq mr ms b">data</code>文件夹中已经存在的<em class="lv"> config.json.example </em>文件生成<em class="lv"> config.json </em>。</p><p id="f7d1" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">启动节点，等待它完成同步:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="d0ff" class="mb kc hu ms b fv nb nc l nd ne">ignacio@ihagopian:~/node$ ./goal node status<br/>Last committed block: 193153<br/>Time since last block: 2.2s<br/><strong class="ms hv">Sync Time: 0.0s</strong><br/>Last consensus protocol: <a class="ae jc" href="https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0" rel="noopener ugc nofollow" target="_blank">https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0</a><br/>Next consensus protocol: <a class="ae jc" href="https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0" rel="noopener ugc nofollow" target="_blank">https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0</a><br/>Round for next consensus protocol: 193154<br/>Next consensus protocol supported: true<br/><strong class="ms hv">Genesis ID: mainnet-v1.0</strong><br/>Genesis hash: wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=</span></pre><p id="d057" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如果您选择第二个选项(为了额外的透明性),在构建源代码后从运行节点(下一步)。</p><h2 id="829c" class="mb kc hu bd kd mc md me kh mf mg mh kl jo mi mj kp js mk ml kt jw mm mn kx mo dt translated">步骤2-从源代码下载并构建go-algorand</h2><p id="d8ab" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">确保安装了<code class="eh mp mq mr ms b">golang 1.12.x</code>；如果不是这种情况，请遵循这里的步骤。</p><p id="6b6b" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">然后我们应该<code class="eh mp mq mr ms b">git clone</code>这个<code class="eh mp mq mr ms b">go-algorand</code>存储库并运行一个bash脚本，确保项目的所有依赖项都被安装。</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="6cdd" class="mb kc hu ms b fv nb nc l nd ne">mkdir -p ${GOPATH}/src/github.com/algorand<br/>cd ${GOPATH}/src/github.com/algorand<br/>git clone <a class="ae jc" href="https://github.com/algorand/go-algorand" rel="noopener ugc nofollow" target="_blank">https://github.com/algorand/go-algorand</a><br/>cd go-algorand<br/>git checkout f105c21953cfd1e5dcd26ac28018f0a66b4b7930<br/>sh ./scripts/configure_dev.sh #or use `bash` instead of `sh`</span></pre><p id="ff54" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">因为有一个关于额外依赖缺失的公开问题，你现在应该执行<code class="eh mp mq mr ms b">sudo apt-get install autoconf</code>来准备构建树。</p><p id="82d0" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">现在，构建项目:<code class="eh mp mq mr ms b">make install</code>，这需要一段时间，并将在<code class="eh mp mq mr ms b">$GOPATH/bin</code>中生成一堆二进制文件。</p><p id="4111" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">如果在步骤1中您想从编译的源代码运行节点，您应该在某个地方创建一个<code class="eh mp mq mr ms b">data</code>文件夹，并且应该包含:</p><ul class=""><li id="5bd7" class="le lf hu jf b jg jh jk jl jo lg js lh jw li ka lj lk ll lm dt translated"><em class="lv">mainnet的genesis.json </em>文件，可以从<a class="ae jc" href="https://github.com/algorand/go-algorand/blob/f105c21953cfd1e5dcd26ac28018f0a66b4b7930/installer/genesis/mainnet/genesis.json" rel="noopener ugc nofollow" target="_blank">这里</a>得到。</li><li id="0dd7" class="le lf hu jf b jg ln jk lo jo lp js lq jw lr ka lj lk ll lm dt translated"><em class="lv"> config.json </em>文件配置有<em class="lv">档案</em>设置为<em class="lv">真</em>，如步骤1所述。</li></ul><p id="ef8e" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">然后运行:<code class="eh mp mq mr ms b">$GOPATH/bin/goal node start -d &lt;pathPreparedDataFolder&gt;</code>并让它像上面提到的那样同步。</p><h2 id="d965" class="mb kc hu bd kd mc md me kh mf mg mh kl jo mi mj kp js mk ml kt jw mm mn kx mo dt translated">第3步—准备拍卖minion</h2><p id="f863" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">转到<code class="eh mp mq mr ms b">$GOPATH/bin</code>，在那里你应该会看到<code class="eh mp mq mr ms b">auctionminion</code>编译后的二进制文件。现在运行<code class="eh mp mq mr ms b">auctionminion -init</code>。这将创建一个<code class="eh mp mq mr ms b">auctionminion.state</code>文件。</p><p id="c9d8" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">像这样编辑文件:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="160f" class="mb kc hu ms b fv nb nc l nd ne">{<br/> “AuctionKey”: “VCINCVUX2DBKQ6WP63NOGPEAQAYGHGSGQX7TSH4M5LI5NBPVAGIHJPMIPM”,<br/> “AuctionID”: 1,<br/> “StartRound”: 130000,<br/> “AlgodURL”: “<a class="ae jc" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080</a>",<br/> “AlgodToken”: “!!your algod.token value here!!”<br/>}</span></pre><p id="b4a6" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated"><em class="lv"> AuctionKey </em>和<em class="lv"> AuctionID </em>值是我们要计算结果的拍卖的关键字和ID。如果你进入拍卖网页，你可以点击<em class="lv">信息</em>部分，看到拍卖数据:</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/563ab118c8bcb6b1786c25dab1b488a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*5-ZYsqU1XnBcnftiStmIYw.png"/></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek"><a class="ae jc" href="https://auctions.algorand.foundation/algorand/auction" rel="noopener ugc nofollow" target="_blank">https://auctions.algorand.foundation/algorand/auction</a></figcaption></figure><p id="ae38" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">此图像也解释了为什么<em class="lv">开始回合</em>应设置为低于<em class="lv">第一回合</em>值<em class="lv">。</em>我们可以将<em class="lv"> StartRound </em>设置为1，但是这将不必要地扫描大量的块，直到到达拍卖开始(你可以自由选择)。</p><p id="01a9" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">最后，<em class="lv"> AlgodURL </em>和<em class="lv"> AlgodToken </em>可以在<em class="lv">algod.net</em>和<em class="lv"> algod.token </em>中的节点<em class="lv">数据</em>文件夹中找到。</p><h2 id="42d3" class="mb kc hu bd kd mc md me kh mf mg mh kl jo mi mj kp js mk ml kt jw mm mn kx mo dt translated">步骤3 —运行auctionminion并查看结果！</h2><p id="edca" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">确保该节点正在运行并且同步，正如我们稍后检查的那样，并运行<code class="eh mp mq mr ms b">auctionminion</code>(无标志/选项)。实际上，只要<em class="lv"> carpenter </em>日志跟踪显示您的节点超出了block 145000，您就有足够的数据在本地完成拍卖结果验证。</p><p id="4884" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">检查输出的最后一行是否是:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="28a4" class="mb kc hu ms b fv nb nc l nd ne">Expected outcomes hash (if settled without cancelling): VeezMNO+CHCSs5AX0NCsrR1qSYu/Y7SYM26tQSkG+do=</span></pre><p id="dd7f" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">请注意<em class="lv"> auctionminion </em>更新<em class="lv"> auctionminion.state </em>为下一次拍卖做准备。如果您想要重新运行此拍卖证明，您需要恢复<em class="lv"> auctionminion.state </em>文件的<em class="lv"> AuctionID </em>和<em class="lv"> StartRound </em>值。</p><h2 id="80d0" class="mb kc hu bd kd mc md me kh mf mg mh kl jo mi mj kp js mk ml kt jw mm mn kx mo dt translated">步骤4 —验证结果</h2><p id="dbe8" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">我们计算了拍卖结果并得到了结果散列<code class="eh mp mq mr ms b">VeezMNO+CHCSs5AX0NCsrR1qSYu/Y7SYM26tQSkG+do=</code>。如果我们看到拍卖的结算<a class="ae jc" href="https://algoexplorer.io/tx/HEDI522DR4L473W4NXPTTV55HBADGIFVH7C7XC3Z2D3TJZAKUQ7A" rel="noopener ugc nofollow" target="_blank">交易</a>，正如我们之前看到的，我们可以注意到这个值与<em class="lv">outcomesha:</em>中的值相匹配</p><figure class="mt mu mv mw fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="fe ff ng"><img src="../Images/7b4b5c722f0b50f2c403c68912a48156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrNt-0FSVtMIr6ZErj0Jog.png"/></div></div><figcaption class="iy iz fg fe ff ja jb bd b be z ek"><a class="ae jc" href="https://algoexplorer.io/tx/HEDI522DR4L473W4NXPTTV55HBADGIFVH7C7XC3Z2D3TJZAKUQ7A" rel="noopener ugc nofollow" target="_blank">https://algoexplorer.io/tx/HEDI522DR4L473W4NXPTTV55HBADGIFVH7C7XC3Z2D3TJZAKUQ7A</a></figcaption></figure><p id="d38a" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">这是个好消息。我们的拍卖结果与提交给区块链的结果相匹配。</p><p id="e26a" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">你可能想知道为什么阿尔格兰德基金会说结果哈希是<code class="eh mp mq mr ms b">KXT3GMGTXYEHBEVTSAL5BUFMVUOWUSMLX5R3JGBTN2WUCKIG7HNA</code> <a class="ae jc" href="https://algorand.foundation/june192019winnings" rel="noopener ugc nofollow" target="_blank">，就像我们在</a>之前看到的那样？如果您对baseXX编码有很好的直觉，您会意识到它是相同值的base32编码。</p><p id="f104" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">您可以按如下方式进行检查:</p><pre class="mt mu mv mw fq mx ms my mz aw na dt"><span id="e38a" class="mb kc hu ms b fv nb nc l nd ne">ignacio@ihagopian:~$ echo VeezMNO+CHCSs5AX0NCsrR1qSYu/Y7SYM26tQSkG+do= | base64 — decode | base32<br/>KXT3GMGTXYEHBEVTSAL5BUFMVUOWUSMLX5R3JGBTN2WUCKIG7HNA====</span></pre><h1 id="6a02" class="kb kc hu bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">结论</h1><p id="99de" class="pw-post-body-paragraph jd je hu jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hn dt translated">在本文中，我们验证了阿尔格兰德基金会的首批拍卖结果。为了在不信任外部二进制文件或数据的情况下做到这一点，我们从源代码编译了一个同步归档节点，并使用<code class="eh mp mq mr ms b">auctionminion</code>工具来计算结果。</p><p id="8987" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">即使我们不仔细检查计算结果的代码的逻辑，我们也知道拍卖结果是可复制的，并且不可撤销地被提交给区块链。如果您愿意，您可以检查源代码以了解逻辑是如何流动的。</p><p id="24f4" class="pw-post-body-paragraph jd je hu jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hn dt translated">此外，你可能有兴趣了解更多关于链上拍卖的机制，除了<code class="eh mp mq mr ms b">auctionminion</code>之外还有其他组件参与。</p><figure class="mt mu mv mw fq iv"><div class="bz el l di"><div class="nl nm l"/></div></figure></div></div>    
</body>
</html>