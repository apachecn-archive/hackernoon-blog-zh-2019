<html>
<head>
<title>Load Balance and Scale Node.js Containers with Nginx and Docker Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Nginx 和 Docker Swarm 对 Node.js 容器进行负载平衡和扩展</h1>
<blockquote>原文：<a href="https://medium.com/hackernoon/load-balance-and-scale-node-js-containers-with-nginx-and-docker-swarm-27d737bbf4a9#2019-06-20">https://medium.com/hackernoon/load-balance-and-scale-node-js-containers-with-nginx-and-docker-swarm-27d737bbf4a9#2019-06-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/26fdf8c593e507430457c23f9572dd03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2kLrLgDZjAt0P_xNrM1qtg.jpeg"/></div></div></figure><div class=""/><p id="e644" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在我之前的博客<a class="ae ka" href="https://levelup.gitconnected.com/set-up-a-nginx-load-balancer-for-a-dockerized-node-js-application-6bff1a54655a" rel="noopener ugc nofollow" target="_blank">中，我们看到了如何在不同主机端口上的 docker 容器中部署 Node.js 应用程序，并使用 Nginx 对其进行负载平衡。</a></p><p id="eb25" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这是一个很好的方法，可以用来理解基础知识。然而，在生产环境中，在不同的端口上单独部署一个一个的容器是不可行的，还要在我们的 Nginx 配置文件中写入每个 ip:port，此外，当容器由于某种原因关闭时，还要管理和重写配置文件。因此，当容器数量增加时，它变得难以管理和令人沮丧。</p><p id="5e26" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">这个问题的一个解决方案是使用<code class="eh kb kc kd ke b">Container Orchestration</code>。我们将使用 docker 本身提供的称为<code class="eh kb kc kd ke b">docker swarm</code>的编排来简化我们的工作。你可以在这里阅读对 swarm、服务、堆栈<a class="ae ka" href="https://docs.docker.com/get-started/part4/" rel="noopener ugc nofollow" target="_blank">的一般介绍</a></p><p id="62f4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">必备:<br/> </strong> Docker 基础知识</p><p id="c49d" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig">概述:</strong></p><p id="af6c" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这篇博客中，我们将对接一个 Node.js 应用程序，然后在一个 swarm 集群中部署 15 个容器，看看我们如何使用 Nginx 在单个 IP 后面对它们进行负载平衡，最后以放大和缩小它们并以更好的方式可视化容器来结束。</p><p id="f634" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><strong class="je ig"> <em class="kf">好了，我们开始吧</em> </strong></p></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="3f78" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们的节点应用程序的 app.js 看起来像这样。</p><figure class="kn ko kp kq fq hw"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="04e4" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">它只是在端口 5000 上用 os.hostname()响应，这样我们就可以区分不同的运行容器。<br/>我们需要将此应用程序归档，因此复制下面的 docker 文件，并打开您的终端 cmd/shell 到同一个文件夹。</p><figure class="kn ko kp kq fq hw"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="0ec9" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在这里，您需要运行<code class="eh kb kc kd ke b">docker build -t username/appname .</code>，其中用户名是您的 docker-hub 用户名，然后使用<code class="eh kb kc kd ke b">docker image push username/appname</code>将其推送到 docker hub。<br/>我们正在将它推送到 docker hub，这样我们就可以进行一次性设置，并可以在任何需要的时候在任何服务器上使用 docker-compose.yml 文件来旋转我们的容器，此外，我们不需要在每台服务器上构建映像，我们只需要在我们的云服务器上使用 docker-compose.yml 文件。<br/>所以对我来说，命令是:</p><ul class=""><li id="df66" class="kt ku if je b jf jg jj jk jn kv jr kw jv kx jz ky kz la lb dt translated"><code class="eh kb kc kd ke b">docker build -t aagam29/nodeapp_balancerdemo .</code></li><li id="2b39" class="kt ku if je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb dt translated"><code class="eh kb kc kd ke b">docker image push aagam29/nodeapp_balancerdemo</code></li></ul></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="3167" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们需要 Nginx 作为容器的负载平衡器，所以让我们来设置它。移动到新文件夹并复制这些文件。<br/>根据您的服务器更改 nginx.conf 中的 IP。</p><figure class="kn ko kp kq fq hw"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="d6e6" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在，我们将做一个类似的图像构建和推动我们做了以上</p><ul class=""><li id="693f" class="kt ku if je b jf jg jj jk jn kv jr kw jv kx jz ky kz la lb dt translated"><code class="eh kb kc kd ke b">docker image build -t aagam29/nginx_balancerdemo</code></li><li id="3b19" class="kt ku if je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb dt translated"><code class="eh kb kc kd ke b">docker image push aagam29/nginx_balancerdemo</code></li></ul><p id="fa68" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">完成后，你应该可以在 docker hub 上看到图片</p><figure class="kn ko kp kq fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lh"><img src="../Images/69b1985d2e0321f850fd9192f9289474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTOKF80F8ejMpZNnYil6zw.png"/></div></div></figure></div><div class="ab cl kg kh hc ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="hn ho hp hq hr"><p id="98b5" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">好了，下一个任务是在我们的部署服务器上创建一个 swarm 集群。简单地输入<code class="eh kb kc kd ke b">docker swarm init </code>，一个蜂群就会被创造出来。我们将在一台服务器上看到部署，以防您希望使用多台服务器，只需<a class="ae ka" href="https://docs.docker.com/engine/swarm/swarm-tutorial/add-nodes/" rel="noopener ugc nofollow" target="_blank">添加一个<strong class="je ig">管理器</strong>节点</a>到集群，并在构建 nginx 映像之前添加其 IP:Port，并开放所需的容器<a class="ae ka" href="https://docs.docker.com/engine/swarm/swarm-tutorial/#open-protocols-and-ports-between-the-hosts" rel="noopener ugc nofollow" target="_blank">端口</a>供它们通信。</p><p id="297b" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">在您的服务器上复制以下 docker-compose 文件，根据您在构建图像时使用的用户名/appname 更改图像名称。</p><figure class="kn ko kp kq fq hw"><div class="bz el l di"><div class="kr ks l"/></div></figure><p id="44ac" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">如果您熟悉 docker-compose 文件，就很容易理解这里发生了什么。对于那些没有的人，我们提供两种服务:</p><ul class=""><li id="4c76" class="kt ku if je b jf jg jj jk jn kv jr kw jv kx jz ky kz la lb dt translated">第一个被命名为<code class="eh kb kc kd ke b">nodeapp</code>，它将生成我们的映像<code class="eh kb kc kd ke b">aagam29/nodeapp_balancerdemo</code>的<code class="eh kb kc kd ke b">15</code>容器，映射将从主机端口 5000 到容器端口 5000。如果一个容器关闭，将有<code class="eh kb kc kd ke b">3</code>次连续重启尝试，当更新时，它将延迟 10 秒关闭→启动容器<br/> <code class="eh kb kc kd ke b">3 by 3</code>，容器将被添加到在文件末尾创建的名为<code class="eh kb kc kd ke b">balance</code>的网络中</li><li id="b07d" class="kt ku if je b jf lc jj ld jn le jr lf jv lg jz ky kz la lb dt translated">第二个名为<code class="eh kb kc kd ke b">proxy</code>，它将从我们的映像<code class="eh kb kc kd ke b">aagam29/nginx_balancerdemo</code>中旋转一个容器，该映像位于从主机端口 80 映射到容器端口 80 的同一个网络<code class="eh kb kc kd ke b">balance</code>中，它依赖于<code class="eh kb kc kd ke b">nodeapp</code>，这意味着一旦<code class="eh kb kc kd ke b">nodeapp</code>服务启动，它就会启动，并且该节点应该是群中的<code class="eh kb kc kd ke b">manager</code>，以便运行该服务</li></ul><p id="abba" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">复制该文件后，我们需要使用<code class="eh kb kc kd ke b">docker stack deploy -c docker-compose.yml swarmnodeapp<br/></code>使用 docker stack 部署我们的服务堆栈。部署堆栈后，我们可以使用<code class="eh kb kc kd ke b">docker service ls </code>和<code class="eh kb kc kd ke b">docker service ps <strong class="je ig">servicename</strong></code> <strong class="je ig"> </strong>检查部署状态，还可以使用<code class="eh kb kc kd ke b">docker container ls</code>查看正在运行的容器。</p><p id="b6ea" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated"><em class="kf">后续截图清晰出整个过程！</em></p><figure class="kn ko kp kq fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff li"><img src="../Images/58ff16255d04ef5e7f7361a635cd2ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iQHcnsWs1cEyxExcXwoncQ.png"/></div></div></figure><figure class="kn ko kp kq fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lh"><img src="../Images/13309263b6ce15be96a0dc62a8521f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uja6yXEP-mYK8ZQGwgL0Jw.png"/></div></div></figure><p id="b695" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">祝贺😃，我们快完成了！如果一切顺利，您可以访问您的 ip 来查看容器 ID，并多次点击刷新来查看它们每次的变化，以交叉检查负载平衡工作是否非常顺利！！</p><figure class="kn ko kp kq fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lh"><img src="../Images/1c9a08e54a79e9d4671c0357dc531e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FczxRJwevBv0oZ_ioj2yXw.png"/></div></div></figure><p id="cb49" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">现在到了扩展的时候了，你可以用 swarm 很容易地扩展你的容器，你所需要做的就是运行<code class="eh kb kc kd ke b">docker service scale servicename=replicas</code>例如<code class="eh kb kc kd ke b">docker service scale swarmnodeapp_nodeapp=50</code></p><figure class="kn ko kp kq fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lj"><img src="../Images/4f0cb827b22da74a1618092d9a3a5f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xKH1cY_IRx_sQrap-Lz6yQ.png"/></div></div></figure><p id="eb15" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">为了更好地可视化运行的容器，我们可以使用 docker 可视化工具。干脆跑<code class="eh kb kc kd ke b">docker container run -p 8080:8080 -v /var/run/docker.sock:/var/run/docker.sock -d dockersamples/visualizer</code></p><figure class="kn ko kp kq fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lk"><img src="../Images/4d71677fdf86bc1546604b48029da043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-t54VpLXtYRt6uICOiPhQ.png"/></div></div></figure><p id="8384" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">然后访问您的 IP:8080，以正确查看您的群中运行的容器。</p><figure class="kn ko kp kq fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ll"><img src="../Images/fd42ecb11f5d52f23679ef14acf6c767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haegJQ-5NZn0BugiTddkmg.png"/></div></div></figure><p id="eaae" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">干得好！</p><p id="7e79" class="pw-post-body-paragraph jc jd if je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hn dt translated">我们刚刚为您的 Node.js 应用程序实现了一次性可伸缩部署设置，还为它配置了负载平衡，并在不使用命令行的情况下可视化了它们。<br/> <strong class="je ig"> <em class="kf">感谢阅读！如果你喜欢你所读的，那么留下一个👏然后跟着走。</em>T9】</strong></p></div></div>    
</body>
</html>